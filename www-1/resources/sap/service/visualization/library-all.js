// This file has been generated by the SAPUI5 'AllInOne' Builder
jQuery.sap.declare('sap.service.visualization.library-all');
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.BarRenderer') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */
jQuery.sap.declare("sap.service.visualization.chart.BarRenderer");

/**
 * @class Bar renderer. 
 * @static
 */
sap.service.visualization.chart.BarRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRenderManager the RenderManager that can be used for writing to the Render-Output-Buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
		
 */
sap.service.visualization.chart.BarRenderer.render = function(oRenderManager, oControl){ 
    // convenience variable
	var rm = oRenderManager;
	
	// write the HTML into the render manager  
    rm.write("<DIV");
    rm.writeControlData(oControl);
    
    rm.writeAttribute("class","sapservicevisualizationchart-Bar"); 
    
    rm.addStyle("width", oControl.getWidth());
	rm.addStyle("height", oControl.getHeight());
	rm.addStyle("position","relative");
	//rm.addStyle("left","0px");
	//rm.addStyle("top","0px");
	rm.writeStyles();
	
    rm.write(">"); 
    rm.write("</DIV>");
};

}; // end of sap.service.visualization.chart.BarRenderer
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.ChartSourceCode.libs.jquery') ) {
  jQuery.sap.declare('sap.service.visualization.chart.ChartSourceCode.libs.jquery');
/*!
 * jQuery JavaScript Library v1.4.3
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Oct 14 23:10:06 2010 -0400
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// (both of which we optimize for)
	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,

	// Is it a simple selector
	isSimple = /^.[^:#\[\.,]*$/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,
	rwhite = /\s/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Check for non-word characters
	rnonword = /\W/,

	// Check for digits
	rdigit = /\d/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,
	
	// Has the ready events already been bound?
	readyBound = false,
	
	// The functions to execute on DOM ready
	readyList = [],

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,
	
	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	init: function( selector, context ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}
		
		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = "body";
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			match = quickExpr.exec( selector );

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					doc = (context ? context.ownerDocument || context : document);

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes;
					}
					
					return jQuery.merge( this, selector );
					
				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $("TAG")
			} else if ( !context && !rnonword.test( selector ) ) {
				this.selector = selector;
				this.context = document;
				selector = document.getElementsByTagName( selector );
				return jQuery.merge( this, selector );

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return (context || rootjQuery).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return jQuery( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.4.3",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this.slice(num)[ 0 ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = jQuery();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );
		
		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + (this.selector ? " " : "") + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},
	
	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// If the DOM is already ready
		if ( jQuery.isReady ) {
			// Execute the function immediately
			fn.call( document, jQuery );

		// Otherwise, remember the function for later
		} else if ( readyList ) {
			// Add the function to the wait list
			readyList.push( fn );
		}

		return this;
	},
	
	eq: function( i ) {
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, +i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},
	
	end: function() {
		return this.prevObject || jQuery(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	// copy reference to target object
	var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy, copyIsArray;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		window.$ = _$;

		if ( deep ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},
	
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,
	
	// Handle when the DOM is ready
	ready: function( wait ) {
		// A third-party is pushing the ready event forwards
		if ( wait === true ) {
			jQuery.readyWait--;
		}

		// Make sure that the DOM is not already loaded
		if ( !jQuery.readyWait || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			if ( readyList ) {
				// Execute all of them
				var fn, i = 0;
				while ( (fn = readyList[ i++ ]) ) {
					fn.call( document, jQuery );
				}

				// Reset the list of functions
				readyList = null;
			}

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
			}
		}
	},
	
	bindReady: function() {
		if ( readyBound ) {
			return;
		}

		readyBound = true;

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			
			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent("onreadystatechange", DOMContentLoaded);
			
			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNaN: function( obj ) {
		return obj == null || !rdigit.test( obj ) || isNaN( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}
		
		// Not own constructor property must be Object
		if ( obj.constructor &&
			!hasOwn.call(obj, "constructor") &&
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
			return false;
		}
		
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
	
		var key;
		for ( key in obj ) {}
		
		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},
	
	error: function( msg ) {
		throw msg;
	},
	
	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );
		
		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test(data.replace(rvalidescape, "@")
			.replace(rvalidtokens, "]")
			.replace(rvalidbraces, "")) ) {

			// Try to use the native JSON parser first
			return window.JSON && window.JSON.parse ?
				window.JSON.parse( data ) :
				(new Function("return " + data))();

		} else {
			jQuery.error( "Invalid JSON: " + data );
		}
	},

	noop: function() {},

	// Evalulates a script in a global context
	globalEval: function( data ) {
		if ( data && rnotwhite.test(data) ) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement,
				script = document.createElement("script");

			script.type = "text/javascript";

			if ( jQuery.support.scriptEval ) {
				script.appendChild( document.createTextNode( data ) );
			} else {
				script.text = data;
			}

			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore( script, head.firstChild );
			head.removeChild( script );
		}
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction(object);

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( var value = object[0];
					i < length && callback.call( value, i, value ) !== false; value = object[++i] ) {}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// The extra typeof function check is to prevent crashes
			// in Safari 2 (See: #3039)
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type(array);

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array ) {
		if ( array.indexOf ) {
			return array.indexOf( elem );
		}

		for ( var i = 0, length = array.length; i < length; i++ ) {
			if ( array[ i ] === elem ) {
				return i;
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length, j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var ret = [], value;

		// Go through the array, translating each of the items to their
		// new value (or values).
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			value = callback( elems[ i ], i, arg );

			if ( value != null ) {
				ret[ ret.length ] = value;
			}
		}

		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	proxy: function( fn, proxy, thisObject ) {
		if ( arguments.length === 2 ) {
			if ( typeof proxy === "string" ) {
				thisObject = fn;
				fn = thisObject[ proxy ];
				proxy = undefined;

			} else if ( proxy && !jQuery.isFunction( proxy ) ) {
				thisObject = proxy;
				proxy = undefined;
			}
		}

		if ( !proxy && fn ) {
			proxy = function() {
				return fn.apply( thisObject || this, arguments );
			};
		}

		// Set the guid of unique handler to the same of original handler, so it can be removed
		if ( fn ) {
			proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
		}

		// So proxy can be declared as an argument
		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can be optionally by executed if its a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;
	
		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}
	
		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);
		
			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}
		
			return elems;
		}
	
		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return (new Date()).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

if ( indexOf ) {
	jQuery.inArray = function( elem, array ) {
		return indexOf.call( array, elem );
	};
}

// Verify that \s matches non-breaking spaces
// (IE fails on this test)
if ( !rwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

// Expose jQuery to the global object
return (window.jQuery = window.$ = jQuery);

})();


(function() {

	jQuery.support = {};

	var root = document.documentElement,
		script = document.createElement("script"),
		div = document.createElement("div"),
		id = "script" + jQuery.now();

	div.style.display = "none";
	div.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	var all = div.getElementsByTagName("*"),
		a = div.getElementsByTagName("a")[0],
		select = document.createElement("select"),
		opt = select.appendChild( document.createElement("option") );

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return;
	}

	jQuery.support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: div.firstChild.nodeType === 3,

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText insted)
		style: /red/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: a.getAttribute("href") === "/a",

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55$/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: div.getElementsByTagName("input")[0].value === "on",

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Will be defined later
		optDisabled: false,
		checkClone: false,
		scriptEval: false,
		noCloneEvent: true,
		boxModel: null,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableHiddenOffsets: true
	};

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as diabled)
	select.disabled = true;
	jQuery.support.optDisabled = !opt.disabled;

	script.type = "text/javascript";
	try {
		script.appendChild( document.createTextNode( "window." + id + "=1;" ) );
	} catch(e) {}

	root.insertBefore( script, root.firstChild );

	// Make sure that the execution of code works by injecting a script
	// tag with appendChild/createTextNode
	// (IE doesn't support this, fails, and uses .text instead)
	if ( window[ id ] ) {
		jQuery.support.scriptEval = true;
		delete window[ id ];
	}

	root.removeChild( script );

	if ( div.attachEvent && div.fireEvent ) {
		div.attachEvent("onclick", function click() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			jQuery.support.noCloneEvent = false;
			div.detachEvent("onclick", click);
		});
		div.cloneNode(true).fireEvent("onclick");
	}

	div = document.createElement("div");
	div.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>";

	var fragment = document.createDocumentFragment();
	fragment.appendChild( div.firstChild );

	// WebKit doesn't clone checked state correctly in fragments
	jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

	// Figure out if the W3C box model works as expected
	// document.body must exist before we can do this
	jQuery(function() {
		var div = document.createElement("div");
		div.style.width = div.style.paddingLeft = "1px";

		document.body.appendChild( div );
		jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;

		if ( "zoom" in div.style ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			jQuery.support.inlineBlockNeedsLayout = div.offsetWidth === 2;

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			jQuery.support.shrinkWrapBlocks = div.offsetWidth !== 2;
		}

		div.innerHTML = "<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";
		var tds = div.getElementsByTagName("td");

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		jQuery.support.reliableHiddenOffsets = tds[0].offsetHeight === 0;

		tds[0].style.display = "";
		tds[1].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE < 8 fail this test)
		jQuery.support.reliableHiddenOffsets = jQuery.support.reliableHiddenOffsets && tds[0].offsetHeight === 0;
		div.innerHTML = "";

		document.body.removeChild( div ).style.display = "none";
		div = tds = null;
	});

	// Technique from Juriy Zaytsev
	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
	var eventSupported = function( eventName ) {
		var el = document.createElement("div");
		eventName = "on" + eventName;

		var isSupported = (eventName in el);
		if ( !isSupported ) {
			el.setAttribute(eventName, "return;");
			isSupported = typeof el[eventName] === "function";
		}
		el = null;

		return isSupported;
	};

	jQuery.support.submitBubbles = eventSupported("submit");
	jQuery.support.changeBubbles = eventSupported("change");

	// release memory in IE
	root = script = div = all = a = null;
})();

jQuery.props = {
	"for": "htmlFor",
	"class": "className",
	readonly: "readOnly",
	maxlength: "maxLength",
	cellspacing: "cellSpacing",
	rowspan: "rowSpan",
	colspan: "colSpan",
	tabindex: "tabIndex",
	usemap: "useMap",
	frameborder: "frameBorder"
};




var windowData = {},
	rbrace = /^(?:\{.*\}|\[.*\])$/;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page	
	expando: "jQuery" + jQuery.now(),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	data: function( elem, name, data ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		elem = elem == window ?
			windowData :
			elem;

		var isNode = elem.nodeType,
			id = isNode ? elem[ jQuery.expando ] : null,
			cache = jQuery.cache, thisCache;

		if ( isNode && !id && typeof name === "string" && data === undefined ) {
			return;
		}

		// Get the data from the object directly
		if ( !isNode ) {
			cache = elem;

		// Compute a unique ID for the element
		} else if ( !id ) {
			elem[ jQuery.expando ] = id = ++jQuery.uuid;
		}

		// Avoid generating a new cache unless none exists and we
		// want to manipulate it.
		if ( typeof name === "object" ) {
			if ( isNode ) {
				cache[ id ] = jQuery.extend(cache[ id ], name);

			} else {
				jQuery.extend( cache, name );
			}

		} else if ( isNode && !cache[ id ] ) {
			cache[ id ] = {};
		}

		thisCache = isNode ? cache[ id ] : cache;

		// Prevent overriding the named cache with undefined values
		if ( data !== undefined ) {
			thisCache[ name ] = data;
		}

		return typeof name === "string" ? thisCache[ name ] : thisCache;
	},

	removeData: function( elem, name ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		elem = elem == window ?
			windowData :
			elem;

		var isNode = elem.nodeType,
			id = isNode ? elem[ jQuery.expando ] : elem,
			cache = jQuery.cache,
			thisCache = isNode ? cache[ id ] : id;

		// If we want to remove a specific section of the element's data
		if ( name ) {
			if ( thisCache ) {
				// Remove the section of cache data
				delete thisCache[ name ];

				// If we've removed all the data, remove the element's cache
				if ( isNode && jQuery.isEmptyObject(thisCache) ) {
					jQuery.removeData( elem );
				}
			}

		// Otherwise, we want to remove all of the element's data
		} else {
			if ( isNode && jQuery.support.deleteExpando ) {
				delete elem[ jQuery.expando ];

			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( jQuery.expando );

			// Completely remove the data cache
			} else if ( isNode ) {
				delete cache[ id ];

			// Remove all fields from the object
			} else {
				for ( var n in elem ) {
					delete elem[ n ];
				}
			}
		}
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		if ( typeof key === "undefined" ) {
			return this.length ? jQuery.data( this[0] ) : null;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		var parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			var data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );

				// If nothing was found internally, try to fetch any
				// data from the HTML5 data-* attribute
				if ( data === undefined && this[0].nodeType === 1 ) {
					data = this[0].getAttribute( "data-" + key );

					if ( typeof data === "string" ) {
						try {
							data = data === "true" ? true :
								data === "false" ? false :
								data === "null" ? null :
								!jQuery.isNaN( data ) ? parseFloat( data ) :
								rbrace.test( data ) ? jQuery.parseJSON( data ) :
								data;
						} catch( e ) {}

					} else {
						data = undefined;
					}
				}
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var $this = jQuery( this ), args = [ parts[0], value ];

				$this.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				$this.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});




jQuery.extend({
	queue: function( elem, type, data ) {
		if ( !elem ) {
			return;
		}

		type = (type || "fx") + "queue";
		var q = jQuery.data( elem, type );

		// Speed up dequeue by getting out quickly if this is just a lookup
		if ( !data ) {
			return q || [];
		}

		if ( !q || jQuery.isArray(data) ) {
			q = jQuery.data( elem, type, jQuery.makeArray(data) );

		} else {
			q.push( data );
		}

		return q;
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ), fn = queue.shift();

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift("inprogress");
			}

			fn.call(elem, function() {
				jQuery.dequeue(elem, type);
			});
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function( i ) {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},

	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue( type, function() {
			var elem = this;
			setTimeout(function() {
				jQuery.dequeue( elem, type );
			}, time );
		});
	},

	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	}
});




var rclass = /[\n\t]/g,
	rspaces = /\s+/,
	rreturn = /\r/g,
	rspecialurl = /^(?:href|src|style)$/,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rradiocheck = /^(?:radio|checkbox)$/i;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name, fn ) {
		return this.each(function(){
			jQuery.attr( this, name, "" );
			if ( this.nodeType === 1 ) {
				this.removeAttribute( name );
			}
		});
	},

	addClass: function( value ) {
		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.addClass( value.call(this, i, self.attr("class")) );
			});
		}

		if ( value && typeof value === "string" ) {
			var classNames = (value || "").split( rspaces );

			for ( var i = 0, l = this.length; i < l; i++ ) {
				var elem = this[i];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className ) {
						elem.className = value;

					} else {
						var className = " " + elem.className + " ", setClass = elem.className;
						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( className.indexOf( " " + classNames[c] + " " ) < 0 ) {
								setClass += " " + classNames[c];
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.removeClass( value.call(this, i, self.attr("class")) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			var classNames = (value || "").split( rspaces );

			for ( var i = 0, l = this.length; i < l; i++ ) {
				var elem = this[i];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						var className = (" " + elem.className + " ").replace(rclass, " ");
						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[c] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value, isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.toggleClass( value.call(this, i, self.attr("class"), stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className, i = 0, self = jQuery(this),
					state = stateVal,
					classNames = value.split( rspaces );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery.data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery.data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ";
		for ( var i = 0, l = this.length; i < l; i++ ) {
			if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		if ( !arguments.length ) {
			var elem = this[0];

			if ( elem ) {
				if ( jQuery.nodeName( elem, "option" ) ) {
					// attributes.value is undefined in Blackberry 4.7 but
					// uses .value. See #6932
					var val = elem.attributes.value;
					return !val || val.specified ? elem.value : elem.text;
				}

				// We need to handle select boxes special
				if ( jQuery.nodeName( elem, "select" ) ) {
					var index = elem.selectedIndex,
						values = [],
						options = elem.options,
						one = elem.type === "select-one";

					// Nothing was selected
					if ( index < 0 ) {
						return null;
					}

					// Loop through all the selected options
					for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
						var option = options[ i ];

						// Don't return options that are disabled or in a disabled optgroup
						if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && 
								(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				}

				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				if ( rradiocheck.test( elem.type ) && !jQuery.support.checkOn ) {
					return elem.getAttribute("value") === null ? "on" : elem.value;
				}
				

				// Everything else, we just grab the value
				return (elem.value || "").replace(rreturn, "");

			}

			return undefined;
		}

		var isFunction = jQuery.isFunction(value);

		return this.each(function(i) {
			var self = jQuery(this), val = value;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call(this, i, self.val());
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray(val) ) {
				val = jQuery.map(val, function (value) {
					return value == null ? "" : value + "";
				});
			}

			if ( jQuery.isArray(val) && rradiocheck.test( this.type ) ) {
				this.checked = jQuery.inArray( self.val(), val ) >= 0;

			} else if ( jQuery.nodeName( this, "select" ) ) {
				var values = jQuery.makeArray(val);

				jQuery( "option", this ).each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					this.selectedIndex = -1;
				}

			} else {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},
		
	attr: function( elem, name, value, pass ) {
		// don't set attributes on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
			return undefined;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery(elem)[name](value);
		}

		var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ),
			// Whether we are setting (or getting)
			set = value !== undefined;

		// Try to normalize/fix the name
		name = notxml && jQuery.props[ name ] || name;

		// Only do all the following if this is a node (faster for style)
		if ( elem.nodeType === 1 ) {
			// These attributes require special treatment
			var special = rspecialurl.test( name );

			// Safari mis-reports the default selected property of an option
			// Accessing the parent's selectedIndex property fixes it
			if ( name === "selected" && !jQuery.support.optSelected ) {
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					// Make sure that it also works with optgroups, see #5701
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}

			// If applicable, access the attribute via the DOM 0 way
			// 'in' checks fail in Blackberry 4.7 #6931
			if ( (name in elem || elem[ name ] !== undefined) && notxml && !special ) {
				if ( set ) {
					// We can't allow the type property to be changed (since it causes problems in IE)
					if ( name === "type" && rtype.test( elem.nodeName ) && elem.parentNode ) {
						jQuery.error( "type property can't be changed" );
					}

					if ( value === null ) {
						if ( elem.nodeType === 1 ) {
							elem.removeAttribute( name );
						}

					} else {
						elem[ name ] = value;
					}
				}

				// browsers index elements by id/name on forms, give priority to attributes.
				if ( jQuery.nodeName( elem, "form" ) && elem.getAttributeNode(name) ) {
					return elem.getAttributeNode( name ).nodeValue;
				}

				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				if ( name === "tabIndex" ) {
					var attributeNode = elem.getAttributeNode( "tabIndex" );

					return attributeNode && attributeNode.specified ?
						attributeNode.value :
						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							undefined;
				}

				return elem[ name ];
			}

			if ( !jQuery.support.style && notxml && name === "style" ) {
				if ( set ) {
					elem.style.cssText = "" + value;
				}

				return elem.style.cssText;
			}

			if ( set ) {
				// convert the value to a string (all browsers do this but IE) see #1070
				elem.setAttribute( name, "" + value );
			}

			// Ensure that missing attributes return undefined
			// Blackberry 4.7 returns "" from getAttribute #6938
			if ( !elem.attributes[ name ] && (elem.hasAttribute && !elem.hasAttribute( name )) ) {
				return undefined;
			}

			var attr = !jQuery.support.hrefNormalized && notxml && special ?
					// Some attributes require a special call on IE
					elem.getAttribute( name, 2 ) :
					elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return attr === null ? undefined : attr;
		}
	}
});




var rnamespaces = /\.(.*)$/,
	rformElems = /^(?:textarea|input|select)$/i,
	rperiod = /\./g,
	rspace = / /g,
	rescape = /[^\w\s.|`]/g,
	fcleanup = function( nm ) {
		return nm.replace(rescape, "\\$&");
	},
	focusCounts = { focusin: 0, focusout: 0 };

/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code originated from
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function( elem, types, handler, data ) {
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// For whatever reason, IE has trouble passing the window object
		// around, causing it to be cloned in the process
		if ( jQuery.isWindow( elem ) && ( elem !== window && !elem.frameElement ) ) {
			elem = window;
		}

		if ( handler === false ) {
			handler = returnFalse;
		}

		var handleObjIn, handleObj;

		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the function being executed has a unique ID
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure
		var elemData = jQuery.data( elem );

		// If no elemData is found then we must be trying to bind to one of the
		// banned noData elements
		if ( !elemData ) {
			return;
		}

		// Use a key less likely to result in collisions for plain JS objects.
		// Fixes bug #7150.
		var eventKey = elem.nodeType ? "events" : "__events__",
			events = elemData[ eventKey ],
			eventHandle = elemData.handle;
			
		if ( typeof events === "function" ) {
			// On plain objects events is a fn that holds the the data
			// which prevents this data from being JSON serialized
			// the function does not need to be called, it just contains the data
			eventHandle = events.handle;
			events = events.events;

		} else if ( !events ) {
			if ( !elem.nodeType ) {
				// On plain objects, create a fn that acts as the holder
				// of the values to avoid JSON serialization of event data
				elemData[ eventKey ] = elemData = function(){};
			}

			elemData.events = events = {};
		}

		if ( !eventHandle ) {
			elemData.handle = eventHandle = function() {
				// Handle the second event of a trigger and when
				// an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && !jQuery.event.triggered ?
					jQuery.event.handle.apply( eventHandle.elem, arguments ) :
					undefined;
			};
		}

		// Add elem as a property of the handle function
		// This is to prevent a memory leak with non-native events in IE.
		eventHandle.elem = elem;

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = types.split(" ");

		var type, i = 0, namespaces;

		while ( (type = types[ i++ ]) ) {
			handleObj = handleObjIn ?
				jQuery.extend({}, handleObjIn) :
				{ handler: handler, data: data };

			// Namespaced event handlers
			if ( type.indexOf(".") > -1 ) {
				namespaces = type.split(".");
				type = namespaces.shift();
				handleObj.namespace = namespaces.slice(0).sort().join(".");

			} else {
				namespaces = [];
				handleObj.namespace = "";
			}

			handleObj.type = type;
			if ( !handleObj.guid ) {
				handleObj.guid = handler.guid;
			}

			// Get the current list of functions bound to this event
			var handlers = events[ type ],
				special = jQuery.event.special[ type ] || {};

			// Init the event handler queue
			if ( !handlers ) {
				handlers = events[ type ] = [];

				// Check for a special event handler
				// Only use addEventListener/attachEvent if the special
				// events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}
			
			if ( special.add ) { 
				special.add.call( elem, handleObj ); 

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add the function to the element's handler list
			handlers.push( handleObj );

			// Keep track of which events have been used, for global triggering
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, pos ) {
		// don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		if ( handler === false ) {
			handler = returnFalse;
		}

		var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
			eventKey = elem.nodeType ? "events" : "__events__",
			elemData = jQuery.data( elem ),
			events = elemData && elemData[ eventKey ];

		if ( !elemData || !events ) {
			return;
		}
		
		if ( typeof events === "function" ) {
			elemData = events;
			events = events.events;
		}

		// types is actually an event object here
		if ( types && types.type ) {
			handler = types.handler;
			types = types.type;
		}

		// Unbind all events for the element
		if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
			types = types || "";

			for ( type in events ) {
				jQuery.event.remove( elem, type + types );
			}

			return;
		}

		// Handle multiple events separated by a space
		// jQuery(...).unbind("mouseover mouseout", fn);
		types = types.split(" ");

		while ( (type = types[ i++ ]) ) {
			origType = type;
			handleObj = null;
			all = type.indexOf(".") < 0;
			namespaces = [];

			if ( !all ) {
				// Namespaced event handlers
				namespaces = type.split(".");
				type = namespaces.shift();

				namespace = new RegExp("(^|\\.)" + 
					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
			}

			eventType = events[ type ];

			if ( !eventType ) {
				continue;
			}

			if ( !handler ) {
				for ( j = 0; j < eventType.length; j++ ) {
					handleObj = eventType[ j ];

					if ( all || namespace.test( handleObj.namespace ) ) {
						jQuery.event.remove( elem, origType, handleObj.handler, j );
						eventType.splice( j--, 1 );
					}
				}

				continue;
			}

			special = jQuery.event.special[ type ] || {};

			for ( j = pos || 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( handler.guid === handleObj.guid ) {
					// remove the given handler for the given type
					if ( all || namespace.test( handleObj.namespace ) ) {
						if ( pos == null ) {
							eventType.splice( j--, 1 );
						}

						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}

					if ( pos != null ) {
						break;
					}
				}
			}

			// remove generic event handler if no more handlers exist
			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				ret = null;
				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			var handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			delete elemData.events;
			delete elemData.handle;

			if ( typeof elemData === "function" ) {
				jQuery.removeData( elem, eventKey );

			} else if ( jQuery.isEmptyObject( elemData ) ) {
				jQuery.removeData( elem );
			}
		}
	},

	// bubbling is internal
	trigger: function( event, data, elem /*, bubbling */ ) {
		// Event object or event type
		var type = event.type || event,
			bubbling = arguments[3];

		if ( !bubbling ) {
			event = typeof event === "object" ?
				// jQuery.Event object
				event[ jQuery.expando ] ? event :
				// Object literal
				jQuery.extend( jQuery.Event(type), event ) :
				// Just the event type (string)
				jQuery.Event(type);

			if ( type.indexOf("!") >= 0 ) {
				event.type = type = type.slice(0, -1);
				event.exclusive = true;
			}

			// Handle a global trigger
			if ( !elem ) {
				// Don't bubble custom events when global (to avoid too much overhead)
				event.stopPropagation();

				// Only trigger if we've ever bound an event for it
				if ( jQuery.event.global[ type ] ) {
					jQuery.each( jQuery.cache, function() {
						if ( this.events && this.events[type] ) {
							jQuery.event.trigger( event, data, this.handle.elem );
						}
					});
				}
			}

			// Handle triggering a single element

			// don't do events on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
				return undefined;
			}

			// Clean up in case it is reused
			event.result = undefined;
			event.target = elem;

			// Clone the incoming data, if any
			data = jQuery.makeArray( data );
			data.unshift( event );
		}

		event.currentTarget = elem;

		// Trigger the event, it is assumed that "handle" is a function
		var handle = elem.nodeType ?
			jQuery.data( elem, "handle" ) :
			(jQuery.data( elem, "__events__" ) || {}).handle;

		if ( handle ) {
			handle.apply( elem, data );
		}

		var parent = elem.parentNode || elem.ownerDocument;

		// Trigger an inline bound script
		try {
			if ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) {
				if ( elem[ "on" + type ] && elem[ "on" + type ].apply( elem, data ) === false ) {
					event.result = false;
					event.preventDefault();
				}
			}

		// prevent IE from throwing an error for some elements with some event types, see #3533
		} catch (inlineError) {}

		if ( !event.isPropagationStopped() && parent ) {
			jQuery.event.trigger( event, data, parent, true );

		} else if ( !event.isDefaultPrevented() ) {
			var target = event.target, old, targetType = type.replace(rnamespaces, ""),
				isClick = jQuery.nodeName(target, "a") && targetType === "click",
				special = jQuery.event.special[ targetType ] || {};

			if ( (!special._default || special._default.call( elem, event ) === false) && 
				!isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) {

				try {
					if ( target[ targetType ] ) {
						// Make sure that we don't accidentally re-trigger the onFOO events
						old = target[ "on" + targetType ];

						if ( old ) {
							target[ "on" + targetType ] = null;
						}

						jQuery.event.triggered = true;
						target[ targetType ]();
					}

				// prevent IE from throwing an error for some elements with some event types, see #3533
				} catch (triggerError) {}

				if ( old ) {
					target[ "on" + targetType ] = old;
				}

				jQuery.event.triggered = false;
			}
		}
	},

	handle: function( event ) {
		var all, handlers, namespaces, namespace_sort = [], namespace_re, events, args = jQuery.makeArray( arguments );

		event = args[0] = jQuery.event.fix( event || window.event );
		event.currentTarget = this;

		// Namespaced event handlers
		all = event.type.indexOf(".") < 0 && !event.exclusive;

		if ( !all ) {
			namespaces = event.type.split(".");
			event.type = namespaces.shift();
			namespace_sort = namespaces.slice(0).sort();
			namespace_re = new RegExp("(^|\\.)" + namespace_sort.join("\\.(?:.*\\.)?") + "(\\.|$)");
		}

		event.namespace = event.namespace || namespace_sort.join(".");

		events = jQuery.data(this, this.nodeType ? "events" : "__events__");

		if ( typeof events === "function" ) {
			events = events.events;
		}

		handlers = (events || {})[ event.type ];

		if ( events && handlers ) {
			// Clone the handlers to prevent manipulation
			handlers = handlers.slice(0);

			for ( var j = 0, l = handlers.length; j < l; j++ ) {
				var handleObj = handlers[ j ];

				// Filter the functions by class
				if ( all || namespace_re.test( handleObj.namespace ) ) {
					// Pass in a reference to the handler function itself
					// So that we can later remove it
					event.handler = handleObj.handler;
					event.data = handleObj.data;
					event.handleObj = handleObj;
	
					var ret = handleObj.handler.apply( this, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}

					if ( event.isImmediatePropagationStopped() ) {
						break;
					}
				}
			}
		}

		return event.result;
	},

	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// store a copy of the original event object
		// and "clone" to set read-only properties
		var originalEvent = event;
		event = jQuery.Event( originalEvent );

		for ( var i = this.props.length, prop; i; ) {
			prop = this.props[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary
		if ( !event.target ) {
			event.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either
		}

		// check if target is a textnode (safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement ) {
			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
		}

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var doc = document.documentElement, body = document.body;
			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
		}

		// Add which for key events
		if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
			event.which = event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey ) {
			event.metaKey = event.ctrlKey;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button !== undefined ) {
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
		}

		return event;
	},

	// Deprecated, use jQuery.guid instead
	guid: 1E8,

	// Deprecated, use jQuery.proxy instead
	proxy: jQuery.proxy,

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady,
			teardown: jQuery.noop
		},

		live: {
			add: function( handleObj ) {
				jQuery.event.add( this,
					liveConvert( handleObj.origType, handleObj.selector ),
					jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) ); 
			},

			remove: function( handleObj ) {
				jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
			}
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} : 
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src ) {
	// Allow instantiation without the 'new' keyword
	if ( !this.preventDefault ) {
		return new jQuery.Event( src );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;
	// Event type
	} else {
		this.type = src;
	}

	// timeStamp is buggy for some events on Firefox(#3843)
	// So we won't rely on the native value
	this.timeStamp = jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		
		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Checks if an event happened on an element within another element
// Used in jQuery.event.special.mouseenter and mouseleave handlers
var withinElement = function( event ) {
	// Check if mouse(over|out) are still within the same parent element
	var parent = event.relatedTarget;

	// Firefox sometimes assigns relatedTarget a XUL element
	// which we cannot access the parentNode property of
	try {
		// Traverse up the tree
		while ( parent && parent !== this ) {
			parent = parent.parentNode;
		}

		if ( parent !== this ) {
			// set the correct event type
			event.type = event.data;

			// handle event if we actually just moused on to a non sub-element
			jQuery.event.handle.apply( this, arguments );
		}

	// assuming we've left the element since we most likely mousedover a xul element
	} catch(e) { }
},

// In case of event delegation, we only need to rename the event.type,
// liveHandler will take care of the rest.
delegate = function( event ) {
	event.type = event.data;
	jQuery.event.handle.apply( this, arguments );
};

// Create mouseenter and mouseleave events
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		setup: function( data ) {
			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
		},
		teardown: function( data ) {
			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
		}
	};
});

// submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function( data, namespaces ) {
			if ( this.nodeName.toLowerCase() !== "form" ) {
				jQuery.event.add(this, "click.specialSubmit", function( e ) {
					var elem = e.target, type = elem.type;

					if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
						e.liveFired = undefined;
						return trigger( "submit", this, arguments );
					}
				});
	 
				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
					var elem = e.target, type = elem.type;

					if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
						e.liveFired = undefined;
						return trigger( "submit", this, arguments );
					}
				});

			} else {
				return false;
			}
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialSubmit" );
		}
	};

}

// change delegation, happens here so we have bind.
if ( !jQuery.support.changeBubbles ) {

	var changeFilters,

	getVal = function( elem ) {
		var type = elem.type, val = elem.value;

		if ( type === "radio" || type === "checkbox" ) {
			val = elem.checked;

		} else if ( type === "select-multiple" ) {
			val = elem.selectedIndex > -1 ?
				jQuery.map( elem.options, function( elem ) {
					return elem.selected;
				}).join("-") :
				"";

		} else if ( elem.nodeName.toLowerCase() === "select" ) {
			val = elem.selectedIndex;
		}

		return val;
	},

	testChange = function testChange( e ) {
		var elem = e.target, data, val;

		if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
			return;
		}

		data = jQuery.data( elem, "_change_data" );
		val = getVal(elem);

		// the current data will be also retrieved by beforeactivate
		if ( e.type !== "focusout" || elem.type !== "radio" ) {
			jQuery.data( elem, "_change_data", val );
		}
		
		if ( data === undefined || val === data ) {
			return;
		}

		if ( data != null || val ) {
			e.type = "change";
			e.liveFired = undefined;
			return jQuery.event.trigger( e, arguments[1], elem );
		}
	};

	jQuery.event.special.change = {
		filters: {
			focusout: testChange, 

			beforedeactivate: testChange,

			click: function( e ) {
				var elem = e.target, type = elem.type;

				if ( type === "radio" || type === "checkbox" || elem.nodeName.toLowerCase() === "select" ) {
					return testChange.call( this, e );
				}
			},

			// Change has to be called before submit
			// Keydown will be called before keypress, which is used in submit-event delegation
			keydown: function( e ) {
				var elem = e.target, type = elem.type;

				if ( (e.keyCode === 13 && elem.nodeName.toLowerCase() !== "textarea") ||
					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
					type === "select-multiple" ) {
					return testChange.call( this, e );
				}
			},

			// Beforeactivate happens also before the previous element is blurred
			// with this event you can't trigger a change event, but you can store
			// information
			beforeactivate: function( e ) {
				var elem = e.target;
				jQuery.data( elem, "_change_data", getVal(elem) );
			}
		},

		setup: function( data, namespaces ) {
			if ( this.type === "file" ) {
				return false;
			}

			for ( var type in changeFilters ) {
				jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
			}

			return rformElems.test( this.nodeName );
		},

		teardown: function( namespaces ) {
			jQuery.event.remove( this, ".specialChange" );

			return rformElems.test( this.nodeName );
		}
	};

	changeFilters = jQuery.event.special.change.filters;

	// Handle when the input is .focus()'d
	changeFilters.focus = changeFilters.beforeactivate;
}

function trigger( type, elem, args ) {
	args[0].type = type;
	return jQuery.event.handle.apply( elem, args );
}

// Create "bubbling" focus and blur events
if ( document.addEventListener ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( focusCounts[fix]++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			}, 
			teardown: function() { 
				if ( --focusCounts[fix] === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};

		function handler( e ) { 
			e = jQuery.event.fix( e );
			e.type = fix;
			return jQuery.event.trigger( e, null, e.target );
		}
	});
}

jQuery.each(["bind", "one"], function( i, name ) {
	jQuery.fn[ name ] = function( type, data, fn ) {
		// Handle object literals
		if ( typeof type === "object" ) {
			for ( var key in type ) {
				this[ name ](key, data, type[key], fn);
			}
			return this;
		}
		
		if ( jQuery.isFunction( data ) || data === false ) {
			fn = data;
			data = undefined;
		}

		var handler = name === "one" ? jQuery.proxy( fn, function( event ) {
			jQuery( this ).unbind( event, handler );
			return fn.apply( this, arguments );
		}) : fn;

		if ( type === "unload" && name !== "one" ) {
			this.one( type, data, fn );

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.add( this[i], type, handler, data );
			}
		}

		return this;
	};
});

jQuery.fn.extend({
	unbind: function( type, fn ) {
		// Handle object literals
		if ( typeof type === "object" && !type.preventDefault ) {
			for ( var key in type ) {
				this.unbind(key, type[key]);
			}

		} else {
			for ( var i = 0, l = this.length; i < l; i++ ) {
				jQuery.event.remove( this[i], type, fn );
			}
		}

		return this;
	},
	
	delegate: function( selector, types, data, fn ) {
		return this.live( types, data, fn, selector );
	},
	
	undelegate: function( selector, types, fn ) {
		if ( arguments.length === 0 ) {
				return this.unbind( "live" );
		
		} else {
			return this.die( types, null, fn, selector );
		}
	},
	
	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},

	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			var event = jQuery.Event( type );
			event.preventDefault();
			event.stopPropagation();
			jQuery.event.trigger( event, data, this[0] );
			return event.result;
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments, i = 1;

		// link all the functions, so any of them can unbind this click handler
		while ( i < args.length ) {
			jQuery.proxy( fn, args[ i++ ] );
		}

		return this.click( jQuery.proxy( fn, function( event ) {
			// Figure out which function to execute
			var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
			jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );

			// Make sure that clicks stop
			event.preventDefault();

			// and execute the function
			return args[ lastToggle ].apply( this, arguments ) || false;
		}));
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

var liveMap = {
	focus: "focusin",
	blur: "focusout",
	mouseenter: "mouseover",
	mouseleave: "mouseout"
};

jQuery.each(["live", "die"], function( i, name ) {
	jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
		var type, i = 0, match, namespaces, preType,
			selector = origSelector || this.selector,
			context = origSelector ? this : jQuery( this.context );
		
		if ( typeof types === "object" && !types.preventDefault ) {
			for ( var key in types ) {
				context[ name ]( key, data, types[key], selector );
			}
			
			return this;
		}

		if ( jQuery.isFunction( data ) ) {
			fn = data;
			data = undefined;
		}

		types = (types || "").split(" ");

		while ( (type = types[ i++ ]) != null ) {
			match = rnamespaces.exec( type );
			namespaces = "";

			if ( match )  {
				namespaces = match[0];
				type = type.replace( rnamespaces, "" );
			}

			if ( type === "hover" ) {
				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
				continue;
			}

			preType = type;

			if ( type === "focus" || type === "blur" ) {
				types.push( liveMap[ type ] + namespaces );
				type = type + namespaces;

			} else {
				type = (liveMap[ type ] || type) + namespaces;
			}

			if ( name === "live" ) {
				// bind live handler
				for ( var j = 0, l = context.length; j < l; j++ ) {
					jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
				}

			} else {
				// unbind live handler
				context.unbind( "live." + liveConvert( type, selector ), fn );
			}
		}
		
		return this;
	};
});

function liveHandler( event ) {
	var stop, maxLevel, elems = [], selectors = [],
		related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
		events = jQuery.data( this, this.nodeType ? "events" : "__events__" );

	if ( typeof events === "function" ) {
		events = events.events;
	}

	// Make sure we avoid non-left-click bubbling in Firefox (#3861)
	if ( event.liveFired === this || !events || !events.live || event.button && event.type === "click" ) {
		return;
	}

	if ( event.namespace ) {
		namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
	}

	event.liveFired = this;

	var live = events.live.slice(0);

	for ( j = 0; j < live.length; j++ ) {
		handleObj = live[j];

		if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
			selectors.push( handleObj.selector );

		} else {
			live.splice( j--, 1 );
		}
	}

	match = jQuery( event.target ).closest( selectors, event.currentTarget );

	for ( i = 0, l = match.length; i < l; i++ ) {
		close = match[i];

		for ( j = 0; j < live.length; j++ ) {
			handleObj = live[j];

			if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) ) {
				elem = close.elem;
				related = null;

				// Those two events require additional checking
				if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
					event.type = handleObj.preType;
					related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];
				}

				if ( !related || related !== elem ) {
					elems.push({ elem: elem, handleObj: handleObj, level: close.level });
				}
			}
		}
	}

	for ( i = 0, l = elems.length; i < l; i++ ) {
		match = elems[i];

		if ( maxLevel && match.level > maxLevel ) {
			break;
		}

		event.currentTarget = match.elem;
		event.data = match.handleObj.data;
		event.handleObj = match.handleObj;

		ret = match.handleObj.origHandler.apply( match.elem, arguments );

		if ( ret === false || event.isPropagationStopped() ) {
			maxLevel = match.level;

			if ( ret === false ) {
				stop = false;
			}
		}
	}

	return stop;
}

function liveConvert( type, selector ) {
	return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspace, "&");
}

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.bind( name, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}
});

// Prevent memory leaks in IE
// Window isn't included so as not to unbind existing unload events
// More info:
//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/
if ( window.attachEvent && !window.addEventListener ) {
	jQuery(window).bind("unload", function() {
		for ( var id in jQuery.cache ) {
			if ( jQuery.cache[ id ].handle ) {
				// Try/Catch is to handle iframes being unloaded, see #4280
				try {
					jQuery.event.remove( jQuery.cache[ id ].handle.elem );
				} catch(e) {}
			}
		}
	});
}


/*!
 * Sizzle CSS Selector Engine - v1.0
 *  Copyright 2009, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function(){
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function(selector, context, results, seed) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var parts = [], m, set, checkSet, extra, prune = true, contextXML = Sizzle.isXML(context),
		soFar = selector, ret, cur, pop, i;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec("");
		m = chunker.exec(soFar);

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {
		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context );
		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set );
			}
		}
	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
			set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray(set);
			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}
		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );
		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}
		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}
	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function(results){
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort(sortOrder);

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[i-1] ) {
					results.splice(i--, 1);
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function(expr, set){
	return Sizzle(expr, null, null, set);
};

Sizzle.matchesSelector = function(node, expr){
	return Sizzle(expr, null, null, [node]).length > 0;
};

Sizzle.find = function(expr, context, isXML){
	var set;

	if ( !expr ) {
		return [];
	}

	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
		var type = Expr.order[i], match;
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			var left = match[1];
			match.splice(1,1);

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace(/\\/g, "");
				set = Expr.find[ type ]( match, context, isXML );
				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = context.getElementsByTagName("*");
	}

	return {set: set, expr: expr};
};

Sizzle.filter = function(expr, set, inplace, not){
	var old = expr, result = [], curLoop = set, match, anyFound,
		isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

	while ( expr && set.length ) {
		for ( var type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				var filter = Expr.filter[ type ], found, item, left = match[1];
				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;
					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							var pass = not ^ !!found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;
								} else {
									curLoop[i] = false;
								}
							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );
			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw "Syntax error, unrecognized expression: " + msg;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],
	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},
	leftMatch: {},
	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},
	attrHandle: {
		href: function(elem){
			return elem.getAttribute("href");
		}
	},
	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !/\W/.test(part),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},
		">": function(checkSet, part){
			var isPartStr = typeof part === "string",
				elem, i = 0, l = checkSet.length;

			if ( isPartStr && !/\W/.test(part) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];
					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}
			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];
					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},
		"": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck, nodeCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
		},
		"~": function(checkSet, part, isXML){
			var doneName = done++, checkFn = dirCheck, nodeCheck;

			if ( typeof part === "string" && !/\W/.test(part) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
		}
	},
	find: {
		ID: function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},
		NAME: function(match, context){
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [], results = context.getElementsByName(match[1]);

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},
		TAG: function(match, context){
			return context.getElementsByTagName(match[1]);
		}
	},
	preFilter: {
		CLASS: function(match, curLoop, inplace, result, not, isXML){
			match = " " + match[1].replace(/\\/g, "") + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}
					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},
		ID: function(match){
			return match[1].replace(/\\/g, "");
		},
		TAG: function(match, curLoop){
			return match[1].toLowerCase();
		},
		CHILD: function(match){
			if ( match[1] === "nth" ) {
				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},
		ATTR: function(match, curLoop, inplace, result, not, isXML){
			var name = match[1].replace(/\\/g, "");
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},
		PSEUDO: function(match, curLoop, inplace, result, not){
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);
				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
					if ( !inplace ) {
						result.push.apply( result, ret );
					}
					return false;
				}
			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},
		POS: function(match){
			match.unshift( true );
			return match;
		}
	},
	filters: {
		enabled: function(elem){
			return elem.disabled === false && elem.type !== "hidden";
		},
		disabled: function(elem){
			return elem.disabled === true;
		},
		checked: function(elem){
			return elem.checked === true;
		},
		selected: function(elem){
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			elem.parentNode.selectedIndex;
			return elem.selected === true;
		},
		parent: function(elem){
			return !!elem.firstChild;
		},
		empty: function(elem){
			return !elem.firstChild;
		},
		has: function(elem, i, match){
			return !!Sizzle( match[3], elem ).length;
		},
		header: function(elem){
			return (/h\d/i).test( elem.nodeName );
		},
		text: function(elem){
			return "text" === elem.type;
		},
		radio: function(elem){
			return "radio" === elem.type;
		},
		checkbox: function(elem){
			return "checkbox" === elem.type;
		},
		file: function(elem){
			return "file" === elem.type;
		},
		password: function(elem){
			return "password" === elem.type;
		},
		submit: function(elem){
			return "submit" === elem.type;
		},
		image: function(elem){
			return "image" === elem.type;
		},
		reset: function(elem){
			return "reset" === elem.type;
		},
		button: function(elem){
			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
		},
		input: function(elem){
			return (/input|select|textarea|button/i).test(elem.nodeName);
		}
	},
	setFilters: {
		first: function(elem, i){
			return i === 0;
		},
		last: function(elem, i, match, array){
			return i === array.length - 1;
		},
		even: function(elem, i){
			return i % 2 === 0;
		},
		odd: function(elem, i){
			return i % 2 === 1;
		},
		lt: function(elem, i, match){
			return i < match[3] - 0;
		},
		gt: function(elem, i, match){
			return i > match[3] - 0;
		},
		nth: function(elem, i, match){
			return match[3] - 0 === i;
		},
		eq: function(elem, i, match){
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function(elem, match, i, array){
			var name = match[1], filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;
			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;
			} else {
				Sizzle.error( "Syntax error, unrecognized expression: " + name );
			}
		},
		CHILD: function(elem, match){
			var type = match[1], node = elem;
			switch (type) {
				case 'only':
				case 'first':
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}
					if ( type === "first" ) { 
						return true; 
					}
					node = elem;
				case 'last':
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}
					return true;
				case 'nth':
					var first = match[2], last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					var doneName = match[0],
						parent = elem.parentNode;
	
					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
						var count = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 
						parent.sizcache = doneName;
					}
					
					var diff = elem.nodeIndex - last;
					if ( first === 0 ) {
						return diff === 0;
					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},
		ID: function(elem, match){
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},
		TAG: function(elem, match){
			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
		},
		CLASS: function(elem, match){
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},
		ATTR: function(elem, match){
			var name = match[1],
				result = Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},
		POS: function(elem, match, i, array){
			var name = match[2], filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function(array, results) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch(e){
	makeArray = function(array, results) {
		var ret = results || [], i = 0;

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );
		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}
			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};
} else {
	sortOrder = function( a, b ) {
		var ap = [], bp = [], aup = a.parentNode, bup = b.parentNode,
			cur = aup, al, bl;

		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// If the nodes are siblings (or identical) we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Utility function for retreiving the text value of an array of DOM nodes
Sizzle.getText = function( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += Sizzle.getText( elem.childNodes );
		}
	}

	return ret;
};

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime();
	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	var root = document.documentElement;
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function(match, context, isXML){
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
			}
		};

		Expr.filter.ID = function(elem, match){
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );
	root = form = null; // release memory in IE
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function(match, context){
			var results = context.getElementsByTagName(match[1]);

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";
	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {
		Expr.attrHandle.href = function(elem){
			return elem.getAttribute("href", 2);
		};
	}

	div = null; // release memory in IE
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle, div = document.createElement("div");
		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function(query, context, extra, seed){
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				if ( context.nodeType === 9 ) {
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var old = context.id, id = context.id = "__sizzle__";

					try {
						return makeArray( context.querySelectorAll( "#" + id + " " + query ), extra );

					} catch(pseudoError) {
					} finally {
						if ( old ) {
							context.id = old;

						} else {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		div = null; // release memory in IE
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,
		pseudoWorks = false;

	try {
		// This should fail with an exception
		// Gecko does not error, returns false instead
		matches.call( document.documentElement, ":sizzle" );
	
	} catch( pseudoError ) {
		pseudoWorks = true;
	}

	if ( matches ) {
		Sizzle.matchesSelector = function( node, expr ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) ) {
						return matches.call( node, expr );
					}
				} catch(e) {}

				return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function(match, context, isXML) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	div = null; // release memory in IE
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem.sizcache = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];
		if ( elem ) {
			elem = elem[dir];
			var match = false;

			while ( elem ) {
				if ( elem.sizcache === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem.sizcache = doneName;
						elem.sizset = i;
					}
					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

Sizzle.contains = document.documentElement.contains ? function(a, b){
	return a !== b && (a.contains ? a.contains(b) : true);
} : function(a, b){
	return !!(a.compareDocumentPosition(b) & 16);
};

Sizzle.isXML = function(elem){
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function(selector, context){
	var tmpSet = [], later = "", match,
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS;

jQuery.fn.extend({
	find: function( selector ) {
		var ret = this.pushStack( "", "find", selector ), length = 0;

		for ( var i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( var n = length; n < ret.length; n++ ) {
					for ( var r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},
	
	is: function( selector ) {
		return !!selector && jQuery.filter( selector, this ).length > 0;
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		if ( jQuery.isArray( selectors ) ) {
			var match, matches = {}, selector, level = 1;

			if ( cur && selectors.length ) {
				for ( i = 0, l = selectors.length; i < l; i++ ) {
					selector = selectors[i];

					if ( !matches[selector] ) {
						matches[selector] = jQuery.expr.match.POS.test( selector ) ? 
							jQuery( selector, context || this.context ) :
							selector;
					}
				}

				while ( cur && cur.ownerDocument && cur !== context ) {
					for ( selector in matches ) {
						match = matches[selector];

						if ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) {
							ret.push({ selector: selector, elem: cur, level: level });
						}
					}

					cur = cur.parentNode;
					level++;
				}
			}

			return ret;
		}

		var pos = POS.test( selectors ) ? 
			jQuery( selectors, context || this.context ) : null;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique(ret) : ret;
		
		return this.pushStack( ret, "closest", selectors );
	},
	
	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {
		if ( !elem || typeof elem === "string" ) {
			return jQuery.inArray( this[0],
				// If it receives a string, the selector is used
				// If it receives nothing, the siblings are used
				elem ? jQuery( elem ) : this.parent().children() );
		}
		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context || this.context ) :
				jQuery.makeArray( selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );
		
		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call(arguments).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},
	
	dir: function( elem, dir, until ) {
		var matched = [], cur = elem[dir];
		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return (elem === qualifier) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
	});
}




var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,  // checked="checked" or checked (html5)
	raction = /\=([^="'>\s]+\/)>/g,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	};

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append(this);
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ), contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		return this.each(function() {
			jQuery( this ).wrapAll( html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery(arguments[0]);
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery(arguments[0]).toArray() );
			return set;
		}
	},
	
	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					 elem.parentNode.removeChild( elem );
				}
			}
		}
		
		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}
		
		return this;
	},

	clone: function( events ) {
		// Do the clone
		var ret = this.map(function() {
			if ( !jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this) ) {
				// IE copies events bound via attachEvent when
				// using cloneNode. Calling detachEvent on the
				// clone will also remove the events from the orignal
				// In order to get around this, we use innerHTML.
				// Unfortunately, this means some modifications to
				// attributes in IE that are actually only stored
				// as properties will not be copied (such as the
				// the name attribute on an input).
				var html = this.outerHTML, ownerDocument = this.ownerDocument;
				if ( !html ) {
					var div = ownerDocument.createElement("div");
					div.appendChild( this.cloneNode(true) );
					html = div.innerHTML;
				}

				return jQuery.clean([html.replace(rinlinejQuery, "")
					// Handle the case in IE 8 where action=/test/> self-closes a tag
					.replace(raction, '="$1">')
					.replace(rleadingWhitespace, "")], ownerDocument)[0];
			} else {
				return this.cloneNode(true);
			}
		});

		// Copy the events from the original to the clone
		if ( events === true ) {
			cloneCopyEvent( this, ret );
			cloneCopyEvent( this.find("*"), ret.find("*") );
		}

		// Return the cloned set
		return ret;
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnocache.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery(this);
				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery(value).detach();
			}

			return this.each(function() {
				var next = this.nextSibling, parent = this.parentNode;

				jQuery(this).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value );
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, value = args[0], scripts = [], fragment, parent;

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}
			
			fragment = results.fragment;
			
			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						i > 0 || results.cacheable || this.length > 1  ?
							fragment.cloneNode(true) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent(orig, ret) {
	var i = 0;

	ret.each(function() {
		if ( this.nodeName !== (orig[i] && orig[i].nodeName) ) {
			return;
		}

		var oldData = jQuery.data( orig[i++] ), curData = jQuery.data( this, oldData ), events = oldData && oldData.events;

		if ( events ) {
			delete curData.handle;
			curData.events = {};

			for ( var type in events ) {
				for ( var handler in events[ type ] ) {
					jQuery.event.add( this, type, events[ type ][ handler ], events[ type ][ handler ].data );
				}
			}
		}
	});
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults,
		doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);

	// Only cache "small" (1/2 KB) strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
		!rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {

		cacheable = true;
		cacheresults = jQuery.fragments[ args[0] ];
		if ( cacheresults ) {
			if ( cacheresults !== 1 ) {
				fragment = cacheresults;
			}
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [], insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;
		
		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;
			
		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = (i > 0 ? this.clone(true) : this).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}
		
			return this.pushStack( ret, name, insert.selector );
		}
	};
});

jQuery.extend({
	clean: function( elems, context, fragment, scripts ) {
		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [];

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" && !rhtml.test( elem ) ) {
				elem = context.createTextNode( elem );

			} else if ( typeof elem === "string" ) {
				// Fix "XHTML"-style tags in all browsers
				elem = elem.replace(rxhtmlTag, "<$1></$2>");

				// Trim whitespace, otherwise indexOf won't work as expected
				var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
					wrap = wrapMap[ tag ] || wrapMap._default,
					depth = wrap[0],
					div = context.createElement("div");

				// Go to html and back, then peel off extra wrappers
				div.innerHTML = wrap[1] + elem + wrap[2];

				// Move to the right depth
				while ( depth-- ) {
					div = div.lastChild;
				}

				// Remove IE's autoinserted <tbody> from table fragments
				if ( !jQuery.support.tbody ) {

					// String was a <table>, *may* have spurious <tbody>
					var hasBody = rtbody.test(elem),
						tbody = tag === "table" && !hasBody ?
							div.firstChild && div.firstChild.childNodes :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !hasBody ?
								div.childNodes :
								[];

					for ( var j = tbody.length - 1; j >= 0 ; --j ) {
						if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
							tbody[ j ].parentNode.removeChild( tbody[ j ] );
						}
					}

				}

				// IE completely kills leading whitespace when innerHTML is used
				if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
					div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
				}

				elem = div.childNodes;
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
				
				} else {
					if ( ret[i].nodeType === 1 ) {
						ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},
	
	cleanData: function( elems ) {
		var data, id, cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;
		
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];
			
			if ( id ) {
				data = cache[ id ];
				
				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}
				}
				
				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}
				
				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || "" );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rdashAlpha = /-([a-z])/ig,
	rupper = /([A-Z])/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	// cache check for defaultView.getComputedStyle
	getComputedStyle = document.defaultView && document.defaultView.getComputedStyle,

	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"zIndex": true,
		"fontWeight": true,
		"opacity": true,
		"zoom": true,
		"lineHeight": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			// Make sure that NaN and null values aren't set. See: #7116
			if ( typeof value === "number" && isNaN( value ) || value == null ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( typeof value === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		// Make sure that we're working with the right name
		var ret, origName = jQuery.camelCase( name ),
			hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name, origName );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	},

	camelCase: function( string ) {
		return string.replace( rdashAlpha, fcamelCase );
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					val = getWH( elem, name, extra );

				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val + "px";
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat(value);

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
				(parseFloat(RegExp.$1) / 100) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style;

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// Set the alpha filter to set the opacity
			var opacity = jQuery.isNaN(value) ?
				"" :
				"alpha(opacity=" + value * 100 + ")",
				filter = style.filter || "";

			style.filter = ralpha.test(filter) ?
				filter.replace(ralpha, opacity) :
				style.filter + ' ' + opacity;
		}
	};
}

if ( getComputedStyle ) {
	curCSS = function( elem, newName, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( !(defaultView = elem.ownerDocument.defaultView) ) {
			return undefined;
		}

		if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};

} else if ( document.documentElement.currentStyle ) {
	curCSS = function( elem, name ) {
		var left, rsLeft, ret = elem.currentStyle && elem.currentStyle[ name ], style = elem.style;

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			elem.runtimeStyle.left = elem.currentStyle.left;
			style.left = name === "fontSize" ? "1em" : (ret || 0);
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			elem.runtimeStyle.left = rsLeft;
		}

		return ret;
	};
}

function getWH( elem, name, extra ) {
	var which = name === "width" ? cssWidth : cssHeight,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight;

	if ( extra === "border" ) {
		return val;
	}

	jQuery.each( which, function() {
		if ( !extra ) {
			val -= parseFloat(jQuery.css( elem, "padding" + this )) || 0;
		}

		if ( extra === "margin" ) {
			val += parseFloat(jQuery.css( elem, "margin" + this )) || 0;

		} else {
			val -= parseFloat(jQuery.css( elem, "border" + this + "Width" )) || 0;
		}
	});

	return val;
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth, height = elem.offsetHeight;

		return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var jsc = jQuery.now(),
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rnoContent = /^(?:GET|HEAD|DELETE)$/,
	rbracket = /\[\]$/,
	jsre = /\=\?(&|$)/,
	rquery = /\?/,
	rts = /([?&])_=[^&]*/,
	rurl = /^(\w+:)?\/\/([^\/?#]+)/,
	r20 = /%20/g,
	rhash = /#.*$/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load;

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf(" ");
		if ( off >= 0 ) {
			var selector = url.slice(off, url.length);
			url = url.slice(0, off);
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = null;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			complete: function( res, status ) {
				// If successful, inject the HTML into all the matched elements
				if ( status === "success" || status === "notmodified" ) {
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(res.responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						res.responseText );
				}

				if ( callback ) {
					self.each( callback, [res.responseText, status, res] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param(this.serializeArray());
	},

	serializeArray: function() {
		return this.map(function() {
			return this.elements ? jQuery.makeArray(this.elements) : this;
		})
		.filter(function() {
			return this.name && !this.disabled &&
				(this.checked || rselectTextarea.test(this.nodeName) ||
					rinput.test(this.type));
		})
		.map(function( i, elem ) {
			var val = jQuery(this).val();

			return val == null ?
				null :
				jQuery.isArray(val) ?
					jQuery.map( val, function( val, i ) {
						return { name: elem.name, value: val };
					}) :
					{ name: elem.name, value: val };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function( i, o ) {
	jQuery.fn[o] = function( f ) {
		return this.bind(o, f);
	};
});

jQuery.extend({
	get: function( url, data, callback, type ) {
		// shift arguments if data argument was omited
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = null;
		}

		return jQuery.ajax({
			type: "GET",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	getScript: function( url, callback ) {
		return jQuery.get(url, null, callback, "script");
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get(url, data, callback, "json");
	},

	post: function( url, data, callback, type ) {
		// shift arguments if data argument was omited
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = {};
		}

		return jQuery.ajax({
			type: "POST",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},

	ajaxSetup: function( settings ) {
		jQuery.extend( jQuery.ajaxSettings, settings );
	},

	ajaxSettings: {
		url: location.href,
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		username: null,
		password: null,
		traditional: false,
		*/
		// This function can be overriden by calling jQuery.ajaxSetup
		xhr: function() {
			return new window.XMLHttpRequest();
		},
		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			script: "text/javascript, application/javascript",
			json: "application/json, text/javascript",
			text: "text/plain",
			_default: "*/*"
		}
	},

	ajax: function( origSettings ) {
		var s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings),
			jsonp, status, data, type = s.type.toUpperCase(), noContent = rnoContent.test(type);

		s.url = s.url.replace( rhash, "" );

		// Use original (not extended) context object if it was provided
		s.context = origSettings && origSettings.context != null ? origSettings.context : s;

		// convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Handle JSONP Parameter Callbacks
		if ( s.dataType === "jsonp" ) {
			if ( type === "GET" ) {
				if ( !jsre.test( s.url ) ) {
					s.url += (rquery.test( s.url ) ? "&" : "?") + (s.jsonp || "callback") + "=?";
				}
			} else if ( !s.data || !jsre.test(s.data) ) {
				s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";
			}
			s.dataType = "json";
		}

		// Build temporary JSONP function
		if ( s.dataType === "json" && (s.data && jsre.test(s.data) || jsre.test(s.url)) ) {
			jsonp = s.jsonpCallback || ("jsonp" + jsc++);

			// Replace the =? sequence both in the query string and the data
			if ( s.data ) {
				s.data = (s.data + "").replace(jsre, "=" + jsonp + "$1");
			}

			s.url = s.url.replace(jsre, "=" + jsonp + "$1");

			// We need to make sure
			// that a JSONP style response is executed properly
			s.dataType = "script";

			// Handle JSONP-style loading
			var customJsonp = window[ jsonp ];

			window[ jsonp ] = function( tmp ) {
				data = tmp;
				jQuery.handleSuccess( s, xhr, status, data );
				jQuery.handleComplete( s, xhr, status, data );

				if ( jQuery.isFunction( customJsonp ) ) {
					customJsonp( tmp );

				} else {
					// Garbage collect
					window[ jsonp ] = undefined;

					try {
						delete window[ jsonp ];
					} catch( jsonpError ) {}
				}
				
				if ( head ) {
					head.removeChild( script );
				}
			};
		}

		if ( s.dataType === "script" && s.cache === null ) {
			s.cache = false;
		}

		if ( s.cache === false && type === "GET" ) {
			var ts = jQuery.now();

			// try replacing _= if it is there
			var ret = s.url.replace(rts, "$1_=" + ts);

			// if nothing was replaced, add timestamp to the end
			s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
		}

		// If data is available, append data to url for get requests
		if ( s.data && type === "GET" ) {
			s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
		}

		// Watch for a new set of requests
		if ( s.global && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Matches an absolute URL, and saves the domain
		var parts = rurl.exec( s.url ),
			remote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host);

		// If we're requesting a remote document
		// and trying to load JSON or Script with a GET
		if ( s.dataType === "script" && type === "GET" && remote ) {
			var head = document.getElementsByTagName("head")[0] || document.documentElement;
			var script = document.createElement("script");
			if ( s.scriptCharset ) {
				script.charset = s.scriptCharset;
			}
			script.src = s.url;

			// Handle Script loading
			if ( !jsonp ) {
				var done = false;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function() {
					if ( !done && (!this.readyState ||
							this.readyState === "loaded" || this.readyState === "complete") ) {
						done = true;
						jQuery.handleSuccess( s, xhr, status, data );
						jQuery.handleComplete( s, xhr, status, data );

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}
					}
				};
			}

			// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
			// This arises when a base node is used (#2709 and #4378).
			head.insertBefore( script, head.firstChild );

			// We handle everything using the script element injection
			return undefined;
		}

		var requestDone = false;

		// Create the request object
		var xhr = s.xhr();

		if ( !xhr ) {
			return;
		}

		// Open the socket
		// Passing null username, generates a login popup on Opera (#2865)
		if ( s.username ) {
			xhr.open(type, s.url, s.async, s.username, s.password);
		} else {
			xhr.open(type, s.url, s.async);
		}

		// Need an extra try/catch for cross domain requests in Firefox 3
		try {
			// Set content-type if data specified and content-body is valid for this type
			if ( (s.data != null && !noContent) || (origSettings && origSettings.contentType) ) {
				xhr.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[s.url] ) {
					xhr.setRequestHeader("If-Modified-Since", jQuery.lastModified[s.url]);
				}

				if ( jQuery.etag[s.url] ) {
					xhr.setRequestHeader("If-None-Match", jQuery.etag[s.url]);
				}
			}

			// Set header so the called script knows that it's an XMLHttpRequest
			// Only send the header if it's not a remote XHR
			if ( !remote ) {
				xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
			}

			// Set the Accepts header for the server, depending on the dataType
			xhr.setRequestHeader("Accept", s.dataType && s.accepts[ s.dataType ] ?
				s.accepts[ s.dataType ] + ", */*; q=0.01" :
				s.accepts._default );
		} catch( headerError ) {}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false ) {
			// Handle the global AJAX counter
			if ( s.global && jQuery.active-- === 1 ) {
				jQuery.event.trigger( "ajaxStop" );
			}

			// close opended socket
			xhr.abort();
			return false;
		}

		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxSend", [xhr, s] );
		}

		// Wait for a response to come back
		var onreadystatechange = xhr.onreadystatechange = function( isTimeout ) {
			// The request was aborted
			if ( !xhr || xhr.readyState === 0 || isTimeout === "abort" ) {
				// Opera doesn't call onreadystatechange before this point
				// so we simulate the call
				if ( !requestDone ) {
					jQuery.handleComplete( s, xhr, status, data );
				}

				requestDone = true;
				if ( xhr ) {
					xhr.onreadystatechange = jQuery.noop;
				}

			// The transfer is complete and the data is available, or the request timed out
			} else if ( !requestDone && xhr && (xhr.readyState === 4 || isTimeout === "timeout") ) {
				requestDone = true;
				xhr.onreadystatechange = jQuery.noop;

				status = isTimeout === "timeout" ?
					"timeout" :
					!jQuery.httpSuccess( xhr ) ?
						"error" :
						s.ifModified && jQuery.httpNotModified( xhr, s.url ) ?
							"notmodified" :
							"success";

				var errMsg;

				if ( status === "success" ) {
					// Watch for, and catch, XML document parse errors
					try {
						// process the data (runs the xml through httpData regardless of callback)
						data = jQuery.httpData( xhr, s.dataType, s );
					} catch( parserError ) {
						status = "parsererror";
						errMsg = parserError;
					}
				}

				// Make sure that the request was successful or notmodified
				if ( status === "success" || status === "notmodified" ) {
					// JSONP handles its own success callback
					if ( !jsonp ) {
						jQuery.handleSuccess( s, xhr, status, data );
					}
				} else {
					jQuery.handleError( s, xhr, status, errMsg );
				}

				// Fire the complete handlers
				if ( !jsonp ) {
					jQuery.handleComplete( s, xhr, status, data );
				}

				if ( isTimeout === "timeout" ) {
					xhr.abort();
				}

				// Stop memory leaks
				if ( s.async ) {
					xhr = null;
				}
			}
		};

		// Override the abort handler, if we can (IE 6 doesn't allow it, but that's OK)
		// Opera doesn't fire onreadystatechange at all on abort
		try {
			var oldAbort = xhr.abort;
			xhr.abort = function() {
				// xhr.abort in IE7 is not a native JS function
				// and does not have a call property
				if ( xhr && oldAbort.call ) {
					oldAbort.call( xhr );
				}

				onreadystatechange( "abort" );
			};
		} catch( abortError ) {}

		// Timeout checker
		if ( s.async && s.timeout > 0 ) {
			setTimeout(function() {
				// Check to see if the request is still happening
				if ( xhr && !requestDone ) {
					onreadystatechange( "timeout" );
				}
			}, s.timeout);
		}

		// Send the data
		try {
			xhr.send( noContent || s.data == null ? null : s.data );

		} catch( sendError ) {
			jQuery.handleError( s, xhr, null, sendError );

			// Fire the complete handlers
			jQuery.handleComplete( s, xhr, status, data );
		}

		// firefox 1.5 doesn't fire statechange for sync requests
		if ( !s.async ) {
			onreadystatechange();
		}

		// return XMLHttpRequest to allow aborting the request etc.
		return xhr;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [], add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value;
			s[ s.length ] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};
		
		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}
		
		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray(a) || a.jquery ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});
			
		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[prefix], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray(obj) && obj.length ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});
			
	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		if ( jQuery.isEmptyObject( obj ) ) {
			add( prefix, "" );

		// Serialize object item.
		} else {
			jQuery.each( obj, function( k, v ) {
				buildParams( prefix + "[" + k + "]", v, traditional, add );
			});
		}
					
	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	handleError: function( s, xhr, status, e ) {
		// If a local callback was specified, fire it
		if ( s.error ) {
			s.error.call( s.context, xhr, status, e );
		}

		// Fire the global callback
		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxError", [xhr, s, e] );
		}
	},

	handleSuccess: function( s, xhr, status, data ) {
		// If a local callback was specified, fire it and pass it the data
		if ( s.success ) {
			s.success.call( s.context, data, status, xhr );
		}

		// Fire the global callback
		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxSuccess", [xhr, s] );
		}
	},

	handleComplete: function( s, xhr, status ) {
		// Process result
		if ( s.complete ) {
			s.complete.call( s.context, xhr, status );
		}

		// The request was completed
		if ( s.global ) {
			jQuery.triggerGlobal( s, "ajaxComplete", [xhr, s] );
		}

		// Handle the global AJAX counter
		if ( s.global && jQuery.active-- === 1 ) {
			jQuery.event.trigger( "ajaxStop" );
		}
	},
		
	triggerGlobal: function( s, type, args ) {
		(s.context && s.context.url == null ? jQuery(s.context) : jQuery.event).trigger(type, args);
	},

	// Determines if an XMLHttpRequest was successful or not
	httpSuccess: function( xhr ) {
		try {
			// IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450
			return !xhr.status && location.protocol === "file:" ||
				xhr.status >= 200 && xhr.status < 300 ||
				xhr.status === 304 || xhr.status === 1223;
		} catch(e) {}

		return false;
	},

	// Determines if an XMLHttpRequest returns NotModified
	httpNotModified: function( xhr, url ) {
		var lastModified = xhr.getResponseHeader("Last-Modified"),
			etag = xhr.getResponseHeader("Etag");

		if ( lastModified ) {
			jQuery.lastModified[url] = lastModified;
		}

		if ( etag ) {
			jQuery.etag[url] = etag;
		}

		return xhr.status === 304;
	},

	httpData: function( xhr, type, s ) {
		var ct = xhr.getResponseHeader("content-type") || "",
			xml = type === "xml" || !type && ct.indexOf("xml") >= 0,
			data = xml ? xhr.responseXML : xhr.responseText;

		if ( xml && data.documentElement.nodeName === "parsererror" ) {
			jQuery.error( "parsererror" );
		}

		// Allow a pre-filtering function to sanitize the response
		// s is checked to keep backwards compatibility
		if ( s && s.dataFilter ) {
			data = s.dataFilter( data, type );
		}

		// The filter can actually parse the response
		if ( typeof data === "string" ) {
			// Get the JavaScript object, if JSON is used.
			if ( type === "json" || !type && ct.indexOf("json") >= 0 ) {
				data = jQuery.parseJSON( data );

			// If the type is "script", eval it in global context
			} else if ( type === "script" || !type && ct.indexOf("javascript") >= 0 ) {
				jQuery.globalEval( data );
			}
		}

		return data;
	}

});

/*
 * Create the request object; Microsoft failed to properly
 * implement the XMLHttpRequest in IE7 (can't request local files),
 * so we use the ActiveXObject when it is available
 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
 * we need a fallback.
 */
if ( window.ActiveXObject ) {
	jQuery.ajaxSettings.xhr = function() {
		if ( window.location.protocol !== "file:" ) {
			try {
				return new window.XMLHttpRequest();
			} catch(xhrError) {}
		}

		try {
			return new window.ActiveXObject("Microsoft.XMLHTTP");
		} catch(activeError) {}
	};
}

// Does this browser support XHR requests?
jQuery.support.ajax = !!jQuery.ajaxSettings.xhr();




var elemdisplay = {},
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)(.*)$/,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	];

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback);
		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !jQuery.data(this[i], "olddisplay") && this[i].style.display === "none" ) {
					this[i].style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( this[i].style.display === "" && jQuery.css( this[i], "display" ) === "none" ) {
					jQuery.data(this[i], "olddisplay", defaultDisplay(this[i].nodeName));
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				this[i].style.display = jQuery.data(this[i], "olddisplay") || "";
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				var display = jQuery.css( this[i], "display" );

				if ( display !== "none" ) {
					jQuery.data( this[i], "olddisplay", display );
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				this[i].style.display = "none";
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed(speed, easing, callback);

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete );
		}

		return this[ optall.queue === false ? "each" : "queue" ](function() {
			// XXX ‘this’ does not always have a nodeName when running the
			// test suite

			var opt = jQuery.extend({}, optall), p,
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				self = this;

			for ( p in prop ) {
				var name = jQuery.camelCase( p );

				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
					p = name;
				}

				if ( prop[p] === "hide" && hidden || prop[p] === "show" && !hidden ) {
					return opt.complete.call(this);
				}

				if ( isElement && ( p === "height" || p === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height
					// animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {
						if ( !jQuery.support.inlineBlockNeedsLayout ) {
							this.style.display = "inline-block";

						} else {
							var display = defaultDisplay(this.nodeName);

							// inline-level elements accept inline-block;
							// block-level elements need to be inline with layout
							if ( display === "inline" ) {
								this.style.display = "inline-block";

							} else {
								this.style.display = "inline";
								this.style.zoom = 1;
							}
						}
					}
				}

				if ( jQuery.isArray( prop[p] ) ) {
					// Create (if needed) and add to specialEasing
					(opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];
					prop[p] = prop[p][0];
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			opt.curAnim = jQuery.extend({}, prop);

			jQuery.each( prop, function( name, val ) {
				var e = new jQuery.fx( self, opt, name );

				if ( rfxtypes.test(val) ) {
					e[ val === "toggle" ? hidden ? "show" : "hide" : val ]( prop );

				} else {
					var parts = rfxnum.exec(val),
						start = e.cur(true) || 0;

					if ( parts ) {
						var end = parseFloat( parts[2] ),
							unit = parts[3] || "px";

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( self, name, (end || 1) + unit);
							start = ((end || 1) / e.cur(true)) * start;
							jQuery.style( self, name, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			});

			// For JS strict compliance
			return true;
		});
	},

	stop: function( clearQueue, gotoEnd ) {
		var timers = jQuery.timers;

		if ( clearQueue ) {
			this.queue([]);
		}

		this.each(function() {
			// go in reverse order so anything added to the queue during the loop is ignored
			for ( var i = timers.length - 1; i >= 0; i-- ) {
				if ( timers[i].elem === this ) {
					if (gotoEnd) {
						// force the next step to be the last
						timers[i](true);
					}

					timers.splice(i, 1);
				}
			}
		});

		// start the next in the queue if the last step wasn't forced
		if ( !gotoEnd ) {
			this.dequeue();
		}

		return this;
	}

});

function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show", 1),
	slideUp: genFx("hide", 1),
	slideToggle: genFx("toggle", 1),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Queueing
		opt.old = opt.complete;
		opt.complete = function() {
			if ( opt.queue !== false ) {
				jQuery(this).dequeue();
			}
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		if ( !options.orig ) {
			options.orig = {};
		}
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
			return this.elem[ this.prop ];
		}

		var r = parseFloat( jQuery.css( this.elem, this.prop ) );
		return r && r > -10000 ? r : 0;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		this.startTime = jQuery.now();
		this.start = from;
		this.end = to;
		this.unit = unit || this.unit || "px";
		this.now = this.start;
		this.pos = this.state = 0;

		var self = this, fx = jQuery.fx;
		function t( gotoEnd ) {
			return self.step(gotoEnd);
		}

		t.elem = this.elem;

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval(fx.tick, fx.interval);
		}
	},

	// Simple 'show' function
	show: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any
		// flash of content
		this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom(this.cur(), 0);
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var t = jQuery.now(), done = true;

		if ( gotoEnd || t >= this.options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			this.options.curAnim[ this.prop ] = true;

			for ( var i in this.options.curAnim ) {
				if ( this.options.curAnim[i] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( this.options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
					var elem = this.elem, options = this.options;
					jQuery.each( [ "", "X", "Y" ], function (index, value) {
						elem.style[ "overflow" + value ] = options.overflow[index];
					} );
				}

				// Hide the element if the "hide" operation was done
				if ( this.options.hide ) {
					jQuery(this.elem).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( this.options.hide || this.options.show ) {
					for ( var p in this.options.curAnim ) {
						jQuery.style( this.elem, p, this.options.orig[p] );
					}
				}

				// Execute the complete function
				this.options.complete.call( this.elem );
			}

			return false;

		} else {
			var n = t - this.startTime;
			this.state = n / this.options.duration;

			// Perform the easing function, defaults to swing
			var specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop];
			var defaultEasing = this.options.easing || (jQuery.easing.swing ? "swing" : "linear");
			this.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration);
			this.now = this.start + ((this.end - this.start) * this.pos);

			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timers = jQuery.timers;

		for ( var i = 0; i < timers.length; i++ ) {
			if ( !timers[i]() ) {
				timers.splice(i--, 1);
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

function defaultDisplay( nodeName ) {
	if ( !elemdisplay[ nodeName ] ) {
		var elem = jQuery("<" + nodeName + ">").appendTo("body"),
			display = elem.css("display");

		elem.remove();

		if ( display === "none" || display === "" ) {
			display = "block";
		}

		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) { 
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box || { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = (win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop ),
			scrollLeft = (win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft),
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) { 
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		jQuery.offset.initialize();

		var offsetParent = elem.offsetParent, prevOffsetParent = elem,
			doc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,
			body = doc.body, defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop, left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {
	initialize: function() {
		var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, "marginTop") ) || 0,
			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

		jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );

		container.innerHTML = html;
		body.insertBefore( container, body.firstChild );
		innerDiv = container.firstChild;
		checkDiv = innerDiv.firstChild;
		td = innerDiv.nextSibling.firstChild.firstChild;

		this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
		this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

		checkDiv.style.position = "fixed";
		checkDiv.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
		checkDiv.style.position = checkDiv.style.top = "";

		innerDiv.style.overflow = "hidden";
		innerDiv.style.position = "relative";

		this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

		this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

		body.removeChild( container );
		body = container = innerDiv = checkDiv = table = td = null;
		jQuery.offset.initialize = jQuery.noop;
	},

	bodyOffset: function( body ) {
		var top = body.offsetTop, left = body.offsetLeft;

		jQuery.offset.initialize();

		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},
	
	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = (position === "absolute" && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1),
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is absolute
		if ( calculatePosition ) {
			curPosition = curElem.position();
		}

		curTop  = calculatePosition ? curPosition.top  : parseInt( curCSSTop,  10 ) || 0;
		curLeft = calculatePosition ? curPosition.left : parseInt( curCSSLeft, 10 ) || 0;

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if (options.top != null) {
			props.top = (options.top - curOffset.top) + curTop;
		}
		if (options.left != null) {
			props.left = (options.left - curOffset.left) + curLeft;
		}
		
		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({
	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function(val) {
		var elem = this[0], win;
		
		if ( !elem ) {
			return null;
		}

		if ( val !== undefined ) {
			// Set the scroll offset
			return this.each(function() {
				win = getWindow( this );

				if ( win ) {
					win.scrollTo(
						!i ? val : jQuery(win).scrollLeft(),
						 i ? val : jQuery(win).scrollTop()
					);

				} else {
					this[ method ] = val;
				}
			});
		} else {
			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn["inner" + name] = function() {
		return this[0] ?
			parseFloat( jQuery.css( this[0], type, "padding" ) ) :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn["outer" + name] = function( margin ) {
		return this[0] ?
			parseFloat( jQuery.css( this[0], type, margin ? "margin" : "border" ) ) :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}
		
		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		return jQuery.isWindow( elem ) ?
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			elem.document.compatMode === "CSS1Compat" && elem.document.documentElement[ "client" + name ] ||
			elem.document.body[ "client" + name ] :

			// Get document width or height
			(elem.nodeType === 9) ? // is it a document
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
				Math.max(
					elem.documentElement["client" + name],
					elem.body["scroll" + name], elem.documentElement["scroll" + name],
					elem.body["offset" + name], elem.documentElement["offset" + name]
				) :

				// Get or set width or height on the element
				size === undefined ?
					// Get width or height on the element
					parseFloat( jQuery.css( elem, type ) ) :

					// Set the width or height on the element (default to pixels if value is unitless)
					this.css( type, typeof size === "string" ? size : size + "px" );
	};

});


})(window);

}; // end of sap.service.visualization.chart.ChartSourceCode.libs.jquery
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.ChartSourceCode.libs.json2') ) {
  jQuery.sap.declare('sap.service.visualization.chart.ChartSourceCode.libs.json2');
/*
    http://www.JSON.org/json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

}; // end of sap.service.visualization.chart.ChartSourceCode.libs.json2
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.ChartSourceCode.libs.sapcommonglobalization') ) {
  jQuery.sap.declare('sap.service.visualization.chart.ChartSourceCode.libs.sapcommonglobalization');
/**
 * @author I055660
 */

(function() {

	// make sure undefined is undefined
	var undefined;
	
	if(window) {
		sap = window.sap || {};
	} else {
		sap = sap || {};
	}
		
	// Specially for sap.common.globalization as APP Root	
	if(sap)
	{
		sap.common = sap.common || {};	
	}
	if(sap.common)
	{
		sap.common.globalization =  sap.common.globalization || {};
	}
		
	
	/**
	 * Version number like 1.0.0.
	 * 
	 * @return {String} the version number
	 * @public
	 * @static
	 */
	sap.common.globalization.VERSION = function() {
		return "0.0.1";
    };
	
	/**
	 * Build number like 100.
	 * 
	 * @return {Number} the build number
	 * @public
	 * @static
	 */
	// Do NOT change the BUILD function including the coding format, 
	// it will be auto-updated by build script.
	sap.common.globalization.BUILD = function() {return 99;};
	
	/**
	 * Declear a module and create namespace.
	 * 
	 * @para {String} ns the module namespace
	 * @return {Object} the created module
	 * @public
	 * @static
	 */
	sap.common.globalization.declare = function(ns) {
		if (!ns)
			throw new Error("name required");
		if (typeof (ns) != "string")
			throw new Error("name has to be a string");
		if (ns.charAt(0) == '.' || ns.charAt(ns.length - 1) == '.' || ns.indexOf("..") != -1)
			throw new Error("illegal name: " + ns);

		ns = ns.split(".");
		var o = window;
		for ( var i = 0; i < ns.length; i++) {
			o[ns[i]] = o[ns[i]] || {};
			o = o[ns[i]];
		}
		return o;
	};
	
	/**
	 * Requre a module.
	 * 
	 * @para {String} ns the module namespace
	 * @public
	 * @static
	 */
	sap.common.globalization.require = function(ns) {

	};
	
	/**
	 * Extend class, superClz's constructor will be applied with no parameters.
	 * 
	 * @para {function} subClz the sub class
	 * @para {function} superClz the super class to be extended
	 * @return {function} the extended subClz
	 * @public
	 * @static
	 */
	sap.common.globalization.extend = function(subClz, superClz) {
		var subClzPrototype = subClz.prototype;
		// console.log(subClz);
		// console.log("Super class");
		// console.log(superClz );
		
		// add the superclass prototype to the subclass definition
		subClz.superclass = superClz.prototype;
		
		// copy prototype
		var F = function(){};
		F.prototype = superClz.prototype;
		
		subClz.prototype = new F();
		for (var prop in subClzPrototype) {
			if (subClzPrototype.hasOwnProperty(prop)) {
				subClz.prototype[prop] = subClzPrototype[prop];
			}
		}
    	subClz.prototype.constructor = subClz;
		if(superClz.prototype.constructor == Object.prototype.constructor) {
			superClz.prototype.constructor = superClz;
		}
    	return subClz;
	};
	
})();(function() {

		/**
		* 	The NumericFormatManager manages the spreadsheet numeric format objects 
		* 	and provides a simple interface to apply formatting.
		*/
		sap.common.globalization.declare("sap.common.globalization.NumericFormatManager");
		 
		sap.common.globalization.require("sap.common.globalization.utils.NumberUtil");
		sap.common.globalization.require("sap.common.globalization.utils.BooleanUtil");
		sap.common.globalization.require("sap.common.globalization.utils.DataFormatUtils");
		sap.common.globalization.require("sap.common.globalization.utils.StringUtil");
		sap.common.globalization.require("sap.common.globalization.numericFormat.FTUtil");
		sap.common.globalization.require("sap.common.globalization.numericFormat.FT");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory");
		
		sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");
		
		sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
		sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");
		
		
	    var sapNumManager = sap.common.globalization.NumericFormatManager;
	    
	    sapNumManager.DEFAULT_FORMAT_DATE_TIME = "SAP_FORMAT_DEFAULT_DATE_TIME";
	    sapNumManager.DEFAULT_FORMAT_TIME = "SAP_FORMAT_DEFAULT_TIME";
	    sapNumManager.DEFAULT_FORMAT_SHORT_DATE = "SAP_FORMAT_DEFAULT_SHORT_DATE";
	    sapNumManager.DEFAULT_FORMAT_LONG_DATE = "SAP_FORMAT_DEFAULT_LONG_DATE";
	    sapNumManager.DEFAULT_FORMAT_NUMBER = "SAP_DEFAULT_NUMBER_FORMAT";
	    sapNumManager.DEFAULT_FORMAT_BOOLEAN = "SAP_DEFAULT_BOOLEAN_FORMAT";
		
		//------------------------------------------------------------------/
		// New add NumericFormatManager member in JS for outside to pass-in.
	    sapNumManager.XL_PVL = "en"; //TODO will be used in GlobalizationPreference.js
	    sapNumManager.SAP_PARAMETERS = {}; //  SAP_PARAMETERS is passed in from unit test or other app.
	    
	    sapNumManager.resetParameters = function() {
			sapNumManager.SAP_PARAMETERS = {};
		};
	    //------------------------------------------------------------------/
	    
		/**
		 * 	Object to hold mapping of formatStrings to numeric formats.
		 */
		sapNumManager._formats = {}; /*Object*/
		// protected static var _formats:Object;
		
		//--------------------------------------------------------------------------
		//
		//  Class methods
		//
		//--------------------------------------------------------------------------
		
		/**
		 * 	Returns the numeric format associated with the specified formatString.
		 * 	If a numeric format hasn't been created for the specified formatString, 
		 * 	a new numeric format instance will be returned and associated with that formatString.
		 * 
		 * 	@param formatString		The string representing the numeric formatting for the spreadsheet cell.
		 * 							Matches the value found in Excel under Format -> Cells -> Number -> Custom.
		 */
		sapNumManager.getFormat = function(formatString /*String*/) {
			if ((formatString == null) || (formatString == "")) {							// handle null case by returning null format.  FT doesn't handle nulls.
				return null;
			}
			
			if (!sapNumManager._formats) {
				sapNumManager._formats = new Object();
			}
			var numFormat /* FT*/ = sapNumManager._formats[formatString];
			var  _s_g_df= sap.common.globalization.defaultFormat;
			
			if (numFormat == null) {
				// handle for default date/time format string
				if(formatString == sapNumManager.DEFAULT_FORMAT_SHORT_DATE||formatString == sapNumManager.DEFAULT_FORMAT_LONG_DATE
					||formatString == sapNumManager.DEFAULT_FORMAT_DATE_TIME||formatString == sapNumManager.DEFAULT_FORMAT_TIME)
				{
					var formatString /*String*/;
					var custNumFac/*CustomNumericFormatLocaleFactory*/ = _s_g_df.CustomNumericFormatLocaleFactory.getInstance();
					switch(formatString)
					{
						case sapNumManager.DEFAULT_FORMAT_SHORT_DATE:
							var sDateFac/*DefaultShortDateFormatLocaleFactory*/ = new _s_g_df.DefaultShortDateFormatLocaleFactory();
							numFormat = new sap.common.globalization.numericFormat.FT(sDateFac,custNumFac);
							formatString = sDateFac.getDefaultDateFormat();
							break;
						case sapNumManager.DEFAULT_FORMAT_LONG_DATE:
							var lDateFac/*DefaultDateFormatLocaleFactory*/ = new _s_g_df.DefaultDateFormatLocaleFactory();
							numFormat = new sap.common.globalization.numericFormat.FT(lDateFac,custNumFac);
							formatString = lDateFac.getDefaultDateFormat();
							break;
						case sapNumManager.DEFAULT_FORMAT_DATE_TIME:
							var dTimeFac/*DefaultDateTimeFormatLocaleFactory*/ = new _s_g_df.DefaultDateTimeFormatLocaleFactory();
							numFormat = new sap.common.globalization.numericFormat.FT(dTimeFac,custNumFac);
							formatString = dTimeFac.getDefaultDateFormat();
							break;
						case sapNumManager.DEFAULT_FORMAT_TIME:
						default:
							var timeFac/*DefaultTimeFormatLocaleFactory*/ = new _s_g_df.DefaultTimeFormatLocaleFactory();
							numFormat = new sap.common.globalization.numericFormat.FT(timeFac,custNumFac);
							formatString = timeFac.getDefaultDateFormat();
					}
					
					// parse the default format string.
					numFormat.parse(formatString);
				}
				else if (formatString==sapNumManager.DEFAULT_FORMAT_NUMBER)
				{
					var numericFormatFactory/*DefaultNumericFormatLocaleFactory*/ = new _s_g_df.DefaultNumericFormatLocaleFactory();
					var numericFormatFactory;
					var numFormatString /*String */ = numericFormatFactory.getDefaultNumericFormat();
					numFormat = new sap.common.globalization.numericFormat.FT(_s_g_df.CustomDateFormatLocaleFactory.getInstance(), numericFormatFactory);
					numFormat.parse(numFormatString);
				}
				else if (_s_g_df.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat(formatString))
				{
					var currencyFormatFactory/*DefaultCurrencyFormatLocaleFactory*/ = new _s_g_df.DefaultCurrencyFormatLocaleFactory(formatString);
					var currencyFormatString/*String*/ = currencyFormatFactory.getDefaultCurrencyFormat();
		
					numFormat = new sap.common.globalization.numericFormat.FT(_s_g_df.CustomDateFormatLocaleFactory.getInstance(), currencyFormatFactory);
					numFormat.parse(currencyFormatString);
				}
				else if (formatString == sapNumManager.DEFAULT_FORMAT_BOOLEAN)
				{
					numFormat = new sap.common.globalization.numericFormat.FTBoolean();				
					numFormat.parse(formatString);
				}
				else
				{
					numFormat = new sap.common.globalization.numericFormat.FT();				
					numFormat.parse(formatString);
				}
				// cache the format
				sapNumManager._formats[formatString] = numFormat;
			}
		
			return numFormat;									
		};
	
		/**
		 * @Deprecated
		 * 	Applies the numeric format to the value and returns the resultant String.
		 * 
		 * 	@param value			The value to format.
		 * 	@param formatString		The string representing the numeric formatting for the spreadsheet cell.
		 * 							Matches the value found in Excel under Format -> Cells -> Number -> Custom.
		 */
	
		sapNumManager.format = function(value /*Object*/, formatString /*String*/) /*String*/ {
			var numericFormat /* FT */  = sapNumManager.getFormat(formatString);
			if (numericFormat == null) {													// no NumericFormat; return raw value
				return value;
			}
			return numericFormat.display(value);
		};
		
		/**
		 * This method will format the @param value with the @param formatString and return the result string.
		 * The @param formatString will only be applied to the @param value when the @param value is Number or
		 * Numeric String (exclude blank string) or Boolean String and the @param formatString is a valid Excel format string.
		 * 
		 * @param value
		 * @param formatString
		 * @return formatted text
		 * 
		 */
		sapNumManager.formatToText = function(value /*Object*/, formatString /*String*/)/*String*/
		{
			return this._format(value, formatString);
		};
		
		/**
		 * This method will format the @param value with the @param formatString and return the result string.
		 * The @param formatString will only be applied to the @param value when the @param value is Number or
		 * Numeric String (exclude blank string) or Boolean String and the @param formatString is a valid Excel format string.
		 * 
		 * The returned string is an html string.
		 * If the @param formatString contains information of negative color, the result string will include html tag for displaying
		 * style. And all the html entities in the @param value will be escaped in the result string.
		 * 
		 * @param value
		 * @param formatString
		 * @return formatted html text
		 * 
		 */
		sapNumManager.formatToHtmlText = function(value /*object*/ , formatString /*String*/) /*String*/
		{
			return this._format(value, formatString, true);
		};
		
		/**
		 * @private
		 * Refactored from DataUtils.getFormattedString which is used only for charts tooltips.
		 * 
		 * @param value
		 * @param formatString
		 * @param htmlText
		 * @return 
		 * 
		 */
		sapNumManager._format =function(value/* Object*/, formatString /*String*/, htmlText/*Boolean*/ )/*String*/
		{
			htmlText  = htmlText || false; // default value is false.
			 
			var nonNullRawText/*Object*/ = value == null ? '' : value;
			var ft/*FT*/ = sapNumManager.getFormat(formatString);
			var applyColor/*Boolean*/ = false;
			var color/*Number*/ = NaN;
			
			var formattedText/*String*/ = String(nonNullRawText);
			
			// format with FT if exists
			if (ft)
			{
				// reset FT color
				ft.color = undefined;
				// format numeric data
				if (sap.common.globalization.utils.NumberUtil.isNumericValue(nonNullRawText))
				{
					formattedText = ft.display(Number(nonNullRawText));
					color = Number(ft.color);
				}
				// format boolean data
				else if (sap.common.globalization.utils.BooleanUtil.isBooleanValue(nonNullRawText) && sap.common.globalization.numericFormat.FTUtil.isBooleanFT(ft)) 
				{
					formattedText = ft.display(nonNullRawText);
				}
			}
			
			// format to the html text
			if (htmlText)
			{
				formattedText = sap.common.globalization.utils.StringUtil.escapeEntities(formattedText);
				
				// check wether to apply the color to the formatted string
				// the color need html support
				if (!isNaN(color))
				{
					formattedText = sap.common.globalization.utils.DataFormatUtils.decorateColorHTML(formattedText, color);	
				}
			}
			
			return formattedText;
		};
		
		// pass the JS gen locale info to customize the Flocalization symbols.
		
		/*{longMonths: {_MonthStrings },
		  shortMonths: {_shortMonthStrings},
		  longWeekDays: {_DayStrings},
		  shortWeekDays: {_shortDayStrings},
		  dtCodes: {_DateTimeCodes},
		  numSeparators: {_NumericStrings},
		  dtSeparators: {_DateTimeStrings},
		  currencySymbol: {_CurrencySymbol},
		  amPms: {_AmPms},
		  };
		 */
		sapNumManager.setCustomizedLocaleInfo = function(value){
			
			sap.common.globalization.numericFormat.FLocalization.getInstance().setCustomizedLocaleInfo(value);
			
		}; 
		
		//  default is null
		sapNumManager.currentLocale = null;
		
		// Set page or app PVL.
		sapNumManager.setPVL = function(value){
			
			sap.common.globalization.GlobalizationPreference.getInstance().setPvl(value);

			if(!sapNumManager.currentLocale || sapNumManager.currentLocale != value)
			{
				sapNumManager.currentLocale  = value;
				sapNumManager.setCustomizedLocaleInfo(null); // set default locale info
			} 
			
		}; 

})();(function(){

	sap.common.globalization.declare("sap.common.globalization.GlobalizationPreference");

	sap.common.globalization.require("sap.common.globalization.NumericFormatManager");
	
	sap.common.globalization.GlobalizationPreference =function()
	{
		// TODO FlashVarUtil
		// this._preferredViewingLocale = FlashVarUtil.getFlashVarFromChildToParent("XL_PVL",
		this.__className = "sap.common.globalization.GlobalizationPreference";
		// this._preferredViewingLocale = 'en'; // TODO  
		this._preferredViewingLocale = null;  //= sap.common.globalization.NumericFormatManager.XL_PVL;
	}
	
	var _s_g_defaultFormat_gPreference = sap.common.globalization.GlobalizationPreference;
	_s_g_defaultFormat_gPreference._instance /*GlobalizationPreference;*/ = null; // TODO default GlobalizationPreference value null. 
	
	_s_g_defaultFormat_gPreference.DOCUMENT_LOCALE/*String*/ = "en"; //TODO set default DOCUMENT_LOCALE to en
	
	
	_s_g_defaultFormat_gPreference.getInstance = function()/*GlobalizationPreference*/
	{
		if (!_s_g_defaultFormat_gPreference._instance)
		{
			_s_g_defaultFormat_gPreference._instance = new sap.common.globalization.GlobalizationPreference();
		}
		return _s_g_defaultFormat_gPreference._instance;
	}
	
	_s_g_defaultFormat_gPreference.resetInstance =function()/*void*/
	{
		_s_g_defaultFormat_gPreference._instance = new sap.common.globalization.GlobalizationPreference();
	}
	
	/**
	 * PVL locale.
	 */
	_s_g_defaultFormat_gPreference.prototype.pvl =function()/*String*/
	{
		return this._preferredViewingLocale;
	}
	
	/**
	 * @private
	 * Internal usage, mainly for test. It's not a setter since
	 * mxmlc contains a bug which will break the compilation...
	 */
	_s_g_defaultFormat_gPreference.prototype.setPvl = function(value/*String*/)/*void*/
	{
		if (value != this._preferredViewingLocale)
		{
			this._preferredViewingLocale = value;
		}
	}


	
	/**
	 * PVL dominant language.
	 */
	_s_g_defaultFormat_gPreference.prototype.pvlIsoLanguageCode = function()/*String*/
	{
		return this._getIsoLanguageCode(this.pvl());
	}
	
	/**
	 * Locale of the document, e.g. the locale when generating the SWF. 
	 */
	_s_g_defaultFormat_gPreference.prototype.documentLocale =function()/*String*/
	{
		return _s_g_defaultFormat_gPreference.DOCUMENT_LOCALE;
	}
	
	/**
	 * document language.
	 */
	_s_g_defaultFormat_gPreference.prototype.documentIsoLanguageCode=function()/*String*/
	{
		return this._getIsoLanguageCode(_s_g_defaultFormat_gPreference.DOCUMENT_LOCALE);
	} 
	
	/**
	 * Get the language code of the locale string.
	 * 
	 * @param locale locale string
	 * @return 
	 */
	_s_g_defaultFormat_gPreference.prototype._getIsoLanguageCode =function(locale/*String*/)/*String*/
	{
		if (locale)
		{
			return String(locale).split("_")[0];
		}
		return locale;
	}

})();

(function(){

	sap.common.globalization.declare("sap.common.globalization.GlobalizationBooleanConstant");

	var _s_g_gBooleanConstant = sap.common.globalization.GlobalizationBooleanConstant;
	// TODO set default booleanString with hard-code value, in case it support resource bundle in the future, port ResourceStringManager also.
	// private static var _resourceManager:IResourceStringManager = ResourceStringManager.getInstance();
// 		
	// private static const BOOLEAN_STRING_TRUE:String = "BOOLEAN_STRING_TRUE";
// 		
	// private static const BOOLEAN_STRING_FALSE:String = "BOOLEAN_STRING_FALSE";
	
	/**
	 * Get the globalized strings for boolean.
	 * Always an array that contains the boolean string retrieved from resource manager.
	 * 
	 * @return 
	 * 
	 */
	_s_g_gBooleanConstant.getBooleanStrings = function()/*Array*/
	{
		// var trueString:String = _resourceManager.getString(ResourceStringConstant.DEFULT_BUNDLE_NAME, BOOLEAN_STRING_TRUE);
		// var falseString:String = _resourceManager.getString(ResourceStringConstant.DEFULT_BUNDLE_NAME, BOOLEAN_STRING_FALSE);
		// return [String(trueString), String(falseString)];
		return ["TRUE", "FALSE"];
	}

})();(function(){

	sap.common.globalization.declare("sap.common.globalization.GlobalizationNumericConstant");
	sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");
		
	sap.common.globalization.GlobalizationNumericConstant =function(){
		this.__className = "sap.common.globalization.GlobalizationNumericConstant";
		
	}
	
	var _s_g_gNumericConstant = sap.common.globalization.GlobalizationNumericConstant;
	
	// keys to fetch the format string
	_s_g_gNumericConstant._FORMAT_TYPE_NUMBER/*String*/ = "number";
	_s_g_gNumericConstant._FORMAT_TYPE_CURRENCY/*String*/ = "currency";
	
	// Keys for numeric separators
	_s_g_gNumericConstant._KEY_TYPE_NUMERIC/*String*/ = "numeric";
	_s_g_gNumericConstant._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR/*String*/ = "displayThousandsSeparator";
	_s_g_gNumericConstant._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR/*String*/ = "displayDecimalSeparator";
	
	_s_g_gNumericConstant._DEFAULT_FORMAT_STRING/*Object*/ =         {
        "af":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "af_ZA": {},
        "ar":             {
            "number": "#,##0.###;#,##0.###-",
            "currency": "¤ #,##0.00;¤ #,##0.00-"
        },
        "ar_AE": {},
        "ar_BH": {},
        "ar_DZ": {},
        "ar_EG": {},
        "ar_IQ": {},
        "ar_JO": {},
        "ar_KW": {},
        "ar_LB": {},
        "ar_LY": {},
        "ar_MA": {},
        "ar_OM": {},
        "ar_QA":             {
            "number": "#0.###;#0.###-",
            "currency": "¤#0.00"
        },
        "ar_SA":             {
            "number": "#0.###;#0.###-",
            "currency": "¤#0.00"
        },
        "ar_SY":             {
            "number": "#0.###;#0.###-",
            "currency": "¤#0.00"
        },
        "ar_TN":             {
            "number": "#0.###;#0.###-",
            "currency": "¤#0.00"
        },
        "ar_YE":             {
            "number": "#0.###;#0.###-",
            "currency": "¤#0.00"
        },
        "az":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "az_AZ": {},
        "be":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "be_BY": {},
        "bg":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "bg_BG": {},
        "bn":             {
            "number": "#,##,##0.###",
            "currency": "#,##,##0.00¤;(#,##,##0.00¤)"
        },
        "bn_IN": {},
        "bs":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "bs_BA": {},
        "ca":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "ca_ES": {},
        "cs":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "cs_CZ": {},
        "cy":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "cy_GB": {},
        "da":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "da_DK": {},
        "de":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "de_AT": {"currency": "¤ #,##0.00"},
        "de_CH": {"currency": "¤ #,##0.00;¤-#,##0.00"},
        "de_DE": {},
        "de_LI": {"currency": "¤ #,##0.00"},
        "de_LU": {},
        "el":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "el_GR": {},
        "en":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00;(¤#,##0.00)"
        },
        "en_AU": {"currency": "¤#,##0.00"},
        "en_BZ": {"currency": "¤#,##0.00"},
        "en_CA": {},
        "en_GB": {"currency": "¤#,##0.00"},
        "en_IE": {"currency": "¤#,##0.00"},
        "en_JM": {"currency": "¤#,##0.00"},
        "en_NZ": {"currency": "¤#,##0.00"},
        "en_PH": {},
        "en_TT": {"currency": "¤#,##0.00"},
        "en_US": {},
        "en_VI": {},
        "en_ZA": {"currency": "¤#,##0.00"},
        "en_ZW": {"currency": "¤#,##0.00"},
        "es":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "es_AR": {},
        "es_BO": {},
        "es_CL": {"currency": "¤#,##0.00;¤-#,##0.00"},
        "es_CO": {},
        "es_CR": {},
        "es_DO": {},
        "es_EC": {"currency": "¤#,##0.00;¤-#,##0.00"},
        "es_ES": {},
        "es_GT": {},
        "es_HN": {},
        "es_MX": {},
        "es_NI": {},
        "es_PA": {},
        "es_PE": {},
        "es_PR": {},
        "es_PY": {"currency": "¤ #,##0.00;¤ -#,##0.00"},
        "es_SV": {},
        "es_UY": {"currency": "¤ #,##0.00;(¤ #,##0.00)"},
        "es_VE": {"currency": "¤#,##0.00;¤-#,##0.00"},
        "et":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "et_EE": {},
        "eu":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "eu_ES": {},
        "fa":             {
            "number": "#,##0.###;'-#,##0.###'",
            "currency": "#,##0.00 ¤;'-#,##0.00' ¤"
        },
        "fa_IR": {},
        "fi":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "fi_FI": {},
        "fo":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00;¤-#,##0.00"
        },
        "fo_FO": {},
        "fr":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "fr_BE": {},
        "fr_CA": {"currency": "#,##0.00 ¤;(#,##0.00 ¤)"},
        "fr_CH": {"currency": "¤ #,##0.00;¤-#,##0.00"},
        "fr_FR": {},
        "fr_LU": {},
        "fr_MC": {},
        "gl":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "gl_ES": {},
        "gu":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "gu_IN": {},
        "he":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "he_IL": {},
        "hi":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "hi_IN": {},
        "hr":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "hr_HR": {},
        "hu":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "hu_HU": {},
        "hy":             {
            "number": "#0.###",
            "currency": "#0.00 ¤"
        },
        "hy_AM": {},
        "id":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "id_ID": {},
        "is":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "is_IS": {},
        "it":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "it_CH": {"currency": "¤ #,##0.00;¤-#,##0.00"},
        "it_IT": {},
        "ja":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "ja_JP": {},
        "ka":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "ka_GE": {},
        "kk":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "kk_KZ": {},
        "kn":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "kn_IN": {},
        "ko":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "ko_KR": {},
        "kok":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "kok_IN": {},
        "lt":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "lt_LT": {},
        "lv":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "lv_LV": {},
        "mk":             {
            "number": "#,##0.###;(#,##0.###)",
            "currency": "¤ #,##0.00"
        },
        "mk_MK": {},
        "ml":             {
            "number": "#,##,##0.###",
            "currency": "#,##,##0.00¤"
        },
        "ml_IN": {},
        "mn":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "mn_MN": {},
        "mr":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "mr_IN": {},
        "ms":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00;(¤#,##0.00)"
        },
        "ms_BN": {"currency": "¤ #,##0.00"},
        "ms_MY": {},
        "mt":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "mt_MT": {},
        "nb":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "nb_NO": {},
        "nl":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00;¤ #,##0.00-"
        },
        "nl_BE": {"currency": "#,##0.00 ¤"},
        "nl_NL": {},
        "nn":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "nn_NO": {},
        "pa":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "pa_IN": {},
        "pl":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "pl_PL": {},
        "pt":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00;(¤#,##0.00)"
        },
        "pt_BR": {},
        "pt_PT": {"currency": "#,##0.00 ¤"},
        "ro":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "ro_RO": {},
        "ru":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "ru_RU": {},
        "se":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "se_NO": {},
        "sk":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "sk_SK": {},
        "sl":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "sl_SI": {},
        "sq":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "sq_AL": {},
        "sr":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "sr_BA": {},
        "sr_CS": {},
        "sv":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "sv_FI": {},
        "sv_SE": {},
        "sw":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "sw_KE": {"currency": "¤#,##0.00"},
        "syr":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "syr_SY": {},
        "ta":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "ta_IN": {},
        "te":             {
            "number": "#,##,##0.###",
            "currency": "¤ #,##,##0.00"
        },
        "te_IN": {},
        "th":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00;¤-#,##0.00"
        },
        "th_TH": {},
        "tn":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "tn_ZA": {},
        "tr":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "tr_TR": {},
        "uk":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "uk_UA": {},
        "uz":             {
            "number": "#,##0.###",
            "currency": "¤ #,##0.00"
        },
        "uz_UZ": {},
        "vi":             {
            "number": "#,##0.###",
            "currency": "#,##0.00 ¤"
        },
        "vi_VN": {},
        "xh":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "xh_ZA": {},
        "zh":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "zh_CN": {},
        "zh_HK": {},
        "zh_MO": {},
        "zh_SG": {},
        "zh_TW": {},
        "zu":             {
            "number": "#,##0.###",
            "currency": "¤#,##0.00"
        },
        "zu_ZA": {}
    };
	
	_s_g_gNumericConstant._RESOURCE_MAP/*Object*/ =  {
        "af": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "af_ZA": {"numeric": {}},
        "ar": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "ar_AE": {"numeric": {}},
        "ar_BH": {"numeric": {}},
        "ar_DZ": {"numeric": {}},
        "ar_EG": {"numeric": {}},
        "ar_IQ": {"numeric": {}},
        "ar_JO": {"numeric": {}},
        "ar_KW": {"numeric": {}},
        "ar_LB": {"numeric": {}},
        "ar_LY": {"numeric": {}},
        "ar_MA": {"numeric": {}},
        "ar_OM": {"numeric": {}},
        "ar_QA": {"numeric": {}},
        "ar_SA": {"numeric": {}},
        "ar_SY": {"numeric": {}},
        "ar_TN": {"numeric": {}},
        "ar_YE": {"numeric": {}},
        "az": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "az_AZ": {"numeric": {}},
        "be": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "be_BY": {"numeric": {}},
        "bg": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "bg_BG": {"numeric": {}},
        "bn": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "bn_IN": {"numeric": {}},
        "bs": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "bs_BA": {"numeric": {}},
        "ca": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "ca_ES": {"numeric": {}},
        "cs": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "cs_CZ": {"numeric": {}},
        "cy": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "cy_GB": {"numeric": {}},
        "da": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "da_DK": {"numeric": {}},
        "de": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "de_AT": {"numeric": {}},
        "de_CH": {"numeric":             {
            "displayThousandsSeparator": "'",
            "displayDecimalSeparator": "."
        }},
        "de_DE": {"numeric": {}},
        "de_LI": {"numeric":             {
            "displayThousandsSeparator": "'",
            "displayDecimalSeparator": "."
        }},
        "de_LU": {"numeric": {}},
        "el": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "el_GR": {"numeric": {}},
        "en": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "en_AU": {"numeric": {}},
        "en_BZ": {"numeric": {}},
        "en_CA": {"numeric": {}},
        "en_GB": {"numeric": {}},
        "en_IE": {"numeric": {}},
        "en_JM": {"numeric": {}},
        "en_NZ": {"numeric": {}},
        "en_PH": {"numeric": {}},
        "en_TT": {"numeric": {}},
        "en_US": {"numeric": {}},
        "en_VI": {"numeric": {}},
        "en_ZA": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "en_ZW": {"numeric": {}},
        "es": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "es_AR": {"numeric": {}},
        "es_BO": {"numeric": {}},
        "es_CL": {"numeric": {}},
        "es_CO": {"numeric": {}},
        "es_CR": {"numeric": {}},
        "es_DO": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_EC": {"numeric": {}},
        "es_ES": {"numeric": {}},
        "es_GT": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_HN": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_MX": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_NI": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_PA": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_PE": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_PR": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_PY": {"numeric": {}},
        "es_SV": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "es_UY": {"numeric": {}},
        "es_VE": {"numeric": {}},
        "et": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "et_EE": {"numeric": {}},
        "eu": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "eu_ES": {"numeric": {}},
        "fa": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "fa_IR": {"numeric": {}},
        "fi": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "fi_FI": {"numeric": {}},
        "fo": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "fo_FO": {"numeric": {}},
        "fr": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "fr_BE": {"numeric": {"displayThousandsSeparator": "."}},
        "fr_CA": {"numeric": {}},
        "fr_CH": {"numeric":             {
            "displayThousandsSeparator": "'",
            "displayDecimalSeparator": "."
        }},
        "fr_FR": {"numeric": {}},
        "fr_LU": {"numeric": {"displayThousandsSeparator": "."}},
        "fr_MC": {"numeric": {}},
        "gl": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "gl_ES": {"numeric": {}},
        "gu": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "gu_IN": {"numeric": {}},
        "he": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "he_IL": {"numeric": {}},
        "hi": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "hi_IN": {"numeric": {}},
        "hr": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "hr_HR": {"numeric": {}},
        "hu": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "hu_HU": {"numeric": {}},
        "hy": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "hy_AM": {"numeric": {}},
        "id": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "id_ID": {"numeric": {}},
        "is": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "is_IS": {"numeric": {}},
        "it": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "it_CH": {"numeric":             {
            "displayThousandsSeparator": "'",
            "displayDecimalSeparator": "."
        }},
        "it_IT": {"numeric": {}},
        "ja": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "ja_JP": {"numeric": {}},
        "ka": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "ka_GE": {"numeric": {}},
        "kk": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "kk_KZ": {"numeric": {}},
        "kn": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "kn_IN": {"numeric": {}},
        "ko": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "ko_KR": {"numeric": {}},
        "kok": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "kok_IN": {"numeric": {}},
        "lt": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "lt_LT": {"numeric": {}},
        "lv": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "lv_LV": {"numeric": {}},
        "mk": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "mk_MK": {"numeric": {}},
        "ml": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "ml_IN": {"numeric": {}},
        "mn": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "mn_MN": {"numeric": {}},
        "mr": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "mr_IN": {"numeric": {}},
        "ms": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "ms_BN": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "ms_MY": {"numeric": {}},
        "mt": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "mt_MT": {"numeric": {}},
        "nb": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "nb_NO": {"numeric": {}},
        "nl": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "nl_BE": {"numeric": {}},
        "nl_NL": {"numeric": {}},
        "nn": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "nn_NO": {"numeric": {}},
        "pa": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "pa_IN": {"numeric": {}},
        "pl": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "pl_PL": {"numeric": {}},
        "pt": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "pt_BR": {"numeric": {}},
        "pt_PT": {"numeric": {"displayThousandsSeparator": " "}},
        "ro": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "ro_RO": {"numeric": {}},
        "ru": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "ru_RU": {"numeric": {}},
        "se": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "se_NO": {"numeric": {}},
        "sk": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "sk_SK": {"numeric": {}},
        "sl": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "sl_SI": {"numeric": {}},
        "sq": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "sq_AL": {"numeric": {}},
        "sr": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "sr_BA": {"numeric": {}},
        "sr_CS": {"numeric": {}},
        "sv": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "sv_FI": {"numeric": {}},
        "sv_SE": {"numeric": {}},
        "sw": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "sw_KE": {"numeric": {}},
        "syr": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "syr_SY": {"numeric": {}},
        "ta": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "ta_IN": {"numeric": {}},
        "te": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "te_IN": {"numeric": {}},
        "th": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "th_TH": {"numeric": {}},
        "tn": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "tn_ZA": {"numeric": {}},
        "tr": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "tr_TR": {"numeric": {}},
        "uk": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "uk_UA": {"numeric": {}},
        "uz": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "uz_UZ": {"numeric": {}},
        "vi": {"numeric":             {
            "displayThousandsSeparator": ".",
            "displayDecimalSeparator": ","
        }},
        "vi_VN": {"numeric": {}},
        "xh": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "xh_ZA": {"numeric": {}},
        "zh": {"numeric":             {
            "displayThousandsSeparator": ",",
            "displayDecimalSeparator": "."
        }},
        "zh_CN": {"numeric": {}},
        "zh_HK": {"numeric": {}},
        "zh_MO": {"numeric": {}},
        "zh_SG": {"numeric": {}},
        "zh_TW": {"numeric": {}},
        "zu": {"numeric":             {
            "displayThousandsSeparator": " ",
            "displayDecimalSeparator": ","
        }},
        "zu_ZA": {"numeric": {}}
    };
	
	_s_g_gNumericConstant.getParseThousandSeparator = function(locale/*String*/ )/*String*/
	{
		return ",";
	}
	
	_s_g_gNumericConstant.getDisplayThousandSeparator =function(locale/*String*/ )/*String*/
	{
		var locale = locale || null; // default value is null.
		if (locale)
		{
			// if explicitly pass in, then try to fetch it.
			if (_s_g_gNumericConstant._resourceExist(locale, _s_g_gNumericConstant._KEY_TYPE_NUMERIC, _s_g_gNumericConstant._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR))
			{
				return _s_g_gNumericConstant.getNumericResource(locale, _s_g_gNumericConstant._KEY_TYPE_NUMERIC, _s_g_gNumericConstant._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR);
			} else {
				return null;
			}
		}
		return _s_g_gNumericConstant._getAppropriateNumericResource(_s_g_gNumericConstant._KEY_TYPE_NUMERIC, _s_g_gNumericConstant._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR);
	}
	
	_s_g_gNumericConstant.getParseDecimalSeparator =function(locale/*String*/)/*String*/
	{
		return ".";
	}
	
	_s_g_gNumericConstant.getDisplayDecimalSeparator =function(locale/*String*/ )/*String*/
	{
		var locale = locale || null;
		if (locale)
		{
			// if explicitly pass in, then try to fetch it.
			if (_s_g_gNumericConstant._resourceExist(locale, _s_g_gNumericConstant._KEY_TYPE_NUMERIC, _s_g_gNumericConstant._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR))
			{
				return _s_g_gNumericConstant.getNumericResource(locale, _s_g_gNumericConstant._KEY_TYPE_NUMERIC, _s_g_gNumericConstant._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR);
			} else {
				return null;
			}
		}
		return _s_g_gNumericConstant._getAppropriateNumericResource(_s_g_gNumericConstant._KEY_TYPE_NUMERIC, _s_g_gNumericConstant._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR);
	}
	
	_s_g_gNumericConstant.getParseCurrencySymbol =function()/*String*/
	{
		return "¤";
	}
	
	_s_g_gNumericConstant.getDefaultNumberFormat=function(locale/*String*/)/*String*/
	{
		var locale = locale || null;
		
		if (locale)
		{
			if (_s_g_gNumericConstant._formatExist(locale, _s_g_gNumericConstant._FORMAT_TYPE_NUMBER))
			{
				return _s_g_gNumericConstant._getNumericFormat(locale, _s_g_gNumericConstant._FORMAT_TYPE_NUMBER);
			} else {
				return null;
			}
		}
		return _s_g_gNumericConstant._getAppropriateNumericFormat(_s_g_gNumericConstant._FORMAT_TYPE_NUMBER);
	}
	
	_s_g_gNumericConstant.getDefaultCurrencyFormat =function(locale/*String*/ )/*String*/
	{
		var locale = locale || null;
		
		if (locale)
		{
			if (_s_g_gNumericConstant._formatExist(locale, _s_g_gNumericConstant._FORMAT_TYPE_CURRENCY))
			{
				return _s_g_gNumericConstant._getNumericFormat(locale, _s_g_gNumericConstant._FORMAT_TYPE_CURRENCY);
			} else {
				return null;
			}
		}
		return _s_g_gNumericConstant._getAppropriateNumericFormat(_s_g_gNumericConstant._FORMAT_TYPE_CURRENCY);
	}
	
	/**
	 * Get the actual locale for the default currency format.
	 */
	_s_g_gNumericConstant.getActualLocaleForDefaultCurrencyFormat =function()/*String*/
	{
		return _s_g_gNumericConstant.getActualLocaleForNumerFormat(_s_g_gNumericConstant._FORMAT_TYPE_CURRENCY);
	}
	
	_s_g_gNumericConstant.getActualLocaleForDefaultNumberFormat=function()/*String*/
	{
		return _s_g_gNumericConstant.getActualLocaleForNumerFormat(_s_g_gNumericConstant._FORMAT_TYPE_NUMBER);
	}
	
	_s_g_gNumericConstant.getActualLocaleForNumerFormat=function(type/*String*/)/*String*/
	{
		// first, try to fetch the resource according to pvl locale
		var pvlLocale/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvl();
		if (_s_g_gNumericConstant._formatExist(pvlLocale, type))
		{
			return pvlLocale;
		}
		
		// second, try to fetch the resource according to pvl dominant language
		var pvlIsoLanguageCode/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();
		if (_s_g_gNumericConstant._formatExist(pvlIsoLanguageCode, type))
		{
			return pvlIsoLanguageCode;
		}
		
		// third, try to fetch the resource according to document locale
		var documentLocale/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();
		if (_s_g_gNumericConstant._formatExist(documentLocale, type))
		{
			return documentLocale;
		}
		
		// fourth, try to fetch the resource according to document language
		var documentIsoLanguageCode/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();
		if (_s_g_gNumericConstant._formatExist(documentIsoLanguageCode, type))
		{
			return documentIsoLanguageCode;
		}
		
		return "en";
	}
	
	_s_g_gNumericConstant._getAppropriateNumericFormat=function(type/*String*/)/*String*/
	{
		return _s_g_gNumericConstant._getNumericFormat(_s_g_gNumericConstant.getActualLocaleForNumerFormat(type), type);
	}
	
	_s_g_gNumericConstant._formatExist =function(locale/*String*/, type/*String*/)/*Boolean*/
	{
		return (locale && type && _s_g_gNumericConstant._DEFAULT_FORMAT_STRING[locale] && _s_g_gNumericConstant._DEFAULT_FORMAT_STRING[locale][type]);
	}
	
	_s_g_gNumericConstant._getNumericFormat =function(locale/*String*/, type/*String*/)/*String*/
	{
		return _s_g_gNumericConstant._DEFAULT_FORMAT_STRING[locale][type];
	}
	
	/**
	 * A standard method to fetch appropriate numeric resources. It will follow a fall back
	 * strategy to get the resource.
	 * 
	 * @param type type of the resource
	 * @param resourceKey key of the resource
	 * 
	 * @return resource string or null if not found.
	 */
	_s_g_gNumericConstant._getAppropriateNumericResource =function(type/*String*/, resourceKey/*String*/)/*String*/
	{
		// first, try to fetch the resource according to pvl locale
		var pvlLocale/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvl();
		if (_s_g_gNumericConstant._resourceExist(pvlLocale, type, resourceKey))
		{
			return _s_g_gNumericConstant.getNumericResource(pvlLocale, type, resourceKey);
		}
		
		// second, try to fetch the resource according to pvl dominant language
		var pvlIsoLanguageCode/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();
		if (_s_g_gNumericConstant._resourceExist(pvlIsoLanguageCode, type, resourceKey))
		{
			return _s_g_gNumericConstant.getNumericResource(pvlIsoLanguageCode, type, resourceKey);
		}
		
		// third, try to fetch the resource according to document locale
		var documentLocale/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();
		if (_s_g_gNumericConstant._resourceExist(documentLocale, type, resourceKey))
		{
			return _s_g_gNumericConstant.getNumericResource(documentLocale, type, resourceKey);
		}
		
		// fourth, try to fetch the resource according to document language
		var documentIsoLanguageCode/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();
		if (_s_g_gNumericConstant._resourceExist(documentIsoLanguageCode, type, resourceKey))
		{
			return _s_g_gNumericConstant.getNumericResource(documentIsoLanguageCode, type, resourceKey);
		}
		
		return _s_g_gNumericConstant.getNumericResource("en", type, resourceKey);
	}
	
	_s_g_gNumericConstant._resourceExist =function(locale/*String*/, type/*String*/, resourceKey/*String*/)/*Boolean*/
	{
		return (locale && type && resourceKey && _s_g_gNumericConstant._RESOURCE_MAP[locale]
			&& _s_g_gNumericConstant._RESOURCE_MAP[locale][type] && _s_g_gNumericConstant._RESOURCE_MAP[locale][type][resourceKey]);
	}
	
	_s_g_gNumericConstant.getNumericResource =function(locale/*String*/, type/*String*/, resourceKey/*String*/)/*String*/
	{
		return _s_g_gNumericConstant._RESOURCE_MAP[locale][type][resourceKey];
	}

})();(function()
{
	sap.common.globalization.declare("sap.common.globalization.GlobalizationDateConstant");
	sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");
	
	sap.common.globalization.GlobalizationDateConstant = function()
	{
		this.__className = "sap.common.globalization.defaultFormat.GlobalizationDateConstant";
	}
	var _g_n_g = sap.common.globalization.GlobalizationDateConstant;
		// keys for retrieving different data type Default Format String
		_g_n_g.FORMAT_TYPE_SHORTDATE/*:String*/ = "shortDate",
		_g_n_g.FORMAT_TYPE_LONGDATE/*:String*/ = "longDate",
		_g_n_g.FORMAT_TYPE_DATE_TIME/*:String*/ = "dateTime",
		_g_n_g.FORMAT_TYPE_TIME/*:String*/ = "timeFormat",
		
		// Key for retrieving internal predefined tokens and separators
		_g_n_g.KEY_TYPE_DATE/*:String*/ = "date",
		_g_n_g.KEY_TYPE_TIME/*:String*/ = "time",
		
		_g_n_g.KEY_TOKEN_SHORT_DAY/*:String*/ = "shortDay",
		_g_n_g.KEY_TOKEN_LONG_DAY/*:String*/ = "longDay",
		_g_n_g.KEY_TOKEN_SHORT_MONTH/*:String*/ = "shortMonth",
		_g_n_g.KEY_TOKEN_LONG_MONTH/*:String*/ = "longMonth",
		_g_n_g.KEY_TOKEN_AM_PM/*:String*/ = "amPm",
		_g_n_g.KEY_DATE_SEPARATOR/*:String*/ = "dateSeparator",
		_g_n_g.KEY_TIME_SEPARATOR/*:String*/ = "timeSeparator",
		_g_n_g.KEY_TOKEN_ABBREV_ERA/*:String*/ = "eraAbbr",

		_g_n_g.DEFAULT_FORMAT_STRING/*:Object*/ = {
		    "af":     {
		        "longDate": "dddd dd MMMM yyyy;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "af_ZA": {},
		    "ar":     {
		        "longDate": "dddd، d MMMM، yyyy;@",
		        "shortDate": "d/M/yyyy;@",
		        "dateTime":"dd/MM/yyyy h:mm:ss AM/PM;@",
		        "timeFormat":"h:mm:ss AM/PM;@"
		    },
		    "ar_AE": {},
		    "ar_BH": {},
		    "ar_DZ": {},
		    "ar_EG": {},
		    "ar_IQ": {},
		    "ar_JO": {},
		    "ar_KW": {},
		    "ar_LB": {},
		    "ar_LY": {},
		    "ar_MA": {},
		    "ar_OM": {},
		    "ar_QA": {},
		    "ar_SA": {},
		    "ar_SY": {},
		    "ar_TN": {},
		    "ar_YE": {},
		    "az":     {
		        "longDate": "dddd, d, MMMM, yyyy;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"d MMM, yyyy HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "az_AZ": {},
		    "be":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "d.M.yy;@",
		        "dateTime":"d.M.yyyy HH.mm.ss;@",
		        "timeFormat": "HH.mm.ss;@"
		    },
		    "be_BY": {},
		    "bg":     {
		        "longDate": "dd MMMM yyyy, dddd;@",
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"dd.MM.yyyy HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "bg_BG": {},
		    "bn":     {
		        "longDate": "dddd, d MMMM, yyyy;@",
		        "shortDate": "d/M/yy;@",
		        "dateTime":"d MMM, yyyy h:mm:ss AM/PM;@",
		        "timeFormat": "h:mm:ss AM/PM;@"
		    },
		    "bn_IN": {},
		    "bs":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "bs_BA": {},
		    "ca":     {
		        "longDate": 'dddd d "de" MMMM "de" yyyy;@',
		        "shortDate": "dd/MM/yy;@",
		        "dateTime":"dd/MM/yyyy H:mm:ss;@",
		        "timeFormat": "H:mm:ss;@"
		    },
		    "ca_ES": {},
		    "cs":     {
		        "longDate": "dddd, d. MMMM yyyy;@",
		        "shortDate": "d.M.yy;@",
		        "dateTime":"d.M.yyyy H:mm:ss;@",
		        "timeFormat": "H:mm:ss;@"
		    },
		    "cs_CZ": {},
		    "cy":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d h:mm:ss AM/PM;@",
		        "timeFormat": "h:mm:ss AM/PM;@"
		    },
		    "cy_GB": {},
		    "da":     {
		        "longDate": 'dddd "den" d. MMMM yyyy;@',
		        "shortDate": "dd/MM/yy;@",
		        "dateTime":"dd/MM/yyyy HH.mm.ss;@",
		        "timeFormat": "HH.mm.ss;@"
		    },
		    "da_DK": {},
		    "de":     {
		        "longDate": "dddd, d. MMMM yyyy;@",
		        "shortDate": "dd.MM.yy;@",
		        "dateTime": "dd.MM.yyyy HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "de_AT": {"longDate": "dddd, dd. MMMM yyyy;@"},
		    "de_CH": {},
		    "de_DE": {},
		    "de_LI": {},																																																													
		    "de_LU": {},
		    "el":     {
		        "longDate": "dddd, dd MMMM yyyy;@",
		        "shortDate": "dd/MM/yyyy;@",
		        "dateTime":"dd MMM yyyy h:mm:ss AM/PM;@",
		        "timeFormat": "h:mm:ss AM/PM;@"
		    },
		    "el_GR": {},
		    "en":     {
		        "longDate": "dddd, MMMM d, yyyy;@",
		        "shortDate": "M/d/yy;@",
		        "dateTime": "MMM d, yyyy h:mm:ss AM/PM;@",
		        "timeFormat": "h:mm:ss AM/PM;@"
		    },
		    "en_AU":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "d/MM/yy;@",
		        "dateTime": "dd/MM/yyyy h:mm:ss AM/PM;@"
		    },
		    "en_BZ":     {
		        "dateTime": "dd-MMM-yyyy h:mm:ss AM/PM;@"
		    },
		    "en_CA": {
		    	"shortDate": "yy-MM-dd;@",
		    	"dateTime": "yyyy-MM-dd h:mm:ss AM/PM;@"
		    },
		    "en_GB":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "dd/MM/yyyy;@",
		        "dateTime": "d MMM yyyy HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "en_IE":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "dd/MM/yyyy;@",
		        "dateTime": "d MMM yyyy HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "en_JM": {},
		    "en_NZ":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "d/MM/yy;@",
		        "dateTime": "d/MM/yyyy h:mm:ss AM/PM;@"
		    },
		    "en_PH": {},
		    "en_TT": {},
		    "en_US": {},
		    "en_VI": {},
		    "en_ZA":     {
		        "longDate": "dddd dd MMMM yyyy;@",
		        "shortDate": "yyyy/MM/dd;@",
		        "dateTime": "dd MMM yyyy h:mm:ss AM/PM;@"
		    },
		    "en_ZW":     {
		        "longDate": "dddd dd MMMM yyyy;@",
		        "shortDate": "d/M/yyyy;@",
		        "dateTime": "dd MMM, yyyy h:mm:ss AM/PM;@"
		    },
		    "es":     {
		        "longDate": 'dddd d "de" MMMM "de" yyyy;@',
		        "shortDate": "dd/MM/yy;@",
		        "dateTime":"dd/MM/yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "es_AR": {},
		    "es_BO": {},
		    "es_CL": {
		    	"shortDate": "dd-MM-yy;@",
		    	"dateTime":"dd-MM-yyyy H:mm:ss;@",
		    	"timeFormat":"H:mm:ss;@"
		    	},
		    "es_CO": {
		    	"shortDate": "d/MM/yy;@",
		    	"dateTime":"d/MM/yyyy H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "es_CR": {},
		    "es_DO": {},
		    "es_EC": {
		    	"dateTime":"dd/MM/yyyy H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "es_ES": {},
		    "es_GT": {
		    	"shortDate": "d/MM/yy;@",
		    	"dateTime":"d/MM/yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "es_HN": {"longDate": 'dddd dd "de" MMMM "de" yyyy;@'},
		    "es_MX": {},
		    "es_NI": {},
		    "es_PA": {
		    	"shortDate": "MM/dd/yy;@",
		    	"dateTime":"MM/dd/yyyy HH:mm:ss;@"
		    },
		    "es_PE": {"shortDate": "d/MM/yy;@"},
		    "es_PR": {
		    	"shortDate": "MM/dd/yy;@",
		    	"dateTime":"MM/dd/yyyy HH:mm:ss;@"
		    },
		    "es_PY": {},
		    "es_SV": {},
		    "es_UY": {},
		    "es_VE": {},
		    "et":     {
		        "longDate": "dddd, d, MMMM yyyy;@",
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"dd.MM.yyyy H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "et_EE": {},
		    "eu":     {
		        "longDate": 'dddd, yyyy"eko" MMMM"ren" dd"a";@',
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "eu_ES": {},
		    "fa":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "yy/M/d;@",
		        "dateTime": "yyyy/M/d، H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "fa_IR": {},
		    "fi":     {
		        "longDate": "dddd d. MMMM yyyy;@",
		        "shortDate": "d.M.yyyy;@",
		        "dateTime":"d.M.yyyy H.mm.ss;@",
		        "timeFormat":"H.mm.ss;@"
		    },
		    "fi_FI": {},
		    "fo":     {
		        "longDate": "dddd dd MMMM yyyy;@",
		        "shortDate": "dd-MM-yy;@",
		        "dateTime":"dd-MM-yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "fo_FO": {},
		    "fr":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "dd/MM/yy;@",
		        "dateTime": "d MMM yyyy HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "fr_BE": {"shortDate": "d/MM/yy;@"},
		    "fr_CA": {
		    	"shortDate": "yy-MM-dd;@",
		    	"dateTime": "yyyy-MM-dd HH:mm:ss;@"
			},
		    "fr_CH":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "dd.MM.yy;@"
		    },
		    "fr_FR": {},
		    "fr_LU": {},
		    "fr_MC": {},
		    "gl":     {
		        "longDate": "dddd dd MMMM yyyy;@",
		        "shortDate": "dd/MM/yy;@",
		        "dateTime":"d MMM, yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "gl_ES": {},
		    "gu":     {
		        "longDate": "dddd, d MMMM, yyyy;@",
		        "shortDate": "d-MM-yy;@",
		        "dateTime":"d MMM, yyyy hh:mm:ss AM/PM;@",
		        "timeFormat":"hh:mm:ss AM/PM;@"
		    },
		    "gu_IN": {},
		    "he":     {
		        "longDate": "dddd, d בMMMM yyyy;@",
		        "shortDate": "dd/MM/yy;@",
		        "dateTime": "dd/MM/yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "he_IL": {},
		    "hi":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "d-M-yy;@",
		        "dateTime":"dd-MM-yyyy h:mm:ss AM/PM;@",
		        "timeFormat":"h:mm:ss AM/PM;@"
		    },
		    "hi_IN": {},
		    "hr":     {
		        "longDate": "dddd, d. MMMM yyyy.;@",
		        "shortDate": "dd.MM.yyyy.;@",
		        "dateTime":"d.M.yyyy. HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "hr_HR": {},
		    "hu":     {
		        "longDate": "yyyy. MMMM d., dddd;@",
		        "shortDate": "yyyy.MM.dd.;@",
		        "dateTime":"yyyy.MM.dd. H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "hu_HU": {},
		    "hy":     {
		        "longDate": "dddd, MMMM d, yyyy;@",
		        "shortDate": "MM/dd/yy;@",
		        "dateTime":"MMM d, yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "hy_AM": {},
		    "id":     {
		        "longDate": "dddd, dd MMMM yyyy;@",
		        "shortDate": "dd/MM/yy;@",
		        "dateTime":"d MMM yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "id_ID": {},
		    "is":     {
		        "longDate": "dddd, d. MMMM yyyy;@",
		        "shortDate": "d.M.yyyy;@",
		        "dateTime":"d.M.yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "is_IS": {},
		    "it":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "dd/MM/yy;@",
		        "dateTime":"dd/MMM/yyyy HH.mm.ss;@",
		        "timeFormat":"HH.mm.ss;@"
		    },
		    "it_CH":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"d-MMM-yyyy HH.mm.ss;@"
		    },
		    "it_IT": {},
		    "ja":     {
		        "longDate": "yyyy年M月d日dddd;@",
		        "shortDate": "yy/MM/dd;@",
		        "dateTime": "yyyy/MM/dd H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "ja_JP": {},
		    "ka":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "ka_GE": {},
		    "kk":     {
		        "longDate": 'dddd, d MMMM yyyy "ж".;@',
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"dd.MM.yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "kk_KZ": {},
		    "kn":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "d-M-yy;@",
		        "dateTime":"d MMM yyyy hh:mm:ss AM/PM;@",
		        "timeFormat":"hh:mm:ss AM/PM;@"
		    },
		    "kn_IN": {},
		    "ko":     {
		        "longDate": "yyyy년 M월 d일 dddd;@",
		        "shortDate": "yy. M. d.;@",
		        "dateTime": "yyyy. M. d. AM/PM h:mm:ss;@",
		        "timeFormat":"AM/PM h:mm:ss;@"
		    },
		    "ko_KR": {},
		    "kok":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "kok_IN": {},
		    "lt":     {
		        "longDate": 'yyyy "m". MMMM d "d".,dddd;@',
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy.MM.dd HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "lt_LT": {},
		    "lv":     {
		        "longDate": 'dddd, yyyy. "gada" d. MMMM;@',
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":'yyyy. "gada" d. MMM HH:mm:ss;@',
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "lv_LV": {},
		    "mk":     {
		        "longDate": "dddd, dd MMMM yyyy;@",
		        "shortDate": "dd.M.yy;@",
		        "dateTime":"dd.M.yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "mk_MK": {},
		    "ml":     {
		        "longDate": "yyyy, MMMM d, dddd;@",
		        "shortDate": "dd/MM/yy;@",
		        "dateTime": "yyyy, MMM d h:mm:ss AM/PM;@",
		        "timeFormat":"h:mm:ss AM/PM;@"
		    },
		    "ml_IN": {},
		    "mn":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "mn_MN": {},
		    "mr":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "d-M-yy;@",
		        "dateTime":"d MMM yyyy h-mm-ss AM/PM;@",
		        "timeFormat":"h-mm-ss AM/PM;@"
		    },
		    "mr_IN": {},
		    "ms":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "ms_BN": {
		        "longDate": "dd MMMM yyyy;@",
		        "dateTime":"dd/MM/yyyy H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "ms_MY": {},
		    "mt":     {
		        "longDate": 'dddd, d "ta"’ MMMM yyyy;@',
		        "shortDate": "dd/MM/yyyy;@",
		        "dateTime":"dd MMM yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "mt_MT": {},
		    "nb":     {
		        "longDate": "dddd d. MMMM yyyy;@",
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"d. MMM yyyy HH.mm.ss;@",
		        "timeFormat":"HH.mm.ss;@"
		    },
		    "nb_NO": {},
		    "nl":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "dd-MM-yy;@",
		        "dateTime":"d MMM yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "nl_BE": {
		        "shortDate": "d/MM/yy;@",
		        "dateTime":"d-MMM-yyyy HH:mm:ss;@"
		    },
		    "nl_NL": {},
		    "nn":     {
		        "longDate": "dddd d. MMMM yyyy;@",
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"d. MMM. yyyy HH.mm.ss;@",
		        "timeFormat":"HH.mm.ss;@"
		    },
		    "nn_NO": {},
		    "pa":     {
		        "longDate": "dddd, dd MMMM yyyy;@",
		        "shortDate": "dd/MM/yyyy;@",
		        "dateTime":"d MMM yyyy h:mm:ss AM/PM;@",
		        "timeFormat":"h:mm:ss AM/PM;@"
		    },
		    "pa_IN": {},
		    "pl":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "dd-MM-yy;@",
		        "dateTime":"dd-MM-yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "pl_PL": {},
		    "pt":     {
		        "longDate": 'dddd, d "de" MMMM "de" yyyy;@',
		        "shortDate": "dd/MM/yy;@",
		        "dateTime": "dd/MM/yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "pt_BR": {},
		    "pt_PT": {
		        "dateTime": 'd "de" MMM "de" yyyy HH:mm:ss;@'
		    },
		    "ro":     {
		        "longDate": "dddd, d MMMM yyyy;@",
		        "shortDate": "dd.MM.yyyy;@",
		        "dateTime": "dd.MM.yyyy, HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "ro_RO": {},
		    "ru":     {
		        "longDate": 'dddd, d MMMM yyyy "г".;@',
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"dd.MM.yyyy H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "ru_RU": {},
		    "se":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "se_NO": {},
		    "sk":     {
		        "longDate": "dddd, d. MMMM yyyy;@",
		        "shortDate": "d.M.yyyy;@",
		        "dateTime":"d.M.yyyy H:mm:ss;@",
		        "timeFormat":"H:mm:ss;@"
		    },
		    "sk_SK": {},
		    "sl":     {
		        "longDate": "dddd, dd. MMMM yyyy;@",
		        "shortDate": "d. MM. yy;@",
		        "dateTime":"d. MMM. yyyy HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "sl_SI": {},
		    "sq":     {
		        "longDate": "dddd, dd MMMM yyyy;@",
		        "shortDate": "yy-MM-dd;@",
		        "dateTime":"yyyy-MM-dd h.mm.ss.AM/PM;@",
		        "timeFormat": "h.mm.ss.AM/PM;@"
		    },
		    "sq_AL": {},
		    "sr":     {
		        "longDate": "dddd, dd. MMMM yyyy.;@",
		        "shortDate": "d.M.yy.;@",
		        "dateTime":"dd.MM.yyyy. HH.mm.ss;@",
		        "timeFormat":"HH.mm.ss;@"
		    },
		    "sr_BA": {},
		    "sr_CS": {},
		    "sv":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"d MMM yyyy HH.mm.ss;@",
		        "timeFormat":"HH.mm.ss;@"
		    },
		    "sv_FI": {},
		    "sv_SE": {},
		    "sw":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "sw_KE": {},
		    "syr":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"y MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "syr_SY": {},
		    "ta":     {
		        "longDate": "dddd, d MMMM, yyyy;@",
		        "shortDate": "d-M-yy;@",
		        "dateTime":"d MMM, yyyy h:mm:ss AM/PM;@",
		        "timeFormat": "h:mm:ss AM/PM;@"
		    },
		    "ta_IN": {},
		    "te":     {
		        "longDate": "dddd d MMMM yyyy;@",
		        "shortDate": "dd-MM-yy;@",
		        "dateTime":"d MMM yyyy h:mm:ss AM/PM;@",
		        "timeFormat": "h:mm:ss AM/PM;@"
		    },
		    "te_IN": {},
		    "th":     {
		        "longDate": "ddddที่ d MMMM G yyyy;@",
		        "shortDate": "d/M/yyyy;@",
		        "dateTime": "d MMM yyyy, H:mm:ss;@",
		        "timeFormat": "H:mm:ss;@"
		    },
		    "th_TH": {},
		    "tn":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "tn_ZA": {},
		    "tr":     {
		        "longDate": "dd MMMM yyyy dddd;@",
		        "shortDate": "dd.MM.yyyy;@",
		        "dateTime":"dd MMM yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "tr_TR": {},
		    "uk":     {
		        "longDate": 'dddd, d MMMM yyyy "р".;@',
		        "shortDate": "dd.MM.yy;@",
		        "dateTime":"d MMM yyyy HH:mm:ss;@",
		        "timeFormat":"HH:mm:ss;@"
		    },
		    "uk_UA": {},
		    "uz":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "uz_UZ": {},
		    "vi":     {
		        "longDate": 'dddd, "ngày" dd MMMM "năm" yyyy;@',
		        "shortDate": "dd/MM/yyyy;@",
		        "dateTime": "HH:mm:ss dd-MM-yyyy;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "vi_VN": {},
		    "xh":     {
		        "longDate": "dddd, yyyy MMMM dd;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime":"yyyy MMM d HH:mm:ss;@",
		        "timeFormat": "HH:mm:ss;@"
		    },
		    "xh_ZA": {},
		    "zh":     {
		        "longDate": "yyyy年M月d日dddd;@",
		        "shortDate": "yy-M-d;@",
		        "dateTime": "yyyy-M-d AM/PMhh:mm:ss;@",
		        "timeFormat": "AM/PMhh:mm:ss;@"
		    },
		    "zh_CN": {},
		    "zh_HK": {},
		    "zh_MO": {},
		    "zh_SG": {},
		    "zh_TW": {},
		    "zu":     {
		        "longDate": "dddd dd MMMM yyyy;@",
		        "shortDate": "yyyy-MM-dd;@",
		        "dateTime": "d MMM yyyy h:mm:ss AM/PM;@",
		        "timeFormat": "h:mm:ss AM/PM;@"
		    },
		    "zu_ZA": {}
		} ,
		_g_n_g.RESOURCE_MAP/*:Object*/ = {
			"af":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "voor Christus",
		                "na Christus"
		            ],
		            "eraAbbr":             [
		                "v.C.",
		                "n.C."
		            ],
		            "shortDay":             [
		                "So",
		                "Ma",
		                "Di",
		                "Wo",
		                "Do",
		                "Vr",
		                "Sa"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Feb",
		                "Mar",
		                "Apr",
		                "Mei",
		                "Jun",
		                "Jul",
		                "Aug",
		                "Sep",
		                "Okt",
		                "Nov",
		                "Des"
		            ],
		            "longDay":             [
		                "Sondag",
		                "Maandag",
		                "Dinsdag",
		                "Woensdag",
		                "Donderdag",
		                "Vrydag",
		                "Saterdag"
		            ],
		            "longMonth":             [
		                "Januarie",
		                "Februarie",
		                "Maart",
		                "April",
		                "Mei",
		                "Junie",
		                "Julie",
		                "Augustus",
		                "September",
		                "Oktober",
		                "November",
		                "Desember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "vm.",
		                "nm."
		            ]
		        }
		    },
		    "af_ZA":     {
		        "date": {},
		        "time": {}
		    },
		    "ar":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "قبل الميلاد",
		                "ميلادي"
		            ],
		            "eraAbbr":             [
		                "ق.م",
		                "م"
		            ],
		            "shortDay":             [
		                "أحد",
		                "إثنين",
		                "ثلاثاء",
		                "أربعاء",
		                "خميس",
		                "جمعة",
		                "سبت"
		            ],
		            "shortMonth":             [
		                "يناير",
		                "فبراير",
		                "مارس",
		                "أبريل",
		                "مايو",
		                "يونيو",
		                "يوليو",
		                "أغسطس",
		                "سبتمبر",
		                "أكتوبر",
		                "نوفمبر",
		                "ديسمبر"
		            ],
		            "longDay":             [
		                "الأحد",
		                "الإثنين",
		                "الثلاثاء",
		                "الأربعاء",
		                "الخميس",
		                "الجمعة",
		                "السبت"
		            ],
		            "longMonth":             [
		                "يناير",
		                "فبراير",
		                "مارس",
		                "أبريل",
		                "مايو",
		                "يونيو",
		                "يوليو",
		                "أغسطس",
		                "سبتمبر",
		                "أكتوبر",
		                "نوفمبر",
		                "ديسمبر"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "ص",
		                "م"
		            ]
		        }
		    },
		    "ar_AE":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_BH":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_DZ":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_EG":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_IQ":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_JO":     {
		        "date":         {
		            "shortDay":             [
		                "الأحد",
		                "الاثنين",
		                "الثلاثاء",
		                "الأربعاء",
		                "الخميس",
		                "الجمعة",
		                "السبت"
		            ],
		            "shortMonth":             [
		                "كانون الثاني",
		                "شباط",
		                "آذار",
		                "نيسان",
		                "أيار",
		                "حزيران",
		                "تموز",
		                "آب",
		                "أيلول",
		                "تشرين الأول",
		                "تشرين الثاني",
		                "كانون الأول"
		            ],
		            "longMonth":             [
		                "كانون الثاني",
		                "شباط",
		                "آذار",
		                "نيسان",
		                "أيار",
		                "حزيران",
		                "تموز",
		                "آب",
		                "أيلول",
		                "تشرين الأول",
		                "تشرين الثاني",
		                "كانون الأول"
		            ]
		        },
		        "time": {}
		    },
		    "ar_KW":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_LB":     {
		        "date":         {
		            "shortDay":             [
		                "الأحد",
		                "الاثنين",
		                "الثلاثاء",
		                "الأربعاء",
		                "الخميس",
		                "الجمعة",
		                "السبت"
		            ],
		            "shortMonth":             [
		                "كانون الثاني",
		                "شباط",
		                "آذار",
		                "نيسان",
		                "نوار",
		                "حزيران",
		                "تموز",
		                "آب",
		                "أيلول",
		                "تشرين الأول",
		                "تشرين الثاني",
		                "كانون الأول"
		            ],
		            "longMonth":             [
		                "كانون الثاني",
		                "شباط",
		                "آذار",
		                "نيسان",
		                "نوار",
		                "حزيران",
		                "تموز",
		                "آب",
		                "أيلول",
		                "تشرين الأول",
		                "تشرين الثاني",
		                "كانون الأول"
		            ]
		        },
		        "time": {}
		    },
		    "ar_LY":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_MA":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_OM":     {
		        "date": {},
		        "time": {}
		    },
		    "ar_QA":     {
		        "date": {"shortDay":         [
		            "الأحد",
		            "الاثنين",
		            "الثلاثاء",
		            "الأربعاء",
		            "الخميس",
		            "الجمعة",
		            "السبت"
		        ]},
		        "time": {}
		    },
		    "ar_SA":     {
		        "date": {"shortDay":         [
		            "الأحد",
		            "الاثنين",
		            "الثلاثاء",
		            "الأربعاء",
		            "الخميس",
		            "الجمعة",
		            "السبت"
		        ]},
		        "time": {}
		    },
		    "ar_SY":     {
		        "date":         {
		            "shortDay":             [
		                "الأحد",
		                "الاثنين",
		                "الثلاثاء",
		                "الأربعاء",
		                "الخميس",
		                "الجمعة",
		                "السبت"
		            ],
		            "shortMonth":             [
		                "كانون الثاني",
		                "شباط",
		                "آذار",
		                "نيسان",
		                "نوار",
		                "حزيران",
		                "تموز",
		                "آب",
		                "أيلول",
		                "تشرين الأول",
		                "تشرين الثاني",
		                "كانون الأول"
		            ],
		            "longMonth":             [
		                "كانون الثاني",
		                "شباط",
		                "آذار",
		                "نيسان",
		                "نوار",
		                "حزيران",
		                "تموز",
		                "آب",
		                "أيلول",
		                "تشرين الأول",
		                "تشرين الثاني",
		                "كانون الأول"
		            ]
		        },
		        "time": {}
		    },
		    "ar_TN":     {
		        "date": {"shortDay":         [
		            "الأحد",
		            "الاثنين",
		            "الثلاثاء",
		            "الأربعاء",
		            "الخميس",
		            "الجمعة",
		            "السبت"
		        ]},
		        "time": {}
		    },
		    "ar_YE":     {
		        "date": {"shortDay":         [
		            "الأحد",
		            "الاثنين",
		            "الثلاثاء",
		            "الأربعاء",
		            "الخميس",
		            "الجمعة",
		            "السبت"
		        ]},
		        "time": {}
		    },
		    "az":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "eramızdan əvvəl",
		                "bizim eramızın"
		            ],
		            "eraAbbr":             [
		                "e.ə.",
		                "b.e."
		            ],
		            "shortDay":             [
		                "B.",
		                "B.E.",
		                "Ç.A.",
		                "Ç.",
		                "C.A.",
		                "C",
		                "Ş."
		            ],
		            "shortMonth":             [
		                "yan",
		                "fev",
		                "mar",
		                "apr",
		                "may",
		                "iyn",
		                "iyl",
		                "avq",
		                "sen",
		                "okt",
		                "noy",
		                "dek"
		            ],
		            "longDay":             [
		                "bazar",
		                "bazar ertəsi",
		                "çərşənbə axşamı",
		                "çərşənbə",
		                "cümə axşamı",
		                "cümə",
		                "şənbə"
		            ],
		            "longMonth":             [
		                "Yanvar",
		                "Fevral",
		                "Mart",
		                "Aprel",
		                "May",
		                "İyun",
		                "İyul",
		                "Avqust",
		                "Sentyabr",
		                "Oktyabr",
		                "Noyabr",
		                "Dekabr"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "az_AZ":     {
		        "date": {},
		        "time": {}
		    },
		    "be":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "да н.э.",
		                "н.э."
		            ],
		            "eraAbbr":             [
		                "да н.е.",
		                "н.е."
		            ],
		            "eraNarrow":             [
		                "да н.э.",
		                "н.э."
		            ],
		            "shortDay":             [
		                "нд",
		                "пн",
		                "аў",
		                "ср",
		                "чц",
		                "пт",
		                "сб"
		            ],
		            "shortMonth":             [
		                "сту",
		                "лют",
		                "сак",
		                "кра",
		                "май",
		                "чэр",
		                "ліп",
		                "жні",
		                "вер",
		                "кас",
		                "ліс",
		                "сне"
		            ],
		            "longDay":             [
		                "нядзеля",
		                "панядзелак",
		                "аўторак",
		                "серада",
		                "чацвер",
		                "пятніца",
		                "субота"
		            ],
		            "longMonth":             [
		                "студзень",
		                "люты",
		                "сакавік",
		                "красавік",
		                "май",
		                "чэрвень",
		                "ліпень",
		                "жнівень",
		                "верасень",
		                "кастрычнік",
		                "лістапад",
		                "снежань"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "да палудня",
		                "пасля палудня"
		            ]
		        }
		    },
		    "be_BY":     {
		        "date": {},
		        "time": {}
		    },
		    "bg":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "пр.Хр.",
		                "сл.Хр."
		            ],
		            "eraAbbr":             [
		                "пр. н. е.",
		                "от н. е."
		            ],
		            "eraNarrow": ["сл.н.е."],
		            "shortDay":             [
		                "нд",
		                "пн",
		                "вт",
		                "ср",
		                "чт",
		                "пт",
		                "сб"
		            ],
		            "shortMonth":             [
		                "ян.",
		                "февр.",
		                "март",
		                "апр.",
		                "май",
		                "юни",
		                "юли",
		                "авг.",
		                "септ.",
		                "окт.",
		                "ноем.",
		                "дек."
		            ],
		            "longDay":             [
		                "неделя",
		                "понеделник",
		                "вторник",
		                "сряда",
		                "четвъртък",
		                "петък",
		                "събота"
		            ],
		            "longMonth":             [
		                "януари",
		                "февруари",
		                "март",
		                "април",
		                "май",
		                "юни",
		                "юли",
		                "август",
		                "септември",
		                "октомври",
		                "ноември",
		                "декември"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "пр. об.",
		                "сл. об."
		            ]
		        }
		    },
		    "bg_BG":     {
		        "date": {},
		        "time": {}
		    },
		    "bn":     {
		        "date":         {
		            "dateSeparator": "/",
		            "eraAbbr":             [
		                "খৃষ্টপূর্ব",
		                "খৃষ্টাব্দ"
		            ],
		            "shortDay":             [
		                "রবি",
		                "সোম",
		                "মঙ্গল",
		                "বুধ",
		                "বৃহস্পতি",
		                "শুক্র",
		                "শনি"
		            ],
		            "shortMonth":             [
		                "জানুয়ারী",
		                "ফেব্রুয়ারী",
		                "মার্চ",
		                "এপ্রিল",
		                "মে",
		                "জুন",
		                "জুলাই",
		                "আগস্ট",
		                "সেপ্টেম্বর",
		                "অক্টোবর",
		                "নভেম্বর",
		                "ডিসেম্বর"
		            ],
		            "longDay":             [
		                "রবিবার",
		                "সোমবার",
		                "মঙ্গলবার",
		                "বুধবার",
		                "বৃহষ্পতিবার",
		                "শুক্রবার",
		                "শনিবার"
		            ],
		            "longMonth":             [
		                "জানুয়ারী",
		                "ফেব্রুয়ারী",
		                "মার্চ",
		                "এপ্রিল",
		                "মে",
		                "জুন",
		                "জুলাই",
		                "আগস্ট",
		                "সেপ্টেম্বর",
		                "অক্টোবর",
		                "নভেম্বর",
		                "ডিসেম্বর"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "পূর্বাহ্ণ",
		                "অপরাহ্ণ"
		            ]
		        }
		    },
		    "bn_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "bs":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "7",
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6"
		            ],
		            "shortMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ],
		            "longDay":             [
		                "7",
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6"
		            ],
		            "longMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "bs_BA":     {
		        "date": {},
		        "time": {}
		    },
		    "ca":     {
		        "date":         {
		            "dateSeparator": "/",
		            "eraAbbr":             [
		                "aC",
		                "dC"
		            ],
		            "shortDay":             [
		                "dg.",
		                "dl.",
		                "dt.",
		                "dc.",
		                "dj.",
		                "dv.",
		                "ds."
		            ],
		            "shortMonth":             [
		                "gen.",
		                "febr.",
		                "març",
		                "abr.",
		                "maig",
		                "juny",
		                "jul.",
		                "ag.",
		                "set.",
		                "oct.",
		                "nov.",
		                "des."
		            ],
		            "longDay":             [
		                "diumenge",
		                "dilluns",
		                "dimarts",
		                "dimecres",
		                "dijous",
		                "divendres",
		                "dissabte"
		            ],
		            "longMonth":             [
		                "gener",
		                "febrer",
		                "març",
		                "abril",
		                "maig",
		                "juny",
		                "juliol",
		                "agost",
		                "setembre",
		                "octubre",
		                "novembre",
		                "desembre"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "a.m.",
		                "p.m."
		            ]
		        }
		    },
		    "ca_ES":     {
		        "date": {},
		        "time": {}
		    },
		    "cs":     {
		        "date":         {
		            "dateSeparator": ".",
		            "eraAbbr":             [
		                "př.Kr.",
		                "po Kr."
		            ],
		            "shortDay":             [
		                "ne",
		                "po",
		                "út",
		                "st",
		                "čt",
		                "pá",
		                "so"
		            ],
		            "shortMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12",
		            ],
		            "longDay":             [
		                "neděle",
		                "pondělí",
		                "úterý",
		                "středa",
		                "čtvrtek",
		                "pátek",
		                "sobota"
		            ],
		            "longMonth":             [
		                "ledna",
		                "února",
		                "března",
		                "dubna",
		                "května",
		                "června",
		                "července",
		                "srpna",
		                "září",
		                "října",
		                "listopadu",
		                "prosince"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "dop.",
		                "odp."
		            ]
		        }
		    },
		    "cs_CZ":     {
		        "date": {},
		        "time": {}
		    },
		    "cy":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "Cyn Crist",
		                "Oed Crist"
		            ],
		            "eraAbbr":             [
		                "CC",
		                "OC"
		            ],
		            "eraNarrow":             [
		                "C",
		                "O"
		            ],
		            "shortDay":             [
		                "Sul",
		                "Llun",
		                "Maw",
		                "Mer",
		                "Iau",
		                "Gwen",
		                "Sad"
		            ],
		            "shortMonth":             [
		                "Ion",
		                "Chwef",
		                "Mawrth",
		                "Ebrill",
		                "Mai",
		                "Meh",
		                "Gorff",
		                "Awst",
		                "Medi",
		                "Hyd",
		                "Tach",
		                "Rhag"
		            ],
		            "longDay":             [
		                "Dydd Sul",
		                "Dydd Llun",
		                "Dydd Mawrth",
		                "Dydd Mercher",
		                "Dydd Iau",
		                "Dydd Gwener",
		                "Dydd Sadwrn"
		            ],
		            "longMonth":             [
		                "Ionawr",
		                "Chwefror",
		                "Mawrth",
		                "Ebrill",
		                "Mai",
		                "Mehefin",
		                "Gorffenaf",
		                "Awst",
		                "Medi",
		                "Hydref",
		                "Tachwedd",
		                "Rhagfyr"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "cy_GB":     {
		        "date": {},
		        "time": {}
		    },
		    "da":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "eraAbbr":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "shortDay":             [
		                "søn",
		                "man",
		                "tir",
		                "ons",
		                "tor",
		                "fre",
		                "lør"
		            ],
		            "shortMonth":             [
		                "jan.",
		                "feb.",
		                "mar.",
		                "apr.",
		                "maj",
		                "jun.",
		                "jul.",
		                "aug.",
		                "sep.",
		                "okt.",
		                "nov.",
		                "dec."
		            ],
		            "longDay":             [
		                "søndag",
		                "mandag",
		                "tirsdag",
		                "onsdag",
		                "torsdag",
		                "fredag",
		                "lørdag"
		            ],
		            "longMonth":             [
		                "januar",
		                "februar",
		                "marts",
		                "april",
		                "maj",
		                "juni",
		                "juli",
		                "august",
		                "september",
		                "oktober",
		                "november",
		                "december"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "f.m.",
		                "e.m."
		            ]
		        }
		    },
		    "da_DK":     {
		        "date": {},
		        "time": {}
		    },
		   "de":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "v. Chr.",
		                "n. Chr."
		            ],
		            "eraAbbr":             [
		                "v. Chr.",
		                "n. Chr."
		            ],
		            "shortDay":             [
		                "So.",
		                "Mo.",
		                "Di.",
		                "Mi.",
		                "Do.",
		                "Fr.",
		                "Sa."
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Feb",
		                "Mär",
		                "Apr",
		                "Mai",
		                "Jun",
		                "Jul",
		                "Aug",
		                "Sep",
		                "Okt",
		                "Nov",
		                "Dez"
		            ],
		            "longDay":             [
		                "Sonntag",
		                "Montag",
		                "Dienstag",
		                "Mittwoch",
		                "Donnerstag",
		                "Freitag",
		                "Samstag"
		            ],
		            "longMonth":             [
		                "Januar",
		                "Februar",
		                "März",
		                "April",
		                "Mai",
		                "Juni",
		                "Juli",
		                "August",
		                "September",
		                "Oktober",
		                "November",
		                "Dezember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "vorm.",
		                "nachm."
		            ]
		        }
		    },
		    "de_AT":     {
		        "date":         {
		            "shortMonth": 		[
		            	"Jän", 
		            	"Feb",
		                "Mär",
		                "Apr",
		                "Mai",
		                "Jun",
		                "Jul",
		                "Aug",
		                "Sep",
		                "Okt",
		                "Nov",
		                "Dez"],
		            "longMonth": [
		            	"Jänner",
		            	"Februar",
		                "März",
		                "April",
		                "Mai",
		                "Juni",
		                "Juli",
		                "August",
		                "September",
		                "Oktober",
		                "November",
		                "Dezember"]
		        },
		        "time": {}
		    },
		    "de_CH":     {
		        "date": {},
		        "time": {}
		    },
		    "de_DE":     {
		        "date": {},
		        "time": {}
		    },
		    "de_LI":     {
		        "date": {},
		        "time": {}
		    },
		    "de_LU":     {
		        "date": {},
		        "time": {}
		    },
		    "el":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "π.Χ.",
		                "μ.Χ."
		            ],
		            "eraAbbr":             [
		                "π.Χ.",
		                "μ.Χ."
		            ],
		            "shortDay":             [
		                "Κυρ",
		                "Δευ",
		                "Τρι",
		                "Τετ",
		                "Πεμ",
		                "Παρ",
		                "Σαβ"
		            ],
		            "shortMonth":             [
		                "Ιαν",
		                "Φεβ",
		                "Μαρ",
		                "Απρ",
		                "Μαϊ",
		                "Ιουν",
		                "Ιουλ",
		                "Αυγ",
		                "Σεπ",
		                "Οκτ",
		                "Νοε",
		                "Δεκ"
		            ],
		            "longDay":             [
		                "Κυριακή",
		                "Δευτέρα",
		                "Τρίτη",
		                "Τετάρτη",
		                "Πέμπτη",
		                "Παρασκευή",
		                "Σάββατο"
		            ],
		            "longMonth":             [
		                "Ιανουαρίου",
		                "Φεβρουαρίου",
		                "Μαρτίου",
		                "Απριλίου",
		                "Μαΐου",
		                "Ιουνίου",
		                "Ιουλίου",
		                "Αυγούστου",
		                "Σεπτεμβρίου",
		                "Οκτωβρίου",
		                "Νοεμβρίου",
		                "Δεκεμβρίου"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "π.μ.",
		                "μ.μ."
		            ]
		        }
		    },
		    "el_GR":     {
		        "date": {},
		        "time": {}
		    },
		    "en":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "Before Christ",
		                "Anno Domini"
		            ],
		            "eraAbbr":             [
		                "BC",
		                "AD"
		            ],
		            "eraNarrow":             [
		                "B",
		                "A"
		            ],
		            "shortDay":             [
		                "Sun",
		                "Mon",
		                "Tue",
		                "Wed",
		                "Thu",
		                "Fri",
		                "Sat"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Feb",
		                "Mar",
		                "Apr",
		                "May",
		                "Jun",
		                "Jul",
		                "Aug",
		                "Sep",
		                "Oct",
		                "Nov",
		                "Dec"
		            ],
		            "longDay":             [
		                "Sunday",
		                "Monday",
		                "Tuesday",
		                "Wednesday",
		                "Thursday",
		                "Friday",
		                "Saturday"
		            ],
		            "longMonth":             [
		                "January",
		                "February",
		                "March",
		                "April",
		                "May",
		                "June",
		                "July",
		                "August",
		                "September",
		                "October",
		                "November",
		                "December"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "en_AU":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "en_BZ":     {
		        "date": {"dateSeparator": "/"},
		        "time": {"timeSeparator": ":"}
		    },
		    "en_CA":     {
		        "date": {"dateSeparator": "-"},
		        "time": {}
		    },
		    "en_GB":     {
		        "date": {"dateSeparator": "/"},
		        "time": {"timeSeparator": ":"}
		    },
		    "en_IE":     {
		        "date": {"dateSeparator": "/"},
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "a.m.",
		                "p.m."
		            ]
		        }
		    },
		    "en_JM":     {
		        "date": {},
		        "time": {}
		    },
		    "en_NZ":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "en_PH":     {
		        "date": {},
		        "time": {}
		    },
		    "en_TT":     {
		        "date": {},
		        "time": {}
		    },
		    "en_US":     {
		        "date": {},
		        "time": {}
		    },
		    "en_VI":     {
		        "date": {},
		        "time": {}
		    },
		    "en_ZA":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "en_ZW":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "es":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "antes de Cristo",
		                "anno Dómini"
		            ],
		            "eraAbbr":             [
		                "a.C.",
		                "d.C."
		            ],
		            "shortDay":             [
		                "dom",
		                "lun",
		                "mar",
		                "mié",
		                "jue",
		                "vie",
		                "sáb"
		            ],
		            "shortMonth":             [
		                "ene",
		                "feb",
		                "mar",
		                "abr",
		                "may",
		                "jun",
		                "jul",
		                "ago",
		                "sep",
		                "oct",
		                "nov",
		                "dic"
		            ],
		            "longDay":             [
		                "domingo",
		                "lunes",
		                "martes",
		                "miércoles",
		                "jueves",
		                "viernes",
		                "sábado"
		            ],
		            "longMonth":             [
		                "enero",
		                "febrero",
		                "marzo",
		                "abril",
		                "mayo",
		                "junio",
		                "julio",
		                "agosto",
		                "septiembre",
		                "octubre",
		                "noviembre",
		                "diciembre"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "a.m.",
		                "p.m."
		            ]
		        }
		    },
		    "es_AR":     {
		        "date": {},
		        "time": {"amPm":         [
		            "a.m.",
		            "p.m."
		        ]}
		    },
		    "es_BO":     {
		        "date": {},
		        "time": {}
		    },
		    "es_CL":     {
		        "date": {"dateSeparator": "-"},
		        "time": {"timeSeparator": ":"}
		    },
		    "es_CO":     {
		        "date": {"dateSeparator": "/"},
		        "time": {"timeSeparator": ":"}
		    },
		    "es_CR":     {
		        "date": {},
		        "time": {}
		    },
		    "es_DO":     {
		        "date": {},
		        "time": {}
		    },
		    "es_EC":     {
		        "date": {},
		        "time": {"timeSeparator": ":"}
		    },
		    "es_ES":     {
		        "date": {},
		        "time": {}
		    },
		    "es_GT":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "es_HN":     {
		        "date": {},
		        "time": {}
		    },
		    "es_MX":     {
		        "date": {},
		        "time": {}
		    },
		    "es_NI":     {
		        "date": {},
		        "time": {}
		    },
		    "es_PA":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "es_PE":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "es_PR":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "es_PY":     {
		        "date": {},
		        "time": {}
		    },
		    "es_SV":     {
		        "date": {},
		        "time": {}
		    },
		    "es_UY":     {
		        "date": {},
		        "time": {}
		    },
		    "es_VE":     {
		        "date": {},
		        "time": {}
		    },
		    "et":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "enne meie aega",
		                "meie aja järgi"
		            ],
		            "eraAbbr":             [
		                "e.m.a.",
		                "m.a.j."
		            ],
		            "shortDay":             [
		                "P",
		                "E",
		                "T",
		                "K",
		                "N",
		                "R",
		                "L"
		            ],
		            "shortMonth":             [
		                "jaan",
		                "veebr",
		                "märts",
		                "apr",
		                "mai",
		                "juuni",
		                "juuli",
		                "aug",
		                "sept",
		                "okt",
		                "nov",
		                "dets"
		            ],
		            "longDay":             [
		                "pühapäev",
		                "esmaspäev",
		                "teisipäev",
		                "kolmapäev",
		                "neljapäev",
		                "reede",
		                "laupäev"
		            ],
		            "longMonth":             [
		                "jaanuar",
		                "veebruar",
		                "märts",
		                "aprill",
		                "mai",
		                "juuni",
		                "juuli",
		                "august",
		                "september",
		                "oktoober",
		                "november",
		                "detsember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "et_EE":     {
		        "date": {},
		        "time": {}
		    },
		    "eu":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "ig",
		                "al",
		                "as",
		                "az",
		                "og",
		                "or",
		                "lr"
		            ],
		            "shortMonth":             [
		                "urt",
		                "ots",
		                "mar",
		                "api",
		                "mai",
		                "eka",
		                "uzt",
		                "abu",
		                "ira",
		                "urr",
		                "aza",
		                "abe"
		            ],
		            "longDay":             [
		                "igandea",
		                "astelehena",
		                "asteartea",
		                "asteazkena",
		                "osteguna",
		                "ostirala",
		                "larunbata"
		            ],
		            "longMonth":             [
		                "urtarrila",
		                "otsaila",
		                "martxoa",
		                "apirila",
		                "maiatza",
		                "ekaina",
		                "uztaila",
		                "abuztua",
		                "iraila",
		                "urria",
		                "azaroa",
		                "abendua"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "eu_ES":     {
		        "date": {},
		        "time": {}
		    },
		    "fa":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "قبل از میلاد",
		                "میلادی"
		            ],
		            "eraAbbr":             [
		                "ق.م.",
		                "م."
		            ],
		            "eraNarrow":             [
		                "ق",
		                "م"
		            ],
		            "shortDay":             [
		                "یکشنبه",
		                "دوشنبه",
		                "سه‌شنبه",
		                "چهارشنبه",
		                "پنجشنبه",
		                "جمعه",
		                "شنبه"
		            ],
		            "shortMonth":             [
		                "ژانویهٔ",
		                "فوریهٔ",
		                "مارس",
		                "آوریل",
		                "مهٔ",
		                "ژوئن",
		                "ژوئیهٔ",
		                "اوت",
		                "سپتامبر",
		                "اکتبر",
		                "نوامبر",
		                "دسامبر"
		            ],
		            "longDay":             [
		                "یکشنبه",
		                "دوشنبه",
		                "سه‌شنبه",
		                "چهارشنبه",
		                "پنجشنبه",
		                "جمعه",
		                "شنبه"
		            ],
		            "longMonth":             [
		                "ژانویهٔ",
		                "فوریهٔ",
		                "مارس",
		                "آوریل",
		                "مهٔ",
		                "ژوئن",
		                "ژوئیهٔ",
		                "اوت",
		                "سپتامبر",
		                "اکتبر",
		                "نوامبر",
		                "دسامبر"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "قبل از ظهر",
		                "بعد از ظهر"
		            ]
		        }
		    },
		    "fa_IR":     {
		        "date": {},
		        "time": {}
		    },
		    "fi":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "ennen Kristuksen syntymää",
		                "jälkeen Kristuksen syntymän"
		            ],
		            "eraAbbr":             [
		                "eKr.",
		                "jKr."
		            ],
		            "shortDay":             [
		                "su",
		                "ma",
		                "ti",
		                "ke",
		                "to",
		                "pe",
		                "la"
		            ],
		            "shortMonth":             [
		                "tammikuuta",
		                "helmikuuta",
		                "maaliskuuta",
		                "huhtikuuta",
		                "toukokuuta",
		                "kesäkuuta",
		                "heinäkuuta",
		                "elokuuta",
		                "syyskuuta",
		                "lokakuuta",
		                "marraskuuta",
		                "joulukuuta"
		            ],
		            "longDay":             [
		                "sunnuntaina",
		                "maanantaina",
		                "tiistaina",
		                "keskiviikkona",
		                "torstaina",
		                "perjantaina",
		                "lauantaina"
		            ],
		            "longMonth":             [
		                "tammikuuta",
		                "helmikuuta",
		                "maaliskuuta",
		                "huhtikuuta",
		                "toukokuuta",
		                "kesäkuuta",
		                "heinäkuuta",
		                "elokuuta",
		                "syyskuuta",
		                "lokakuuta",
		                "marraskuuta",
		                "joulukuuta"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "ap.",
		                "ip."
		            ]
		        }
		    },
		    "fi_FI":     {
		        "date": {},
		        "time": {}
		    },
		    "fo":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "fyrir Krist",
		                "eftir Krist"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "eraNarrow":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "shortDay":             [
		                "sun",
		                "mán",
		                "týs",
		                "mik",
		                "hós",
		                "frí",
		                "ley"
		            ],
		            "shortMonth":             [
		                "jan",
		                "feb",
		                "mar",
		                "apr",
		                "mai",
		                "jun",
		                "jul",
		                "aug",
		                "sep",
		                "okt",
		                "nov",
		                "des"
		            ],
		            "longDay":             [
		                "sunnudagur",
		                "mánadagur",
		                "týsdagur",
		                "mikudagur",
		                "hósdagur",
		                "fríggjadagur",
		                "leygardagur"
		            ],
		            "longMonth":             [
		                "januar",
		                "februar",
		                "mars",
		                "apríl",
		                "mai",
		                "juni",
		                "juli",
		                "august",
		                "september",
		                "oktober",
		                "november",
		                "desember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "fo_FO":     {
		        "date": {},
		        "time": {}
		    },
		    "fr":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "avant Jésus-Christ",
		                "après Jésus-Christ"
		            ],
		            "eraAbbr":             [
		                "av. J.-C.",
		                "ap. J.-C."
		            ],
		            "shortDay":             [
		                "dim.",
		                "lun.",
		                "mar.",
		                "mer.",
		                "jeu.",
		                "ven.",
		                "sam."
		            ],
		            "shortMonth":             [
		                "janv.",
		                "févr.",
		                "mars",
		                "avr.",
		                "mai",
		                "juin",
		                "juil.",
		                "août",
		                "sept.",
		                "oct.",
		                "nov.",
		                "déc."
		            ],
		            "longDay":             [
		                "dimanche",
		                "lundi",
		                "mardi",
		                "mercredi",
		                "jeudi",
		                "vendredi",
		                "samedi"
		            ],
		            "longMonth":             [
		                "janvier",
		                "février",
		                "mars",
		                "avril",
		                "mai",
		                "juin",
		                "juillet",
		                "août",
		                "septembre",
		                "octobre",
		                "novembre",
		                "décembre"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "fr_BE":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "fr_CA":     {
		        "date": {"dateSeparator": "-"},
		        "time": {}
		    },
		    "fr_CH":     {
		        "date": {"dateSeparator": "."},
		        "time": {}
		    },
		    "fr_FR":     {
		        "date": {},
		        "time": {}
		    },
		    "fr_LU":     {
		        "date": {},
		        "time": {}
		    },
		    "fr_MC":     {
		        "date": {},
		        "time": {}
		    },
		    "gl":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "antes de Cristo",
		                "despois de Cristo"
		            ],
		            "eraAbbr":             [
		                "a.C.",
		                "d.C."
		            ],
		            "shortDay":             [
		                "Dom",
		                "Lun",
		                "Mar",
		                "Mér",
		                "Xov",
		                "Ven",
		                "Sáb"
		            ],
		            "shortMonth":             [
		                "Xan",
		                "Feb",
		                "Mar",
		                "Abr",
		                "Mai",
		                "Xuñ",
		                "Xul",
		                "Ago",
		                "Set",
		                "Out",
		                "Nov",
		                "Dec"
		            ],
		            "longDay":             [
		                "Domingo",
		                "Luns",
		                "Martes",
		                "Mércores",
		                "Xoves",
		                "Venres",
		                "Sábado"
		            ],
		            "longMonth":             [
		                "Xaneiro",
		                "Febreiro",
		                "Marzo",
		                "Abril",
		                "Maio",
		                "Xuño",
		                "Xullo",
		                "Agosto",
		                "Setembro",
		                "Outubro",
		                "Novembro",
		                "Decembro"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "gl_ES":     {
		        "date": {},
		        "time": {}
		    },
		    "gu":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "ઈસવીસન પૂર્વે",
		                "ઇસવીસન"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "eraNarrow":             [
		                "ઇ સ પુ",
		                "ઇસ"
		            ],
		            "shortDay":             [
		                "રવિ",
		                "સોમ",
		                "મંગળ",
		                "બુધ",
		                "ગુરુ",
		                "શુક્ર",
		                "શનિ"
		            ],
		            "shortMonth":             [
		                "જાન્યુ",
		                "ફેબ્રુ",
		                "માર્ચ",
		                "એપ્રિલ",
		                "મે",
		                "જૂન",
		                "જુલાઈ",
		                "ઑગસ્ટ",
		                "સપ્ટે",
		                "ઑક્ટો",
		                "નવે",
		                "ડિસે"
		            ],
		            "longDay":             [
		                "રવિવાર",
		                "સોમવાર",
		                "મંગળવાર",
		                "બુધવાર",
		                "ગુરુવાર",
		                "શુક્રવાર",
		                "શનિવાર"
		            ],
		            "longMonth":             [
		                "જાન્યુઆરી",
		                "ફેબ્રુઆરી",
		                "માર્ચ",
		                "એપ્રિલ",
		                "મે",
		                "જૂન",
		                "જુલાઈ",
		                "ઑગસ્ટ",
		                "સપ્ટેમ્બર",
		                "ઑક્ટ્બર",
		                "નવેમ્બર",
		                "ડિસેમ્બર"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "am",
		                "pm"
		            ]
		        }
		    },
		    "gu_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "he":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "לפני הספירה",
		                "לספירה"
		            ],
		            "eraAbbr":             [
		                "לפנה״ס",
		                "לסה״נ"
		            ],
		            "shortDay":             [
		                "יום א'",
		                "יום ב'",
		                "יום ג'",
		                "יום ד'",
		                "יום ה'",
		                "יום ו'",
		                "שבת"
		            ],
		            "shortMonth":             [
		                "ינו",
		                "פבר",
		                "מרס",
		                "אפר",
		                "מאי",
		                "יונ",
		                "יול",
		                "אוג",
		                "ספט",
		                "אוק",
		                "נוב",
		                "דצמ"
		            ],
		            "longDay":             [
		                "יום ראשון",
		                "יום שני",
		                "יום שלישי",
		                "יום רביעי",
		                "יום חמישי",
		                "יום שישי",
		                "יום שבת"
		            ],
		            "longMonth":             [
		                "ינואר",
		                "פברואר",
		                "מרס",
		                "אפריל",
		                "מאי",
		                "יוני",
		                "יולי",
		                "אוגוסט",
		                "ספטמבר",
		                "אוקטובר",
		                "נובמבר",
		                "דצמבר"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "לפנה\"צ",
		                "אחה\"צ"
		            ]
		        }
		    },
		    "he_IL":     {
		        "date": {},
		        "time": {}
		    },
		    "hi":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "ईसापूर्व",
		                "सन"
		            ],
		            "shortDay":             [
		                "रवि",
		                "सोम",
		                "मंगल",
		                "बुध",
		                "गुरु",
		                "शुक्र",
		                "शनि"
		            ],
		            "shortMonth":             [
		                "जनवरी",
		                "फरवरी",
		                "मार्च",
		                "अप्रैल",
		                "मई",
		                "जून",
		                "जुलाई",
		                "अगस्त",
		                "सितम्बर",
		                "अक्तूबर",
		                "नवम्बर",
		                "दिसम्बर"
		            ],
		            "longDay":             [
		                "रविवार",
		                "सोमवार",
		                "मंगलवार",
		                "बुधवार",
		                "गुरुवार",
		                "शुक्रवार",
		                "शनिवार"
		            ],
		            "longMonth":             [
		                "जनवरी",
		                "फरवरी",
		                "मार्च",
		                "अप्रैल",
		                "मई",
		                "जून",
		                "जुलाई",
		                "अगस्त",
		                "सितम्बर",
		                "अक्तूबर",
		                "नवम्बर",
		                "दिसम्बर"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "hi_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "hr":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "Prije Krista",
		                "Poslije Krista"
		            ],
		            "eraAbbr":             [
		                "pr.n.e.",
		                "AD"
		            ],
		            "shortDay":             [
		                "ned",
		                "pon",
		                "uto",
		                "sri",
		                "čet",
		                "pet",
		                "sub"
		            ],
		            "shortMonth":             [
		                "01.",
		                "02.",
		                "03.",
		                "04.",
		                "05.",
		                "06.",
		                "07.",
		                "08.",
		                "09.",
		                "10.",
		                "11.",
		                "12."
		            ],
		            "longDay":             [
		                "nedjelja",
		                "ponedjeljak",
		                "utorak",
		                "srijeda",
		                "četvrtak",
		                "petak",
		                "subota"
		            ],
		            "longMonth":             [
		                "siječnja",
		                "veljače",
		                "ožujka",
		                "travnja",
		                "svibnja",
		                "lipnja",
		                "srpnja",
		                "kolovoza",
		                "rujna",
		                "listopada",
		                "studenoga",
		                "prosinca"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "hr_HR":     {
		        "date": {},
		        "time": {}
		    },
		    "hu":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "időszámításunk előtt",
		                "időszámításunk szerint"
		            ],
		            "eraAbbr":             [
		                "i. e.",
		                "i. sz."
		            ],
		            "shortDay":             [
		                "V",
		                "H",
		                "K",
		                "Sze",
		                "Cs",
		                "P",
		                "Szo"
		            ],
		            "shortMonth":             [
		                "jan.",
		                "febr.",
		                "márc.",
		                "ápr.",
		                "máj.",
		                "jún.",
		                "júl.",
		                "aug.",
		                "szept.",
		                "okt.",
		                "nov.",
		                "dec."
		            ],
		            "longDay":             [
		                "vasárnap",
		                "hétfő",
		                "kedd",
		                "szerda",
		                "csütörtök",
		                "péntek",
		                "szombat"
		            ],
		            "longMonth":             [
		                "január",
		                "február",
		                "március",
		                "április",
		                "május",
		                "június",
		                "július",
		                "augusztus",
		                "szeptember",
		                "október",
		                "november",
		                "december"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "de.",
		                "du."
		            ]
		        }
		    },
		    "hu_HU":     {
		        "date": {},
		        "time": {}
		    },
		    "hy":     {
		        "date":         {
		            "dateSeparator": "/",
		            "eraAbbr":             [
		                "Ք․Ա․",
		                "Ք․Ե․"
		            ],
		            "shortDay":             [
		                "Կիր",
		                "Երկ",
		                "Երք",
		                "Չոր",
		                "Հնգ",
		                "Ուր",
		                "Շաբ"
		            ],
		            "shortMonth":             [
		                "Յնր",
		                "Փտր",
		                "Մրտ",
		                "Ապր",
		                "Մյս",
		                "Յնս",
		                "Յլս",
		                "Օգս",
		                "Սեպ",
		                "Հոկ",
		                "Նոյ",
		                "Դեկ"
		            ],
		            "longDay":             [
		                "Կիրակի",
		                "Երկուշաբթի",
		                "Երեքշաբթի",
		                "Չորեքշաբթի",
		                "Հինգշաբթի",
		                "Ուրբաթ",
		                "Շաբաթ"
		            ],
		            "longMonth":             [
		                "Յունուար",
		                "Փետրուար",
		                "Մարտ",
		                "Ապրիլ",
		                "Մայիս",
		                "Յունիս",
		                "Յուլիս",
		                "Օգոստոս",
		                "Սեպտեմբեր",
		                "Հոկտեմբեր",
		                "Նոյեմբեր",
		                "Դեկտեմբեր"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "Առ․",
		                "Եր․"
		            ]
		        }
		    },
		    "hy_AM":     {
		        "date": {},
		        "time": {}
		    },
		    "id":     {
		        "date":         {
		            "dateSeparator": "/",
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "Min",
		                "Sen",
		                "Sel",
		                "Rab",
		                "Kam",
		                "Jum",
		                "Sab"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Feb",
		                "Mar",
		                "Apr",
		                "Mei",
		                "Jun",
		                "Jul",
		                "Agu",
		                "Sep",
		                "Okt",
		                "Nov",
		                "Des"
		            ],
		            "longDay":             [
		                "Minggu",
		                "Senin",
		                "Selasa",
		                "Rabu",
		                "Kamis",
		                "Jumat",
		                "Sabtu"
		            ],
		            "longMonth":             [
		                "Januari",
		                "Februari",
		                "Maret",
		                "April",
		                "Mei",
		                "Juni",
		                "Juli",
		                "Agustus",
		                "September",
		                "Oktober",
		                "November",
		                "Desember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "id_ID":     {
		        "date": {},
		        "time": {}
		    },
		    "is":     {
		        "date":         {
		            "dateSeparator": ".",
		            "eraAbbr":             [
		                "fyrir Krist",
		                "eftir Krist",
		            ],
		            "eraNarrow":             [
		                "f.k.",
		                "e.k."
		            ],
		            "shortDay":             [
		                "sun",
		                "mán",
		                "þri",
		                "mið",
		                "fim",
		                "fös",
		                "lau"
		            ],
		            "shortMonth":             [
		                "jan",
		                "feb",
		                "mar",
		                "apr",
		                "maí",
		                "jún",
		                "júl",
		                "ágú",
		                "sep",
		                "okt",
		                "nóv",
		                "des"
		            ],
		            "longDay":             [
		                "sunnudagur",
		                "mánudagur",
		                "þriðjudagur",
		                "miðvikudagur",
		                "fimmtudagur",
		                "föstudagur",
		                "laugardagur"
		            ],
		            "longMonth":             [
		                "janúar",
		                "febrúar",
		                "mars",
		                "apríl",
		                "maí",
		                "júní",
		                "júlí",
		                "ágúst",
		                "september",
		                "október",
		                "nóvember",
		                "desember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "f.h.",
		                "e.h."
		            ]
		        }
		    },
		    "is_IS":     {
		        "date": {},
		        "time": {}
		    },
		    "it":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "a.C.",
		                "d.C"
		            ],
		            "eraAbbr":             [
		                "aC",
		                "dC"
		            ],
		            "shortDay":             [
		                "dom",
		                "lun",
		                "mar",
		                "mer",
		                "gio",
		                "ven",
		                "sab"
		            ],
		            "shortMonth":             [
		                "gen",
		                "feb",
		                "mar",
		                "apr",
		                "mag",
		                "giu",
		                "lug",
		                "ago",
		                "set",
		                "ott",
		                "nov",
		                "dic"
		            ],
		            "longDay":             [
		                "domenica",
		                "lunedì",
		                "martedì",
		                "mercoledì",
		                "giovedì",
		                "venerdì",
		                "sabato"
		            ],
		            "longMonth":             [
		                "gennaio",
		                "febbraio",
		                "marzo",
		                "aprile",
		                "maggio",
		                "giugno",
		                "luglio",
		                "agosto",
		                "settembre",
		                "ottobre",
		                "novembre",
		                "dicembre"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "m.",
		                "p."
		            ]
		        }
		    },
		    "it_CH":     {
		        "date": {"dateSeparator": "."},
		        "time": {}
		    },
		    "it_IT":     {
		        "date": {},
		        "time": {}
		    },
		    "ja":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "紀元前",
		                "西暦"
		            ],
		            "eraAbbr":             [
		                "紀元前",
		                "西暦"
		            ],
		            "shortDay":             [
		                "日",
		                "月",
		                "火",
		                "水",
		                "木",
		                "金",
		                "土"
		            ],
		            "shortMonth":             [
		                "1月",
		                "2月",
		                "3月",
		                "4月",
		                "5月",
		                "6月",
		                "7月",
		                "8月",
		                "9月",
		                "10月",
		                "11月",
		                "12月"
		            ],
		            "longDay":             [
		                "日曜日",
		                "月曜日",
		                "火曜日",
		                "水曜日",
		                "木曜日",
		                "金曜日",
		                "土曜日"
		            ],
		            "longMonth":             [
		                "1月",
		                "2月",
		                "3月",
		                "4月",
		                "5月",
		                "6月",
		                "7月",
		                "8月",
		                "9月",
		                "10月",
		                "11月",
		                "12月"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "午前",
		                "午後"
		            ]
		        }
		    },
		    "ja_JP":     {
		        "date": {},
		        "time": {}
		    },
		    "ka":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "ჩვენს წელთაღრიცხვამდე",
		                "ჩვენი წელთაღრიცხვით"
		            ],
		            "eraAbbr":             [
		                "ჩვენს წელთაღრიცხვამდე",
		                "ჩვენი წელთაღრიცხვით"
		            ],
		            "eraNarrow":             [
		                "ჩვენს წელთაღრიცხვამდე",
		                "ჩვენი წელთაღრიცხვით"
		            ],
		            "shortDay":             [
		                "კვი",
		                "ორშ",
		                "სამ",
		                "ოთხ",
		                "ხუთ",
		                "პარ",
		                "შაბ"
		            ],
		            "shortMonth":             [
		                "იან",
		                "თებ",
		                "მარ",
		                "აპრ",
		                "მაი",
		                "ივნ",
		                "ივლ",
		                "აგვ",
		                "სექ",
		                "ოქტ",
		                "ნოე",
		                "დეკ"
		            ],
		            "longDay":             [
		                "კვირა",
		                "ორშაბათი",
		                "სამშაბათი",
		                "ოთხშაბათი",
		                "ხუთშაბათი",
		                "პარასკევი",
		                "შაბათი"
		            ],
		            "longMonth":             [
		                "იანვარი",
		                "თებერვალი",
		                "მარტი",
		                "აპრილი",
		                "მაისი",
		                "ივნისი",
		                "ივლისი",
		                "აგვისტო",
		                "სექტემბერი",
		                "ოქტომბერი",
		                "ნოემბერი",
		                "დეკემბერი"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "დილის",
		                "საღამოს"
		            ]
		        }
		    },
		    "ka_GE":     {
		        "date": {},
		        "time": {}
		    },
		    "kk":     {
		        "date":         {
		            "dateSeparator": ".",
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "жс.",
		                "дс.",
		                "сс.",
		                "ср.",
		                "бс.",
		                "жм.",
		                "сһ."
		            ],
		            "shortMonth":             [
		                "қаң.",
		                "ақп.",
		                "нау.",
		                "сәу.",
		                "мам.",
		                "мау.",
		                "шіл.",
		                "там.",
		                "қыр.",
		                "қаз.",
		                "қар.",
		                "желт."
		            ],
		            "longDay":             [
		                "жексені",
		                "дуйсенбі",
		                "сейсенбі",
		                "сәренбі",
		                "бейсенбі",
		                "жұма",
		                "сенбі"
		            ],
		            "longMonth":             [
		                "қаңтар",
		                "ақпан",
		                "наурыз",
		                "сәуір",
		                "мамыр",
		                "маусым",
		                "шілде",
		                "тамыз",
		                "қыркүйек",
		                "қазан",
		                "қараша",
		                "желтоқсан"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "kk_KZ":     {
		        "date": {},
		        "time": {}
		    },
		    "kn":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "ಈಸಪೂವ೯.",
		                "ಕ್ರಿಸ್ತ ಶಕ"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "ರ.",
		                "ಸೋ.",
		                "ಮಂ.",
		                "ಬು.",
		                "ಗು.",
		                "ಶು.",
		                "ಶನಿ."
		            ],
		            "shortMonth":             [
		                "ಜನವರೀ",
		                "ಫೆಬ್ರವರೀ",
		                "ಮಾರ್ಚ್",
		                "ಎಪ್ರಿಲ್",
		                "ಮೆ",
		                "ಜೂನ್",
		                "ಜುಲೈ",
		                "ಆಗಸ್ಟ್",
		                "ಸಪ್ಟೆಂಬರ್",
		                "ಅಕ್ಟೋಬರ್",
		                "ನವೆಂಬರ್",
		                "ಡಿಸೆಂಬರ್"
		            ],
		            "longDay":             [
		                "ರವಿವಾರ",
		                "ಸೋಮವಾರ",
		                "ಮಂಗಳವಾರ",
		                "ಬುಧವಾರ",
		                "ಗುರುವಾರ",
		                "ಶುಕ್ರವಾರ",
		                "ಶನಿವಾರ"
		            ],
		            "longMonth":             [
		                "ಜನವರೀ",
		                "ಫೆಬ್ರವರೀ",
		                "ಮಾರ್ಚ್",
		                "ಎಪ್ರಿಲ್",
		                "ಮೆ",
		                "ಜೂನ್",
		                "ಜುಲೈ",
		                "ಆಗಸ್ಟ್",
		                "ಸಪ್ಟೆಂಬರ್",
		                "ಅಕ್ಟೋಬರ್",
		                "ನವೆಂಬರ್",
		                "ಡಿಸೆಂಬರ್"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "am",
		                "pm"
		            ]
		        }
		    },
		    "kn_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "ko":     {
		        "date":         {
		            "dateSeparator": ". ",
		            "era":             [
		                "서력기원전",
		                "서력기원"
		            ],
		            "eraAbbr":             [
		                "기원전",
		                "서기"
		            ],
		            "shortDay":             [
		                "일",
		                "월",
		                "화",
		                "수",
		                "목",
		                "금",
		                "토"
		            ],
		            "shortMonth":             [
		                "1월",
		                "2월",
		                "3월",
		                "4월",
		                "5월",
		                "6월",
		                "7월",
		                "8월",
		                "9월",
		                "10월",
		                "11월",
		                "12월"
		            ],
		            "longDay":             [
		                "일요일",
		                "월요일",
		                "화요일",
		                "수요일",
		                "목요일",
		                "금요일",
		                "토요일"
		            ],
		            "longMonth":             [
		                "1월",
		                "2월",
		                "3월",
		                "4월",
		                "5월",
		                "6월",
		                "7월",
		                "8월",
		                "9월",
		                "10월",
		                "11월",
		                "12월"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "오전",
		                "오후"
		            ]
		        }
		    },
		    "ko_KR":     {
		        "date": {},
		        "time": {}
		    },
		    "kok":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "क्रिस्तपूर्व",
		                "क्रिस्तशखा"
		            ],
		            "shortDay":             [
		                "रवि",
		                "सोम",
		                "मंगळ",
		                "बुध",
		                "गुरु",
		                "शुक्र",
		                "शनि"
		            ],
		            "shortMonth":             [
		                "जानेवारी",
		                "फेबृवारी",
		                "मार्च",
		                "एप्रिल",
		                "मे",
		                "जून",
		                "जुलै",
		                "ओगस्ट",
		                "सेप्टेंबर",
		                "ओक्टोबर",
		                "नोव्हेंबर",
		                "डिसेंबर"
		            ],
		            "longDay":             [
		                "आदित्यवार",
		                "सोमवार",
		                "मंगळार",
		                "बुधवार",
		                "गुरुवार",
		                "शुक्रवार",
		                "शनिवार"
		            ],
		            "longMonth":             [
		                "जानेवारी",
		                "फेब्रुवारी",
		                "मार्च",
		                "एप्रिल",
		                "मे",
		                "जून",
		                "जुलै",
		                "ओगस्ट",
		                "सेप्टेंबर",
		                "ओक्टोबर",
		                "नोव्हेंबर",
		                "डिसेंबर"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "म.पू.",
		                "म.नं."
		            ]
		        }
		    },
		    "kok_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "lt":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "prieš Kristų",
		                "po Kristaus"
		            ],
		            "eraAbbr":             [
		                "pr. Kr.",
		                "po Kr."
		            ],
		            "shortDay":             [
		                "Sk",
		                "Pr",
		                "An",
		                "Tr",
		                "Kt",
		                "Pn",
		                "Št"
		            ],
		            "shortMonth":             [
		                "Sau",
		                "Vas",
		                "Kov",
		                "Bal",
		                "Geg",
		                "Bir",
		                "Lie",
		                "Rgp",
		                "Rgs",
		                "Spl",
		                "Lap",
		                "Grd"
		            ],
		            "longDay":             [
		                "sekmadienis",
		                "pirmadienis",
		                "antradienis",
		                "trečiadienis",
		                "ketvirtadienis",
		                "penktadienis",
		                "šeštadienis"
		            ],
		            "longMonth":             [
		                "sausio",
		                "vasario",
		                "kovo",
		                "balandžio",
		                "gegužės",
		                "birželio",
		                "liepos",
		                "rugpjūčio",
		                "rugsėjo",
		                "spalio",
		                "lapkričio",
		                "gruodžio"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "priešpiet",
		                "popiet"
		            ]
		        }
		    },
		    "lt_LT":     {
		        "date": {},
		        "time": {}
		    },
		    "lv":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "pirms mūsu ēras",
		                "mūsu ērā"
		            ],
		            "eraAbbr":             [
		                "p.m.ē.",
		                "m.ē."
		            ],
		            "eraNarrow":             [
		                "p.m.ē.",
		                "m.ē."
		            ],
		            "shortDay":             [
		                "Sv",
		                "Pr",
		                "Ot",
		                "Tr",
		                "Ce",
		                "Pk",
		                "Se"
		            ],
		            "shortMonth":             [
		                "janv.",
		                "febr.",
		                "marts",
		                "apr.",
		                "maijs",
		                "jūn.",
		                "jūl.",
		                "aug.",
		                "sept.",
		                "okt.",
		                "nov.",
		                "dec."
		            ],
		            "longDay":             [
		                "svētdiena",
		                "pirmdiena",
		                "otrdiena",
		                "trešdiena",
		                "ceturtdiena",
		                "piektdiena",
		                "sestdiena"
		            ],
		            "longMonth":             [
		                "janvāris",
		                "februāris",
		                "marts",
		                "aprīlis",
		                "maijs",
		                "jūnijs",
		                "jūlijs",
		                "augusts",
		                "septembris",
		                "oktobris",
		                "novembris",
		                "decembris"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "lv_LV":     {
		        "date": {},
		        "time": {}
		    },
		    "mk":     {
		        "date":         {
		            "dateSeparator": ".",
		            "eraAbbr":             [
		                "пр.н.е.",
		                "ае."
		            ],
		            "shortDay":             [
		                "нед.",
		                "пон.",
		                "вт.",
		                "сре.",
		                "чет.",
		                "пет.",
		                "саб."
		            ],
		            "shortMonth":             [
		                "јан.",
		                "фев.",
		                "мар.",
		                "апр.",
		                "мај",
		                "јун.",
		                "јул.",
		                "авг.",
		                "септ.",
		                "окт.",
		                "ноем.",
		                "декем."
		            ],
		            "longDay":             [
		                "недела",
		                "понеделник",
		                "вторник",
		                "среда",
		                "четврток",
		                "петок",
		                "сабота"
		            ],
		            "longMonth":             [
		                "јануари",
		                "февруари",
		                "март",
		                "април",
		                "мај",
		                "јуни",
		                "јули",
		                "август",
		                "септември",
		                "октомври",
		                "ноември",
		                "декември"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "претпладне",
		                "попладне"
		            ]
		        }
		    },
		    "mk_MK":     {
		        "date": {},
		        "time": {}
		    },
		    "ml":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "ക്രിസ്തുവിനു് മുമ്പ്‌",
		                "ക്രിസ്തുവിന് പിന്‍പ്"
		            ],
		            "eraAbbr":             [
		                "ക്രി.മു.",
		                "ക്രി.പി."
		            ],
		            "eraNarrow":             [
		                "ക്രി.മു.",
		                "ക്രി.പി."
		            ],
		            "shortDay":             [
		                "ഞായര്‍",
		                "തിങ്കള്‍",
		                "ചൊവ്വ",
		                "ബുധന്‍",
		                "വ്യാഴം",
		                "വെള്ളി",
		                "ശനി"
		            ],
		            "shortMonth":             [
		                "ജനു",
		                "ഫെബ്രു",
		                "മാര്‍",
		                "ഏപ്രി",
		                "മേയ്",
		                "ജൂണ്‍",
		                "ജൂലൈ",
		                "ഓഗ",
		                "സെപ്റ്റം",
		                "ഒക്ടോ",
		                "നവം",
		                "ഡിസം"
		            ],
		            "longDay":             [
		                "ഞായറാഴ്ച",
		                "തിങ്കളാഴ്ച",
		                "ചൊവ്വാഴ്ച",
		                "ബുധനാഴ്ച",
		                "വ്യാഴാഴ്ച",
		                "വെള്ളിയാഴ്ച",
		                "ശനിയാഴ്ച"
		            ],
		            "longMonth":             [
		                "ജനുവരി",
		                "ഫെബ്രുവരി",
		                "മാര്‍ച്ച്",
		                "ഏപ്രില്‍",
		                "മേയ്",
		                "ജൂണ്‍",
		                "ജൂലൈ",
		                "ഓഗസ്റ്റ്",
		                "സെപ്റ്റംബര്‍",
		                "ഒക്ടോബര്‍",
		                "നവംബര്‍",
		                "ഡിസംബര്‍"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "am",
		                "pm"
		            ]
		        }
		    },
		    "ml_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "mn":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "манай эриний өмнөх",
		                "манай эриний"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "shortMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ],
		            "longDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "longMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "mn_MN":     {
		        "date": {},
		        "time": {}
		    },
		    "mr":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "ईसवीसनपूर्व",
		                "ईसवीसन"
		            ],
		            "eraAbbr":             [
		                "ई.स.पू.",
		                "ई.स."
		            ],
		            "shortDay":             [
		                "रवि",
		                "सोम",
		                "मंगळ",
		                "बुध",
		                "गुरु",
		                "शुक्र",
		                "शनि"
		            ],
		            "shortMonth":             [
		                "जानेवारी",
		                "फेब्रुवारी",
		                "मार्च",
		                "एप्रिल",
		                "मे",
		                "जून",
		                "जुलै",
		                "ऑगस्ट",
		                "सप्टेंबर",
		                "ऑक्टोबर",
		                "नोव्हेंबर",
		                "डिसेंबर"
		            ],
		            "longDay":             [
		                "रविवार",
		                "सोमवार",
		                "मंगळवार",
		                "बुधवार",
		                "गुरुवार",
		                "शुक्रवार",
		                "शनिवार"
		            ],
		            "longMonth":             [
		                "जानेवारी",
		                "फेब्रुवारी",
		                "मार्च",
		                "एप्रिल",
		                "मे",
		                "जून",
		                "जुलै",
		                "ऑगस्ट",
		                "सप्टेंबर",
		                "ऑक्टोबर",
		                "नोव्हेंबर",
		                "डिसेंबर"
		            ]
		        },
		        "time":         {
		            "timeSeparator": "-",
		            "amPm":             [
		                "am",
		                "pm"
		            ]
		        }
		    },
		    "mr_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "ms":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "Ahd",
		                "Isn",
		                "Sel",
		                "Rab",
		                "Kha",
		                "Jum",
		                "Sab"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Feb",
		                "Mac",
		                "Apr",
		                "Mei",
		                "Jun",
		                "Jul",
		                "Ogos",
		                "Sep",
		                "Okt",
		                "Nov",
		                "Dis"
		            ],
		            "longDay":             [
		                "Ahad",
		                "Isnin",
		                "Selasa",
		                "Rabu",
		                "Khamis",
		                "Jumaat",
		                "Sabtu"
		            ],
		            "longMonth":             [
		                "Januari",
		                "Februari",
		                "Mac",
		                "April",
		                "Mei",
		                "Jun",
		                "Julai",
		                "Ogos",
		                "September",
		                "Oktober",
		                "November",
		                "Disember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "ms_BN":     {
		        "date": {},
		        "time": {"timeSeparator": ":"}
		    },
		    "ms_MY":     {
		        "date": {},
		        "time": {}
		    },
		    "mt":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "Qabel Kristu",
		                "Wara Kristu"
		            ],
		            "eraAbbr":             [
		                "QK",
		                "WK"
		            ],
		            "shortDay":             [
		                "Ħad",
		                "Tne",
		                "Tli",
		                "Erb",
		                "Ħam",
		                "Ġim",
		                "Sib"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Fra",
		                "Mar",
		                "Apr",
		                "Mej",
		                "Ġun",
		                "Lul",
		                "Aww",
		                "Set",
		                "Ott",
		                "Nov",
		                "Diċ"
		            ],
		            "longDay":             [
		                "Il-Ħadd",
		                "It-Tnejn",
		                "It-Tlieta",
		                "L-Erbgħa",
		                "Il-Ħamis",
		                "Il-Ġimgħa",
		                "Is-Sibt"
		            ],
		            "longMonth":             [
		                "Jannar",
		                "Frar",
		                "Marzu",
		                "April",
		                "Mejju",
		                "Ġunju",
		                "Lulju",
		                "Awwissu",
		                "Settembru",
		                "Ottubru",
		                "Novembru",
		                "Diċembru"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "QN",
		                "WN"
		            ]
		        }
		    },
		    "mt_MT":     {
		        "date": {},
		        "time": {}
		    },
		    "nb":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "eraAbbr":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "shortDay":             [
		                "søn.",
		                "man.",
		                "tir.",
		                "ons.",
		                "tor.",
		                "fre.",
		                "lør."
		            ],
		            "shortMonth":             [
		                "jan.",
		                "feb.",
		                "mars",
		                "apr.",
		                "mai",
		                "juni",
		                "juli",
		                "aug.",
		                "sep.",
		                "okt.",
		                "nov.",
		                "des."
		            ],
		            "longDay":             [
		                "søndag",
		                "mandag",
		                "tirsdag",
		                "onsdag",
		                "torsdag",
		                "fredag",
		                "lørdag"
		            ],
		            "longMonth":             [
		                "januar",
		                "februar",
		                "mars",
		                "april",
		                "mai",
		                "juni",
		                "juli",
		                "august",
		                "september",
		                "oktober",
		                "november",
		                "desember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "nb_NO":     {
		        "date": {},
		        "time": {}
		    },
		    "nl":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "Voor Christus",
		                "Anno Domini"
		            ],
		            "eraAbbr":             [
		                "v. Chr.",
		                "n. Chr."
		            ],
		            "shortDay":             [
		                "zo",
		                "ma",
		                "di",
		                "wo",
		                "do",
		                "vr",
		                "za"
		            ],
		            "shortMonth":             [
		                "jan.",
		                "feb.",
		                "mrt.",
		                "apr.",
		                "mei",
		                "jun.",
		                "jul.",
		                "aug.",
		                "sep.",
		                "okt.",
		                "nov.",
		                "dec."
		            ],
		            "longDay":             [
		                "zondag",
		                "maandag",
		                "dinsdag",
		                "woensdag",
		                "donderdag",
		                "vrijdag",
		                "zaterdag"
		            ],
		            "longMonth":             [
		                "januari",
		                "februari",
		                "maart",
		                "april",
		                "mei",
		                "juni",
		                "juli",
		                "augustus",
		                "september",
		                "oktober",
		                "november",
		                "december"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "nl_BE":     {
		        "date": {"dateSeparator": "/"},
		        "time": {}
		    },
		    "nl_NL":     {
		        "date": {},
		        "time": {}
		    },
		    "nn":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "eraAbbr":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "shortDay":             [
		                "sø.",
		                "må.",
		                "ty.",
		                "on.",
		                "to.",
		                "fr.",
		                "la."
		            ],
		            "shortMonth":             [
		                "jan",
		                "feb",
		                "mar",
		                "apr",
		                "mai",
		                "jun",
		                "jul",
		                "aug",
		                "sep",
		                "okt",
		                "nov",
		                "des"
		            ],
		            "longDay":             [
		                "søndag",
		                "måndag",
		                "tysdag",
		                "onsdag",
		                "torsdag",
		                "fredag",
		                "laurdag"
		            ],
		            "longMonth":             [
		                "januar",
		                "februar",
		                "mars",
		                "april",
		                "mai",
		                "juni",
		                "juli",
		                "august",
		                "september",
		                "oktober",
		                "november",
		                "desember"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "formiddag",
		                "ettermiddag"
		            ]
		        }
		    },
		    "nn_NO":     {
		        "date": {},
		        "time": {}
		    },
		    "pa":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "ਈਸਾਪੂਰਵ",
		                "ਸੰਨ"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "ਐਤ.",
		                "ਸੋਮ.",
		                "ਮੰਗਲ.",
		                "ਬੁਧ.",
		                "ਵੀਰ.",
		                "ਸ਼ੁਕਰ.",
		                "ਸ਼ਨੀ."
		            ],
		            "shortMonth":             [
		                "ਜਨਵਰੀ",
		                "ਫ਼ਰਵਰੀ",
		                "ਮਾਰਚ",
		                "ਅਪ੍ਰੈਲ",
		                "ਮਈ",
		                "ਜੂਨ",
		                "ਜੁਲਾਈ",
		                "ਅਗਸਤ",
		                "ਸਤੰਬਰ",
		                "ਅਕਤੂਬਰ",
		                "ਨਵੰਬਰ",
		                "ਦਸੰਬਰ"
		            ],
		            "longDay":             [
		                "ਐਤਵਾਰ",
		                "ਸੋਮਵਾਰ",
		                "ਮੰਗਲਵਾਰ",
		                "ਬੁਧਵਾਰ",
		                "ਵੀਰਵਾਰ",
		                "ਸ਼ੁੱਕਰਵਾਰ",
		                "ਸ਼ਨੀਚਰਵਾਰ"
		            ],
		            "longMonth":             [
		                "ਜਨਵਰੀ",
		                "ਫ਼ਰਵਰੀ",
		                "ਮਾਰਚ",
		                "ਅਪ੍ਰੈਲ",
		                "ਮਈ",
		                "ਜੂਨ",
		                "ਜੁਲਾਈ",
		                "ਅਗਸਤ",
		                "ਸਤੰਬਰ",
		                "ਅਕਤੂਬਰ",
		                "ਨਵੰਬਰ",
		                "ਦਸੰਬਰ"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "ਸਵੇਰੇ",
		                "ਸ਼ਾਮ"
		            ]
		        }
		    },
		    "pa_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "pl":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "p.n.e.",
		                "n.e."
		            ],
		            "eraAbbr":             [
		                "p.n.e.",
		                "n.e."
		            ],
		            "shortDay":             [
		                "niedz.",
		                "pon.",
		                "wt.",
		                "śr.",
		                "czw.",
		                "pt.",
		                "sob."
		            ],
		            "shortMonth":             [
		                "sty",
		                "lut",
		                "mar",
		                "kwi",
		                "maj",
		                "cze",
		                "lip",
		                "sie",
		                "wrz",
		                "paź",
		                "lis",
		                "gru"
		            ],
		            "longDay":             [
		                "niedziela",
		                "poniedziałek",
		                "wtorek",
		                "środa",
		                "czwartek",
		                "piątek",
		                "sobota"
		            ],
		            "longMonth":             [
		                "stycznia",
		                "lutego",
		                "marca",
		                "kwietnia",
		                "maja",
		                "czerwca",
		                "lipca",
		                "sierpnia",
		                "września",
		                "października",
		                "listopada",
		                "grudnia"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "pl_PL":     {
		        "date": {},
		        "time": {}
		    },
		    "pt":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "Antes de Cristo",
		                "Ano do Senhor"
		            ],
		            "eraAbbr":             [
		                "a.C.",
		                "d.C."
		            ],
		            "shortDay":             [
		                "dom",
		                "seg",
		                "ter",
		                "qua",
		                "qui",
		                "sex",
		                "sáb"
		            ],
		            "shortMonth":             [
		                "jan",
		                "fev",
		                "mar",
		                "abr",
		                "mai",
		                "jun",
		                "jul",
		                "ago",
		                "set",
		                "out",
		                "nov",
		                "dez"
		            ],
		            "longDay":             [
		                "domingo",
		                "segunda-feira",
		                "terça-feira",
		                "quarta-feira",
		                "quinta-feira",
		                "sexta-feira",
		                "sábado"
		            ],
		            "longMonth":             [
		                "janeiro",
		                "fevereiro",
		                "março",
		                "abril",
		                "maio",
		                "junho",
		                "julho",
		                "agosto",
		                "setembro",
		                "outubro",
		                "novembro",
		                "dezembro"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "pt_BR":     {
		        "date": {},
		        "time": {}
		    },
		    "pt_PT":     {
		        "date":         {
		            "shortMonth":             [
		                "Jan",
		                "Fev",
		                "Mar",
		                "Abr",
		                "Mai",
		                "Jun",
		                "Jul",
		                "Ago",
		                "Set",
		                "Out",
		                "Nov",
		                "Dez"
		            ],
		            "longMonth":             [
		                "Janeiro",
		                "Fevereiro",
		                "Março",
		                "Abril",
		                "Maio",
		                "Junho",
		                "Julho",
		                "Agosto",
		                "Setembro",
		                "Outubro",
		                "Novembro",
		                "Dezembro"
		            ]
		        },
		        "time": {"amPm":         [
		            "Antes do meio-dia",
		            "Depois do meio-dia"
		        ]}
		    },
		    "ro":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "înainte de Hristos",
		                "după Hristos"
		            ],
		            "eraAbbr":             [
		                "î.Hr.",
		                "d.Hr."
		            ],
		            "shortDay":             [
		                "Du",
		                "Lu",
		                "Ma",
		                "Mi",
		                "Jo",
		                "Vi",
		                "Sâ"
		            ],
		            "shortMonth":             [
		                "ian.",
		                "feb.",
		                "mar.",
		                "apr.",
		                "mai",
		                "iun.",
		                "iul.",
		                "aug.",
		                "sept.",
		                "oct.",
		                "nov.",
		                "dec."
		            ],
		            "longDay":             [
		                "duminică",
		                "luni",
		                "marți",
		                "miercuri",
		                "joi",
		                "vineri",
		                "sâmbătă"
		            ],
		            "longMonth":             [
		                "ianuarie",
		                "februarie",
		                "martie",
		                "aprilie",
		                "mai",
		                "iunie",
		                "iulie",
		                "august",
		                "septembrie",
		                "octombrie",
		                "noiembrie",
		                "decembrie"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "ro_RO":     {
		        "date": {},
		        "time": {}
		    },
		    "ru":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "до н.э.",
		                "н.э."
		            ],
		            "eraAbbr":             [
		                "до н.э.",
		                "н.э."
		            ],
		            "shortDay":             [
		                "Вс",
		                "Пн",
		                "Вт",
		                "Ср",
		                "Чт",
		                "Пт",
		                "Сб"
		            ],
		            "shortMonth":             [
		                "янв.",
		                "февр.",
		                "марта",
		                "апр.",
		                "мая",
		                "июня",
		                "июля",
		                "авг.",
		                "сент.",
		                "окт.",
		                "нояб.",
		                "дек."
		            ],
		            "longDay":             [
		                "воскресенье",
		                "понедельник",
		                "вторник",
		                "среда",
		                "четверг",
		                "пятница",
		                "суббота"
		            ],
		            "longMonth":             [
		                "января",
		                "февраля",
		                "марта",
		                "апреля",
		                "мая",
		                "июня",
		                "июля",
		                "августа",
		                "сентября",
		                "октября",
		                "ноября",
		                "декабря"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "ru_RU":     {
		        "date": {},
		        "time": {}
		    },
		    "se":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "ovdal Kristtusa",
		                "maŋŋel Kristtusa"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "eraNarrow":             [
		                "o.Kr.",
		                "m.Kr."
		            ],
		            "shortDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "shortMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ],
		            "longDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "longMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "se_NO":     {
		        "date": {},
		        "time": {}
		    },
		    "sk":     {
		        "date":         {
		            "dateSeparator": ".",
		            "eraAbbr":             [
		                "pred n.l.",
		                "n.l."
		            ],
		            "shortDay":             [
		                "ne",
		                "po",
		                "ut",
		                "st",
		                "št",
		                "pi",
		                "so"
		            ],
		            "shortMonth":             [
		                "jan",
		                "feb",
		                "mar",
		                "apr",
		                "máj",
		                "jún",
		                "júl",
		                "aug",
		                "sep",
		                "okt",
		                "nov",
		                "dec"
		            ],
		            "longDay":             [
		                "nedeľa",
		                "pondelok",
		                "utorok",
		                "streda",
		                "štvrtok",
		                "piatok",
		                "sobota"
		            ],
		            "longMonth":             [
		                "januára",
		                "februára",
		                "marca",
		                "apríla",
		                "mája",
		                "júna",
		                "júla",
		                "augusta",
		                "septembra",
		                "októbra",
		                "novembra",
		                "decembra"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "dopoludnia",
		                "popoludní"
		            ]
		        }
		    },
		    "sk_SK":     {
		        "date": {},
		        "time": {}
		    },
		    "sl":     {
		        "date":         {
		            "dateSeparator": ". ",
		            "era":             [
		                "pred našim štetjem",
		                "naše štetje"
		            ],
		            "eraAbbr":             [
		                "pr. n. št.",
		                "po Kr."
		            ],
		            "shortDay":             [
		                "ned",
		                "pon",
		                "tor",
		                "sre",
		                "čet",
		                "pet",
		                "sob"
		            ],
		            "shortMonth":             [
		                "jan",
		                "feb",
		                "mar",
		                "apr",
		                "maj",
		                "jun",
		                "jul",
		                "avg",
		                "sep",
		                "okt",
		                "nov",
		                "dec"
		            ],
		            "longDay":             [
		                "nedelja",
		                "ponedeljek",
		                "torek",
		                "sreda",
		                "četrtek",
		                "petek",
		                "sobota"
		            ],
		            "longMonth":             [
		                "januar",
		                "februar",
		                "marec",
		                "april",
		                "maj",
		                "junij",
		                "julij",
		                "avgust",
		                "september",
		                "oktober",
		                "november",
		                "december"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "dop.",
		                "pop."
		            ]
		        }
		    },
		    "sl_SI":     {
		        "date": {},
		        "time": {}
		    },
		    "sq":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "p.e.r.",
		                "n.e.r."
		            ],
		            "shortDay":             [
		                "Die",
		                "Hën",
		                "Mar",
		                "Mër",
		                "Enj",
		                "Pre",
		                "Sht"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Shk",
		                "Mar",
		                "Pri",
		                "Maj",
		                "Qer",
		                "Kor",
		                "Gsh",
		                "Sht",
		                "Tet",
		                "Nën",
		                "Dhj"
		            ],
		            "longDay":             [
		                "e diel",
		                "e hënë",
		                "e martë",
		                "e mërkurë",
		                "e enjte",
		                "e premte",
		                "e shtunë"
		            ],
		            "longMonth":             [
		                "janar",
		                "shkurt",
		                "mars",
		                "prill",
		                "maj",
		                "qershor",
		                "korrik",
		                "gusht",
		                "shtator",
		                "tetor",
		                "nëntor",
		                "dhjetor"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "PD",
		                "MD"
		            ]
		        }
		    },
		    "sq_AL":     {
		        "date": {},
		        "time": {}
		    },
		    "sr":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "Пре нове ере",
		                "Нове ере"
		            ],
		            "eraAbbr":             [
		                "п. н. е.",
		                "н. е"
		            ],
		            "eraNarrow":             [
		                "п.н.е.",
		                "н.е."
		            ],
		            "shortDay":             [
		                "нед",
		                "пон",
		                "уто",
		                "сре",
		                "чет",
		                "пет",
		                "суб"
		            ],
		            "shortMonth":             [
		                "јан",
		                "феб",
		                "мар",
		                "апр",
		                "мај",
		                "јун",
		                "јул",
		                "авг",
		                "сеп",
		                "окт",
		                "нов",
		                "дец"
		            ],
		            "longDay":             [
		                "недеља",
		                "понедељак",
		                "уторак",
		                "среда",
		                "четвртак",
		                "петак",
		                "субота"
		            ],
		            "longMonth":             [
		                "јануар",
		                "фебруар",
		                "март",
		                "април",
		                "мај",
		                "јун",
		                "јул",
		                "август",
		                "септембар",
		                "октобар",
		                "новембар",
		                "децембар"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "пре подне",
		                "поподне"
		            ]
		        }
		    },
		    "sr_BA":     {
		        "date": {},
		        "time": {}
		    },
		    "sr_CS":     {
		        "date": {},
		        "time": {}
		    },
		    "sv":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "före Kristus",
		                "efter Kristus"
		            ],
		            "eraAbbr":             [
		                "f.Kr.",
		                "e.Kr."
		            ],
		            "shortDay":             [
		                "sön",
		                "mån",
		                "tis",
		                "ons",
		                "tors",
		                "fre",
		                "lör"
		            ],
		            "shortMonth":             [
		                "jan",
		                "feb",
		                "mar",
		                "apr",
		                "maj",
		                "jun",
		                "jul",
		                "aug",
		                "sep",
		                "okt",
		                "nov",
		                "dec"
		            ],
		            "longDay":             [
		                "söndag",
		                "måndag",
		                "tisdag",
		                "onsdag",
		                "torsdag",
		                "fredag",
		                "lördag"
		            ],
		            "longMonth":             [
		                "januari",
		                "februari",
		                "mars",
		                "april",
		                "maj",
		                "juni",
		                "juli",
		                "augusti",
		                "september",
		                "oktober",
		                "november",
		                "december"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ".",
		            "amPm":             [
		                "fm",
		                "em"
		            ]
		        }
		    },
		    "sv_FI":     {
		        "date": {},
		        "time": {}
		    },
		    "sv_SE":     {
		        "date": {},
		        "time": {}
		    },
		    "sw":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "Kabla ya Kristo",
		                "Baada ya Kristo"
		            ],
		            "eraAbbr":             [
		                "KK",
		                "BK"
		            ],
		            "shortDay":             [
		                "Jpi",
		                "Jtt",
		                "Jnn",
		                "Jtn",
		                "Alh",
		                "Iju",
		                "Jmo"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Feb",
		                "Mac",
		                "Apr",
		                "Mei",
		                "Jun",
		                "Jul",
		                "Ago",
		                "Sep",
		                "Okt",
		                "Nov",
		                "Des"
		            ],
		            "longDay":             [
		                "Jumapili",
		                "Jumatatu",
		                "Jumanne",
		                "Jumatano",
		                "Alhamisi",
		                "Ijumaa",
		                "Jumamosi"
		            ],
		            "longMonth":             [
		                "Januari",
		                "Februari",
		                "Machi",
		                "Aprili",
		                "Mei",
		                "Juni",
		                "Julai",
		                "Agosti",
		                "Septemba",
		                "Oktoba",
		                "Novemba",
		                "Desemba"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "sw_KE":     {
		        "date": {},
		        "time": {}
		    },
		    "syr":     {
		        "date":         {
		            "dateSeparator": "-",
		            "shortDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "shortMonth":             [
		                "܏ܟܢ ܏ܒ",
		                "ܫܒܛ",
		                "ܐܕܪ",
		                "ܢܝܣܢ",
		                "ܐܝܪ",
		                "ܚܙܝܪܢ",
		                "ܬܡܘܙ",
		                "ܐܒ",
		                "ܐܝܠܘܠ",
		                "܏ܬܫ ܏ܐ",
		                "܏ܬܫ ܏ܒ",
		                "܏ܟܢ ܏ܐ"
		            ],
		            "longDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "longMonth":             [
		                "܏ܟܢ ܏ܒ",
		                "ܫܒܛ",
		                "ܐܕܪ",
		                "ܢܝܣܢ",
		                "ܐܝܪ",
		                "ܚܙܝܪܢ",
		                "ܬܡܘܙ",
		                "ܐܒ",
		                "ܐܝܠܘܠ",
		                "܏ܬܫ ܏ܐ",
		                "܏ܬܫ ܏ܒ",
		                "܏ܟܢ ܏ܐ"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "syr_SY":     {
		        "date": {},
		        "time": {}
		    },
		    "ta":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "கிறிஸ்துவுக்கு முன்",
		                "அனோ டோமினி"
		            ],
		            "eraAbbr":             [
		                "கிமு",
		                "கிபி"
		            ],
		            "shortDay":             [
		                "ஞா",
		                "தி",
		                "செ",
		                "பு",
		                "வி",
		                "வெ",
		                "ச"
		            ],
		            "shortMonth":             [
		                "ஜன.",
		                "பிப்.",
		                "மார்.",
		                "ஏப்.",
		                "மே",
		                "ஜூன்",
		                "ஜூலை",
		                "ஆக.",
		                "செப்.",
		                "அக்.",
		                "நவ.",
		                "டிச."
		            ],
		            "longDay":             [
		                "ஞாயிறு",
		                "திங்கள்",
		                "செவ்வாய்",
		                "புதன்",
		                "வியாழன்",
		                "வெள்ளி",
		                "சனி"
		            ],
		            "longMonth":             [
		                "ஜனவரி",
		                "பிப்ரவரி",
		                "மார்ச்",
		                "ஏப்ரல்",
		                "மே",
		                "ஜூன்",
		                "ஜூலை",
		                "ஆகஸ்ட்",
		                "செப்டம்பர்",
		                "அக்டோபர்",
		                "நவம்பர்",
		                "டிசம்பர்"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "am",
		                "pm"
		            ]
		        }
		    },
		    "ta_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "te":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "ఈసాపూర్వ.",
		                "సన్."
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "ఆది",
		                "సోమ",
		                "మంగళ",
		                "బుధ",
		                "గురు",
		                "శుక్ర",
		                "శని"
		            ],
		            "shortMonth":             [
		                "జనవరి",
		                "ఫిబ్రవరి",
		                "మార్చి",
		                "ఏప్రిల్",
		                "మే",
		                "జూన్",
		                "జూలై",
		                "ఆగస్టు",
		                "సెప్టెంబర్",
		                "అక్టోబర్",
		                "నవంబర్",
		                "డిసెంబర్"
		            ],
		            "longDay":             [
		                "ఆదివారం",
		                "సోమవారం",
		                "మంగళవారం",
		                "బుధవారం",
		                "గురువారం",
		                "శుక్రవారం",
		                "శనివారం"
		            ],
		            "longMonth":             [
		                "జనవరి",
		                "ఫిబ్రవరి",
		                "మార్చి",
		                "ఏప్రిల్",
		                "మే",
		                "జూన్",
		                "జూలై",
		                "ఆగస్టు",
		                "సెప్టెంబర్",
		                "అక్టోబర్",
		                "నవంబర్",
		                "డిసెంబర్"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "am",
		                "pm"
		            ]
		        }
		    },
		    "te_IN":     {
		        "date": {},
		        "time": {}
		    },
		    "th":     {
		        "date":         {
		            "dateSeparator": "/",
		            "era":             [
		                "ปีก่อนคริสต์ศักราช",
		                "คริสต์ศักราช"
		            ],
		            "eraAbbr":             [
		                "ปีก่อน ค.ศ.",
		                "ค.ศ."
		            ],
		            "eraNarrow": ["ก่อน ค.ศ."],
		            "shortDay":             [
		                "อา.",
		                "จ.",
		                "อ.",
		                "พ.",
		                "พฤ.",
		                "ศ.",
		                "ส."
		            ],
		            "shortMonth":             [
		                "ม.ค.",
		                "ก.พ.",
		                "มี.ค.",
		                "เม.ย.",
		                "พ.ค.",
		                "มิ.ย.",
		                "ก.ค.",
		                "ส.ค.",
		                "ก.ย.",
		                "ต.ค.",
		                "พ.ย.",
		                "ธ.ค."
		            ],
		            "longDay":             [
		                "วันอาทิตย์",
		                "วันจันทร์",
		                "วันอังคาร",
		                "วันพุธ",
		                "วันพฤหัสบดี",
		                "วันศุกร์",
		                "วันเสาร์"
		            ],
		            "longMonth":             [
		                "มกราคม",
		                "กุมภาพันธ์",
		                "มีนาคม",
		                "เมษายน",
		                "พฤษภาคม",
		                "มิถุนายน",
		                "กรกฎาคม",
		                "สิงหาคม",
		                "กันยายน",
		                "ตุลาคม",
		                "พฤศจิกายน",
		                "ธันวาคม"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "ก่อนเที่ยง",
		                "หลังเที่ยง"
		            ]
		        }
		    },
		    "th_TH":     {
		        "date": {},
		        "time": {}
		    },
		    "tn":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "BC",
		                "AD"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "shortMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ],
		            "longDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "longMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "tn_ZA":     {
		        "date": {},
		        "time": {}
		    },
		    "tr":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "Milattan Önce",
		                "Milattan Sonra"
		            ],
		            "eraAbbr":             [
		                "MÖ",
		                "MS"
		            ],
		            "shortDay":             [
		                "Paz",
		                "Pzt",
		                "Sal",
		                "Çar",
		                "Per",
		                "Cum",
		                "Cmt"
		            ],
		            "shortMonth":             [
		                "Oca",
		                "Şub",
		                "Mar",
		                "Nis",
		                "May",
		                "Haz",
		                "Tem",
		                "Ağu",
		                "Eyl",
		                "Eki",
		                "Kas",
		                "Ara"
		            ],
		            "longDay":             [
		                "Pazar",
		                "Pazartesi",
		                "Salı",
		                "Çarşamba",
		                "Perşembe",
		                "Cuma",
		                "Cumartesi"
		            ],
		            "longMonth":             [
		                "Ocak",
		                "Şubat",
		                "Mart",
		                "Nisan",
		                "Mayıs",
		                "Haziran",
		                "Temmuz",
		                "Ağustos",
		                "Eylül",
		                "Ekim",
		                "Kasım",
		                "Aralık"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "tr_TR":     {
		        "date": {},
		        "time": {}
		    },
		    "uk":     {
		        "date":         {
		            "dateSeparator": ".",
		            "era":             [
		                "до нашої ери",
		                "нашої ери"
		            ],
		            "eraAbbr":             [
		                "до н.е.",
		                "н.е."
		            ],
		            "shortDay":             [
		                "Нд",
		                "Пн",
		                "Вт",
		                "Ср",
		                "Чт",
		                "Пт",
		                "Сб"
		            ],
		            "shortMonth":             [
		                "січ.",
		                "лют.",
		                "бер.",
		                "квіт.",
		                "трав.",
		                "черв.",
		                "лип.",
		                "серп.",
		                "вер.",
		                "жовт.",
		                "лист.",
		                "груд."
		            ],
		            "longDay":             [
		                "Неділя",
		                "Понеділок",
		                "Вівторок",
		                "Середа",
		                "Четвер",
		                "Пʼятниця",
		                "Субота"
		            ],
		            "longMonth":             [
		                "січня",
		                "лютого",
		                "березня",
		                "квітня",
		                "травня",
		                "червня",
		                "липня",
		                "серпня",
		                "вересня",
		                "жовтня",
		                "листопада",
		                "грудня"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "дп",
		                "пп"
		            ]
		        }
		    },
		    "uk_UA":     {
		        "date": {},
		        "time": {}
		    },
		    "uz":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "shortMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ],
		            "longDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "longMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "uz_UZ":     {
		        "date": {},
		        "time": {}
		    },
		    "vi":     {
		        "date":         {
		            "dateSeparator": "/",
		            "eraAbbr":             [
		                "tr. CN",
		                "sau CN"
		            ],
		            "shortDay":             [
		                "CN",
		                "Th 2",
		                "Th 3",
		                "Th 4",
		                "Th 5",
		                "Th 6",
		                "Th 7"
		            ],
		            "shortMonth":             [
		                "thg 1",
		                "thg 2",
		                "thg 3",
		                "thg 4",
		                "thg 5",
		                "thg 6",
		                "thg 7",
		                "thg 8",
		                "thg 9",
		                "thg 10",
		                "thg 11",
		                "thg 12"
		            ],
		            "longDay":             [
		                "Chủ nhật",
		                "Thứ hai",
		                "Thứ ba",
		                "Thứ tư",
		                "Thứ năm",
		                "Thứ sáu",
		                "Thứ bảy"
		            ],
		            "longMonth":             [
		                "tháng một",
		                "tháng hai",
		                "tháng ba",
		                "tháng tư",
		                "tháng năm",
		                "tháng sáu",
		                "tháng bảy",
		                "tháng tám",
		                "tháng chín",
		                "tháng mười",
		                "tháng mười một",
		                "tháng mười hai"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "SA",
		                "CH"
		            ]
		        }
		    },
		    "vi_VN":     {
		        "date": {},
		        "time": {}
		    },
		    "xh":     {
		        "date":         {
		        	"dateSeparator": "-",
		            "era":             [
		                "BC",
		                "umnyaka wokuzalwa kukaYesu"
		            ],
		            "eraAbbr":             [
		                "BCE",
		                "CE"
		            ],
		            "shortDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "shortMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ],
		            "longDay":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7"
		            ],
		            "longMonth":             [
		                "1",
		                "2",
		                "3",
		                "4",
		                "5",
		                "6",
		                "7",
		                "8",
		                "9",
		                "10",
		                "11",
		                "12"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "xh_ZA":     {
		        "date": {},
		        "time": {}
		    },
		    "zh":     {
		        "date":         {
		            "dateSeparator": "-",
		            "era":             [
		                "公元前",
		                "公元"
		            ],
		            "eraAbbr":             [
		                "公元前",
		                "公元"
		            ],
		            "shortDay":             [
		                "周日",
		                "周一",
		                "周二",
		                "周三",
		                "周四",
		                "周五",
		                "周六"
		            ],
		            "shortMonth":             [
		                "1月",
		                "2月",
		                "3月",
		                "4月",
		                "5月",
		                "6月",
		                "7月",
		                "8月",
		                "9月",
		                "10月",
		                "11月",
		                "12月"
		            ],
		            "longDay":             [
		                "星期日",
		                "星期一",
		                "星期二",
		                "星期三",
		                "星期四",
		                "星期五",
		                "星期六"
		            ],
		            "longMonth":             [
		                "1月",
		                "2月",
		                "3月",
		                "4月",
		                "5月",
		                "6月",
		                "7月",
		                "8月",
		                "9月",
		                "10月",
		                "11月",
		                "12月"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "上午",
		                "下午"
		            ]
		        }
		    },
		    "zh_CN":     {
		        "date": {},
		        "time": {}
		    },
		    "zh_HK":     {
		        "date": {},
		        "time": {}
		    },
		    "zh_MO":     {
		        "date": {},
		        "time": {}
		    },
		    "zh_SG":     {
		        "date": {},
		        "time": {}
		    },
		    "zh_TW":     {
		        "date": {},
		        "time": {}
		    },
		    "zu":     {
		        "date":         {
		            "dateSeparator": "-",
		            "eraAbbr":             [
		                "BC",
		                "AD"
		            ],
		            "shortDay":             [
		                "Son",
		                "Mso",
		                "Bil",
		                "Tha",
		                "Sin",
		                "Hla",
		                "Mgq"
		            ],
		            "shortMonth":             [
		                "Jan",
		                "Feb",
		                "Mas",
		                "Apr",
		                "Mey",
		                "Jun",
		                "Jul",
		                "Aga",
		                "Sep",
		                "Okt",
		                "Nov",
		                "Dis"
		            ],
		            "longDay":             [
		                "Sonto",
		                "Msombuluko",
		                "Lwesibili",
		                "Lwesithathu",
		                "uLwesine",
		                "Lwesihlanu",
		                "Mgqibelo"
		            ],
		            "longMonth":             [
		                "Januwari",
		                "Februwari",
		                "Mashi",
		                "Apreli",
		                "Meyi",
		                "Juni",
		                "Julayi",
		                "Agasti",
		                "Septhemba",
		                "Okthoba",
		                "Novemba",
		                "Disemba"
		            ]
		        },
		        "time":         {
		            "timeSeparator": ":",
		            "amPm":             [
		                "AM",
		                "PM"
		            ]
		        }
		    },
		    "zu_ZA":     {
		        "date": {},
		        "time": {}
		    }
		}
		_g_n_g.formatExist = function (locale/*:String*/, type/*:String*/)/*:Boolean*/
		{
			return (locale && type && _g_n_g.DEFAULT_FORMAT_STRING[locale] && _g_n_g.DEFAULT_FORMAT_STRING[locale][type]);
		}
		/**
		 * @private
		 * Get Default predefined format string according to the current locale.
		 */
		_g_n_g.getDefaultDateFormat = function (locale/*:String*/, type/*:String*/)/*:String*/
		{
			return _g_n_g.DEFAULT_FORMAT_STRING[locale][type];
		}
		
		/**
		 * Get short day strings according to locale. eg. Mon,Tue... for english.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate short day strings with fall back strategy.
		 *  
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getShortDay = function (locale/*:String*/)/*:Array*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_SHORT_DAY))
				{
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_SHORT_DAY);
				}
				else
				{
					return null;
				}
			}
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_SHORT_DAY);
		}
		
		/**
		 * Get long day strings according to locale. eg. Monday,Tuesday... for english.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate long day strings with fall back strategy
		 *  
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getLongDay = function (locale/*:String*/)/*:Array*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_LONG_DAY))
				{
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_LONG_DAY);
				}
				else
				{
					return null;
				}
			}
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_LONG_DAY);
		}
		
		/**
		 * Get short month strings according to locale. eg. Jan,Feb... for english.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate short month strings with fall back strategy
		 *  
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getShortMonth = function (locale/*:String*/)/*:Array*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_SHORT_MONTH))
				{
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_SHORT_MONTH);
				}
				else
				{
					return null;
				}
			}
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_SHORT_MONTH);
		}
		
		/**
		 * Get long month strings according to locale. eg. January,Febuary... for english.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate long month strings with fall back strategy
		 *  
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getLongMonth = function (locale/*:String*/)/*:Array*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_LONG_MONTH))
				{
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_LONG_MONTH);
				}
				else
				{
					return null;
				}
			}
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_LONG_MONTH);
		}
		
		/**
		 * Get date separator for short date format according to locale. eg. "/" for english.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate date separator with fall back strategy
		 *  
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getDateSeparator = function (locale/*:String*/)/*:String*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_DATE_SEPARATOR))
				{
					console.log("getDateSeparator-getDateResource"+_g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_DATE_SEPARATOR).toString());
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_DATE_SEPARATOR).toString()/* as String*/;
				}
				else
				{
					return null;
				}
			}
			console.log("getDateSeparator-getAppropriateDateResource"+_g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_DATE_SEPARATOR).toString())
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_DATE_SEPARATOR).toString() /*as String*/;
		}
		
		/**
		 * Get time separator for Default date time/Default time format according to locale. eg. ":" for english.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate time separator with fall back strategy 
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getTimeSeparator = function (locale/*:String*/)/*:String*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TIME_SEPARATOR))
				{
					console.log("getTimeSeparator-getDateResource"+_g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TIME_SEPARATOR).toString());
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TIME_SEPARATOR).toString() /*as String*/;
				}
				else
				{
					return null;	
				}
			}
			console.log("getTimeSeparator-getAppropriateDateResource"+_g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TIME_SEPARATOR).toString());
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TIME_SEPARATOR).toString() /*as String*/;
		}
		
		/**
		 * Get am/pm tokens for date format according to locale. eg. "AM/PM" for english.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate am/pm tokens with fall back strategy
		 *  
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getAmPmToken = function (locale/*:String*/)/*:Array*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TOKEN_AM_PM))
				{
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TOKEN_AM_PM);
				}
				else
				{
					return null;
				}
			}
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_TIME, _g_n_g.KEY_TOKEN_AM_PM);
		}
		
		/**
		 * Get abbrev Era string.
		 * @return Array or null if Era string does not exist.
		 * 
		 */
		_g_n_g.getAbbrevEraString = function (locale/*:String*/)/*:Array*/
		{
			if (locale)
			{
				if (_g_n_g.resourceExist(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_ABBREV_ERA))
				{
					return _g_n_g.getDateResource(locale, _g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_ABBREV_ERA);
				}
				else
				{
					return null;
				}
			}
			return _g_n_g.getAppropriateDateResource(_g_n_g.KEY_TYPE_DATE, _g_n_g.KEY_TOKEN_ABBREV_ERA);
		}

		/**
		 * Get predefined short date format according to locale.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate predefined short date format with fall back strategy
		 *  
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getDefaultShorDateFormat = function (locale/*:String*/)/*:String*/
		{
			if (locale)
			{
				if (_g_n_g.formatExist(locale, _g_n_g.FORMAT_TYPE_SHORTDATE))
				{
					console.log("getDefaultShorDateFormat-getDefaultDateFormat"+_g_n_g.getDefaultDateFormat(locale, _g_n_g.FORMAT_TYPE_SHORTDATE).toString());
					return _g_n_g.getDefaultDateFormat(locale, _g_n_g.FORMAT_TYPE_SHORTDATE).toString();
				} 
				else
				{
					return "";
				}
			}
			console.log("getDefaultShorDateFormat-getAppropriateDateFormat"+_g_n_g.getAppropriateDateFormat(_g_n_g.FORMAT_TYPE_SHORTDATE).toString());
			return _g_n_g.getAppropriateDateFormat(_g_n_g.FORMAT_TYPE_SHORTDATE).toString();
		}
		
		/**
		 * Get predefined long date format according to locale.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate predefined long date format with fall back strategy
		 *   
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getDefaultLongDateFormat = function (locale/*:String*/)/*:String*/
		{
			if (locale)
			{
				if (_g_n_g.formatExist(locale, _g_n_g.FORMAT_TYPE_LONGDATE))
				{
					console.log("getDefaultLongDateFormat-getDefaultDateFormat"+_g_n_g.getDefaultDateFormat(locale, _g_n_g.FORMAT_TYPE_LONGDATE).toString());
					return _g_n_g.getDefaultDateFormat(locale, _g_n_g.FORMAT_TYPE_LONGDATE).toString();
				} 
				else 
				{
					return null;
				}
			}
			console.log("getDefaultLongDateFormat-getAppropriateDateFormat"+_g_n_g.getAppropriateDateFormat(_g_n_g.FORMAT_TYPE_LONGDATE));
			return _g_n_g.getAppropriateDateFormat(_g_n_g.FORMAT_TYPE_LONGDATE);
		}
		
		/**
		 * Get predefined date time format according to locale.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate predefined date time format with fall back strategy
		 *   
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getDefaultDateTimeFormat = function (locale/*:String*/)/*:String*/
		{
			if (locale)
			{
				if (_g_n_g.formatExist(locale, _g_n_g.FORMAT_TYPE_DATE_TIME))
				{
					console.log("getDefaultDateTimeFormat-getDefaultDateFormat"+_g_n_g.getDefaultDateFormat(locale, _g_n_g.FORMAT_TYPE_DATE_TIME).toString());
					return _g_n_g.getDefaultDateFormat(locale, _g_n_g.FORMAT_TYPE_DATE_TIME).toString();
				} 
				else 
				{
					return null;
				}
			}
			console.log("getDefaultDateTimeFormat-getAppropriateDateFormat"+_g_n_g.getAppropriateDateFormat(_g_n_g.FORMAT_TYPE_DATE_TIME).toString());
			return _g_n_g.getAppropriateDateFormat(_g_n_g.FORMAT_TYPE_DATE_TIME).toString();
		}
		
		/**
		 * Get predefined time format according to locale.
		 * If the locale is explicitly specified, then try to retrieve it according to the locale, return null if the
		 * locale is not supported.
		 * If no locale is passed in, retrieve the appropriate predefined time format with fall back strategy
		 *   
		 * @param locale
		 * @return 
		 * 
		 */
		_g_n_g.getDefaultTimeFormat = function (locale/*:String*/)/*:String*/
		{
			if (locale)
			{
				if (_g_n_g.formatExist(locale, _g_n_g.FORMAT_TYPE_TIME))
				{
					return _g_n_g.getDefaultDateFormat(locale, _g_n_g.FORMAT_TYPE_TIME).toString();
				} 
				else 
				{
					return null;
				}
			}
			return _g_n_g.getAppropriateDateFormat(_g_n_g.FORMAT_TYPE_TIME).toString();
		}
		
		/**
		 * A standard method to fetch appropriate date format. It will follow a fall back
		 * strategy to get the resource.
		 * 
		 * @param type type of the resource
		 * 
		 * @return date format string
		 */
		_g_n_g.getAppropriateDateFormat = function (type/*:String*/)/*:String*/
		{
			// first, try to fetch the resource according to pvl locale
			var pvlLocale/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvl();
			if (_g_n_g.formatExist(pvlLocale, type))
			{
				return _g_n_g.getDefaultDateFormat(pvlLocale, type).toString();
			}
			
			// second, try to fetch the resource according to pvl dominant language
			var pvlIsoLanguageCode/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();
			if (_g_n_g.formatExist(pvlIsoLanguageCode, type))
			{
				return _g_n_g.getDefaultDateFormat(pvlIsoLanguageCode, type).toString();
			}
			
			// third, try to fetch the resource according to document locale
			var documentLocale/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();
			if (_g_n_g.formatExist(documentLocale, type))
			{
				return _g_n_g.getDefaultDateFormat(documentLocale, type).toString();
			}
			
			// fourth, try to fetch the resource according to document language
			var documentIsoLanguageCode/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();
			if (_g_n_g.formatExist(documentIsoLanguageCode, type))
			{
				return _g_n_g.getDefaultDateFormat(documentIsoLanguageCode, type).toString();
			}
			
			return _g_n_g.getDefaultDateFormat("en", type).toString();
		}
		
		
		
		/**
		 * A standard method to fetch appropriate numeric resources. It will follow a fall back
		 * strategy to get the resource.
		 * 
		 * @param type type of the resource
		 * @param resourceKey key of the resource
		 * 
		 * @return resource string or null if not found.
		 */
		_g_n_g.getAppropriateDateResource = function (type/*:String*/, resourceKey/*:String*/)/*:Object*/
		{
			// first, try to fetch the resource according to pvl locale
			var pvlLocale/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvl();
			if (_g_n_g.resourceExist(pvlLocale, type, resourceKey))
			{
				return _g_n_g.getDateResource(pvlLocale, type, resourceKey);
			}
			
			// second, try to fetch the resource according to pvl dominant language
			var pvlIsoLanguageCode/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();
			if (_g_n_g.resourceExist(pvlIsoLanguageCode, type, resourceKey))
			{
				return _g_n_g.getDateResource(pvlIsoLanguageCode, type, resourceKey);
			}
			
			// third, try to fetch the resource according to document locale
			var documentLocale/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();
			if (_g_n_g.resourceExist(documentLocale, type, resourceKey))
			{
				return _g_n_g.getDateResource(documentLocale, type, resourceKey);
			}
			
			// fourth, try to fetch the resource according to document language
			var documentIsoLanguageCode/*:String*/ = sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();
			if (_g_n_g.resourceExist(documentIsoLanguageCode, type, resourceKey))
			{
				return _g_n_g.getDateResource(documentIsoLanguageCode, type, resourceKey);
			}
			
			return _g_n_g.getDateResource("en", type, resourceKey);
		}
		
		_g_n_g.resourceExist = function (locale/*:String*/, type/*:String*/, resourceKey/*:String*/)/*:Boolean*/
		{
			return (locale && type && resourceKey && _g_n_g.RESOURCE_MAP[locale]
				&& _g_n_g.RESOURCE_MAP[locale][type] && _g_n_g.RESOURCE_MAP[locale][type][resourceKey]);
		}
		
		_g_n_g.getDateResource = function (locale/*:String*/, type/*:String*/, resourceKey/*:String*/)/*:Object*/
		{
			return _g_n_g.RESOURCE_MAP[locale][type][resourceKey];
		}
	}
)();
(function(){

	sap.common.globalization.declare("sap.common.globalization.GlobalizationNumericUtil");


		sap.common.globalization.GlobalizationNumericUtil =function()
		{
			this.__className = "sap.common.globalization.GlobalizationNumericUtil";			
		}
		
		/**
		 * Check whether the given locale uses two digit grouping.
		 */
		sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry =function(locale/*String*/)/*Boolean*/
		{
			switch(locale)
			{
				case "bn":
				case "bn_IN":
				case "gu":
				case "gu_IN":
				case "hi":
				case "hi_IN":
				case "kn":
				case "kn_IN":
				case "kok":
				case "kok_IN":
				case "ml":
				case "ml_IN":
				case "mr":
				case "mr_IN":
				case "pa":
				case "pa_IN":
				case "ta":
				case "ta_IN":
				case "te":
				case "te_IN":
					return true;
				default:
					return false;
			}
		}
})();
(function() {

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FLocalization");

		sap.common.globalization.require("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");
		sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");
		sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");
		sap.common.globalization.require("sap.common.globalization.utils.StringUtil");
		sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");
		sap.common.globalization.require("sap.common.globalization.NumericFormatManager");
	
		 

		 // for singleton to create instance.
		sap.common.globalization.numericFormat.FLocalization = function()
		{
			this.__className = "sap.common.globalization.numericFormat.FLocalization";
			
			this.IMDateSeparator/*String*/ = _s_g_n_FLocalization._DateTimeStrings['en'][1];
			this.IMDayCode/*String*/ = _s_g_n_FLocalization._DateTimeCodes['en'][5];
			this.IMDecimalSeparator/*String*/ = _s_g_n_FLocalization._NumericStrings['en'][1];
			this.IMGeneralFormatName/*String*/ = "General";
			this.IMHourCode/*String*/ =  _s_g_n_FLocalization._DateTimeCodes['en'][3];
			this.IMMinuteCode/*String*/ =  _s_g_n_FLocalization._DateTimeCodes['en'][1];
			this.IMMonthCode/*String*/ =  _s_g_n_FLocalization._DateTimeCodes['en'][4];
			this.IMSABBREVDAYNAME1/*String*/ = _s_g_n_FLocalization._shortDayStrings['en'][1];
			this.IMSABBREVDAYNAME2/*String*/ = _s_g_n_FLocalization._shortDayStrings['en'][2];
			this.IMSABBREVDAYNAME3/*String*/ = _s_g_n_FLocalization._shortDayStrings['en'][3];
			this.IMSABBREVDAYNAME4/*String*/ =_s_g_n_FLocalization._shortDayStrings['en'][4];
			this.IMSABBREVDAYNAME5/*String*/ = _s_g_n_FLocalization._shortDayStrings['en'][5];
			this.IMSABBREVDAYNAME6/*String*/ = _s_g_n_FLocalization._shortDayStrings['en'][6];
			this.IMSABBREVDAYNAME7/*String*/ = _s_g_n_FLocalization._shortDayStrings['en'][7];
			this.IMSABBREVMONTHNAME1/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][1];
			this.IMSABBREVMONTHNAME10 /*String*/= _s_g_n_FLocalization._shortMonthStrings['en'][10];
			this.IMSABBREVMONTHNAME11/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][11];
			this.IMSABBREVMONTHNAME12/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][12];
			this.IMSABBREVMONTHNAME2/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][2];
			this.IMSABBREVMONTHNAME3/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][3];
			this.IMSABBREVMONTHNAME4/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][4];
			this.IMSABBREVMONTHNAME5/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][5];
			this.IMSABBREVMONTHNAME6/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][6];
			this.IMSABBREVMONTHNAME7/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][7];
			this.IMSABBREVMONTHNAME8/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][8];
			this.IMSABBREVMONTHNAME9/*String*/ = _s_g_n_FLocalization._shortMonthStrings['en'][9];
			this.IMSDAYNAME1/*String*/ = _s_g_n_FLocalization._DayStrings['en'][1];
			this.IMSDAYNAME2/*String*/ = _s_g_n_FLocalization._DayStrings['en'][2];
			this.IMSDAYNAME3/*String*/ = _s_g_n_FLocalization._DayStrings['en'][3];
			this.IMSDAYNAME4/*String*/ = _s_g_n_FLocalization._DayStrings['en'][4];
			this.IMSDAYNAME5/*String*/ = _s_g_n_FLocalization._DayStrings['en'][5];
			this.IMSDAYNAME6/*String*/ = _s_g_n_FLocalization._DayStrings['en'][6];
			this.IMSDAYNAME7/*String*/ = _s_g_n_FLocalization._DayStrings['en'][7];
			this.IMSMONTHNAME1/*String*/ = _s_g_n_FLocalization._MonthStrings['en'][1];
			this.IMSMONTHNAME10/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][10];
			this.IMSMONTHNAME11/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][11];
			this.IMSMONTHNAME12/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][12];
			this.IMSMONTHNAME2/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][2];
			this.IMSMONTHNAME3/*String*/ = _s_g_n_FLocalization._MonthStrings['en'][3];
			this.IMSMONTHNAME4/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][4];
			this.IMSMONTHNAME5/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][5];
			this.IMSMONTHNAME6/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][6];
			this.IMSMONTHNAME7/*String*/ = _s_g_n_FLocalization._MonthStrings['en'][7];
			this.IMSMONTHNAME8/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][8];
			this.IMSMONTHNAME9/*String*/ =  _s_g_n_FLocalization._MonthStrings['en'][9];
			this.IMSecondCode/*String*/ =  _s_g_n_FLocalization._DateTimeCodes['en'][2];
			this.IMTimeSeparator/*String*/ = _s_g_n_FLocalization._DateTimeStrings['en'][2];
			this.IMYearCode/*String*/ =  _s_g_n_FLocalization._DateTimeCodes['en'][6];	
			this.IMCurrencySymbol/*String*/ = _s_g_n_FLocalization._CurrencySymbol['en'][1];
			this.SAPDateSeparator/*String*/ = _s_g_n_FLocalization._SAPDateString;
			this.SAPTimeSeparator/*String*/ = _s_g_n_FLocalization._SAPTimeString;
			this.SAPCurrencySymbol/*String*/ = _s_g_n_FLocalization._SAPCurrencySymbol;	
			this.SAPDecimalSeparator/*String*/ = _s_g_n_FLocalization._SAPDecimalSeparator;
			this.SAPThousandsSeparator/*String*/ = _s_g_n_FLocalization._SAPThousandsSeparator;
			this.SAPLongDay/*Array*/ = _s_g_n_FLocalization._SAPLongDay;
			this.SAPShortDay/*Array*/ = _s_g_n_FLocalization._SAPShortDay;
			this.SAPLongMonth/*Array*/ = _s_g_n_FLocalization._SAPLongMonth;
			this.SAPShortMonth/*Array*/ = _s_g_n_FLocalization._SAPShortMonth;
			this.IMAMTOKEN/*String*/ = _s_g_n_FLocalization._AmPms['en'][1];
			this.IMPMTOKEN/*String*/ = _s_g_n_FLocalization._AmPms['en'][2];
			
			// private
			this._IMThousandsSeparator = this.replaceNBSP(_s_g_n_FLocalization._NumericStrings['en'][2])
		
			// locale info of numeric formats for parsing
			this._numericParseLocaleInfo/*NumericParseLocaleInfoImpl*/ = null; // TODO default is null.
		
			// locale info of numeric formats for displaying
			this._numericDisplayLocaleInfo/*NumericDisplayLocaleInfoImpl*/ = null; // TODO default is null.
			
					
			this._dateParseLocaleInfo/*DateParseLocaleInfoImpl*/ = null;
			
			this._dateDisplayLocaleInfo/*DateDisplayLocaleInfoImpl*/ = null;
		}
		
		var _s_g_n_FLocalization = sap.common.globalization.numericFormat.FLocalization;

		 _s_g_n_FLocalization._defaultLocale/*String*/ = "en";
						
		 _s_g_n_FLocalization._DayStrings/*Object*/ = null;
		 _s_g_n_FLocalization._shortDayStrings/*Object*/ = null;
		 _s_g_n_FLocalization._MonthStrings/*Object*/ = null;
		 _s_g_n_FLocalization._shortMonthStrings/*Object*/ = null;
		 _s_g_n_FLocalization._DateTimeCodes/*Object*/ = null;
		 _s_g_n_FLocalization._NumericStrings/*Object*/ = null;
		 _s_g_n_FLocalization._DateTimeStrings/*Object*/ = null;
		 _s_g_n_FLocalization._CurrencySymbol/*Object*/ = null;
		 _s_g_n_FLocalization._SAPCurrencySymbol/*String*/ = null;
		 _s_g_n_FLocalization._SAPDateString/*String*/ = null;
		 _s_g_n_FLocalization._SAPTimeString/*String*/ = null;
		 _s_g_n_FLocalization._SAPThousandsSeparator/*String*/ = null;
		 _s_g_n_FLocalization._SAPDecimalSeparator/*String*/ = null;
		 _s_g_n_FLocalization._SAPLongDay/*Array*/ = null;
		 _s_g_n_FLocalization._SAPShortDay/*Array*/ = null;
		 _s_g_n_FLocalization._SAPLongMonth/*Array*/ = null;
		 _s_g_n_FLocalization._SAPShortMonth/*Array*/ = null;
		
		/**
		 * Tokens for AM and PM, which have the default value of "AM" and "PM".
		 */
		 _s_g_n_FLocalization._AmPms/*Object*/ = null;
		
		 _s_g_n_FLocalization._singleton/*FLocalization*/ = null;
		
		// Move ahead of constant because of the  
		sap.common.globalization.numericFormat.FLocalization.prototype.replaceNBSP = function(value/*String*/)/*String*/
		{
			if (value)
			{
				var newValue/*String*/ = "";
				var nonBreakingSpaceCode/*uint*/ = 160; // UTF-8 char code
				
				// HACK handle non-breaking spaces by converting them to normal spaces
				// see ADAPT01021228 
				for (var i/*uint*/ = 0; i < value.length; ++i)
				{
					if (value.charCodeAt(i) == nonBreakingSpaceCode)
					{
						newValue += " "; // replace with normal space char
					}
					else
					{
						newValue += value.charAt(i);
					}	
				}
				
				value = newValue;
			}
			return value; 
		}
		
		_s_g_n_FLocalization.getInstance=function()/*FLocalization*/
		{
			if(!_s_g_n_FLocalization._singleton)
			{
			// if ( _s_g_n_FLocalization._shortDayStrings == null ) {
				
				_s_g_n_FLocalization._initStrings(); // To not block unit test.
		
				// check for PVL flashvar
				_s_g_n_FLocalization._initializePvlDateStrings();	
				//check for flashvar overides
				_s_g_n_FLocalization._initSAPGlobilizationStrings();
				_s_g_n_FLocalization._singleton = new sap.common.globalization.numericFormat.FLocalization();
				
				_s_g_n_FLocalization._singleton.IMSABBREVDAYNAME1 = _s_g_n_FLocalization._shortDayStrings['en'][1];
			}								
			// TODO better error checking
			return _s_g_n_FLocalization._singleton;
		}
		
		_s_g_n_FLocalization.resetInstance=function()
		{
			_s_g_n_FLocalization._resetAllStaticVars();
			_s_g_n_FLocalization._initStrings();
			_s_g_n_FLocalization._initializePvlDateStrings();
			_s_g_n_FLocalization._initSAPGlobilizationStrings();
			_s_g_n_FLocalization._singleton = new sap.common.globalization.numericFormat.FLocalization();
			_s_g_n_FLocalization._singleton.IMSABBREVDAYNAME1 = _s_g_n_FLocalization._shortDayStrings['en'][1];
		}
		

	var customizedLocaleInfoType = {
		'monthStrings' : '_MonthStrings',
		'shortMonthStrings' : '_shortMonthStrings',
		'dayStrings' : '_DayStrings',
		'shortDayStrings' : '_shortDayStrings',
		'dateTimeCodes' : '_DateTimeCodes',
		'numericStrings' : '_NumericStrings',
		'dateTimeStrings' : '_DateTimeStrings',
		'currencySymbol' : '_CurrencySymbol',
		'amPms' : '_AmPms'
	};

		/*
		 * The input locale info
		 
		{
			dayStrings: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
			shortDayStrings: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
			monthStrings: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			shortMonthStrings: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			dateTimeCodes: ["m", "s", "h", "M", "D", "Y"],
			numericStrings: [".", ","],	
			dateTimeStrings: [ "/", ":"],				
			currencySymbol: ["$", "$"],			
			amPms: [ "AM", "PM"]
		}
		*/

	
		// set the customize locale info
		_s_g_n_FLocalization.prototype.setCustomizedLocaleInfo =function(value){

			if(value)
			{
				var localeInfoName;

				for(localeInfoName in customizedLocaleInfoType)		
				{
					if(value.hasOwnProperty(localeInfoName))
					{
						var localeInfoType = customizedLocaleInfoType[localeInfoName];
						this._setCustomizedLocaleInfoByType(localeInfoType, value[localeInfoName])
					}
				}		
			}
			else // set the locale default locale info
			{
				var locale = sap.common.globalization.GlobalizationPreference.getInstance().pvl();
				if(!locale)
					locale = 'en';
				var gDateConstant =sap.common.globalization.GlobalizationDateConstant;
				
				this._setCustomizedLocaleInfoByType(customizedLocaleInfoType["dayStrings"], gDateConstant.getLongDay(locale));
				this._setCustomizedLocaleInfoByType(customizedLocaleInfoType["shortDayStrings"],gDateConstant.getShortDay(locale));
				this._setCustomizedLocaleInfoByType(customizedLocaleInfoType["monthStrings"], gDateConstant.getLongMonth(locale));
				this._setCustomizedLocaleInfoByType(customizedLocaleInfoType["shortMonthStrings"], gDateConstant.getShortMonth(locale));
				
				// NEED to confirm, will not set the default locale info for below items.
				// this._setCustomizedLocaleInfoByType("dateTimeCodes",locale,gDateConstant.getShortDay(locale) );
				// this._setCustomizedLocaleInfoByType("numericStrings",locale, );
				// this._setCustomizedLocaleInfoByType("dateTimeStrings",locale, );
				// this._setCustomizedLocaleInfoByType("currencySymbol",locale, );
				this._setCustomizedLocaleInfoByType(customizedLocaleInfoType["amPms"], gDateConstant.getShortMonth(locale));
	
			}
			
		};
		
		_s_g_n_FLocalization.prototype._setCustomizedLocaleInfoByType =function(type /*String*/, value/*Array*/){
			if(value && value.length>0)
			{
				var j;
				for(var i=0; i<value.length;i++)
				{	
					j= i+1;
					_s_g_n_FLocalization[type]["en"][j] = value[i]; // ONLY set "en" here.
				}					
			}
		};
		
		_s_g_n_FLocalization._initStrings =function()/*void*/
		{
				 _s_g_n_FLocalization._DayStrings =  { "en": 
      					{   1: "Monday",
      						 2 : "Tuesday",
							 3: "Wednesday",
							 4: "Thursday",
							 5: "Friday",
							 6: "Saturday",
							 7: "Sunday"
       					}
   							};  
							
						 _s_g_n_FLocalization._shortDayStrings =  { "en": 
      					{   1: "Mon",
      						 2 : "Tue",
							 3: "Wed",
							 4: "Thu",
							 5: "Fri",
							 6: "Sat",
							 7: "Sun"
       					}
   							};  
							
								
						 _s_g_n_FLocalization._MonthStrings =  { "en": 
      					{   1: "January",
      						 2 : "February",
							 3: "March",
							 4: "April",
							 5: "May",
							 6: "June",
							 7: "July",
							 8: "August",
							 9: "September",
							 10: "October",
							 11: "November",
							 12: "December"
       					}
   							};  
							
						_s_g_n_FLocalization._shortMonthStrings =  { "en": 
      					{   1: "Jan",
      						 2 : "Feb",
							 3: "Mar",
							 4: "Apr",
							 5: "May",
							 6: "Jun",
							 7: "Jul",
							 8: "Aug",
							 9: "Sep",
							 10: "Oct",
							 11: "Nov",
							 12: "Dec"
       					}
   							};  
							
						
					 _s_g_n_FLocalization._DateTimeCodes =  { "en": 
      					{   1: "m",
      						 2 : "s",
							 3: "h",
							 4: "M",
							 5: "D",
							 6: "Y"
       					}
   							};  
							
							
					 _s_g_n_FLocalization._NumericStrings =  { "en": 
      					{   1: ".",
      						 2 : ","		
       					}
   							};  
							
							
						_s_g_n_FLocalization._DateTimeStrings =  { "en": 
      					{   1: "/",
      						 2 : ":"				
       					}
   							};  
   							
   						_s_g_n_FLocalization._CurrencySymbol = { "en": 
	      					{   
	      						1: "$",
								2: "$"				
	       					}
       					};
       					
       					_s_g_n_FLocalization._AmPms = { "en":
       						{
       							1: "AM",
       							2: "PM"
       						}
       					};
		}
		
		_s_g_n_FLocalization._initSAPGlobilizationStrings =function()/*void*/
		{
				// using bics flash var as top priority if it does not exist use the sap_decimal. So do the following flash vars.
				// TODO FLEXGlobals use SAPGlobals for test
				var _s_g_nfm = sap.common.globalization.NumericFormatManager;
				
				var decimal/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_DECIMAL"];
				decimal = decimal ? decimal : _s_g_nfm["SAP_PARAMETERS"]["SAP_decimal"];
				
				var thousandSeparator/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_THOUSANDSEPARATOR"];
				thousandSeparator = thousandSeparator ? thousandSeparator : _s_g_nfm["SAP_PARAMETERS"]["SAP_thousandSeparator"];
				
				var monthsLong/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_MONTHSLONG"];
				monthsLong = monthsLong ? monthsLong : _s_g_nfm["SAP_PARAMETERS"]["SAP_monthsLong"];
				
				var monthsShort/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_MONTHSSHORT"];
				monthsShort = monthsShort ? monthsShort : _s_g_nfm["SAP_PARAMETERS"]["SAP_monthsShort"];
				
				var daysLong/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_DAYSLONG"];
				daysLong = daysLong ? daysLong : _s_g_nfm["SAP_PARAMETERS"]["SAP_daysLong"];
				
				var daysShort/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_DAYSSHORT"];
				daysShort = daysShort ? daysShort : _s_g_nfm["SAP_PARAMETERS"]["SAP_daysShort"];
				
				var dateSeparator/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_DATESEPARATOR"];
				dateSeparator = dateSeparator ? dateSeparator : _s_g_nfm["SAP_PARAMETERS"]["SAP_dateSeparator"];
				
				var timeSeparator/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["BICSWS_TIMESEPARATOR"];
				timeSeparator = timeSeparator ? timeSeparator : _s_g_nfm["SAP_PARAMETERS"]["SAP_timeSeparator"];
				
				var currencySymbol/*String*/ = _s_g_nfm["SAP_PARAMETERS"]["SAP_s_g_n_FLocalization._CurrencySymbol"];
				
				var temp/*Array*/;
				
				if(daysLong) {
					temp = daysLong.split(",");
					_s_g_n_FLocalization._SAPLongDay = temp;
					
					 _s_g_n_FLocalization._DayStrings["en"][1] = temp[0];
					 _s_g_n_FLocalization._DayStrings["en"][2] = temp[1];
					 _s_g_n_FLocalization._DayStrings["en"][3] = temp[2];
					 _s_g_n_FLocalization._DayStrings["en"][4] = temp[3];
					 _s_g_n_FLocalization._DayStrings["en"][5] = temp[4];
					 _s_g_n_FLocalization._DayStrings["en"][6] = temp[5];
					 _s_g_n_FLocalization._DayStrings["en"][7] = temp[6];
				}				
				if(daysShort){
					temp = daysShort.split(",");
					_s_g_n_FLocalization._SAPShortDay = temp;
					
					 _s_g_n_FLocalization._shortDayStrings["en"][1] = temp[0];
					 _s_g_n_FLocalization._shortDayStrings["en"][2] = temp[1];
					 _s_g_n_FLocalization._shortDayStrings["en"][3] = temp[2];
					 _s_g_n_FLocalization._shortDayStrings["en"][4] = temp[3];
					 _s_g_n_FLocalization._shortDayStrings["en"][5] = temp[4];
					 _s_g_n_FLocalization._shortDayStrings["en"][6] = temp[5];
					 _s_g_n_FLocalization._shortDayStrings["en"][7] = temp[6];
				}
				if(monthsLong){
					temp = monthsLong.split(",");
					_s_g_n_FLocalization._SAPLongMonth = temp;
					
					 _s_g_n_FLocalization._MonthStrings["en"][1] = temp[0];
					 _s_g_n_FLocalization._MonthStrings["en"][2] = temp[1];
					 _s_g_n_FLocalization._MonthStrings["en"][3] = temp[2];
					 _s_g_n_FLocalization._MonthStrings["en"][4] = temp[3];
					 _s_g_n_FLocalization._MonthStrings["en"][5] = temp[4];
					 _s_g_n_FLocalization._MonthStrings["en"][6] = temp[5];
					 _s_g_n_FLocalization._MonthStrings["en"][7] = temp[6];
					 _s_g_n_FLocalization._MonthStrings["en"][8] = temp[7];
					 _s_g_n_FLocalization._MonthStrings["en"][9] = temp[8];
					 _s_g_n_FLocalization._MonthStrings["en"][10] = temp[9];
					 _s_g_n_FLocalization._MonthStrings["en"][11] = temp[10];
					 _s_g_n_FLocalization._MonthStrings["en"][12] = temp[11];	 	 
				}
				if(monthsShort){
					temp = monthsShort.split(",");
					_s_g_n_FLocalization._SAPShortMonth = temp;

					 _s_g_n_FLocalization._shortMonthStrings["en"][1] = temp[0];
					 _s_g_n_FLocalization._shortMonthStrings["en"][2] = temp[1];
					 _s_g_n_FLocalization._shortMonthStrings["en"][3] = temp[2];
					 _s_g_n_FLocalization._shortMonthStrings["en"][4] = temp[3];
					 _s_g_n_FLocalization._shortMonthStrings["en"][5] = temp[4];
					 _s_g_n_FLocalization._shortMonthStrings["en"][6] = temp[5];
					 _s_g_n_FLocalization._shortMonthStrings["en"][7] = temp[6];
					 _s_g_n_FLocalization._shortMonthStrings["en"][8] = temp[7];
					 _s_g_n_FLocalization._shortMonthStrings["en"][9] = temp[8];
					 _s_g_n_FLocalization._shortMonthStrings["en"][10] = temp[9];
					 _s_g_n_FLocalization._shortMonthStrings["en"][11] = temp[10];
					 _s_g_n_FLocalization._shortMonthStrings["en"][12] = temp[11];
				}
				if(decimal)
					 _s_g_n_FLocalization._SAPDecimalSeparator = decimal;
				if(thousandSeparator)
					 _s_g_n_FLocalization._SAPThousandsSeparator = thousandSeparator;
				if(dateSeparator)
					 _s_g_n_FLocalization._SAPDateString = dateSeparator;
				if(timeSeparator)
					 _s_g_n_FLocalization._SAPTimeString = timeSeparator;
				if(currencySymbol)
					_s_g_n_FLocalization._SAPCurrencySymbol = currencySymbol;
		}
		

	
		// // private var this._IMThousandsSeparator/*String*/ = replaceNBSP(_s_g_n_FLocalization._NumericStrings['en'][2]);
// 		
		// // locale info of numeric formats for parsing
		// private var this._numericParseLocaleInfo:NumericParseLocaleInfoImpl;
// 		
		// // locale info of numeric formats for displaying
		// private var this._numericDisplayLocaleInfo:NumericDisplayLocaleInfoImpl;
// 		

		_s_g_n_FLocalization.prototype.IMThousandsSeparator =function(v)
		{
			if(arguments.length>=1){
				this._IMThousandsSeparator = this.replaceNBSP(v);
				return this;
			}else{
				//get
				return this._IMThousandsSeparator;
			}
		} 
		
		_s_g_n_FLocalization.prototype.getDateParseLocaleInfo=function()/*IDateParseLocaleInfo*/
		{
			if (!this._dateParseLocaleInfo)
			{
				// Date separators
				this._dateParseLocaleInfo = new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl();
				this._dateParseLocaleInfo.IMDateSeparator(this.IMDateSeparator);
				
				// Time separators
				this._dateParseLocaleInfo.IMTimeSeparator(this.IMTimeSeparator);
			}
			return this._dateParseLocaleInfo;
		}
		

		
		_s_g_n_FLocalization.prototype.getDateDisplayLocaleInfo= function()/*IDateDisplayLocaleInfo*/
		{
			if (!this._dateDisplayLocaleInfo)
			{
				// Customized Tokens, SAP Tokens and SAP Separators for Date
				this._dateDisplayLocaleInfo = new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();

//				1. Do not replace separator with OS one.
//				2. Replace separator with SAP one if existing.
				this._dateDisplayLocaleInfo.IMDateSeparator(this.SAPDateSeparator);

				this._dateDisplayLocaleInfo.IMSDAYNAME1(this.IMSDAYNAME1);
				this._dateDisplayLocaleInfo.IMSDAYNAME2(this.IMSDAYNAME2);
				this._dateDisplayLocaleInfo.IMSDAYNAME3(this.IMSDAYNAME3);
				this._dateDisplayLocaleInfo.IMSDAYNAME4(this.IMSDAYNAME4);
				this._dateDisplayLocaleInfo.IMSDAYNAME5(this.IMSDAYNAME5);
				this._dateDisplayLocaleInfo.IMSDAYNAME6(this.IMSDAYNAME6);
				this._dateDisplayLocaleInfo.IMSDAYNAME7(this.IMSDAYNAME7);
				
				this._dateDisplayLocaleInfo.IMSABBREVDAYNAME1(this.IMSABBREVDAYNAME1);
				this._dateDisplayLocaleInfo.IMSABBREVDAYNAME2(this.IMSABBREVDAYNAME2);
				this._dateDisplayLocaleInfo.IMSABBREVDAYNAME3(this.IMSABBREVDAYNAME3);
				this._dateDisplayLocaleInfo.IMSABBREVDAYNAME4(this.IMSABBREVDAYNAME4);
				this._dateDisplayLocaleInfo.IMSABBREVDAYNAME5(this.IMSABBREVDAYNAME5);
				this._dateDisplayLocaleInfo.IMSABBREVDAYNAME6(this.IMSABBREVDAYNAME6);
				this._dateDisplayLocaleInfo.IMSABBREVDAYNAME7(this.IMSABBREVDAYNAME7);
				
				this._dateDisplayLocaleInfo.IMSMONTHNAME1(this.IMSMONTHNAME1);
				this._dateDisplayLocaleInfo.IMSMONTHNAME2(this.IMSMONTHNAME2);
				this._dateDisplayLocaleInfo.IMSMONTHNAME3(this.IMSMONTHNAME3);
				this._dateDisplayLocaleInfo.IMSMONTHNAME4(this.IMSMONTHNAME4);
				this._dateDisplayLocaleInfo.IMSMONTHNAME5(this.IMSMONTHNAME5);
				this._dateDisplayLocaleInfo.IMSMONTHNAME6(this.IMSMONTHNAME6);
				this._dateDisplayLocaleInfo.IMSMONTHNAME7(this.IMSMONTHNAME7);
				this._dateDisplayLocaleInfo.IMSMONTHNAME8(this.IMSMONTHNAME8);
				this._dateDisplayLocaleInfo.IMSMONTHNAME9(this.IMSMONTHNAME9);
				this._dateDisplayLocaleInfo.IMSMONTHNAME10(this.IMSMONTHNAME10);
				this._dateDisplayLocaleInfo.IMSMONTHNAME11(this.IMSMONTHNAME11);
				this._dateDisplayLocaleInfo.IMSMONTHNAME12(this.IMSMONTHNAME12);
				
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME1(this.IMSABBREVMONTHNAME1);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME2(this.IMSABBREVMONTHNAME2);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME3(this.IMSABBREVMONTHNAME3);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME4(this.IMSABBREVMONTHNAME4);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME5(this.IMSABBREVMONTHNAME5);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME6(this.IMSABBREVMONTHNAME6);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME7(this.IMSABBREVMONTHNAME7);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME8(this.IMSABBREVMONTHNAME8);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME9(this.IMSABBREVMONTHNAME9);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME10(this.IMSABBREVMONTHNAME10);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME11(this.IMSABBREVMONTHNAME11);
				this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME12(this.IMSABBREVMONTHNAME12);
				
				// Customized Tokens, SAP Tokens and SAP Separators for Time
				this._dateDisplayLocaleInfo.IMTimeSeparator(this.SAPTimeSeparator);
				
				this._dateDisplayLocaleInfo.IMAMTOKEN(this.IMAMTOKEN);
				this._dateDisplayLocaleInfo.IMPMTOKEN(this.IMPMTOKEN);
			}
			return this._dateDisplayLocaleInfo;
		}
	
		/**
		 * Return the locale info of numeric formats for parsing.
		 */
		_s_g_n_FLocalization.prototype.numericParseLocaleInfo =function()/*INumericParseLocaleInfo*/
		{
			if (!this._numericParseLocaleInfo)
			{
				this._numericParseLocaleInfo = new sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl(this._IMThousandsSeparator,
					this.IMDecimalSeparator, this.IMCurrencySymbol);
			}
			return this._numericParseLocaleInfo;
		}
		
		/**
		 * Return the locale info of numeric formats for displaying.
		 */
		_s_g_n_FLocalization.prototype.numericDisplayLocaleInfo =function()/*INumericDisplayLocaleInfo*/
		{
			if (!this._numericDisplayLocaleInfo)
			{
				// SAP separators have higher priority
				var thousandsSepartor/*String*/ = (this.SAPThousandsSeparator ? this.SAPThousandsSeparator : this._IMThousandsSeparator);
				var decimalSeparator/*String*/ = (this.SAPDecimalSeparator ? this.SAPDecimalSeparator : this.IMDecimalSeparator);
				var currencySymbol/*String*/ = (this.SAPCurrencySymbol ? this.SAPCurrencySymbol : this.IMCurrencySymbol);
				this._numericDisplayLocaleInfo = new sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl(thousandsSepartor, decimalSeparator, currencySymbol);
			}
			return this._numericDisplayLocaleInfo;
		}
		
		/**
		 * If PVL exist, initializing the pre-defined tokens according to PVL.
		 * 	1. PVL supported, getting tokens according to PVL.
		 * 	2. PVL not supported, getting tokens according to PVL iso language.
		 * 	3. pvl iso language not supported, getting tokens according to document locale.
		 * 	4. document locale not supported, getting tokens according to document locale iso language.
		 * 	5. document locale iso language not supported, getting tokens according to 'en'.
		 * Otherwise, do nothing
		 */
		_s_g_n_FLocalization._initializePvlDateStrings =function()
		{
			var pvl/*String*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvl();
			if (pvl && !sap.common.globalization.utils.StringUtil.isBlankString(pvl))
			{
				// get appropriate tokens according to pvl, with fallback strategy
				var longDay/*Array*/ = sap.common.globalization.GlobalizationDateConstant.getLongDay();
				if (longDay)
				{
					_s_g_n_FLocalization._DayStrings["en"][1] = longDay[1];
					_s_g_n_FLocalization._DayStrings["en"][2] = longDay[2];
					_s_g_n_FLocalization._DayStrings["en"][3] = longDay[3];
					_s_g_n_FLocalization._DayStrings["en"][4] = longDay[4];
					_s_g_n_FLocalization._DayStrings["en"][5] = longDay[5];
					_s_g_n_FLocalization._DayStrings["en"][6] = longDay[6];
					_s_g_n_FLocalization._DayStrings["en"][7] = longDay[0];
				}
				
				var shortDay/*Array*/ = sap.common.globalization.GlobalizationDateConstant.getShortDay();
				if (shortDay)
				{
					_s_g_n_FLocalization._shortDayStrings["en"][1] = shortDay[1];
					_s_g_n_FLocalization._shortDayStrings["en"][2] = shortDay[2];
					_s_g_n_FLocalization._shortDayStrings["en"][3] = shortDay[3];
					_s_g_n_FLocalization._shortDayStrings["en"][4] = shortDay[4];
					_s_g_n_FLocalization._shortDayStrings["en"][5] = shortDay[5];
					_s_g_n_FLocalization._shortDayStrings["en"][6] = shortDay[6];
					_s_g_n_FLocalization._shortDayStrings["en"][7] = shortDay[0];
				}
				
				var longMonth/*Array*/ = sap.common.globalization.GlobalizationDateConstant.getLongMonth();
				if (longMonth)
				{
					_s_g_n_FLocalization._MonthStrings["en"][1] = longMonth[0];
					_s_g_n_FLocalization._MonthStrings["en"][2] = longMonth[1];
					_s_g_n_FLocalization._MonthStrings["en"][3] = longMonth[2];
					_s_g_n_FLocalization._MonthStrings["en"][4] = longMonth[3];
					_s_g_n_FLocalization._MonthStrings["en"][5] = longMonth[4];
					_s_g_n_FLocalization._MonthStrings["en"][6] = longMonth[5];
					_s_g_n_FLocalization._MonthStrings["en"][7] = longMonth[6];
					_s_g_n_FLocalization._MonthStrings["en"][8] = longMonth[7];
					_s_g_n_FLocalization._MonthStrings["en"][9] = longMonth[8];
					_s_g_n_FLocalization._MonthStrings["en"][10] = longMonth[9];
					_s_g_n_FLocalization._MonthStrings["en"][11] = longMonth[10];
					_s_g_n_FLocalization._MonthStrings["en"][12] = longMonth[11];
				}
				
				var shortMonth/*Array*/ = sap.common.globalization.GlobalizationDateConstant.getShortMonth();
				if (shortMonth)
				{
					_s_g_n_FLocalization._shortMonthStrings["en"][1] = shortMonth[0];
					_s_g_n_FLocalization._shortMonthStrings["en"][2] = shortMonth[1];
					_s_g_n_FLocalization._shortMonthStrings["en"][3] = shortMonth[2];
					_s_g_n_FLocalization._shortMonthStrings["en"][4] = shortMonth[3];
					_s_g_n_FLocalization._shortMonthStrings["en"][5] = shortMonth[4];
					_s_g_n_FLocalization._shortMonthStrings["en"][6] = shortMonth[5];
					_s_g_n_FLocalization._shortMonthStrings["en"][7] = shortMonth[6];
					_s_g_n_FLocalization._shortMonthStrings["en"][8] = shortMonth[7];
					_s_g_n_FLocalization._shortMonthStrings["en"][9] = shortMonth[8];
					_s_g_n_FLocalization._shortMonthStrings["en"][10] = shortMonth[9];
					_s_g_n_FLocalization._shortMonthStrings["en"][11] = shortMonth[10];
					_s_g_n_FLocalization._shortMonthStrings["en"][12] = shortMonth[11];
				}
				
				var amPm/*Array*/ = sap.common.globalization.GlobalizationDateConstant.getAmPmToken();
				if (amPm)
				{
					_s_g_n_FLocalization._AmPms["en"][1] = amPm[0];
					_s_g_n_FLocalization._AmPms["en"][2] = amPm[1];
				}
			}
		}
		
		_s_g_n_FLocalization._resetAllStaticVars =function()
		{
			_s_g_n_FLocalization._DayStrings = null;
			_s_g_n_FLocalization._shortDayStrings = null;
			_s_g_n_FLocalization._MonthStrings = null;
			_s_g_n_FLocalization._shortMonthStrings = null;
			_s_g_n_FLocalization._DateTimeCodes = null;
			_s_g_n_FLocalization._NumericStrings = null;
			_s_g_n_FLocalization._DateTimeStrings = null;
			_s_g_n_FLocalization._CurrencySymbol = null;
			_s_g_n_FLocalization._SAPCurrencySymbol = null;
			_s_g_n_FLocalization._SAPDateString = null;
			_s_g_n_FLocalization._SAPTimeString = null;
			_s_g_n_FLocalization._SAPThousandsSeparator = null;
			_s_g_n_FLocalization._SAPDecimalSeparator = null;
			_s_g_n_FLocalization._SAPLongDay = null;
			_s_g_n_FLocalization._SAPShortDay = null;
			_s_g_n_FLocalization._SAPLongMonth = null;
			_s_g_n_FLocalization._SAPShortMonth = null;
			_s_g_n_FLocalization._AmPms = null
		}

})();
(function() {

	sap.common.globalization.declare("sap.common.globalization.utils.BaseUtils");
	
	var su = sap.common.globalization.utils.BaseUtils;

	// static private in globale to make re id is not duplicated
	var _sap_common_util_GEN_UID = 0;

	/**
	 * return the global uid for HTML elements in the same window scope.
	 * 
	 */
	sap.common.globalization.utils.BaseUtils.genUID = function() {
		if (!_sap_common_util_GEN_UID) {
			_sap_common_util_GEN_UID = 0;
		}
		return "xgen_" + (_sap_common_util_GEN_UID++);
	};
	
	
	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};
	/**
	 * apply properties to a item
	 * 
	 * @name sap.common.globalization.utils.BaseUtils.applyProperties 
	 * @memberOf Function.prototype
	 * @function
	 * @param {Object}
	 *            the item to apply properties
	 * @param {Array}
	 *            the properties array
	 * */
	sap.common.globalization.utils.BaseUtils.applyProperties =function(item , properties/*Array*/) 
	{
			if (properties != null) {							// apply the passed properties
				var len = properties.length;
				for (var i=0; i<len; i++) {
					var property = properties[i];
					if(property && property!=null)
					{
						this.applyObjectProperty(item,property.name,property.value);
					}
				}
			}
	}
	sap.common.globalization.utils.BaseUtils.applyObjectProperty=function(object,propertyName,propertyValue)
	{
		try{
				if (su.isFunction(object[propertyName]))
				{
					object[propertyName](propertyValue);
				}
				else if(object.hasOwnProperty(propertyName))
				{
					object[propertyName] = propertyValue;
				}
			}
			catch(e)
			{
				console.log(e);
			}
	
	};
	sap.common.globalization.utils.BaseUtils.getObjectProperty=function(object,propertyName)
	{
		try{
				if (su.isFunction(object[propertyName])) {
					return object[propertyName]();
				} else if(object.hasOwnProperty(propertyName)) {
					return object[propertyName];
				}

			}
			catch(e)
			{
				console.log(e);
			}
	};
	sap.common.globalization.utils.BaseUtils.type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};
	
	sap.common.globalization.utils.BaseUtils.isFunction = function(obj) {
		return su.type(obj) === "function";
	};
	
	sap.common.globalization.utils.BaseUtils.isBoolean = function(obj) {
		return su.type(obj) === "boolean";
	};
	
	sap.common.globalization.utils.BaseUtils.isString = function(obj) {
		return su.type(obj) === "string";
	};
	
	sap.common.globalization.utils.BaseUtils.isArray = function(obj) {
		return su.type(obj) === "array";
	};
	
	sap.common.globalization.utils.BaseUtils.isNumber = function(obj) {
		return su.type(obj) === "number";
	};
	
	sap.common.globalization.utils.BaseUtils.isRegExp = function(obj) {
		return su.type(obj) === "regexp";
	};
	
	/**
	 * Sort an object Array.
	 * 
	 * @param {Array} arr The object Array to sort.
	 * @param {String} prop The object field for the sort.
	 * @param {Boolean} [desc] Sort by ASC or DESC, by default is ASC.
	 * 		
	 */
	sap.common.globalization.utils.BaseUtils.sortArrayOn = function(arr, prop, desc) {
		if(su.isArray(arr) && su.isString(prop)){
			arr.sort(
	            function(a, b){
	                return desc ? 
	                	(a[prop] < b[prop]) - (a[prop] > b[prop]) :
	                		(a[prop] > b[prop]) - (a[prop] < b[prop]);
	            }
	        );
		}
    };
	
})();(function(){
	sap.common.globalization.declare("sap.common.globalization.utils.UnitAbbreviations");
	sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");

	/**
	 *  Tracks the string abbreviations for large numbers.
	 */

    //----------------------------------
    //  Constructor
    //----------------------------------
	
	sap.common.globalization.utils.UnitAbbreviations =function()
	{
		this.__className = "sap.common.globalization.utils.UnitAbbreviations";
		
		this.thousands = "K";
		this.millions = "M";
		this.billions = "B";
		this.trillions = "T";
	}
	
	sap.common.globalization.utils.UnitAbbreviations.prototype.toObject =function()/*Object*/
	{
		return {
		    "thousands": this.thousands, 
		    "millions": this.millions, 
		    "billions": this.billions, 
		    "trillions": this.trillions
	    };
	}
	
	sap.common.globalization.utils.UnitAbbreviations.prototype.copyFromObject =function(obj/*Object*/)/*Boolean*/
	{
		if (!obj)
	    {
	    	obj = {thousands: "K", millions: "M", billions: "B", trillions: "T"};
	    }
	    var changed/*Boolean*/ = false;
        for ( attr/*String*/ in ["thousands", "millions", "billions", "trillions"])
        {
            if (sap.common.globalization.utils.BaseUtils.isString(obj[attr])&& obj[attr] != this[attr])
            {
                this[attr] = obj[attr];
                changed = true;
            }
        }
        return changed;
	}

})();(function(){

	sap.common.globalization.declare("sap.common.globalization.utils.BooleanUtil");
	
	sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");
	
	 /**
	 * Check wether the value passed in is a boolean or string that represents a boolean.
	 *  
	 * @param value
	 * @return  
	 * 
	 */
	sap.common.globalization.utils.BooleanUtil.isBooleanValue = function(value /* Object */) /*boolean*/{

		if (sap.common.globalization.utils.BaseUtils.isBoolean(value))
		{
			return true;
		}
		else if (sap.common.globalization.utils.BaseUtils.isString(value))
		{
			return String(value).toLowerCase() == "true" || String(value).toLowerCase() == "false";
		}
		else
		{
			return false;
		}
	};

})();(function() {
	sap.common.globalization.declare("sap.common.globalization.utils.ColorUtil");

	sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");

	/**
	 * Helper function to convert number to hex String.
	 * @param color the color to be converted.
	 * @return string represting the <code>color</code> in hex.
	 */
	sap.common.globalization.utils.ColorUtil.convertToHexString = function(color) {
		if(color == null || !sap.common.globalization.utils.BaseUtils.isNumber(color) || isNaN(color))
			return null;

		var hex = "#", arr = ["r", "g", "b"], rgb = sap.common.globalization.utils.ColorUtil.convertToRGBObject(color);
		for(var i = 0, len = arr.length; i < len; i++) {
			var item = arr[i], primaryHex = rgb[item].toString(16);
			if(primaryHex.length == 1) {
				hex += "0";
			}
			hex += primaryHex;
		}
		return hex;
	};
	/**
	 * Helper function to convert number to rgb object
	 * @param {number} hex the number to be converted
	 * @return {object} object containing r, g, b properties indicating color.
	 */
	sap.common.globalization.utils.ColorUtil.convertToRGBObject = function(hex) {
		if(hex == null || !sap.common.globalization.utils.BaseUtils.isNumber(hex) || isNaN(hex))
			return null;

		return {
			r : (hex & 0xff0000) >> 16,
			g : (hex & 0x00ff00) >> 8,
			b : hex & 0x0000ff
		};
	};

})();
(function(){

	sap.common.globalization.declare("sap.common.globalization.utils.DataFormatUtils");
	
	sap.common.globalization.require("sap.common.globalization.utils.ColorUtil");
	
	/**
	 * Add <Font COLOR="XXX"> HTML snippet to the given text, according to the given color.
	 */
	sap.common.globalization.utils.DataFormatUtils.decorateColorHTML = function(text /*String*/, color/*Number*/)/*String*/
	{
		if (!isNaN(color))
		{
			return "<FONT COLOR=\"" + sap.common.globalization.utils.ColorUtil.convertToHexString(color) + "\"/>" + text + "</FONT>";
		}
		return text;
	};
	
	
	sap.common.globalization.utils.DataFormatUtils.DataFormatUtils = function()
	{
		throw new Error("Should not initialize DataFormatUtils.");
	};



})();(function(){
	sap.common.globalization.declare("sap.common.globalization.utils.NumberUtil");
	
	sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");
	sap.common.globalization.require("sap.common.globalization.utils.UnitAbbreviations");
	sap.common.globalization.require("sap.common.globalization.utils.StringUtil");
	
	/**
	 *  The NumberUtil class should contain utility functions for working with the <code>Number</code> type
	 */
	
	/**
	 *  The Flash player's support for floating point numbers is poor at times. Numbers may be
	 * 	returned from arithmetic with slight inaccuracies. For instance, a function might return
	 *  24.99999999 instead of 25. This function will compare two numbers more loosely than strict '=='.
	 *  It subtracts one number from the other. The result must be between 10^precision and its opposite.
	 *  (ie. -10^precision < (result of subtraction) < 10^precision)
	 * 
	 *  @param num1			Number	The first number to compare
	 *  @param num2			Number	The second number to compare
	 *  @param precision	int		Raise 10 to the power of this number to determine the range that will return a true result.
	 *  @return 			Boolean	true or false depending on if the values meet the loose equality requirements
	 */
	sap.common.globalization.utils.NumberUtil.checkEquality = function(num1, num2, precision){
		precision = precision || -5;
		//do a normal == check first just in case
		if(num1 == num2) return true;
			
		//calculate the range in which the numbers may be different
		var range/*Number*/ = Math.pow(10, precision - 1);
			
		var difference/*Number*/ = num1 - num2;
		return difference < range && difference > -range;
	};
		
	/**
	 *  Perform a <= check on floating point numbers.
	 * 
	 *  @param lhs			Number	The first number to compare (lefthand side of the operator)
	 *  @param rhs			Number	The second number to compare (righthand side of the operator)
	 *  @param precision	int		Raise 10 to the power of this number to determine the range that will return a true result.
	 * 
	 *  @return 			Boolean	true or false depending on if the values meet the < or loose equality requirements
	 */ 
	sap.common.globalization.utils.NumberUtil.lessThanEqual = function(lhs, rhs, precision){	
		precision = precision || -5;
		return ((lhs < rhs) || sap.common.globalization.utils.NumberUtil.checkEquality(lhs, rhs, precision));
	};

	/**
	 *  Perform a >= check on floating point numbers.
	 * 
	 *  @param lhs			Number	The first number to compare (lefthand side of the operator)
	 *  @param rhs			Number	The second number to compare (righthand side of the operator)
	 *  @param precision	int		Raise 10 to the power of this number to determine the range that will return a true result.
	 * 
	 *  @return 			Boolean	true or false depending on if the values meet the > or loose equality requirements
	 */
	sap.common.globalization.utils.NumberUtil.greaterThanEqual = function(lhs, rhs, precision){	
		precision = precision || -5;
		return ((lhs > rhs) || sap.common.globalization.utils.NumberUtil.checkEquality(lhs, rhs, precision));
	};
		
	/**
	 * Takes a floating point number and returns the precision (i.e., number of decimal places)
	 * 
	 * @param num	Number
	 * @return int
	 * 
	 */
	sap.common.globalization.utils.NumberUtil.getPrecision = function(num) {			
		var numString/*String*/ = String(num);
		var numStringLength/*int*/ = numString.length;
		var decimalIndex/*int*/ = numString.indexOf('.');
		var precision/*int*/ = numStringLength - (decimalIndex + 1);

		return precision;
	};
		
	/**
	 *  Rounds a floating-point Number to a specific number of decimal places.
	 *  This will introduce inaccuracy, but it is a useful way to format a Number for display as text.
	 *  The result may have fewer decimal places than the specified amount.
	 *  [Note] Rounding may cause precision problem since it uses division. That's the limitation
	 *  of math calculation of primitive Number in ActionScript.
	 * 
	 *  @param		numberToRound 	Number	the original Number that should have it's decimal places limited
	 *  @param		decimalPlaces	int		the desired precision of the result
	 *  @return		Number	a Number that has a less than or equal to the desired number of decimal places
	 */
	sap.common.globalization.utils.NumberUtil.roundToPrecision = function(numberToRound, decimalPlaces){
		/**
		 * ADAPT01347279: Use a heuristic way to minimize the impact of the precision problem
		 * of floating point manipulation. Try to avoid rounding.
		 * 
		 * First, get the fraction digit count.
		 * Second, get the best fraction digit. If the fraction part is shorter than the length specified
		 * by "decimalPlaces", then no need to do the rounding.
		 * Third, do the rounding if necessary.
		 */
		var str/*String*/ = numberToRound.toString(10);
		var strSplit/*Array*/ = str.split(".");
		var bestFractionDigit/*int*/ = (strSplit && strSplit.length > 1 ? strSplit[1].length : 0);
		if (bestFractionDigit <= decimalPlaces)
		{
			return numberToRound;
		}
		var roundingValue/*Number*/ = Math.pow(10, decimalPlaces);
		return Math.round(numberToRound * roundingValue) / roundingValue;
	};
		
	/**
	 *  Rounds a Number to the nearest multiple of another Number (i.e. nearest 10).
	 * 
	 *  @param numberToRound	Number	the number that will be rounded
	 *  @param multipleOf		Number	the result will be a multiple of this number
	 *  @param offset			Number	add this amount to the result
	 *  @return					Number	the rounded number
	 */
	sap.common.globalization.utils.NumberUtil.roundToNearest = function(numberToRound, multipleOf, offset)
	{
		multipleOf = multipleOf || 1;
		offset = offset || 0;
		return Math.round((numberToRound + offset) / multipleOf) * multipleOf - offset;
	};
		
	/**
	 * Abbreviate a number using the abbreviations provided
	 * 
	 * @param number 		Number		number to abbreviate
	 * @param abbreviations UnitAbbreviations	unit labels to use
	 * @param maxDecimals 	uint
	 * @return 				String formatted string representing the number in abbreviated form
	 */
	sap.common.globalization.utils.NumberUtil.abbreviate = function(number, abbreviations, maxDecimals) 
	{
		var thousand/*Number*/ = 1E3;
		var million/*Number*/ = 1E6;
		var billion/*Number*/ = 1E9;
		var trillion/*Number*/ = 1E12;
			
		abbreviations = abbreviations || null;
		maxDecimals = maxDecimals || 1;
			
		if (!abbreviations) {
			abbreviations = new sap.common.globalization.utils.UnitAbbreviations();
		}
			
		var abbr/*String*/ = "";
		var absNumber/*Number*/ = Math.abs(number);
			
		if (absNumber >= trillion) 
		{
			number /= trillion;
			abbr = abbreviations.trillions;
		}
		else if (absNumber >= billion)
		{
			number /= billion;
			abbr = abbreviations.billions;
		}
		else if (absNumber >= million)
		{
			number /= million;
			abbr = abbreviations.millions;
		}
		else if (absNumber >= thousand) 
		{
			number /= thousand;
			abbr = abbreviations.thousands;
		}
			
		number = sap.common.globalization.utils.NumberUtil.roundToPrecision(number, maxDecimals);
		return String(number) + abbr;
	};
		
	/**
	 * Parse an object to Number, if the object is not a Number or null,
	 * this method returns the default value specified in defaultValue parameter.
	 * 
	 * @param value 		Object		Object to parse to Number
	 * @param defaultValue	Number		The default value if the input is not a Number or null.
	 * @return 				Number		The parsed Number value, if the input is not a Number or null, the defaultValue will be returned.
	 */ 
	sap.common.globalization.utils.NumberUtil.parseNumber = function(value, defaultValue){
		var result/*Number*/ = defaultValue;
		if(value != null){
			var numValue/*Number*/ = Number(value);
			if(isNaN(numValue) == false){
				result = numValue;
			}
		}
		return result;
	};
		
		
	/**
	 * Check whether the data is number or numeric string.
	 *  
	 * @param data Object
	 * @return Boolean
	 * 
	 */
	sap.common.globalization.utils.NumberUtil.isNumericValue = function(data)
	{
		if (sap.common.globalization.utils.BaseUtils.isNumber(data) && !isNaN(data)){
			return true;
		} 
		else if (sap.common.globalization.utils.BaseUtils.isString(data)){
			return sap.common.globalization.utils.StringUtil.isNumber(String(data));
		}
		else{
			return false;
		}
	};

})();(function(){

	sap.common.globalization.declare("sap.common.globalization.utils.StringUtil");
	sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");
	
    /**
	 * Escape the Html entities in the string.
	 * 
	 * @param txtString
	 * @return 
	 * 
	 */
	sap.common.globalization.utils.StringUtil.escapeEntities =function(txtString /*String*/)/*String*/
	{
		if (txtString)
		{
			txtString = txtString.split("&").join("&amp;");
			txtString = txtString.split("<").join("&lt;");
			txtString = txtString.split(">").join("&gt;");
			txtString = txtString.split('"').join("&quot;");
			txtString = txtString.split("'").join("&apos;");				
		}
		return txtString;
	};
	
	sap.common.globalization.utils.StringUtil.trim = function(string/*string*/)/*string*/{
       return string.replace(/^\s*/, "").replace(/\s*$/, "")
    };
    
	
	sap.common.globalization.utils.StringUtil.isBlankString = function(val/*Object*/)/*Boolean*/ {
		if (val == null || !(sap.common.globalization.utils.BaseUtils.isString(val)))
		{
			return false;
		}
		return sap.common.globalization.utils.StringUtil.trim(val) === "";
	};


	sap.common.globalization.utils.StringUtil.isNumber =function(str/*String*/)/*Boolean*/ {
		if (isNaN(Number(str))) {
			return false;
		// Strings containing all spaces will get cast to 0 (i.e., a number)
		} else if (sap.common.globalization.utils.StringUtil.isBlankString(str)) {
			return false;
		} else {
			return true;
		}			
	}
	

     
})();(function()
// package xcelsius.globalization.numericFormat
{
	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");
	sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");
	sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDate");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
	sap.common.globalization.require("sap.common.globalization.numericFormat.");

	/**
	 * This class generate the locale info for Default Long Date format.
	 *
	 * @author jagu
	 *
	 */
	sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory = function() {
		this.__className = "sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory";
		// locale info for parsing date number format
		this._parseLocaleInfo = null;
		// locale info for displaying date number format
		this._displayLocaleInfo = null;
	}
	
	var _g_d_d = sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory;

	_g_d_d.prototype.getDateParseLocaleInfo = function()/*:IDateParseLocaleInfo*/
	{
		if(!this._parseLocaleInfo) {
			this._parseLocaleInfo = this.getPredefinedDateParseLocaleString();
		}
		return this._parseLocaleInfo;
	}

	_g_d_d.prototype.getDateDisplayLocaleInfo = function()/*:IDateDisplayLocaleInfo*/
	{
		if(!this._displayLocaleInfo) {
			this._displayLocaleInfo = this.getPredefinedDateDisplayLocaleString();

			// apply sap tokens and separators for date type if exists
			this.applySAPDateTokensAndSeparators(this._displayLocaleInfo);
		}
		return this._displayLocaleInfo;
	}

	_g_d_d.prototype.getDefaultDateFormat = function()/*:String*/
	{
		return sap.common.globalization.GlobalizationDateConstant.getDefaultLongDateFormat();
	}
	/**
	 * Create FDate subclass for parsing and displaying Default Date format.
	 *
	 * @return FDefaultDate instance
	 *
	 */
	_g_d_d.prototype.createFDate = function()/*:FDate*/
	{
		return new sap.common.globalization.numericFormat.FDefaultDate(this.getDateParseLocaleInfo(), this.getDateDisplayLocaleInfo());
	}
	/**
	 * @private
	 * Do nothig in this class, becuase for Default Long Date format, it is unnecessary to replace the date separator.
	 * Therefore, it is unnecessary to parse that separator.
	 *
	 * @param locale
	 * @return
	 *
	 */
	_g_d_d.prototype.getPredefinedDateParseLocaleString = function()/*:DateParseLocaleInfoImpl*/
	{
		return new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl();
	}

	_g_d_d.prototype.getPredefinedDateDisplayLocaleString = function()/*:DateDisplayLocaleInfoImpl*/
	{
		var localeInfo/*:DateDisplayLocaleInfoImpl*/ = new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();

		var longDay/*:Array*/ = sap.common.globalization.GlobalizationDateConstant.getLongDay();
		if(longDay) {
			localeInfo.IMSDAYNAME1(longDay[1]);
			localeInfo.IMSDAYNAME2(longDay[2]);
			localeInfo.IMSDAYNAME3(longDay[3]);
			localeInfo.IMSDAYNAME4(longDay[4]);
			localeInfo.IMSDAYNAME5(longDay[5]);
			localeInfo.IMSDAYNAME6(longDay[6]);
			localeInfo.IMSDAYNAME7(longDay[0]);
		}

		var shortDay/*:Array*/ = sap.common.globalization.GlobalizationDateConstant.getShortDay();
		if(shortDay) {
			localeInfo.IMSABBREVDAYNAME1(shortDay[1]);
			localeInfo.IMSABBREVDAYNAME2(shortDay[2]);
			localeInfo.IMSABBREVDAYNAME3(shortDay[3]);
			localeInfo.IMSABBREVDAYNAME4(shortDay[4]);
			localeInfo.IMSABBREVDAYNAME5(shortDay[5]);
			localeInfo.IMSABBREVDAYNAME6(shortDay[6]);
			localeInfo.IMSABBREVDAYNAME7(shortDay[0]);
		}

		var longMonth/*:Array*/ = sap.common.globalization.GlobalizationDateConstant.getLongMonth();
		if(longMonth) {
			localeInfo.IMSMONTHNAME1(longMonth[0]);
			localeInfo.IMSMONTHNAME2(longMonth[1]);
			localeInfo.IMSMONTHNAME3(longMonth[2]);
			localeInfo.IMSMONTHNAME4(longMonth[3]);
			localeInfo.IMSMONTHNAME5(longMonth[4]);
			localeInfo.IMSMONTHNAME6(longMonth[5]);
			localeInfo.IMSMONTHNAME7(longMonth[6]);
			localeInfo.IMSMONTHNAME8(longMonth[7]);
			localeInfo.IMSMONTHNAME9(longMonth[8]);
			localeInfo.IMSMONTHNAME10(longMonth[9]);
			localeInfo.IMSMONTHNAME11(longMonth[10]);
			localeInfo.IMSMONTHNAME12(longMonth[11]);
		}

		var shortMonth/*:Array*/ = sap.common.globalization.GlobalizationDateConstant.getShortMonth();
		if(shortMonth) {
			localeInfo.IMSABBREVMONTHNAME1(shortMonth[0]);
			localeInfo.IMSABBREVMONTHNAME2(shortMonth[1]);
			localeInfo.IMSABBREVMONTHNAME3(shortMonth[2]);
			localeInfo.IMSABBREVMONTHNAME4(shortMonth[3]);
			localeInfo.IMSABBREVMONTHNAME5(shortMonth[4]);
			localeInfo.IMSABBREVMONTHNAME6(shortMonth[5]);
			localeInfo.IMSABBREVMONTHNAME7(shortMonth[6]);
			localeInfo.IMSABBREVMONTHNAME8(shortMonth[7]);
			localeInfo.IMSABBREVMONTHNAME9(shortMonth[8]);
			localeInfo.IMSABBREVMONTHNAME10(shortMonth[9]);
			localeInfo.IMSABBREVMONTHNAME11(shortMonth[10]);
			localeInfo.IMSABBREVMONTHNAME12(shortMonth[11]);
		}

		// initialize the Abbrev Era string for Token G
		var abbrevEra/*:Array*/ = sap.common.globalization.GlobalizationDateConstant.getAbbrevEraString();
		if(abbrevEra && abbrevEra[1]) {
			// abbrevEra[1] - "AD" exists, then pass it to locale info
			// the supported dates are from 1900, so all of them belong to AD.
			localeInfo.IMEraToken(abbrevEra[1]);
		}

		return localeInfo;
	}
	_g_d_d.prototype.applySAPDateTokensAndSeparators = function (displayLocaleInfo/*:DateDisplayLocaleInfoImpl*/)/*:void*/
	{
		var floc/*:FLocalization*/ = sap.common.globalization.numericFormat.FLocalization.getInstance();

		if(floc.SAPShortDay) {
			displayLocaleInfo.IMSABBREVDAYNAME1(floc.SAPShortDay[0]);
			displayLocaleInfo.IMSABBREVDAYNAME2(floc.SAPShortDay[1]);
			displayLocaleInfo.IMSABBREVDAYNAME3(floc.SAPShortDay[2]);
			displayLocaleInfo.IMSABBREVDAYNAME4(floc.SAPShortDay[3]);
			displayLocaleInfo.IMSABBREVDAYNAME5(floc.SAPShortDay[4]);
			displayLocaleInfo.IMSABBREVDAYNAME6(floc.SAPShortDay[5]);
			displayLocaleInfo.IMSABBREVDAYNAME7(floc.SAPShortDay[6]);
		}

		if(floc.SAPLongDay) {
			displayLocaleInfo.IMSDAYNAME1(floc.SAPLongDay[0]);
			displayLocaleInfo.IMSDAYNAME2(floc.SAPLongDay[1]);
			displayLocaleInfo.IMSDAYNAME3(floc.SAPLongDay[2]);
			displayLocaleInfo.IMSDAYNAME4(floc.SAPLongDay[3]);
			displayLocaleInfo.IMSDAYNAME5(floc.SAPLongDay[4]);
			displayLocaleInfo.IMSDAYNAME6(floc.SAPLongDay[5]);
			displayLocaleInfo.IMSDAYNAME7(floc.SAPLongDay[6]);
		}

		if(floc.SAPShortMonth) {
			displayLocaleInfo.IMSABBREVMONTHNAME1(floc.SAPShortMonth[0]);
			displayLocaleInfo.IMSABBREVMONTHNAME2(floc.SAPShortMonth[1]);
			displayLocaleInfo.IMSABBREVMONTHNAME3(floc.SAPShortMonth[2]);
			displayLocaleInfo.IMSABBREVMONTHNAME4(floc.SAPShortMonth[3]);
			displayLocaleInfo.IMSABBREVMONTHNAME5(floc.SAPShortMonth[4]);
			displayLocaleInfo.IMSABBREVMONTHNAME6(floc.SAPShortMonth[5]);
			displayLocaleInfo.IMSABBREVMONTHNAME7(floc.SAPShortMonth[6]);
			displayLocaleInfo.IMSABBREVMONTHNAME8(floc.SAPShortMonth[7]);
			displayLocaleInfo.IMSABBREVMONTHNAME9(floc.SAPShortMonth[8]);
			displayLocaleInfo.IMSABBREVMONTHNAME10(floc.SAPShortMonth[9]);
			displayLocaleInfo.IMSABBREVMONTHNAME11(floc.SAPShortMonth[10]);
			displayLocaleInfo.IMSABBREVMONTHNAME12(floc.SAPShortMonth[11]);
		}

		if(floc.SAPLongMonth) {
			displayLocaleInfo.IMSMONTHNAME1(floc.SAPLongMonth[0]);
			displayLocaleInfo.IMSMONTHNAME2(floc.SAPLongMonth[1]);
			displayLocaleInfo.IMSMONTHNAME3(floc.SAPLongMonth[2]);
			displayLocaleInfo.IMSMONTHNAME4(floc.SAPLongMonth[3]);
			displayLocaleInfo.IMSMONTHNAME5(floc.SAPLongMonth[4]);
			displayLocaleInfo.IMSMONTHNAME6(floc.SAPLongMonth[5]);
			displayLocaleInfo.IMSMONTHNAME7(floc.SAPLongMonth[6]);
			displayLocaleInfo.IMSMONTHNAME8(floc.SAPLongMonth[7]);
			displayLocaleInfo.IMSMONTHNAME9(floc.SAPLongMonth[8]);
			displayLocaleInfo.IMSMONTHNAME10(floc.SAPLongMonth[9]);
			displayLocaleInfo.IMSMONTHNAME11(floc.SAPLongMonth[10]);
			displayLocaleInfo.IMSMONTHNAME12(floc.SAPLongMonth[11]);
		}
	}

})();
(function()
// package xcelsius.globalization.numericFormat
{
	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");

	var gd = sap.common.globalization.defaultFormat;

	gd.DefaultDateTimeFormatLocaleFactory = function() {
		gd.DefaultDateTimeFormatLocaleFactory.superclass.constructor.apply(this);
		this.__className = "sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory";
	}
	gd.DefaultDateTimeFormatLocaleFactory = sap.common.globalization.extend(gd.DefaultDateTimeFormatLocaleFactory, gd.DefaultDateFormatLocaleFactory);
	gd.DefaultDateTimeFormatLocaleFactory.prototype.getDefaultDateFormat = function()/*:String*/
	{
		return sap.common.globalization.GlobalizationDateConstant.getDefaultDateTimeFormat();
	}

	gd.DefaultDateTimeFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators = function(displayLocaleInfo/*:DateDisplayLocaleInfoImpl*/)/*:void*/
	{
		gd.DefaultDateTimeFormatLocaleFactory.superclass.applySAPDateTokensAndSeparators(displayLocaleInfo);
		var floc/*:FLocalization*/ = sap.common.globalization.numericFormat.FLocalization.getInstance();
		if(displayLocaleInfo && floc && floc.SAPTimeSeparator) {
			displayLocaleInfo.IMTimeSeparator(floc.SAPTimeSeparator);
		}
	}

	gd.DefaultDateTimeFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString = function()/*:DateParseLocaleInfoImpl*/
	{
		var localeInfo/*:DateParseLocaleInfoImpl*/ = gd.DefaultDateTimeFormatLocaleFactory.superclass.getPredefinedDateParseLocaleString()
		var timeSep/*:String*/ = sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();
		if(timeSep && localeInfo) {
			localeInfo.IMTimeSeparator(timeSep);
		}
		return localeInfo;
	}

	gd.DefaultDateTimeFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString = function()/*:DateDisplayLocaleInfoImpl*/
	{
		var localeInfo/*:DateDisplayLocaleInfoImpl*/ = gd.DefaultDateTimeFormatLocaleFactory.superclass.getPredefinedDateDisplayLocaleString();
		var timeSep/*:String*/ = sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();
		if(timeSep && localeInfo) {
			localeInfo.IMTimeSeparator(timeSep);
		}

		var amPM/*:Array*/ = sap.common.globalization.GlobalizationDateConstant.getAmPmToken();
		if(amPM && localeInfo) {
			localeInfo.IMAMTOKEN(amPM[0]);
			localeInfo.IMPMTOKEN(amPM[1]);
		}
		return localeInfo;
	}
})();
(function()
	// package xcelsius.globalization.numericFormat
{
	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
	
	var gd = sap.common.globalization.defaultFormat;
		gd.DefaultShortDateFormatLocaleFactory = function()
		{
			gd.DefaultShortDateFormatLocaleFactory.superclass.constructor.apply(this);
			this.__className = "sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory";
		}
		gd.DefaultShortDateFormatLocaleFactory = sap.common.globalization.extend(gd.DefaultShortDateFormatLocaleFactory, gd.DefaultDateFormatLocaleFactory);
		
		gd.DefaultShortDateFormatLocaleFactory.prototype.getDefaultDateFormat = function ()/*:String*/
		{
			return sap.common.globalization.GlobalizationDateConstant.getDefaultShorDateFormat();
		}
		
		gd.DefaultShortDateFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators = function (displayLocaleInfo/*:DateDisplayLocaleInfoImpl*/)/*:void*/
		{
			gd.DefaultShortDateFormatLocaleFactory.superclass.applySAPDateTokensAndSeparators(displayLocaleInfo);
			var floc/*:FLocalization*/ = sap.common.globalization.numericFormat.FLocalization.getInstance();
			// apply date separator
			if (displayLocaleInfo && floc && floc.SAPDateSeparator){
				displayLocaleInfo.IMDateSeparator(floc.SAPDateSeparator);
			}
		}
		
		gd.DefaultShortDateFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString = function ()/*:DateParseLocaleInfoImpl*/
		{
			var localeInfo/*:DateParseLocaleInfoImpl*/ = gd.DefaultShortDateFormatLocaleFactory.superclass.getPredefinedDateParseLocaleString();
			var dateSep/*:String*/ = sap.common.globalization.GlobalizationDateConstant.getDateSeparator();
			if (dateSep && localeInfo){
				localeInfo.IMDateSeparator(dateSep);
			}
			return localeInfo;
		}
		
		gd.DefaultShortDateFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString = function ()/*:DateDisplayLocaleInfoImpl*/
		{
			var localeInfo/*:DateDisplayLocaleInfoImpl*/ = gd.DefaultShortDateFormatLocaleFactory.superclass.getPredefinedDateDisplayLocaleString();
			var dateSep/*:String*/ = sap.common.globalization.GlobalizationDateConstant.getDateSeparator();
			if (dateSep && localeInfo){
				localeInfo.IMDateSeparator(dateSep);
			}
			return localeInfo;
		}
		
})();
(function(){

		sap.common.globalization.declare("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");

		sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo = function()
		{
			this.__className = "sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo";
			this._trueString/*String*/ = ""; 
			this._falseString/*String*/ = "";
		}
		
		// trueString get set
		sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo.prototype.trueString = function(value)/*String*/
		{
			if(arguments.length>=1){
				//set
				this._trueString = value;
				return this;
			}else{
				//get
				return this._trueString;
			}
		}
		
		// falseString get set
		sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo.prototype.falseString =function(value)/*String*/
		{
			if(arguments.length>=1){
				//set
				this._falseString = value;
				return this;
			}else{
				//get
				return this._falseString;
			}
		}
})();(function()
// package xcelsius.globalization.numericFormat
{
	sap.common.globalization.declare("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");
	sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateForPVL");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");
	sap.common.globalization.require("sap.common.globalization.utils.StringUtil");

	var _g_d = sap.common.globalization.defaultFormat;
	_g_d.CustomDateFormatLocaleFactory = function() {
		this.__className = "sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory";
		this._dateParseLocaleInfo = null;
		this._dateDisplayLocaleInfo = null;
	}

	_g_d.CustomDateFormatLocaleFactory._instance = null;
	
	_g_d.CustomDateFormatLocaleFactory.getInstance = function()/*:CustomDateFormatLocaleFactory*/
	{
		if(!_g_d.CustomDateFormatLocaleFactory._instance) {
			_g_d.CustomDateFormatLocaleFactory._instance = new _g_d.CustomDateFormatLocaleFactory();
		}
		return _g_d.CustomDateFormatLocaleFactory._instance;
	}
	_g_d.CustomDateFormatLocaleFactory.prototype.getDateParseLocaleInfo = function()/*:IDateParseLocaleInfo*/
	{
		if(!this._dateParseLocaleInfo) {
			this._dateParseLocaleInfo = sap.common.globalization.numericFormat.FLocalization.getInstance().getDateParseLocaleInfo();
		}
		return this._dateParseLocaleInfo;
	}

	_g_d.CustomDateFormatLocaleFactory.prototype.getDateDisplayLocaleInfo = function()/*:IDateDisplayLocaleInfo*/
	{
		if(!this._dateDisplayLocaleInfo) {
			this._dateDisplayLocaleInfo = sap.common.globalization.numericFormat.FLocalization.getInstance().getDateDisplayLocaleInfo();
		}
		return this._dateDisplayLocaleInfo;
	}

	_g_d.CustomDateFormatLocaleFactory.prototype.createFDate = function()/*:FDate*/
	{
		var pvlExist/*:Boolean*/ = sap.common.globalization.GlobalizationPreference.getInstance().pvl() && !sap.common.globalization.utils.StringUtil.isBlankString(sap.common.globalization.GlobalizationPreference.getInstance().pvl());
		if(pvlExist) {
			// use FDateForPVL is pvl exists, for special handling in short day strings
			return new sap.common.globalization.numericFormat.FDateForPVL(this.getDateParseLocaleInfo(), this.getDateDisplayLocaleInfo());
		} else {
			return new sap.common.globalization.numericFormat.FDate(/*this.getDateParseLocaleInfo()*/null, this.getDateDisplayLocaleInfo());
		}
	}
})();
(function(){

		sap.common.globalization.declare("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");
		sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
		sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");
		
		//Construct
		sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory =function()
		{
			this.__className = "sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory";
			
		}
		
		var _s_g_df_cNumericFLFactory = sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory;
		
		_s_g_df_cNumericFLFactory._instance/*CustomNumericFormatLocaleFactory*/ = null; // TODO default is null.
				
		_s_g_df_cNumericFLFactory.getInstance= function()/*CustomNumericFormatLocaleFactory*/
		{
			if (!_s_g_df_cNumericFLFactory._instance){
				_s_g_df_cNumericFLFactory._instance = new sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory();
			}
			return _s_g_df_cNumericFLFactory._instance;
		}
		
		_s_g_df_cNumericFLFactory.prototype.getNumericParseLocaleInfo =function()/*INumericParseLocaleInfo*/
		{
			// return the one in FLocalization.
			return sap.common.globalization.numericFormat.FLocalization.getInstance().numericParseLocaleInfo();
		}
		
		_s_g_df_cNumericFLFactory.prototype.getNumericDisplayLocaleInfo =function()/*INumericDisplayLocaleInfo*/
		{
			// return the one in FLocalization.
			return sap.common.globalization.numericFormat.FLocalization.getInstance().numericDisplayLocaleInfo();
		}
		
		_s_g_df_cNumericFLFactory.prototype.createFNumber =function()/*FNumber*/
		{
			// use the previous one for non-default formats.
			return new sap.common.globalization.numericFormat.FNumber(this.getNumericParseLocaleInfo(), this.getNumericDisplayLocaleInfo());
		}
})();(function() {
	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");
	sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl = function() {
		this.__className = "sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl";
		// Date Separator
		this._IMDateSeparator = null;

		// Long Month Tokens
		this._IMSMONTHNAME1 = null;
		this._IMSMONTHNAME2 = null;
		this._IMSMONTHNAME3 = null;
		this._IMSMONTHNAME4 = null;
		this._IMSMONTHNAME5 = null;
		this._IMSMONTHNAME6 = null;
		this._IMSMONTHNAME7 = null;
		this._IMSMONTHNAME8 = null;
		this._IMSMONTHNAME9 = null;
		this._IMSMONTHNAME10 = null;
		this._IMSMONTHNAME11 = null;
		this._IMSMONTHNAME12 = null;

		// Short Month Tokens
		this._IMSABBREVMONTHNAME1 = null;
		this._IMSABBREVMONTHNAME2 = null;
		this._IMSABBREVMONTHNAME3 = null;
		this._IMSABBREVMONTHNAME4 = null;
		this._IMSABBREVMONTHNAME5 = null;
		this._IMSABBREVMONTHNAME6 = null;
		this._IMSABBREVMONTHNAME7 = null;
		this._IMSABBREVMONTHNAME8 = null;
		this._IMSABBREVMONTHNAME9 = null;
		this._IMSABBREVMONTHNAME10 = null;
		this._IMSABBREVMONTHNAME11 = null;
		this._IMSABBREVMONTHNAME12 = null;

		// Long Day Tokens
		this._IMSDAYNAME1 = null;
		this._IMSDAYNAME2 = null;
		this._IMSDAYNAME3 = null;
		this._IMSDAYNAME4 = null;
		this._IMSDAYNAME5 = null;
		this._IMSDAYNAME6 = null;
		this._IMSDAYNAME7 = null;

		// Short Day Tokens
		this._IMSABBREVDAYNAME1 = null;
		this._IMSABBREVDAYNAME2 = null;
		this._IMSABBREVDAYNAME3 = null;
		this._IMSABBREVDAYNAME4 = null;
		this._IMSABBREVDAYNAME5 = null;
		this._IMSABBREVDAYNAME6 = null;
		this._IMSABBREVDAYNAME7 = null;

		// Time separator
		this._IMTimeSeparator = null;

		// AM/PM tokens
		this._IMAMToken = null;
		this._IMPMToken = null;

		// Era token
		this._IMEraToken = null;
	}
	var _g_d_d = sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl;
	// Date Separator
	_g_d_d.prototype.IMDateSeparator = function(value) {
		if(arguments.length >= 1) {
			this._IMDateSeparator = value;
		} else {
			return this._IMDateSeparator;
		}
	};
	// Long Month Tokens
	_g_d_d.prototype.IMSMONTHNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME1 = value;
		} else {
			return this._IMSMONTHNAME1;
		}
	};
	_g_d_d.prototype.IMSMONTHNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME2 = value;
		} else {
			return this._IMSMONTHNAME2;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME3 = value;
		} else {
			return this._IMSMONTHNAME3;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME4 = value;
		} else {
			return this._IMSMONTHNAME4;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME5 = value;
		} else {
			return this._IMSMONTHNAME5;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME6 = value;
		} else {
			return this._IMSMONTHNAME6;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME7 = value;
		} else {
			return this._IMSMONTHNAME7;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME8 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME8 = value;
		} else {
			return this._IMSMONTHNAME8;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME9 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME9 = value;
		} else {
			return this._IMSMONTHNAME9;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME10 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME10 = value;
		} else {
			return this._IMSMONTHNAME10;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME11 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME11 = value;
		} else {
			return this._IMSMONTHNAME11;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME12 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME12 = value;
		} else {
			return this._IMSMONTHNAME12;
		}
	};
	// Short Month Tokens
	_g_d_d.prototype.IMSABBREVMONTHNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME1 = value;
		} else {
			return this._IMSABBREVMONTHNAME1;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME2 = value;
		} else {
			return this._IMSABBREVMONTHNAME2;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME3 = value;
		} else {
			return this._IMSABBREVMONTHNAME3;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME4 = value;
		} else {
			return this._IMSABBREVMONTHNAME4;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME5 = value;
		} else {
			return this._IMSABBREVMONTHNAME5;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME6 = value;
		} else {
			return this._IMSABBREVMONTHNAME6;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME7 = value;
		} else {
			return this._IMSABBREVMONTHNAME7;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME8 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME8 = value;
		} else {
			return this._IMSABBREVMONTHNAME8;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME9 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME9 = value;
		} else {
			return this._IMSABBREVMONTHNAME9;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME10 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME10 = value;
		} else {
			return this._IMSABBREVMONTHNAME10;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME11 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME11 = value;
		} else {
			return this._IMSABBREVMONTHNAME11;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME12 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME12 = value;
		} else {
			return this._IMSABBREVMONTHNAME12;
		}
	};
	// Long Day Tokens
	_g_d_d.prototype.IMSDAYNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME1 = value;
		} else {
			return this._IMSDAYNAME1;
		}
	};

	_g_d_d.prototype.IMSDAYNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME2 = value;
		} else {
			return this._IMSDAYNAME2;
		}
	};

	_g_d_d.prototype.IMSDAYNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME3 = value;
		} else {
			return this._IMSDAYNAME3;
		}
	};
	_g_d_d.prototype.IMSDAYNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME4 = value;
		} else {
			return this._IMSDAYNAME4;
		}
	};
	_g_d_d.prototype.IMSDAYNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME5 = value;
		} else {
			return this._IMSDAYNAME5;
		}
	};
	_g_d_d.prototype.IMSDAYNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME6 = value;
		} else {
			return this._IMSDAYNAME6;
		}
	};
	_g_d_d.prototype.IMSDAYNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME7 = value;
		} else {
			return this._IMSDAYNAME7;
		}
	};
	// Short Day Tokens
	_g_d_d.prototype.IMSABBREVDAYNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME1 = value;
		} else {
			return this._IMSABBREVDAYNAME1;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME2 = value;
		} else {
			return this._IMSABBREVDAYNAME2;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME3 = value;
		} else {
			return this._IMSABBREVDAYNAME3;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME4 = value;
		} else {
			return this._IMSABBREVDAYNAME4;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME5 = value;
		} else {
			return this._IMSABBREVDAYNAME5;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME6 = value;
		} else {
			return this._IMSABBREVDAYNAME6;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME7 = value;
		} else {
			return this._IMSABBREVDAYNAME7;
		}
	};
	// Time separator
	_g_d_d.prototype.IMTimeSeparator = function(value) {
		if(arguments.length >= 1) {
			this._IMTimeSeparator = value;
		} else {
			return this._IMTimeSeparator;
		}
	};
	// AM/PM tokens
	_g_d_d.prototype.IMAMTOKEN = function(value) {
		if(arguments.length >= 1) {
			this._IMAMToken = value;
		} else {
			return this._IMAMToken;
		}
	};
	_g_d_d.prototype.IMPMTOKEN = function(value) {
		if(arguments.length >= 1) {
			this._IMPMToken = value;
		} else {
			return this._IMPMToken;
		}
	};
	// Era token
	_g_d_d.prototype.IMEraToken = function(value) {
		if(arguments.length >= 1) {
			this._IMEraToken = value;
		} else {
			return this._IMEraToken;
		}
	};
})();
(function() {

	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");

	sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl = function() {
		this.__className = "sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl";
		this._IMDateSeparator/*:String*/ = null;
		this._IMTimeSeparator/*:String*/ = null;

	};

	sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl.prototype.IMDateSeparator = function(value)/*:String*/
	{
		if(arguments.length >= 1) {
			//set
			this._IMDateSeparator = value;
		} else {
			//get
			return this._IMDateSeparator;
		}
	}

	sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl.prototype.IMTimeSeparator = function(value)/*:String*/
	{
		if(arguments.length >= 1) {
			//set
			this._IMTimeSeparator = value;
		} else {
			//get
			return this._IMTimeSeparator;
		}
	}
})();
(function() {

	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");
	sap.common.globalization.require("sap.common.globalization.GlobalizationBooleanConstant");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");
	
		
	// construct
	sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory =function()
	{
		this.className = "sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory";
		this._displayLocale/*BooleanDisplayLocaleInfo*/ = null; // TODO default value is null
	}
	
	var _s_g_df_dBooleanFLFactory = sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory;
	_s_g_df_dBooleanFLFactory._instance/*DefaultBooleanFormatLocaleFactory*/ = null; //TODO default value is null.
	
	_s_g_df_dBooleanFLFactory.getInstance = function()/*DefaultBooleanFormatLocaleFactory*/
	{
		if (!_s_g_df_dBooleanFLFactory._instance)
		{
			_s_g_df_dBooleanFLFactory._instance = new sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory();
		}
		return _s_g_df_dBooleanFLFactory._instance;
	}
	
	_s_g_df_dBooleanFLFactory.prototype.getBooleanDisplayLocaleInfo = function()/*IBooleanDisplayLocaleInfo*/
	{
		if (!this._displayLocale)
		{
			this._displayLocale = new sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo();
			var booleanStrings/*Array*/ = sap.common.globalization.GlobalizationBooleanConstant.getBooleanStrings();
			if (booleanStrings)
			{
				this._displayLocale.trueString(booleanStrings[0]); // trueString is function
				this._displayLocale.falseString(booleanStrings[1]); // falseString is funtion
			}
		}
		return this._displayLocale;
	}
	
})();(function() {

	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");
	
	sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");
	sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultNumber");
	sap.common.globalization.require("sap.common.globalization.GlobalizationNumericUtil");
	sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");
	sap.common.globalization.require("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");


	sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory =function()
	{
		//TODO: implement function
		this.__className = "sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory.DefaultNumericFormatLocaleFactory";
		// loclae info of default numeric type for parsing
		
		this._numericParseLocaleInfo/*NumericParseLocaleInfoImpl*/ = null; // TODO default value is null.
		
		// loclae info of default numeric type for displaying
		this._numericDisplayLocaleInfo/*NumericDisplayLocaleInfoImpl*/ = null; // TODO default value is null.
		
	}

	var _s_g_d_dNumericFLFactory =  sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory;

	
	_s_g_d_dNumericFLFactory.prototype.getNumericParseLocaleInfo =function()/*INumericParseLocaleInfo*/
	{
		var _s_g = sap.common.globalization;
		if (!this._numericParseLocaleInfo)
		{
			this._numericParseLocaleInfo = new _s_g.defaultFormat.NumericParseLocaleInfoImpl(_s_g.GlobalizationNumericConstant.getParseThousandSeparator(),
				 _s_g.GlobalizationNumericConstant.getParseDecimalSeparator(), _s_g.GlobalizationNumericConstant.getParseCurrencySymbol());
		}	
		return this._numericParseLocaleInfo;
	}
	
	_s_g_d_dNumericFLFactory.prototype.getNumericDisplayLocaleInfo =function()/*INumericDisplayLocaleInfo*/
	{
		if (!this._numericDisplayLocaleInfo)
		{
			// default to EN
			var thousandsSeparator/*String*/ = ",";
			var decimalSeparator/*String*/ = ".";
			
			var _s_g =  sap.common.globalization;
			
			// first try to apply SAP separators for display
			if (_s_g.numericFormat.FLocalization.getInstance().SAPThousandsSeparator)
			{
				thousandsSeparator = _s_g.numericFormat.FLocalization.getInstance().SAPThousandsSeparator;
			}
			else if (_s_g.GlobalizationNumericConstant.getDisplayThousandSeparator())
			{
				thousandsSeparator = _s_g.GlobalizationNumericConstant.getDisplayThousandSeparator();
			}
			
			if (_s_g.numericFormat.FLocalization.getInstance().SAPDecimalSeparator)
			{
				decimalSeparator = _s_g.numericFormat.FLocalization.getInstance().SAPDecimalSeparator;
			}
			else if (_s_g.GlobalizationNumericConstant.getDisplayDecimalSeparator())
			{
				decimalSeparator = _s_g.GlobalizationNumericConstant.getDisplayDecimalSeparator();
			}
			
			var currencySymbol/*String*/ = (_s_g.numericFormat.FLocalization.getInstance().SAPCurrencySymbol ? _s_g.numericFormat.FLocalization.getInstance().SAPCurrencySymbol : this.displayCurrencySymbol());
			
			this._numericDisplayLocaleInfo = new _s_g.defaultFormat.NumericDisplayLocaleInfoImpl(thousandsSeparator, decimalSeparator, currencySymbol);
			
		}
		return this._numericDisplayLocaleInfo;
	}
	
	_s_g_d_dNumericFLFactory.prototype.createFNumber=function()/*FNumber*/
	{
		var fNumber/*FDefaultNumber*/ = new sap.common.globalization.numericFormat.FDefaultNumber(this.getNumericParseLocaleInfo(), this.getNumericDisplayLocaleInfo());
		if (sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry(sap.common.globalization.GlobalizationNumericConstant.getActualLocaleForDefaultNumberFormat()))
		{
			fNumber.groupingStrategy = sap.common.globalization.numericFormat.TwoDigitGroupingStrategy.instance();
		}
		return fNumber;
	}
	
	/**
	 * Get default predefined number format string according to the current locale.
	 * If the pvl is available, get the predefined format string according to pvl. Otherwise, getting the predefined
	 * string according to the document locale.
	 *  
	 * @param type type for default format string. e.g. FORMAT_TYPE_SHORTDATE
	 * @return the predefined format string or return EN if it is not defined.
	 */
	_s_g_d_dNumericFLFactory.prototype.getDefaultNumericFormat =function()/*String*/
	{
		if (sap.common.globalization.GlobalizationNumericConstant.getDefaultNumberFormat())
		{
			return sap.common.globalization.GlobalizationNumericConstant.getDefaultNumberFormat()
		}
		// fall bcak to EN
		return "#,##0.###";
	}
	
	_s_g_d_dNumericFLFactory.prototype.displayCurrencySymbol=function()/*String*/
	{
		return "";
	}
})();(function()
{
	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
	var gd = sap.common.globalization.defaultFormat;
		gd.DefaultTimeFormatLocaleFactory = function()
		{
			gd.DefaultTimeFormatLocaleFactory.superclass.constructor.apply(this);
			this.__className = "sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory";
		}
		gd.DefaultTimeFormatLocaleFactory = sap.common.globalization.extend(gd.DefaultTimeFormatLocaleFactory, gd.DefaultDateFormatLocaleFactory);
		
		gd.DefaultTimeFormatLocaleFactory.prototype.getDefaultDateFormat = function ()/*String*/
		{
			return sap.common.globalization.GlobalizationDateConstant.getDefaultTimeFormat();
		}
		
		gd.DefaultTimeFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators = function (displayLocaleInfo)
		{
			var floc = sap.common.globalization.numericFormat.FLocalization.getInstance();
			if (displayLocaleInfo && floc && floc.SAPTimeSeparator)
			{
				displayLocaleInfo.IMTimeSeparator(floc.SAPTimeSeparator);
			}
		}
		
		gd.DefaultTimeFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString = function ()
		{
			var localeInfo = new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl();
			var timeSep/*:String*/ = sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();
			if (timeSep && localeInfo){
				localeInfo.IMTimeSeparator(timeSep);	
			}
			return localeInfo;
		}
		
		gd.DefaultTimeFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString = function ()
		{
			var localeInfo = new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();
			var timeSep/*String*/ = sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();
			if (timeSep && localeInfo){
				localeInfo.IMTimeSeparator(timeSep);	
			}
			
			var amPM/*:Array*/ = sap.common.globalization.GlobalizationDateConstant.getAmPmToken();
			if (amPM && localeInfo)
			{
				localeInfo.IMAMTOKEN(amPM[0]);
				localeInfo.IMPMTOKEN(amPM[1]);
			}
			return localeInfo;
		}
		
})();(function(){

		sap.common.globalization.declare("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");
		
		sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl = function(thousandsSep/*String*/, decimalSep/*String*/, currencySym/*String*/)
		{
			if (thousandsSep)
			{
				this._thousandsSeparator = thousandsSep;
			}
			else
			{
				this._thousandsSeparator = ",";
				
			}
			
			if (decimalSep)
			{
				this._decimalSeparator = decimalSep;
			}
			else{
				this._decimalSeparator = ".";
			}
			
			if (currencySym)
			{
				this._currencySymbol = currencySym;
			}
			else
			{
				this._currencySymbol = "";
			}
		}
			
		sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.thousandsSeparator = function() /*String*/
		{
			return this._thousandsSeparator;
		}
			
		sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.decimalSeparator= function() /*String*/
		{
			return this._decimalSeparator;
		}
		
		sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.currencySymbol= function() /*String*/
		{
			return this._currencySymbol;
		}
		
})();(function(){

		sap.common.globalization.declare("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");

		sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl = function(thousandsSep/*String*/, decimalSep/*String*/, currencySym/*String*/)
		{
			
			if (thousandsSep)
			{
				this._thousandsSeparator = thousandsSep;
			}
			else
			{
				this._thousandsSeparator = ","; //				
			}
			
			if (decimalSep)
			{
				this._decimalSeparator = decimalSep;
			}
			else
			{
				this._decimalSeparator = ".";				
			}
			
			if (currencySym)
			{
				this._currencySymbol = currencySym;
			}
			else
			{
				this._currencySymbol =  "";
			}
		}
			
		sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.thousandsSeparator = function()/*String*/
		{
			return this._thousandsSeparator;
		}
			
		sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.decimalSeparator= function()/*String*/
		{
			return this._decimalSeparator;
		}
		
		sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.currencySymbol= function()/*String*/
		{
			return this._currencySymbol;
		};


})();(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateA");

	var gn = sap.common.globalization.numericFormat;
	gn.FDateA = function(displayLocale/*IDateDisplayLocaleInfo*/) {
		this.__className = "sap.common.globalization.numericFormat.FDateA";
		this._full = true;/*Boolean*/
		this._displayLocale = displayLocale;

	}
	gn.FDateA.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var i/*:int*/ = 0;
		var l/*:String*/ = format.toLowerCase();
		if(l.substr(0, 5) == "am/pm") {
			o.miltime = false;
			i = 5;
		}

		if(l.substr(0, 3) == "a/p") {
			o.miltime = false;
			this._full = false;
			i = 3;
		}
		return i;
	}
	gn.FDateA.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var str/*:String*/ = "";
		if(o.getHrs() >= 12) {
			if(this._full) {
				str = this._displayLocale.IMPMTOKEN() ? this._displayLocale.IMPMTOKEN() : "PM";
			} else {
				str = this._displayLocale.IMPMTOKEN() ? this._displayLocale.IMPMTOKEN() : "P";
			}
		} else {
			if(this._full) {
				str = this._displayLocale.IMAMTOKEN() ? this._displayLocale.IMAMTOKEN() : "AM";
			} else {
				str = this._displayLocale.IMAMTOKEN() ? this._displayLocale.IMAMTOKEN() : "A";
			}
		}
		return str;
	}
})();(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateB");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");

	// % handling
	var gn = sap.common.globalization.numericFormat;
	gn.FDateB = function(displayLocale/*:IDateDisplayLocaleInfo*/) {

		this.__className = "sap.common.globalization.numericFormat.FDateB";
		this._displayLocaleInfo = displayLocale;
		this.mask = undefined;/***/
		this.c = ""/*undefined*/;/*String*/
		this._tok = {};/*Object*/
		this.initializeTokenMap();

	}
	gn.FDateB.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var i/*:int*/ = 2;
		// [ and ]
		this.c = format.charAt(1);
		// hokey actionscript stuff
		var r/*:**/ = this.createTokenFormatter(this._tok[this.c]);
		if(this.c == 'M' || this.c == 'm') {
			r.bminute = true;
		}
		var ret/*:int*/ = r.parse(o, format.substring(1));
		if(ret > 0) {
			this.mask = r;
			i += ret;
		}
		return i;
	}
	gn.FDateB.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var s/*:Number*/;
		if(this.c == 'S' || this.c == 's') {
			s = 86400 * o.serial;
		} else if(this.c == 'M' || this.c == 'm') {
			s = 1440 * o.serial;
		} else if(this.c == 'H' || this.c == 'h') {
			s = 24 * o.serial;
		}
		this.mask.value = Math.floor(s);
		return this.mask.display(o);
	}
	/**
	 * Initialize the token classes for further parse and display.
	 *
	 * @param clazz
	 * @return
	 *
	 */
	gn.FDateB.prototype.createTokenFormatter = function(clazz/*:Class*/)/*:Object*/
	{
		var token/*:Object*/ = null;
		switch(clazz) {
			case gn.FDateM:
				token = new gn.FDateM(this._displayLocaleInfo);
				break;
			case gn.FDateH:
				token = new gn.FDateH();
				break;
			case gn.FDateS:
				token = new gn.FDateS();
				break;
			default:
			// this should not happend since there's check before call this method
		}
		return token;
	}
	/**
	 * Initialize the tokens map for further parsing and displaying.
	 *
	 */
	gn.FDateB.prototype.initializeTokenMap = function() {
		this._tok["M"] = gn.FDateM;
		this._tok["H"] = gn.FDateH;
		this._tok["S"] = gn.FDateS;
		this._tok["m"] = gn.FDateM;
		this._tok["h"] = gn.FDateH;
		this._tok["s"] = gn.FDateS;
	}
})();
(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateD");
	
	var gn = sap.common.globalization.numericFormat;
	gn.FDateD = function(displayLocaleInfo/*IDateDisplayLocaleInfo*/) {
		this.__className = "sap.common.globalization.numericFormat.FDateD";
		this._placeholders = 0;
		//int

		this._displayLocaleInfo = displayLocaleInfo;
		// IDateDisplayLocaleInfo
	}
	gn.FDateD.prototype.getPlaceholders = function()/*:int*/
	{
		return this._placeholders;
	}

	gn.FDateD.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var i/*:int*/ = 0;
		// figure out day/date and _placeholders
		while(format.charAt(i) == 'D' || format.charAt(i) == 'd') {
			i++;
		}
		if(i <= 2) {
			// significant digits of date
			this._placeholders = i;
		} else if(i == 3) {
			// short day format
			this._placeholders = -1;
		} else if(i >= 4) {
			// long day format
			this._placeholders = -2;
		}
		return i;
	}
	gn.FDateD.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var str/*:String*/ = "";
		if(this._placeholders >= 0) {
			str += o.getDate();
			while(str.length < this._placeholders) {
				str = '0' + str;
			}
		} else {
			var day/*:Number*/ = o.getDay();
			if(this._placeholders == -1) {
				str += this.getShortDay(day);
			} else {
				str += this.getDay(day);
			}
		}
		return str;
	}

	gn.FDateD.prototype.getDay = function(day/*:Number*/)/*:String*/
	{
		if(day == 0) {
			return this._displayLocaleInfo.IMSDAYNAME7();
		}
		if(day == 1) {
			return this._displayLocaleInfo.IMSDAYNAME1();
		}
		if(day == 2) {
			return this._displayLocaleInfo.IMSDAYNAME2();
		}
		if(day == 3) {
			return this._displayLocaleInfo.IMSDAYNAME3();
		}
		if(day == 4) {
			return this._displayLocaleInfo.IMSDAYNAME4();
		}
		if(day == 5) {
			return this._displayLocaleInfo.IMSDAYNAME5();
		}
		if(day == 6 || day == -1) {
			return this._displayLocaleInfo.IMSDAYNAME6();
		}
		// should never happen
		return this._displayLocaleInfo.IMSDAYNAME6();
	}

	gn.FDateD.prototype.getShortDay = function(day/*:Number*/)/*:String*/
	{
		if(day == 0) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME7().split(".")[0];
		}
		if(day == 1) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME1().split(".")[0];
		}
		if(day == 2) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME2().split(".")[0];
		}
		if(day == 3) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME3().split(".")[0];
		}
		if(day == 4) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME4().split(".")[0];
		}
		if(day == 5) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME5().split(".")[0];
		}
		if(day == 6 || day == -1) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME6().split(".")[0];
		}
		// should never happen
		return this._displayLocaleInfo.IMSABBREVDAYNAME6().split(".")[0];
	}
})();
(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateH");
	var gn = sap.common.globalization.numericFormat;
	gn.FDateH = function() {
		this.__className = "sap.common.globalization.numericFormat.FDateH";
		this.placeholders/*int*/ = 1;
		this.number/*Number*/ = 0;
		this.value/*Number*/ = NaN;
	}
	sap.common.globalization.numericFormat.FDateH.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var i/*:int*/ = 0;
		this.number = o.HNum + 1;
		o.HBool = true;
		o.HNum = this.number;
		while(format.charAt(i) == 'H' || format.charAt(i) == 'h') {
			i++;
		}
		if(i > 1) {
			this.placeholders = 2;
		}
		return i;
	}
	gn.FDateH.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var h/*:Number*/;
		if(isNaN(this.value))
			h = o.getHrs();
		else
			h = this.value;
		if(!o.miltime) {
			if(this.number == o.HNum) {
				if(h > 11) {
					h = h - 12;
				}
				if(h == 0) {
					h = 12;
				}
			}
		}

		var str/*:String*/ = "" + h;
		while(this.placeholders > str.length) {
			str = '0' + str;
		}
		return str;
	}
})();
(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateM");
	var gn = sap.common.globalization.numericFormat;
	gn.FDateM = function(displayLocaleInfo/*:IDateDisplayLocaleInfo*/) {
		this.__className = "sap.common.globalization.numericFormat.FDateM";
		this.bminute = false;
		this.placeholders = 0;
		this.value = undefined;
		this._displayLocaleInfo = displayLocaleInfo;
	}
	gn.FDateM.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var i/*:int*/ = 0;
		// figure out day/date and placeholders
		while(format.charAt(i) == 'M' || format.charAt(i) == 'm') {
			i++;
		}
		if(i <= 2) {
			if(o.HBool) {
				this.bminute = true;
			}
			o.HBool = false;
			this.placeholders = i;
		} else if(i == 3) {
			// short month format
			this.placeholders = -1;
		} else if(i == 4) {
			// long month format
			this.placeholders = -2;
		} else if(i == 5) {
			// one letter month
			this.placeholders = -3;
		}
		return i;
	}
	gn.FDateM.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var str/*:String*/ = "";
		if(this.placeholders >= 0 && this.bminute) {
			if(this.value == undefined)
				str += o.getMin();
			else
				str += this.value;
			while(str.length < this.placeholders) {
				str = '0' + str;
			}
		} else {
			var m/*:Number*/ = o.getMonth();
			if(this.placeholders >= 0) {
				m++;
				// 0 to 1 based
				str += m;
				while(str.length < this.placeholders) {
					str = '0' + str;
				}
			} else {
				var a/*:Array*/ = new Array(this._displayLocaleInfo.IMSMONTHNAME1(), this._displayLocaleInfo.IMSMONTHNAME2(), this._displayLocaleInfo.IMSMONTHNAME3(), this._displayLocaleInfo.IMSMONTHNAME4(), this._displayLocaleInfo.IMSMONTHNAME5(), this._displayLocaleInfo.IMSMONTHNAME6(), this._displayLocaleInfo.IMSMONTHNAME7(), this._displayLocaleInfo.IMSMONTHNAME8(), this._displayLocaleInfo.IMSMONTHNAME9(), this._displayLocaleInfo.IMSMONTHNAME10(), this._displayLocaleInfo.IMSMONTHNAME11(), this._displayLocaleInfo.IMSMONTHNAME12());

				var b/*:Array*/ = new Array(this._displayLocaleInfo.IMSABBREVMONTHNAME1(), this._displayLocaleInfo.IMSABBREVMONTHNAME2(), this._displayLocaleInfo.IMSABBREVMONTHNAME3(), this._displayLocaleInfo.IMSABBREVMONTHNAME4(), this._displayLocaleInfo.IMSABBREVMONTHNAME5(), this._displayLocaleInfo.IMSABBREVMONTHNAME6(), this._displayLocaleInfo.IMSABBREVMONTHNAME7(), this._displayLocaleInfo.IMSABBREVMONTHNAME8(), this._displayLocaleInfo.IMSABBREVMONTHNAME9(), this._displayLocaleInfo.IMSABBREVMONTHNAME10(), this._displayLocaleInfo.IMSABBREVMONTHNAME11(), this._displayLocaleInfo.IMSABBREVMONTHNAME12());
				if(this.placeholders == -1) {
					str += b[m];
				} else if(this.placeholders == -3) {
					str += a[m].substring(0, 1);
				} else {
					str += a[m];
				}
			}
		}
		return str;
	}
})();(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateS");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");

	sap.common.globalization.numericFormat.FDateS = function() {
		this.__className = "sap.common.globalization.numericFormat.FDateS";
		this.splaceholders = 1;
		this.msplaceholders = 0;
		this.value = undefined;
		this.IMDecimalSeparator = sap.common.globalization.numericFormat.FLocalization.getInstance().IMDecimalSeparator;
		this.ms = NaN; // in AS3, in case no value is assgned to a number , the default value is NaN.
	}
	sap.common.globalization.numericFormat.FDateS.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var i/*:int*/ = 0;
		// m token directly before means minutes
		var a/*:Array*/ = o.mask;
		var l/*:Number*/ = a.length;
		for(var j/*:Number*/ = l - 1; j >= 0; j--) {
			if(a[j].__className == "sap.common.globalization.numericFormat.FDateM") {
				a[j].bminute = true;
				break;
			}
		}
		// figure out how many significant seconds to display
		while(format.charAt(i) == 'S' || format.charAt(i) == 's') {
			i++;
		}
		if(i > 1) {
			this.splaceholders = 2;
		}
		// figure out how many significant milliseconds to display
		if(format.charAt(i) == this.IMDecimalSeparator.charAt(0) && format.charAt(i + 1) == '0') {
			i++;
			while(format.charAt(i) == '0') {
				i++;
				this.msplaceholders++;
			}
			if(this.msplaceholders > o.ms) {
				o.ms = this.msplaceholders;
			}
		}
		return i;
	}
	sap.common.globalization.numericFormat.FDateS.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var str/*:String*/;
		if(this.value == undefined)
			str = "" + o.getSec();
		else
			str = "" + this.value;
		while(this.splaceholders > str.length) {
			str = '0' + str;
		}
		if(this.msplaceholders > 0) {
			var ms/*:Number*/ = o.getMS() / Math.pow(10, (3 - this.msplaceholders));
			if(this.msplaceholders < this.ms) {
				ms = Math.floor(ms);
			} else {
				ms = Math.round(ms);
			}
			var ts/*:String*/ = "" + ms;
			while(ts.length < this.msplaceholders) {
				ts = '0' + ts;
			}
			str += this.IMDecimalSeparator + ts;
		}
		return str;
	}
})();(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateSep");

	sap.common.globalization.numericFormat.FDateSep = function(parseLocalInfo/*:IDateParseLocaleInfo*/, displayLocaleInfo/*:IDateDisplayLocaleInfo*/) {
		this.__className = "sap.common.globalization.numericFormat.FDateSep";
		this._parseLocalInfo = parseLocalInfo;
		this._displayLocaleInfo = displayLocaleInfo;
	}

	sap.common.globalization.numericFormat.FDateSep.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var symb/*:String*/ = format.charAt(0);

		//only if the SAPDateSeparator has been set by Flashvars...
		if(this._displayLocaleInfo.IMDateSeparator() != null && (symb == "." || symb == "/" || symb == "-"))
			return 1;
		else
			return 0;
		//do not add this to mask

	}
	sap.common.globalization.numericFormat.FDateSep.prototype.display= function (o/*:FDate*/)/*:String*/ {
		var str/*:String*/ = this._displayLocaleInfo.IMDateSeparator();
		return str;
	}

})();(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateY");
		sap.common.globalization.numericFormat.FDateY= function ()
		{
			this.__className = "sap.common.globalization.numericFormat.FDateY";
			this.placeholders = 2;
		}
		sap.common.globalization.numericFormat.FDateY.prototype.parse= function (o/*:FDate*/, format/*:String*/)/*:int*/
		{
			var i/*:int*/=0;
			// figure out how many significant year digits to display
			while (format.charAt(i) == 'Y' || format.charAt(i) == 'y') {
				i++;
			}
			if (i>2) {
				this.placeholders = 4;
			}
			return i;
		}
		sap.common.globalization.numericFormat.FDateY.prototype.display= function (o/*:FDate*/)/*:String*/
		{
			var str/*:String*/ = "" + o.getYear();
			if (this.placeholders < 4) {
				str = str.substring(2);
			}
			return str;
		}
	
		
})();(function(){

	    sap.common.globalization.declare("sap.common.globalization.numericFormat.FText");

		sap.common.globalization.numericFormat.FText = function()
		{
			this.__className ="sap.common.globalization.numericFormat.FText";
			this.color/*Number*/ = 0;
			this.format/*String*/ = "";
			this.condnum/*int*/ = 0;
			this.cond/*Object*/ = {};
			
			this.numAts = 0;
			this.mask=new Array();
		}
		sap.common.globalization.numericFormat.FText.tokens/*String*/ = "@";

		sap.common.globalization.numericFormat.FText.prototype.parse = function(format/*String*/)/*:int*/ {
			var numChars/*int*/ = 0;
			while (format.charAt(numChars) == '@') {
				numChars++;
			}
			
			this.numAts = numChars;
			return numChars;
		}
		
		sap.common.globalization.numericFormat.FText.prototype.display = function(num/*Object*/)/*String*/ {
			var formatted/*String*/ = "";
			for (var i/*int*/=0; i<this.numAts; i++) {
				formatted += num.toString();
			}
			return formatted;
		};

})();(function() {
	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");
	sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl = function() {
		this.__className = "sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl";
		// Date Separator
		this._IMDateSeparator = null;

		// Long Month Tokens
		this._IMSMONTHNAME1 = null;
		this._IMSMONTHNAME2 = null;
		this._IMSMONTHNAME3 = null;
		this._IMSMONTHNAME4 = null;
		this._IMSMONTHNAME5 = null;
		this._IMSMONTHNAME6 = null;
		this._IMSMONTHNAME7 = null;
		this._IMSMONTHNAME8 = null;
		this._IMSMONTHNAME9 = null;
		this._IMSMONTHNAME10 = null;
		this._IMSMONTHNAME11 = null;
		this._IMSMONTHNAME12 = null;

		// Short Month Tokens
		this._IMSABBREVMONTHNAME1 = null;
		this._IMSABBREVMONTHNAME2 = null;
		this._IMSABBREVMONTHNAME3 = null;
		this._IMSABBREVMONTHNAME4 = null;
		this._IMSABBREVMONTHNAME5 = null;
		this._IMSABBREVMONTHNAME6 = null;
		this._IMSABBREVMONTHNAME7 = null;
		this._IMSABBREVMONTHNAME8 = null;
		this._IMSABBREVMONTHNAME9 = null;
		this._IMSABBREVMONTHNAME10 = null;
		this._IMSABBREVMONTHNAME11 = null;
		this._IMSABBREVMONTHNAME12 = null;

		// Long Day Tokens
		this._IMSDAYNAME1 = null;
		this._IMSDAYNAME2 = null;
		this._IMSDAYNAME3 = null;
		this._IMSDAYNAME4 = null;
		this._IMSDAYNAME5 = null;
		this._IMSDAYNAME6 = null;
		this._IMSDAYNAME7 = null;

		// Short Day Tokens
		this._IMSABBREVDAYNAME1 = null;
		this._IMSABBREVDAYNAME2 = null;
		this._IMSABBREVDAYNAME3 = null;
		this._IMSABBREVDAYNAME4 = null;
		this._IMSABBREVDAYNAME5 = null;
		this._IMSABBREVDAYNAME6 = null;
		this._IMSABBREVDAYNAME7 = null;

		// Time separator
		this._IMTimeSeparator = null;

		// AM/PM tokens
		this._IMAMToken = null;
		this._IMPMToken = null;

		// Era token
		this._IMEraToken = null;
	}
	var _g_d_d = sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl;
	// Date Separator
	_g_d_d.prototype.IMDateSeparator = function(value) {
		if(arguments.length >= 1) {
			this._IMDateSeparator = value;
		} else {
			return this._IMDateSeparator;
		}
	};
	// Long Month Tokens
	_g_d_d.prototype.IMSMONTHNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME1 = value;
		} else {
			return this._IMSMONTHNAME1;
		}
	};
	_g_d_d.prototype.IMSMONTHNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME2 = value;
		} else {
			return this._IMSMONTHNAME2;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME3 = value;
		} else {
			return this._IMSMONTHNAME3;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME4 = value;
		} else {
			return this._IMSMONTHNAME4;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME5 = value;
		} else {
			return this._IMSMONTHNAME5;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME6 = value;
		} else {
			return this._IMSMONTHNAME6;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME7 = value;
		} else {
			return this._IMSMONTHNAME7;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME8 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME8 = value;
		} else {
			return this._IMSMONTHNAME8;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME9 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME9 = value;
		} else {
			return this._IMSMONTHNAME9;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME10 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME10 = value;
		} else {
			return this._IMSMONTHNAME10;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME11 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME11 = value;
		} else {
			return this._IMSMONTHNAME11;
		}
	};

	_g_d_d.prototype.IMSMONTHNAME12 = function(value) {
		if(arguments.length >= 1) {
			this._IMSMONTHNAME12 = value;
		} else {
			return this._IMSMONTHNAME12;
		}
	};
	// Short Month Tokens
	_g_d_d.prototype.IMSABBREVMONTHNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME1 = value;
		} else {
			return this._IMSABBREVMONTHNAME1;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME2 = value;
		} else {
			return this._IMSABBREVMONTHNAME2;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME3 = value;
		} else {
			return this._IMSABBREVMONTHNAME3;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME4 = value;
		} else {
			return this._IMSABBREVMONTHNAME4;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME5 = value;
		} else {
			return this._IMSABBREVMONTHNAME5;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME6 = value;
		} else {
			return this._IMSABBREVMONTHNAME6;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME7 = value;
		} else {
			return this._IMSABBREVMONTHNAME7;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME8 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME8 = value;
		} else {
			return this._IMSABBREVMONTHNAME8;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME9 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME9 = value;
		} else {
			return this._IMSABBREVMONTHNAME9;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME10 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME10 = value;
		} else {
			return this._IMSABBREVMONTHNAME10;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME11 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME11 = value;
		} else {
			return this._IMSABBREVMONTHNAME11;
		}
	};

	_g_d_d.prototype.IMSABBREVMONTHNAME12 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVMONTHNAME12 = value;
		} else {
			return this._IMSABBREVMONTHNAME12;
		}
	};
	// Long Day Tokens
	_g_d_d.prototype.IMSDAYNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME1 = value;
		} else {
			return this._IMSDAYNAME1;
		}
	};

	_g_d_d.prototype.IMSDAYNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME2 = value;
		} else {
			return this._IMSDAYNAME2;
		}
	};

	_g_d_d.prototype.IMSDAYNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME3 = value;
		} else {
			return this._IMSDAYNAME3;
		}
	};
	_g_d_d.prototype.IMSDAYNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME4 = value;
		} else {
			return this._IMSDAYNAME4;
		}
	};
	_g_d_d.prototype.IMSDAYNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME5 = value;
		} else {
			return this._IMSDAYNAME5;
		}
	};
	_g_d_d.prototype.IMSDAYNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME6 = value;
		} else {
			return this._IMSDAYNAME6;
		}
	};
	_g_d_d.prototype.IMSDAYNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSDAYNAME7 = value;
		} else {
			return this._IMSDAYNAME7;
		}
	};
	// Short Day Tokens
	_g_d_d.prototype.IMSABBREVDAYNAME1 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME1 = value;
		} else {
			return this._IMSABBREVDAYNAME1;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME2 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME2 = value;
		} else {
			return this._IMSABBREVDAYNAME2;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME3 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME3 = value;
		} else {
			return this._IMSABBREVDAYNAME3;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME4 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME4 = value;
		} else {
			return this._IMSABBREVDAYNAME4;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME5 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME5 = value;
		} else {
			return this._IMSABBREVDAYNAME5;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME6 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME6 = value;
		} else {
			return this._IMSABBREVDAYNAME6;
		}
	};
	_g_d_d.prototype.IMSABBREVDAYNAME7 = function(value) {
		if(arguments.length >= 1) {
			this._IMSABBREVDAYNAME7 = value;
		} else {
			return this._IMSABBREVDAYNAME7;
		}
	};
	// Time separator
	_g_d_d.prototype.IMTimeSeparator = function(value) {
		if(arguments.length >= 1) {
			this._IMTimeSeparator = value;
		} else {
			return this._IMTimeSeparator;
		}
	};
	// AM/PM tokens
	_g_d_d.prototype.IMAMTOKEN = function(value) {
		if(arguments.length >= 1) {
			this._IMAMToken = value;
		} else {
			return this._IMAMToken;
		}
	};
	_g_d_d.prototype.IMPMTOKEN = function(value) {
		if(arguments.length >= 1) {
			this._IMPMToken = value;
		} else {
			return this._IMPMToken;
		}
	};
	// Era token
	_g_d_d.prototype.IMEraToken = function(value) {
		if(arguments.length >= 1) {
			this._IMEraToken = value;
		} else {
			return this._IMEraToken;
		}
	};
})();
(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDate");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateY");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FTimeSep");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateA");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateB");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateSep");

	// % handling
	var gn = sap.common.globalization.numericFormat;
	gn.FDate = function(parseLocaleInfo/*IDateParseLocaleInfo*/, displayLocaleInfo/*IDateDisplayLocaleInfo*/) {

		this.__className = "sap.common.globalization.numericFormat.FDate";
		this.date;/*Date*/
		this.color;/*Number*/
		this.condnum;/*int*/
		this.cond;/*Object*/

		this.tok = {};/*Object*/

		this.HBool = false;/*Boolean*/
		this.serial = 37500;/*Number*/
		this.format = "";/*String*/
		this.HNum = 0;/*Number*/
		this.miltime = true;/*Boolean*/
		this.ms = 0;/*int*/
		this.mask = new Array();/*Array*/
		this._parseLocaleInfo = parseLocaleInfo;
		this._displayLocaleInfo = displayLocaleInfo;

		this.initializeTokenMap();
	};
	gn.FDate.tokens = "MDYHSAmdyhsa";/*String*/
	gn.FDate.prototype.parse = function(format/*String*/) {
		var c = format.charAt(0);

		// unfortunate special case for "." handling
		if(c == ".")
			c = format.substring(0, 2);
		
		// hokey actionscript stuff
		var zzz = this.tok[c];
		if(zzz == undefined)
			return 0;

		var r = this.createTokenFormatter(zzz);

		var ret = r.parse(this, format);
		if(ret > 0) {
			this.mask.push(r);
		} else {
			ret = 0;
		}

		return ret;
	}

	gn.FDate.prototype.display = function(num/*Number*/)/*String*/
	{
		if(num < 0) {
			return "###########################################";
		}
		this.setNumber(num);
		var a = this.mask;
		//Array

		var l = a.length;
		//int
		var s = "";
		//String
		for(var i = 0; i < l; i++) {
			if(( typeof a[i]) == "object") {
				s += a[i].display(this);
			} else {
				s += a[i];
			}
		}

		return s;
	}

	gn.FDate.prototype.getMaskClone = function()/*Array*/
	{
		if(this.mask) {
			return this.mask.slice();
		}
		return [];
	}

	gn.FDate.prototype.getYear = function()/*Number*/
	{
		if(this.serial >= 0 && this.serial < 1)
			return 1900;
		return this.date.getUTCFullYear();
		// getFullYear();
	}

	gn.FDate.prototype.getMonth = function()/*Number*/
	{
		if(this.serial >= 0 && this.serial < 1)
			return 0;
		return this.date.getUTCMonth();
		// getMonth();
	}

	gn.FDate.prototype.getDate = function()/*Number*/
	{
		if(this.serial >= 0 && this.serial < 1)
			return 0;
		// leap year
		if(this.serial == 60) {
			return 29;
		}
		return this.date.getUTCDate();
		// getDate();
	}

	gn.FDate.prototype.getDay = function()/*Number*/
	{
		var d = this.date.getUTCDay();
		// getDay();
		if(this.serial < 60) {
			d--;
		}
		return d;
	}

	gn.FDate.prototype.getHrs = function()/*Number*/
	{
		return this.date.getUTCHours();
		// getHours();
	}

	gn.FDate.prototype.getMin = function()/*Number*/
	{
		return this.date.getUTCMinutes();
		// getMinutes();
	}

	gn.FDate.prototype.getSec = function()/*Number*/
	{
		return this.date.getUTCSeconds();
		// getSeconds();
	}
	gn.FDate.prototype.getMS = function()/*Number*/
	{
		return this.date.getUTCMilliseconds();
		// getMilliseconds();
	}
	// wrong date for leap year in 1900
	gn.FDate.prototype.setNumber = function(num) {
		// round off to the 5th decimal as excel does this
		// var s = Math.pow(10, 6);
		// num = num*s;
		// num = Math.round(num);
		// num = num/s;

		this.serial = num;
		// fix the date here as leap year is missing
		if(num < 60) {
			num++;
		}

		// change to seconds
		var secs = num * 86400 * 1000;
		// 1900 to 1970
		var nsecs = secs - (2209161600 * 1000);
		this.date = new Date(nsecs);

		if(this.date.getUTCMilliseconds() >= 500)
			this.date.setUTCMilliseconds(this.date.getUTCMilliseconds() + 500);
	}
	/**
	 * Initialize the token classes for further parse and display. The
	 * classes used here need be related to the classed in
	 * initializeTokenMap() method.
	 *
	 * @param clazz
	 * @return
	 *
	 */
	gn.FDate.prototype.createTokenFormatter = function(clazz/*Class*/) {
		var token = null;
		switch(clazz) {
			case gn.FDateM:
				token = new gn.FDateM(this._displayLocaleInfo);
				break;
			case gn.FDateD:
				token = new gn.FDateD(this._displayLocaleInfo);
				break;
			case gn.FDateY:
				token = new gn.FDateY();
				break;
			case gn.FDateH:
				token = new gn.FDateH();
				break;
			case gn.FDateS:
				// TODO: need investigation about the Decimal separator in
				// FDateS
				token = new gn.FDateS();
				break;
			case gn.FDateSep:
				token = new gn.FDateSep(this._parseLocaleInfo, this._displayLocaleInfo);
				break;
			case gn.FTimeSep:
				token = new gn.FTimeSep(this._parseLocaleInfo, this._displayLocaleInfo)
				break;
			case gn.FDateA:
				token = new gn.FDateA(this._displayLocaleInfo);
				break;
			case gn.FDateB:
				token = new gn.FDateB(this._displayLocaleInfo);
				break;
			default:
			// this should not happend since there's check before call
			// this method
		}
		return token;
	}
	/**
	 * Initialize the tokens map for further parsing and displaying. The
	 * method can be overrided by the sub-classes to provide more tokens.
	 *
	 */
	gn.FDate.prototype.initializeTokenMap=function() {

		this.tok["M"] = gn.FDateM;
		this.tok["D"] = gn.FDateD;
		this.tok["Y"] = gn.FDateY;
		this.tok["H"] = gn.FDateH;
		this.tok["S"] = gn.FDateS;
		this.tok["A"] = gn.FDateA;
		this.tok["m"] = gn.FDateM;
		this.tok["d"] = gn.FDateD;
		this.tok["y"] = gn.FDateY;
		this.tok["h"] = gn.FDateH;
		this.tok["s"] = gn.FDateS;
		this.tok["a"] = gn.FDateA;
		this.tok["["] = gn.FDateB;
		this.tok["/"] = gn.FDateSep;
		this.tok[".M"] = gn.FDateSep;//Month
		this.tok[".D"] = gn.FDateSep;//Day
		this.tok[".Y"] = gn.FDateSep;//Year
		this.tok["-"] = gn.FDateSep;
		this.tok[".m"] = gn.FTimeSep;//minute
		this.tok[".h"] = gn.FTimeSep;//hour
		this.tok[".s"] = gn.FTimeSep;//second
		this.tok[":"] = gn.FTimeSep;

	}


	gn.FDate.prototype.toString = function()/*String*/
	{
		var output = "[FDate]" + "\n";
		for(var prop in this) {
			output = output + prop + " = " + this[prop] + "\n";
		}
		return output;
	}
}
)();
(function()
{
		sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateForPVL");
		sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateD");
		sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");
	
		sap.common.globalization.numericFormat.FDateForPVL= function (pLoc, dLoc)
		{
			sap.common.globalization.numericFormat.FDateForPVL.superclass.constructor.apply(this, [pLoc, dLoc]);
			this.__className = "sap.common.globalization.numericFormat.FDateForPVL";
		}
		sap.common.globalization.numericFormat.FDateForPVL = sap.common.globalization.extend(sap.common.globalization.numericFormat.FDateForPVL, sap.common.globalization.numericFormat.FDate);
		var _g_n_f = sap.common.globalization.numericFormat.FDateForPVL;
		
		_g_n_f.prototype.createTokenFormatter= function (clazz/*:Class*/)/*:Object*/
		{
			var token/*:Object*/ = null;
			if (clazz == sap.common.globalization.numericFormat.FDefaultDateD)
			{
				// use FDefaultDateD for none-default format with PVL case.
				// here we will not cut the period at the end of short day strings.
				token = new sap.common.globalization.numericFormat.FDefaultDateD(this._displayLocaleInfo);
			}
			else
			{
				token = _g_n_f.superclass.createTokenFormatter.call(this, clazz);
			}
			return token;
		}
		
		_g_n_f.prototype.initializeTokenMap= function ()/*:void*/
		{
			_g_n_f.superclass.initializeTokenMap.apply(this);
			
			//override token "d/D" because we do not want to cut the period at the end of the short day from PVL
			//In legacy code, the period at the end of the short day is cut to keep consistent to excel behavior. 
			this.tok["d"] = sap.common.globalization.numericFormat.FDefaultDateD;
			this.tok["D"] = sap.common.globalization.numericFormat.FDefaultDateD;
		}
	
})();
(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateSep");

		sap.common.globalization.numericFormat.FDefaultDateSep =function (parseLocaleInfo/*:IDateParseLocaleInfo*/, displayLocaleInfo/*:IDateDisplayLocaleInfo*/)
		{
			sap.common.globalization.numericFormat.FDefaultDateSep.superclass.constructor.call(this, parseLocaleInfo, displayLocaleInfo);
			this.__className = "sap.common.globalization.numericFormat.FDefaultDateSep";
		}
		sap.common.globalization.numericFormat.FDefaultDateSep = sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateSep, sap.common.globalization.numericFormat.FDateSep);
		sap.common.globalization.numericFormat.FDefaultDateSep.prototype.parse= function (o/*:FDate*/, format/*:String*/)/*:int*/
		{
			var defaultSep/*:String*/ = this._parseLocalInfo.IMDateSeparator();
			
			if (defaultSep){
				var sepLength/*:int*/ = defaultSep.length;
				// get symbol from the format string
				var symb/*:String*/ = format.substr(0,sepLength); 
				// compare format sep string and the pre-defined sep string
				if(symb==defaultSep)
					return sepLength;
				else
					return 0; //do not add this to mask
			}
			return 0;
		}
})();
(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateH");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");
	// work around for 'h' in lower case in CLDR which desginates the 1-12 hour style of time.

	sap.common.globalization.numericFormat.FDefaultDateH = function() {
		sap.common.globalization.numericFormat.FDefaultDateH.superclass.constructor.apply(this);
		this.__className = "sap.common.globalization.numericFormat.FDefaultDateH";
		this._is12HourStyle = false; // private member
	}

	sap.common.globalization.numericFormat.FDefaultDateH = sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateH, sap.common.globalization.numericFormat.FDateH);

	sap.common.globalization.numericFormat.FDefaultDateH.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		var i/*:int*/ = 0;
		this.number = o.HNum + 1;
		o.HBool = true;
		o.HNum = this.number;
		// initialize whether the hour is using 1-12 style
		this._is12HourStyle = true;
		while(format.charAt(i) == 'H' || format.charAt(i) == 'h') {
			if(format.charAt(i) == 'H') {
				// if there is one H in upper case, then set 1-12 hour style to false
				this._is12HourStyle = false;
			}
			i++;
		}
		if(i > 1) {
			this.placeholders = 2;
		}
		return i;
	}
	sap.common.globalization.numericFormat.FDefaultDateH.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var h/*:Number*/;
		if(isNaN(this.value))
			h = o.getHrs();
		else
			h = this.value;

		// in the FDateH, it depends on FDateA to determine whether it is 1-12 hour style.
		// So for some formats as "h:mm:ss", it will format the data to 0-23 hour style time because there is no
		// am/pm token and the o.miltime returns true (See FDateH). Here is the work around to properly format the above formats with a flag "_is12HourStyle".
		// However, to be simple and have little impact on the existing code, this work around will not affect the am/pm token. I.E. if there
		// is a format string as "H:mm:ss am/pm", then the "am/pm" token will still be displayed even though the hour is shown with 0-23 hour style.
		if(this._is12HourStyle) {
			if(this.number == o.HNum) {
				if(h > 11) {
					h = h - 12;
				}
				if(h == 0) {
					h = 12;
				}
			}
		}

		var str/*:String*/ = "" + h;
		while(this.placeholders > str.length) {
			str = '0' + str;
		}
		return str;
	}
})();
(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateG");
	sap.common.globalization.require("sap.common.globalization.utils.StringUtil");

	sap.common.globalization.numericFormat.FDefaultDateG = function(dispLoc) {
		this.__className = "sap.common.globalization.numericFormat.FDefaultDateG";
		this._displayLocInfo = dispLoc;
		this._count = 0;
	}

	sap.common.globalization.numericFormat.FDefaultDateG.prototype.parse = function(o/*:FDate*/, format/*:String*/)/*:int*/
	{
		if(format && !sap.common.globalization.utils.StringUtil.isBlankString(format)) {
			// parse the 'G' character only when the Era token exists
			if(this._displayLocInfo && this._displayLocInfo.IMEraToken()) {
				this._count = 0;
				var gToken/*:String*/ = format.charAt(this._count);
				while(gToken == 'G') {
					this._count++;
					gToken = format.charAt(this._count);
				}
				return this._count;
			}
		}
		return 0;
	}

	sap.common.globalization.numericFormat.FDefaultDateG.prototype.display = function(o/*:FDate*/)/*:String*/
	{
		var era/*:String*/ = "";
		// TODO:display Era type according to _count
		// Follow CLDR implementation, 1,2,3 for abbrev, 4 for full, 5 for narrow
		if(this._displayLocInfo && this._displayLocInfo.IMEraToken()) {
			switch(this._count) {
				case 4:
				// TODO:FULL;
				case 5:
				// TODO:narrow
				case 1:
				case 2:
				case 3:
				default:
					era = this._displayLocInfo.IMEraToken();
			}
		}
		return era;
	}
})();
(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateD");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");
	var gn = sap.common.globalization.numericFormat;
	sap.common.globalization.numericFormat.FDefaultDateD = function(displayLocaleInfo/*:IDateDisplayLocaleInfo*/) {
		sap.common.globalization.numericFormat.FDefaultDateD.superclass.constructor.call(this, displayLocaleInfo);
		this.__className = "sap.common.globalization.numericFormat.FDefaultDateD";
	}
	sap.common.globalization.numericFormat.FDefaultDateD = sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateD, sap.common.globalization.numericFormat.FDateD);

	gn.FDefaultDateD.prototype.getShortDay = function(day/*:Number*/)/*:String*/
	{
		if(day == 0) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME7();
		}
		if(day == 1) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME1();
		}
		if(day == 2) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME2();
		}
		if(day == 3) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME3();
		}
		if(day == 4) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME4();
		}
		if(day == 5) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME5();
		}
		if(day == 6 || day == -1) {
			return this._displayLocaleInfo.IMSABBREVDAYNAME6();
		}
		// should never happen
		return this._displayLocaleInfo.IMSABBREVDAYNAME6();
	}
})();
(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDate");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateD");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateG");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateH");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FTimeSep");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateSep");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateY");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateA");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateB");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDateSep");

	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateSep");

	sap.common.globalization.numericFormat.FDefaultDate = function(parseLocaleInfo/*:IDateParseLocaleInfo*/, displayLocaleInfo/*:IDateDisplayLocaleInfo*/) {
		sap.common.globalization.numericFormat.FDefaultDate.superclass.constructor.apply(this, [parseLocaleInfo, displayLocaleInfo]);
		this.__className = "sap.common.globalization.numericFormat.FDefaultDate";
	}
	sap.common.globalization.numericFormat.FDefaultDate = sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDate, sap.common.globalization.numericFormat.FDate);
	/**
	 * @private
	 * Override the parent class.
	 * Using FDefaultDateSep instead of FDateSep for date separator. Other tokens remain the same.
	 * The classes used here need be related to the classed in initializeTokenMap() method.
	 *
	 * @param clazz
	 * @return
	 *
	 */
	sap.common.globalization.numericFormat.FDefaultDate.prototype.createTokenFormatter = function(clazz/*:Class*/)/*:Object*/
	{
		var gn = sap.common.globalization.numericFormat;
		var token/*:Object*/ = null;
		switch(clazz) {
			case gn.FDateM:
				token = new gn.FDateM(this._displayLocaleInfo);
				break;
			case gn.FDefaultDateD:
				token = new gn.FDefaultDateD(this._displayLocaleInfo);
				break;
			case gn.FDateY:
				token = new gn.FDateY();
				break;
			case gn.FDefaultDateH:
				token = new gn.FDefaultDateH();
				break;
			case gn.FDateS:
				// TODO: need investigation about the Decimal separator in FDateS
				token = new gn.FDateS();
				break;
			case gn.FDefaultDateSep:
				token = new gn.FDefaultDateSep(this._parseLocaleInfo, this._displayLocaleInfo);
				break;
			case gn.FTimeSep:
				token = new gn.FTimeSep(this._parseLocaleInfo, this._displayLocaleInfo)
				break;
			case gn.FDateA:
				token = new gn.FDateA(this._displayLocaleInfo);
				break;
			case gn.FDateB:
				token = new gn.FDateB(this._displayLocaleInfo);
				break;
			case gn.FDefaultDateG:
				token = new gn.FDefaultDateG(this._displayLocaleInfo);
				break;
			default:
			// this should not happend since there's check before call this method
		}
		return token;
	}
	/**
	 * Initialize the token map for Default Date format, using FDefaultDateSep instead of
	 * FDateSep for date separator. Also fix a bug in FDateSep
	 *
	 *
	 */
	sap.common.globalization.numericFormat.FDefaultDate.prototype.initializeTokenMap = function()/*:void*/
	{
		var gn = sap.common.globalization.numericFormat;
		// copy from super.
		this.tok["M"] = gn.FDateM;
		this.tok["Y"] = gn.FDateY;
		this.tok["S"] = gn.FDateS;
		this.tok["A"] = gn.FDateA;
		this.tok["m"] = gn.FDateM;
		this.tok["y"] = gn.FDateY;
		this.tok["s"] = gn.FDateS;
		this.tok["a"] = gn.FDateA;
		this.tok["["] = gn.FDateB;
		// Default Date D
		this.tok["D"] = gn.FDefaultDateD;
		this.tok["d"] = gn.FDefaultDateD;
		// Default Date H
		this.tok["H"] = gn.FDefaultDateH;
		this.tok["h"] = gn.FDefaultDateH;

		// then initialize date separators
		if(this._parseLocaleInfo && this._parseLocaleInfo.IMDateSeparator) {
			if(this._parseLocaleInfo.IMDateSeparator() == ".") {
				// special handling for date separator ".
				// Also fix a bug in FDateSep, because ".d" (lower case) and ".y" shoulde also be considered
				// as the date separator.
				this.tok[".M"] = gn.FDefaultDateSep;
				//Month
				this.tok[".D"] = gn.FDefaultDateSep;
				//Day
				this.tok[".d"] = gn.FDefaultDateSep;
				//Day
				this.tok[".Y"] = gn.FDefaultDateSep;
				//Year
				this.tok[".y"] = gn.FDefaultDateSep;
				//Year
			} else {
				this.tok[this._parseLocaleInfo.IMDateSeparator()] = gn.FDefaultDateSep;
			}
		}

		if(this._parseLocaleInfo && this._parseLocaleInfo.IMTimeSeparator()) {
			if(this._parseLocaleInfo.IMDateSeparator == ".") {
				// special handling for time separator ".
				// Also add ".H", ".S" token which is not handled in the super class.
				this.tok[".m"] = gn.FTimeSep;
				//minute
				this.tok[".h"] = gn.FTimeSep;
				//hour
				this.tok[".H"] = gn.FTimeSep;
				//hour
				this.tok[".s"] = gn.FTimeSep;
				//second
				this.tok[".S"] = gn.FTimeSep;
				//second
			} else {
				this.tok[this._parseLocaleInfo.IMTimeSeparator()] = gn.FTimeSep;
			}
		}

		// for token G
		this.tok["G"] = gn.FDefaultDateG;
	}
})();
(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.DefaultGroupingStrategy");

	sap.common.globalization.numericFormat.DefaultGroupingStrategy =function()
	{
		this.__className = "sap.common.globalization.numericFormat.DefaultGroupingStrategy";		
	}
	var _s_g_nf_defaultGStrategy = sap.common.globalization.numericFormat.DefaultGroupingStrategy;
	
	_s_g_nf_defaultGStrategy._instance/*DefaultGroupingStrategy*/ = new sap.common.globalization.numericFormat.DefaultGroupingStrategy();

	// normally are 2		
	_s_g_nf_defaultGStrategy.prototype.nextGroupDigits= function()/*int*/
	{
		return 2;
	};
	
	_s_g_nf_defaultGStrategy.instance = function()/*IGroupingStrategy*/
	{
		return _s_g_nf_defaultGStrategy._instance;
	};

})();

(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.Helper");
		sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");
		

		sap.common.globalization.numericFormat.Helper.isThousandsSeparator = function(format/*String*/, index/*int*/,
			thousandsSeparator/*String = null*/)/*Boolean*/ {

		var thousandsSeparator = thousandsSeparator || null;
		var IMThousandsSeparator/*String*/ = (thousandsSeparator ? thousandsSeparator : sap.common.globalization.numericFormat.FLocalization.getInstance().IMThousandsSeparator());
			
			if (IMThousandsSeparator.charAt(0) == ' ') {
				for (var i/*int*/=index; i<format.length; ++i) {
					if (format.charAt(i) != ' ')
						break;
				}
				// comments in AS3.
				/*ADAPT01376528 after checking the following locales, we need add more currency symbols 
				----------------------
				Chinese - Hong Kong SAR
				Croatian (Bosnia/Herzegovina)
				Czech
				English - Philippines
				French - Switzerland
				German - Liechtenstein
				German - Switzerland
				Icelandic
				Italian - Switzerland
				Latvian
				Lithuanian
				Maltese
				Serbian (Latin)
				Slovak
				Slovenian
				Spanish - Honduras
				Spanish - Panama
				Spanish - Peru
				Spanish - Venezuela
				Swahili
				Swedish
				Ukrainian
				Urdu
				----------------------
				*/
				if (format.charAt(i) == '€' || format.charAt(i) == 'г' 
				 || format.charAt(i) == 'k' || format.charAt(i) == 'S'
				 || format.charAt(i) == 'L' || format.charAt(i) == 'm'
				 || format.charAt(i) == 'K')
					return false;
			}
			return (format.charAt(index) == IMThousandsSeparator.charAt(0));		
		}
})();(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FCurr"); {
		//import xcelsius.globalization.localeInfo.INumericDisplayLocaleInfo;
		//import xcelsius.globalization.localeInfo.INumericParseLocaleInfo;

		// # handling
		sap.common.globalization.numericFormat.FCurr = function(parseLocaleInfo, displayLocaleInfo) {
			this.__className = "sap.common.globalization.numericFormat.FCurr";
			this.display/*String*/ = "";
			this._parseLocaleInfo = parseLocaleInfo;
			this._displayLocaleInfo = displayLocaleInfo;

		};
	};
	sap.common.globalization.numericFormat.FCurr.prototype.parse = function(o /*FNumber*/, format /*String*/) {
		var symb /*string*/= this._parseLocaleInfo.currencySymbol();
		var currSymb /*string*/ = this._displayLocaleInfo.currencySymbol();
		//only if the SAPCurrencySeparator has been set by Flashvars...

		if(currSymb != null && symb != null && symb != currSymb) {
			o.currencyIndex = o.mask.length;
			this.display = currSymb;
			return symb.length;
		} else
			return 0;
		//do not add this to mask

	};
})();
(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FNum0");
		
		sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");
		
		sap.common.globalization.numericFormat.FNum0 = function(parseLocaleInfo/*INumericParseLocaleInfo*/)
		{
			this.__className ="sap.common.globalization.numericFormat.FNum0";
			this._parseLocaleInfo = parseLocaleInfo; // private var parseLocaleInfo:INumericParseLocaleInfo;
			this.display = "0"; // public var display:String = "0";
		}
		
		/**
		 * 	@param o
		 * 	@param format
		 */
		sap.common.globalization.numericFormat.FNum0.prototype.parse = function(o/*FNumber*/, format/*String*/)/*int*/ {
			var numChars/*int*/ = 1;
			if (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 1, this._parseLocaleInfo.thousandsSeparator())) {
				var c/*String*/ = format.charAt(2);
				if (c != '#' && c != '?' && c != '0'){
					if(!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 2, this._parseLocaleInfo.thousandsSeparator())) 
							o.scale = o.scale / 1000;
					else
						//For ADAPT01422479. 
						//If the number format contains 2 thousand separators, Excel will divide the value by 1000000
						//We need to behave the same way.  
						o.scale = o.scale / 1000000;
				} 
				else {
					o.bcomma = true;
				}
				// eat the commas
				var i/*int*/ = 1;
				while (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, i++, this._parseLocaleInfo.thousandsSeparator())) {
					numChars++;
				}
			}
			return numChars;
		}
})();(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumP");
		
		sap.common.globalization.numericFormat.FNumP = function(){
			this.__className ="sap.common.globalization.numericFormat.FNumP";
			this.display/*String*/ = "%"; // public var display:String = "%";
		};
		
		sap.common.globalization.numericFormat.FNumP.prototype.parse = function(o/*FNumber*/, format/*String*/)/*int*/ {
			o.scale = o.scale * 100;
	
			return -1;
		}	

})();
(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumQ");
		
		sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");
			
		sap.common.globalization.numericFormat.FNumQ = function(parseLocaleInfo/*INumericParseLocaleInfo*/)
		{
			this.__className ="sap.common.globalization.numericFormat.FNumQ";
			this._parseLocaleInfo = parseLocaleInfo;// private
			this.display/*String*/ = " ";	// public var display:String = " ";
		};
		
		sap.common.globalization.numericFormat.FNumQ.prototype.parse = function(o/*FNumber*/, format/*String*/)/*int*/ {
			var numChars/*int*/ = 1;
			if (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 1, this._parseLocaleInfo.thousandsSeparator())) {
				var c/*String*/ = format.charAt(2);
				if (c != '#' && c != '?' && c != '0' &&
					!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 2, this._parseLocaleInfo.thousandsSeparator())) {
					o.scale = o.scale / 1000;
				} else {
					o.bcomma = true;
				}
				// eat the commas
				var i/*int*/ = 1;
				while (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, i++, this._parseLocaleInfo.thousandsSeparator())) {
					numChars++;
				}
			}
			return numChars;
		}
		

})();


(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumS");
		sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");

		sap.common.globalization.numericFormat.FNumS = function(parseLocaleInfo/*INumericParseLocaleInfo*/)
		{
			this.__className ="sap.common.globalization.numericFormat.FNumS";
			this._parseLocaleInfo = parseLocaleInfo; // private var parseLocaleInfo:INumericParseLocaleInfo;
			
			this.display = "" //public var display:String = "";
		}
		
		sap.common.globalization.numericFormat.FNumS.prototype.parse = function(o/*FNumber*/, format/*String*/)/*int*/ {
			var numChars/*int*/ = 1;
			if (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 1, this._parseLocaleInfo.thousandsSeparator())) {
				var c/*String*/ = format.charAt(2);
				if (c != '#' && c != '?' && c != '0') {
					if(!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 2, this._parseLocaleInfo.thousandsSeparator()))
						o.scale = o.scale / 1000;
					else
						//For ADAPT01422479. 
						//If the number format contains 2 thousand separators, Excel will divide the value by 1000000
						//We need to behave the same way.
						o.scale = o.scale / 1000000;
				} 
				else {
					o.bcomma = true;
				}
				// eat the commas
				var i/*int*/ = 1;
				while (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, i++, this._parseLocaleInfo.thousandsSeparator())) {
					numChars++;
				}
			}
			return numChars;
		}		
})();(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FPeriod");
		sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");

		sap.common.globalization.numericFormat.FPeriod = function(parseLocaleInfo/*INumericParseLocaleInfo*/, displayLocaleInfo/*INumericDisplayLocaleInfo*/)
		{
			this.__className ="sap.common.globalization.numericFormat.FPeriod";
			this._parseLocaleInfo = parseLocaleInfo; //		private var parseLocaleInfo:INumericParseLocaleInfo;
			this.display = displayLocaleInfo.decimalSeparator();
		}
				
		sap.common.globalization.numericFormat.FPeriod.prototype.parse = function(o/*FNumber*/, format/*String*/)/*int*/ 
		{
			var numChars/*int*/ = -1;
			if (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 1, this._parseLocaleInfo.thousandsSeparator())) 
			{
				var c/*String*/ = format.charAt(2);
				if (c != '#' && c != '?' && c != '0' &&
					!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, 2, this._parseLocaleInfo.thousandsSeparator())) 
					{
						o.scale = o.scale / 1000;
					}
				// eat the commas
				var i/*int*/=1;
				while (sap.common.globalization.numericFormat.Helper.isThousandsSeparator(format, i++, this._parseLocaleInfo.thousandsSeparator())) 
				{
					numChars++;
				}
			}
			if (o.period == -1) {
				o.period = o.mask.length;
			}
			return numChars;
		}	
})();(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumber");
		
		/**
		 * Constructor
		 */		
		sap.common.globalization.numericFormat.FNumber = function(parseLocaleInfo/*INumericParseLocaleInfo*/, displayLocaleInfo/*INumericDisplayLocaleInfo*/) 
		{
			
			this.__className ="sap.common.globalization.numericFormat.FNumber";
			this.scale = 1.0;
			this.bcomma = false; // whether we do commas
			this.bsign = true; // whether we show the sign
			this.period = -1; // period position
			this.numfore = undefined; // number before decimal
			this.numaft = undefined; // number after decimal
			this.sign = ""; // sign of number
			this.mask = new Array(); // mask
			this.mfore = new Array(); // ptr to mask objects before period
			this.maft = new Array(); // ptr to mask objects after period
			this.format = undefined; // save the format string
			this.currencyIndex=-1;
			this._tok ={};
			this._tok["#"] = sap.common.globalization.numericFormat.FNumS; //		private var tok:Object = {};
			this._tok["?"] = sap.common.globalization.numericFormat.FNumQ;
			this._tok["%"] = sap.common.globalization.numericFormat.FNumP;
			this._tok["0"] = sap.common.globalization.numericFormat.FNum0;
			
			this.condnum /*Number*/ = 0; // var condnum:int;
			this.cond = {}; //		var cond:*;
			
			var IMDecimalSeparator/*String*/ = parseLocaleInfo.decimalSeparator(); // decimalSeparator is a get function in AS3.
			this._tok[IMDecimalSeparator] = sap.common.globalization.numericFormat.FPeriod; // periods are special handling
			this.IMDecimalSeparator = IMDecimalSeparator; 

			this.parseLocaleInfo = parseLocaleInfo;			
			this.displayLocaleInfo = displayLocaleInfo;
			this.IMThousandsSeparator = displayLocaleInfo.thousandsSeparator(); // thousandsSeparator is a get function in AS3.
			
			//only set this if passed in via Flashvars.
			//this.tok[IMThousandsSeparator] = FComma; // commas are special handling

			var IMCurrencySymbol/*String*/ = this.parseLocaleInfo.currencySymbol(); // currencySymbol is a get function in AS3.
			if (IMCurrencySymbol)
			{
				this._tok[IMCurrencySymbol] = sap.common.globalization.numericFormat.FCurr;  //change this $ to IMCurrencySymbol...
			}
		}		
		
	 	sap.common.globalization.numericFormat.FNumber.tokens/*String*/ = "#?%0";
		
		sap.common.globalization.numericFormat.FNumber.prototype.parse = function(format/*String*/)/*int*/ 
		{
			if (this.format == null) 
			{
				this.format = format;
			}
	
			var c/*Object*/ = format.charAt(0);
			// hokey actionscript stuff
			
			/* ADAPT01376528 limitation: Generally, currency format has two parts - currency symbol($) and numeric format(#,##0.00). 
			If currency symbol included decimal separator and no space between them, xcelsius can not handle it correctly*/
			if (this._tok[c]==undefined 
			|| (c == this.IMDecimalSeparator && (format.length > 1 && format.charAt(1) != '#' && format.charAt(1) != '0')))
			{
				return 0;
			}
			
			var r/*Object*/ = this.createTokenFormatter(this._tok[c]);
			var ret/*Object*/ = r.parse(this, format);
			if(this.period >1)
			{
				var debug = true;	
			}
			if (ret > 0) 
			{
				var index/*uint*/ = this.mask.length;
				this.mask.push(r);
				
				if( this.currencyIndex!=index ) 
				{
					if (this.period == -1) 
					{
						this.mfore.push(index);
					} 
					else 
					{
						this.maft.push(index);
					}
				}
			} 
			else if (ret < 0) 
			{
				this.mask.push(r);
				ret = Math.abs(ret);
			} 
			else 
			{
				ret = 0;
			}
	
			return ret;
		}
		
		sap.common.globalization.numericFormat.FNumber.prototype.display = function(num/*Object*/)/*String*/ 
		{
			if (typeof(num) != "number") 
			{
				return num;
			}
	
			if (isNaN(num) || !isFinite(num)) 
			{
				return num;
			}
	
			if (this.mfore.length == 0 && this.maft.length == 0) 
			{
				return this.format;
			}
			this.setNumber(num);
	
			// put numbers into array for numbers before period
			var s/*:Array*/ = new Array();
			var l/*int*/ = this.mfore.length;
			var cnt/*int*/ = 3; // count of digits for comma placement
			var mi/*int*/ = this.period;
			var ml/*int */= (mi==-1) ? (this.mask.length) : mi;
			var j/*int*/;
			var d/*int*/;
			var a/*Object*/;
			for (var i/*int*/ = l-1; i>=0; i--) 
			{
				mi = this.mfore[i];
				
				//queue up the literals
				for (var j=ml-1; j>mi; j--) 
				{
					a = this.mask[j];
					if ((typeof a) == "object") 
					{
						s.unshift(a.display);
					} 
					else 
					{
						s.unshift(a);
					}
				}
				if (this.numfore.length > 0) 
				{
					// put a number where mask character goes
					if (this.bcomma) 
					{
						if (cnt-- == 0) 
						{
							s.unshift(this.IMThousandsSeparator);
							cnt = 2;
						}
					}
					
					d = this.numfore.length - 1;
					s.unshift(this.numfore.charAt(d));
					this.numfore = this.numfore.substring(0,d);
				} 
				else 
				{
					// ran out of numbers, put mask character in
					var display/*Object*/ = this.mask[mi].display;
					if (display.length != 0) 
					{
						if (this.bcomma && cnt-- == 0) 
						{
							s.unshift(this.IMThousandsSeparator);
							cnt = 2;
						}
						s.unshift(this.mask[mi].display);
					}
				}
				
				ml = mi;
			}
			// ran out of mask, so stuff everything in current spot
			if (this.numfore.length > 0) 
			{
				if (this.bcomma) 
				{
					while (this.numfore.length > 0) 
					{
						if (cnt-- == 0) 
						{
							s.unshift(this.IMThousandsSeparator);
							cnt = 2;
						}
						d = this.numfore.length - 1;
						s.unshift(this.numfore.charAt(d));
						this.numfore = this.numfore.substring(0,d);
					}
				} 
				else 
				{
					s.unshift(this.numfore);
				}
			}
			// take care of the rest of the literals
			a = this.mask;
			
			//this is a hack to reset the index		
			if(this.currencyIndex != -1)
				i=0;
		
			for (j=ml-1; j>=0; j--) 
			{
				if ((typeof a[i]) == "object") 
				{
					s.unshift(this.mask[j].display);
				} 
				else 
				{
					s.unshift(this.mask[j]);
				}
			}
			// do the period and rest of masks
			l = this.mask.length;
			i = (this.period == -1) ? (l) : (this.period);

			mi = 0;
			for ( ; i<l; i++) 
			{
				if ((typeof a[i]) == "object") 
				{
					if (this.maft[mi] == i) 
					{
						mi++;
						if (this.numaft.length > 0) 
						{
							s.push(this.numaft.charAt(0));
							this.numaft = this.numaft.substring(1);
						} 
						else 
						{
							s.push(a[i].display);
						}
					} 
					else 
					{
						s.push(a[i].display);
					}
				} 
				else 
				{
					s.push(a[i]);
				}
			}
	
			var rv/*String*/;
			// add the sign
			if (this.bsign) 
			{
				rv = this.sign + s.join("");
			} 
			else 
			{
				rv = s.join("");
			}
			return rv;
		}
		
		sap.common.globalization.numericFormat.FNumber.prototype.setNumber = function(num/*Number*/)/*void*/ {
			// scale
			num = num * this.scale;
			// round
			var l/*uint*/ = this.maft.length;
			var p/*Function*/ = Math.pow;
			var s/*Number*/ = p(10, l);
			if (num < 0)
				s *= -1;
			var n/*Number*/ = num * s;
			n = Math.round(n);
			num = n/s;
			// break up to two strings before and after decimal
			var strnum/*Array*/ = num.toString().split(".");
			this.numfore = strnum[0];
			// take care of the sign
			if (this.numfore.charAt(0) == '-') {
				this.sign = '-';
				this.numfore = this.numfore.substring(1);
			} else {
				this.sign = "";
			}
			if (this.numfore.charAt(0) == '0') {
				this.numfore = this.numfore.substring(1);
			}
			this.numaft = undefined;
			if (strnum.length < 2) {
				this.numaft = "";
			} else  {
				this.numaft = strnum[1];
			}

		}
		
		sap.common.globalization.numericFormat.FNumber.prototype.createTokenFormatter = function(clazz/*Class*/)/*Object*/
		{
			var token/*Object*/ = null;
			var _s_numericFormat = sap.common.globalization.numericFormat;
			switch(clazz)
			{
				case _s_numericFormat.FNumS:
					token = new sap.common.globalization.numericFormat.FNumS(this.parseLocaleInfo);
					break;
				case _s_numericFormat.FNumQ:
					token = new sap.common.globalization.numericFormat.FNumQ(this.parseLocaleInfo);
					break;
				case _s_numericFormat.FNumP:
					token = new sap.common.globalization.numericFormat.FNumP();
					break;
				case _s_numericFormat.FNum0:
					token = new sap.common.globalization.numericFormat.FNum0(this.parseLocaleInfo);
					break;
				case _s_numericFormat.FPeriod:
					token = new sap.common.globalization.numericFormat.FPeriod(this.parseLocaleInfo, this.displayLocaleInfo);
					break;
				case _s_numericFormat.FCurr:
					token = new sap.common.globalization.numericFormat.FCurr(this.parseLocaleInfo, this.displayLocaleInfo);
					break;
				default:
					// this should not happend since there's check before call this method
			}
			return token;
		}

})();
(function()
{
	sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultNumber");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");
	sap.common.globalization.require("sap.common.globalization.numericFormat.DefaultGroupingStrategy");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FPeriod");
	/**
	 * A special version of FNumber. It will not show the decimal point if
	 * the fracion part of the number is zero.
	 * [NOTE]: Please do NOT use it in non-default formats!!! It's supposed
	 * to be used only for default number format.
	 */

	sap.common.globalization.numericFormat.FDefaultNumber = function(parseLocaleInfo/*:INumericParseLocaleInfo*/, displayLocaleInfo/*:INumericDisplayLocaleInfo*/) {
		sap.common.globalization.numericFormat.FDefaultNumber.superclass.constructor.apply(this, [parseLocaleInfo, displayLocaleInfo]);		this.__className = "sap.common.globalization.numericFormat.FDefaultDateNumber";
		this._groupingStrategy/*:IGroupingStrategy*/ = sap.common.globalization.numericFormat.DefaultGroupingStrategy.instance();
	}
	sap.common.globalization.numericFormat.FDefaultNumber = sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultNumber, sap.common.globalization.numericFormat.FNumber);
	sap.common.globalization.numericFormat.FDefaultNumber.prototype.display = function(num/*:**/)/*:String*/
	{
		if( typeof (num) != "number") {
			return num;
		}

		if(isNaN(num) || !isFinite(num)) {
			return num;
		}

		if(this.mfore.length == 0 && this.maft.length == 0) {
			return this.format;
		}
		this.setNumber(num);

		// put numbers into array for numbers before period
		var s/*:Array*/ = new Array();
		var l/*:int*/ = this.mfore.length;
		var cnt/*:int*/ = 3;
		// count of digits for comma placement
		var mi/*:int*/ = this.period;
		var ml/*:int*/ = (mi == -1) ? (this.mask.length) : mi;
		var j/*:int*/;
		var d/*:int*/;
		var a/*:**/;
		for(var i/*:int*/ = l - 1; i >= 0; i--) {
			mi = this.mfore[i];

			//queue up the literals
			for( j = ml - 1; j > mi; j--) {
				a = this.mask[j];
				if(( typeof a) == "object") {
					s.unshift(a.display);
				} else {
					s.unshift(a);
				}
			}
			if(this.numfore.length > 0) {
				// put a number where mask character goes
				if(this.bcomma) {
					if(cnt-- == 0) {
						s.unshift(	this.IMThousandsSeparator); //TODO 	TO be verified. super.IMThousandsSeparator cannot be accessed 'cause no instance refrence
						cnt = this._groupingStrategy.nextGroupDigits();
					}
				}
				d = this.numfore.length - 1;
				s.unshift(this.numfore.charAt(d));
				this.numfore = this.numfore.substring(0, d);
			} else {
				// ran out of numbers, put mask character in
				var display/*:**/ = this.mask[mi].display;
				if(display.length != 0) {
					if(this.bcomma && cnt-- == 0) {
						s.unshift(this.IMThousandsSeparator);
						cnt = this._groupingStrategy.nextGroupDigits();
					}
					s.unshift(this.mask[mi].display);
				}
			}
			ml = mi;
		}
		// ran out of mask, so stuff everything in current spot
		if(this.numfore.length > 0) {
			if(this.bcomma) {
				while(this.numfore.length > 0) {
					if(cnt-- == 0) {
						s.unshift(this.IMThousandsSeparator);
						cnt = this._groupingStrategy.nextGroupDigits();
					}
					d = this.numfore.length - 1;
					s.unshift(this.numfore.charAt(d));
					this.numfore = this.numfore.substring(0, d);
				}
			} else {
				s.unshift(this.numfore);
			}
		}
		// take care of the rest of the literals
		a = this.mask;

		//this is a hack to reset the index
		if(this.currencyIndex != -1)
			i = 0;

		for( j = ml - 1; j >= 0; j--) {
			if(( typeof a[i]) == "object") {
				s.unshift(this.mask[j].display);
			} else {
				s.unshift(this.mask[j]);
			}
		}

		// do the period and rest of masks
		l = this.mask.length;
		i = (this.period == -1) ? (l) : (this.period);
		mi = 0;
		var dropFraction/*:Boolean*/ = false;
		for(; i < l; i++) {
			if(( typeof a[i]) == "object") {
				// IMPORTANT: the only difference, we won't show decimal number
				// if the fraction part is zero.
				//TODO
				if(a[i].__className == "sap.common.globalization.numericFormat.FPeriod" /*is FPeriod*/ && !this.numaft) {
					dropFraction = true;
					continue;
				}
				if(this.maft[mi] == i) {
					mi++;
					if(this.numaft.length > 0) {
						if(!dropFraction)
							s.push(this.numaft.charAt(0));
						this.numaft = this.numaft.substring(1);
					} else {
						s.push(a[i].display);
					}
				} else {
					s.push(a[i].display);
				}
			} else {
				s.push(a[i]);
			}
		}
		var rv/*:String*/;
		// add the sign
		if(this.bsign) {
			rv = this.sign + s.join("");
		} else {
			rv = s.join("");
		}
		return rv;

		//return super.display(num);
	}

	sap.common.globalization.numericFormat.FDefaultNumber.prototype.groupingStrategy = function(strategy/*:IGroupingStrategy*/)/*:void*/
	{
		if(this._groupingStrategy != strategy) {
			this._groupingStrategy = strategy;
		}
	}
})();
(function() {

	sap.common.globalization.declare("sap.common.globalization.numericFormat.FT");
	sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FText");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");
	
	
	sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");
	
	
	

	//For ADAPT01422479
	//Normally, a number format has three parts seperated by semi-colon: part1;part2;part3
	//If a number format has less than 3 parts, Excel will use the 1st part for values which don't meet any condition.

	//But, for number format which has custom condition, Excel will parse the value using another way:
	//Given this number format: [condition1]part1;[condition2]part2;part3
	//If a value doesn't meet condition1 and condition2, Excel will parse this number using "part3".
	//So, we need a flag to tell whether custom condition is set.
	//If there is no custom condition, use the 1st part by default.
	//If there is custom condition, use the last part by default.

	/**
	 * Constructor
	 */
	sap.common.globalization.numericFormat.FT = function(dateLocaleFactory/*IDateLocaleFactory=null*/, numericLocaleFactory/*INumericLocaleFactory=null*/) {

		this.__className = "sap.common.globalization.numericFormat.FT";
		this._hasCustomCondition = false;
		this.color = undefined;

		this.o = new Array();
		// positive, negative, zero, text

		this._dateLocaleFactory = dateLocaleFactory ? dateLocaleFactory:sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory.getInstance();
		this._numericLocaleFactory = numericLocaleFactory ? numericLocaleFactory:sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory.getInstance();
	}
	var numFT = sap.common.globalization.numericFormat.FT;

	// class static member
	// public static var ftarr:Array = new Array();
	numFT.ftarr = new Array();
	// constants for parsing condition tokens
	// private static const CONDITION_TOKENS:String = "=<>";
	numFT._CONDITION_TOKENS/*String*/ = "=<>";

	numFT._equals = function(a/*Number*/, b/*Number*/)/*Boolean*/
	{
		return (a == b);
	};
	numFT._neq = function(a/*Number*/, b/*Number*/)/*Boolean*/
	{
		return (a != b);
	};
	numFT._gthan = function(a/*Number*/, b/*Number*/)/*Boolean*/
	{
		return (a > b);
	};
	numFT._gte = function(a/*Number*/, b/*Number*/)/*Boolean*/
	{
		return (a >= b);
	};
	numFT._lthan = function(a/*Number*/, b/*Number*/)/*Boolean*/
	{
		return (a < b);
	};
	numFT._lte = function(a/*Number*/, b/*Number*/)/*Boolean*/
	{
		return (a <= b);
	};
	// functions of condition
	// private static const CONDITIONS:Object = {
	numFT._CONDITIONS = {
		"=" : sap.common.globalization.numericFormat.FT._equals,
		"<>" : sap.common.globalization.numericFormat.FT._neq,
		"<" : sap.common.globalization.numericFormat.FT._lthan,
		"<=" : sap.common.globalization.numericFormat.FT._lte,
		">" : sap.common.globalization.numericFormat.FT._gthan,
		">=" : sap.common.globalization.numericFormat.FT._gte
	};

	// constants for parsing color tokens
	// private static const COLORS:Object = {
	numFT._COLORS = {
		"black" : 0x000000,
		"blue" : 0x0000FF,
		"cyan" : 0x00FFFF,
		"green" : 0x00FF00,
		"magenta" : 0xFF00FF,
		"red" : 0xFF0000,
		"white" : 0xFFFFFF,
		"yellow" : 0xFFFF00
	};

	numFT.prototype._isNumeric = function(format/*String*/)/*:Boolean*/
	{
		// const tokens:String = "#?%";
		var tokens/*String*/ = "#?%";

		var l = tokens.length;
		for(var i/*int*/ = 0; i < l; i++) {
			if(format.indexOf(tokens.charAt(i)) != -1)
				return true;
		}

		return false;
	};

	numFT.prototype.parse = function(format/*String*/) {
		this._hasCustomCondition = false;
		var f/*String*/ = format;
		var l/*int*/ = format.length;
		var c/*String*/;
		var index/*int*/ = 0;
		// index into objects below
		for(var i/*int*/ = 0; i < l; i++) {
			c = f.charAt(i);
			if(c == '"') {
				while(i < l) {
					if(f.charAt(++i) == '"' && f.charAt(i - 1) != '\\')
						break;
				}
				continue;
			}
			if(c == '\\' || c == '_' || c == '*') {
				i++;
				continue;
			}
			if(c == ';') {
				if(this.o[index] == undefined) {
					this.o[index] = new sap.common.globalization.numericFormat.FText();
				}
				this.o[index].format = f.substring(0, i);
				index++;
				f = f.substring(i + 1);
				l = f.length;
				i = -1;
				continue;
			}
			if(c == '[') {
				var str/*String*/ = "";
				while(f.charAt(++i) != ']' && (i < l))
				str += f.charAt(i);
				// custom handling, warning major hack
				var sl/*int*/ = str.length;
				var c1/*String*/ = str.charAt(0);
				if(c1 == 's' || c1 == 'm' || c1 == 'h') {
					for(var j/*Number*/ = 1; j < sl; j++) {
						var c2/*String*/ = str.charAt(j);
						if(c1 != c2) {
							break;
						}
					}
					if(j == sl) {
						if(this.o[index] == undefined) {
							this.o[index] = this._dateLocaleFactory.createFDate();
						}
					}
				}
			}
			
			// date tokens dynamically generated
			var zz/*int*/ = sap.common.globalization.numericFormat.FDate.tokens.indexOf(c);
			// ADAPT01376528 currency symbol may have FDate's token, so we need additional check for numeric
			if(sap.common.globalization.numericFormat.FDate.tokens.indexOf(c) != -1 && !this._isNumeric(format)) {
				if(this.o[index] == undefined) {
					this.o[index] = this._dateLocaleFactory.createFDate();
				}
				this.o[index] = this._dateLocaleFactory.createFDate();
			}
			else if (sap.common.globalization.numericFormat.FNumber.tokens.indexOf(c) != -1)
			{
				if(this.o[index] == undefined) {

					this.o[index] = this._numericLocaleFactory.createFNumber();
					
					// don't do negative sign for second entry
					if(index == 1) {
						this.o[index].bsign = false;
					}
				}
			} else if(sap.common.globalization.numericFormat.FText.tokens.indexOf(c) != -1) {
				if(this.o[index] == undefined) {
					this.o[index] = new sap.common.globalization.numericFormat.FText();
				}
			}
		}

		if(this.o[index] == undefined) {
			this.o[index] = this._numericLocaleFactory.createFNumber();
		}

		this.o[index].format = f;

		var ol/*uint*/ = this.o.length;
		for(var i1/*uint*/ = 0; i1 < ol; i1++) {
			var o/* Object */ = this.o[i1];
			// init default condition
			o.condnum = 0;
			if(i1 == 0) {
				o.cond = sap.common.globalization.numericFormat.FT._gthan;
			} else if(i1 == 1) {
				o.cond = sap.common.globalization.numericFormat.FT._lthan;
			} else if(i1 == 2) {
				o.cond = sap.common.globalization.numericFormat.FT._equals;
			}

			var a/* Object */ = o.mask;
			var q/*Boolean*/ = false;
			f = o.format;
			l = f.length;
			for( var j = 0; j < l; j++) {
				c = f.charAt(j);
				// quote handling
				if(c == '"') {
					q = !q;
					continue;
				}

				// backslash handling
				if(c == '\\') {
					j++;
					c = f.charAt(j);
					a.push(c);
					continue;
				}

				if(q) {
					a.push(c);
					continue;
				}
				// * not handling
				if(c == '*') {
					j++;
					continue;
				}
				// _ spacing is just one space
				if(c == '_') {
					j++;
					a.push(' ');
					continue;
				}

				if(c == '[') {
					//We process two kinds of Format
					//Format 1: [$$-409]
					//Format 2: [$NSD]
					//The format 2 is a new format
					c1 = f.charAt(j + 1);
					c2 = f.charAt(j + 2);
					if(c1 == '$' && c2 != "-")// special prefix handling
					{
						var closeBracketIdx/*int*/ = f.indexOf("]", j + 1);
						if(closeBracketIdx != -1) {
							var prefix/*String*/ = f.substring(j + 1, closeBracketIdx);
							if(str.indexOf("-") != -1) {
								prefix = str.substring(1, str.indexOf("-"));
							} else {
								prefix = str.substring(1);
							}
							for(var prefIdx/*int*/ = 0; prefIdx < prefix.length; ++prefIdx) {
								a.push(prefix.charAt(prefIdx));
							}
							j = closeBracketIdx;
							continue;
						}
					} else// color handling
					{
						str = f.substring(j + 1);
						str = str.substring(0, str.indexOf(']')).toLowerCase();

						if(sap.common.globalization.numericFormat.FT._COLORS[str] != undefined) {
							// color handling
							o.color = sap.common.globalization.numericFormat.FT._COLORS[str];
							j += str.length + 1;
							continue;
						} else if(str == "h" || str == "m" || str == "s") {
						} else {
							// conditional handling
							var ind/*Object*/ = 1;
							while(sap.common.globalization.numericFormat.FT._CONDITION_TOKENS.indexOf(str.charAt(ind)) != -1) {
								ind++;
							}
							var tok/*String*/ = str.substring(0, ind);
							if(sap.common.globalization.numericFormat.FT._CONDITIONS[tok] != undefined) {
								o.cond = sap.common.globalization.numericFormat.FT._CONDITIONS[tok];
								o.condnum = str.substring(ind);
								j += str.length + 1;
								this._hasCustomCondition = true;
								continue;
							} else {
								// skip unknown token
								j += str.length + 1;
								continue;
							}
						}
					}
				}

				// token handling
				var ret/*Object */ = o.parse(f.substring(j));
				if(ret > 0) {
					j += ret - 1;
				} else {
					a.push(c);
				}
			}
		}
	};
	//ADAPT01306502 - invoke this function will change the color which caused this bug.
	//Pay more attenation on this problem if you need invoke this method for multiple times.
	numFT.prototype.display = function(num/*Object*/)/*String*/
	{
		var o/*Object*/ = this.o[0];
		var l/*int*/ = this.o.length;
		if(l > 3 && sap.common.globalization.utils.BaseUtils.isString(num)) {
			o = this.o[3];
		} else {
			if(this._hasCustomCondition && l > 0) {
				if(l <= 3)
					o = this.o[l - 1];
				else
					o = this.o[2];
			}
			for(var i/*int*/ = 0; i < 3 && i < l; i++) {
				var ob/*Object*/ = this.o[i];
				if(ob && ob.cond(num, ob.condnum)) {
					o = ob;
					break;
				}
			}
		}
		if(!isNaN(o.color)) {
			this.color = o.color;
		} else {
			this.color = undefined;
			// default
		}

		return (o.display(num));
	}



	/**
	 * @private
	 * Get the numeric display locale info of this Formatter.
	 * separator in order to abbreviate the formatted label.
	 *
	 * @return
	 *
	 */
	numFT.prototype.getNumericDisplayLoacleInfo = function()/*INumericDisplayLocaleInfo*/
	{
		return this._numericLocaleFactory.getNumericDisplayLocaleInfo();
	};


})();
(function(){

	sap.common.globalization.declare("sap.common.globalization.numericFormat.FTBoolean");
	
	sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.NumericFormatManager;");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FT");
	sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");
	
		var  numFormat  = sap.common.globalization.numericFormat;
	
	sap.common.globalization.numericFormat.FTBoolean = function(dateLocaleFactory/*IDateLocaleFactory=null*/, numericLocaleFactory/*INumericLocaleFactory=null*/)
	{
		
		numFormat.FTBoolean.superclass.constructor.apply(this, [ dateLocaleFactory, numericLocaleFactory ]);
		this.__className = "sap.common.globalization.numericFormat.FTBoolean";	

		dateLocaleFactory  = dateLocaleFactory || null;
		numericLocaleFactory = numericLocaleFactory || null;
		
		
		this._booleanLocaleFactory = sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory.getInstance();
	};
	
	// numFormat.FTBoolean.BOOLEAN_TOKEN = sap.common.globalization.NumericFormatManager.DEFAULT_FORMAT_BOOLEAN;
	numFormat.FTBoolean.BOOLEAN_TOKEN = "SAP_DEFAULT_BOOLEAN_FORMAT";
	
	numFormat.FTBoolean = sap.common.globalization.extend(numFormat.FTBoolean, numFormat.FT);
	
	
	sap.common.globalization.numericFormat.FTBoolean.prototype.parse = function(format/*String*/)
	{
		if (format == numFormat.FTBoolean.BOOLEAN_TOKEN){
			this.o[0] = this;	
		}
		else
		{
			// push a FTBoolean to array o, because there are abused use of FT.o in other classes.
			this.o[0] = null;	
		}
	}
	
	sap.common.globalization.numericFormat.FTBoolean.prototype.display = function(bool/*Object*/)/*String*/
	{
		var retValue/*String*/ = String(bool);
		var localeInfo/*IBooleanDisplayLocaleInfo*/ = this._booleanLocaleFactory.getBooleanDisplayLocaleInfo();
		if (localeInfo && this.o[0].__className == "sap.common.globalization.numericFormat.FTBoolean") // this.o[0] is FTBoolean
		{
			if (sap.common.globalization.utils.BaseUtils.isBoolean(bool))
			{
				retValue = bool? localeInfo.trueString():localeInfo.falseString();
			}
			else if (sap.common.globalization.utils.BaseUtils.isString(bool) && (String(bool).toLowerCase() == "true"||String(bool).toLowerCase() == "false"))
			{
				retValue = String(bool).toLowerCase() == "true" ? localeInfo.trueString():localeInfo.falseString();
			}
		}
		return retValue;
	}

})();
(function(){
	    sap.common.globalization.declare("sap.common.globalization.numericFormat.FTimeSep");

		sap.common.globalization.numericFormat.FTimeSep =function(pLocale/*IDateParseLocaleInfo*/, dLocale/*IDateDisplayLocaleInfo*/)
		{
			this._parseLocale = pLocale;
			this._displayLocale = dLocale;
		}
		
		sap.common.globalization.numericFormat.FTimeSep.prototype.parse = function(o/*FDate*/, format/*String*/)/*int*/
		{
			var symb/*String*/ = format.charAt(0);
			
			//only if the SAPTimeSeparator has been set by Flashvars...
			if(this._displayLocale.IMTimeSeparator() != null && (symb == ":" || symb == ".") )
				return 1;
			else
				return 0; //do not add this to mask
			
		}
		sap.common.globalization.numericFormat.FTimeSep.prototype.display = function(o/*FDate*/)/*String*/
		{
			return this._displayLocale.IMTimeSeparator();
		}

})();
(function(){

	sap.common.globalization.declare("sap.common.globalization.numericFormat.FTUtil");
	
	 /**
	 * @private
	 * 	Check whether the ft represents a boolean type format. 
	 * @return 
	 * 
	 */
	sap.common.globalization.numericFormat.FTUtil.isBooleanFT = function(ft/*FT*/)/*Boolean*/
	{
		// return ft && ft is FTBoolean;
		return ft && (ft.__className == "sap.common.globalization.numericFormat.FTBoolean");	
	}
	
	/**
	 * Check whether the ft represents a date(include time) type format. 
	 * @param ft
	 * @return 
	 * 
	 */
	sap.common.globalization.numericFormat.FTUtil.isDate = function(ft/*FT*/)/*Boolean*/
	{
		// return ft && ft.o && ft.o.length>0 && ft.o[0] is FDate;
		return ft && ft.o && ft.o.length>0 && (ft.o[0].__className == "sap.common.globalization.numericFormat.FDate");
	}

})();


(function() {
	sap.common.globalization.declare("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");

	/**
	 * @private
	 * Grouping strategy for special locales including gu gu_IN
	 * hi hi_IN kn kn_IN kok kok_IN mr mr_IN pa pa_IN ta ta_IN te te_IN
	 */
	sap.common.globalization.numericFormat.TwoDigitGroupingStrategy= function()
	{
		this.__className = "sap.common.globalization.numericFormat.TwoDigitGroupingStrategy";
	}
	
	var _s_g_nf_tDGroupStrategy = sap.common.globalization.numericFormat.TwoDigitGroupingStrategy;

	_s_g_nf_tDGroupStrategy._instance/*TwoDigitGroupingStrategy*/ = new sap.common.globalization.numericFormat.TwoDigitGroupingStrategy();
	// should return 1
	_s_g_nf_tDGroupStrategy.prototype.nextGroupDigits =function()/*int*/
	{
		return 1;
	};
	
	_s_g_nf_tDGroupStrategy.instance = function()/*IGroupingStrategy*/
	{
		return _s_g_nf_tDGroupStrategy._instance;
	};

})();(function(){

		sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultCurrencyNumber");
		
		sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");
		sap.common.globalization.require("sap.common.globalization.numericFormat.DefaultGroupingStrategy");
			
		var _s_g_nf = sap.common.globalization.numericFormat;
		
		sap.common.globalization.numericFormat.FDefaultCurrencyNumber = function(parseLocaleInfo/*INumericParseLocaleInfo*/, displayLocaleInfo/*INumericDisplayLocaleInfo*/)
		{
			sap.common.globalization.numericFormat.FDefaultCurrencyNumber.superclass.constructor.apply(this, [parseLocaleInfo,displayLocaleInfo]);
			
			this.__className = "sap.common.globalization.numericFormat.FDefaultCurrencyNumber";
			
			this._groupingStrategy/*IGroupingStrategy*/ = _s_g_nf.DefaultGroupingStrategy.instance();
		}
		
		_s_g_nf.FDefaultCurrencyNumber = sap.common.globalization.extend(_s_g_nf.FDefaultCurrencyNumber, _s_g_nf.FNumber);
		
		
		/**
		 * @private
		 * Override. Here is just a copy. The difference is that it contains a 
		 * fix for a bug regarding how to fetch display value of a mask. 
		 */
		_s_g_nf.FDefaultCurrencyNumber.prototype.display =function(num/*Object*/)/*String*/
		{
			if (typeof(num) != "number") 
			{
				return num;
			}
	
			if (isNaN(num) || !isFinite(num)) 
			{
				return num;
			}
	
			if (this.mfore.length == 0 && this.maft.length == 0) 
			{
				return this.format;
			}
			this.setNumber(num);
	
			// put numbers into array for numbers before period
			var s/*Array*/ = new Array();
			var l/*int*/ = this.mfore.length;
			var cnt/*int*/ = 3; // count of digits for comma placement
			var mi/*int*/ = this.period;
			var ml/*int*/ = (mi==-1) ? (this.mask.length) : mi;
			var j/*int*/;
			var d/*int*/;
			var a/*Object*/;
			for (var i/*int*/ = l-1; i>=0; i--) 
			{
				mi = this.mfore[i];
				
				//queue up the literals
				for (j=ml-1; j>mi; j--) 
				{
					a = this.mask[j];
					if ((typeof a) == "object") 
					{
						s.unshift(a.display);
					} 
					else 
					{
						s.unshift(a);
					}
				}
				if (this.numfore.length > 0) 
				{
					// put a number where mask character goes
					if (this.bcomma) 
					{
						if (cnt-- == 0) 
						{
							s.unshift(this.IMThousandsSeparator);
							cnt  = this._groupingStrategy.nextGroupDigits();
						}
					}
					
					d = this.numfore.length - 1;
					s.unshift(this.numfore.charAt(d));
					this.numfore = this.numfore.substring(0,d);
				} 
				else 
				{
					// ran out of numbers, put mask character in
					var display/*Object*/ = this.mask[mi].display;
					if (display.length != 0) 
					{
						if (this.bcomma && cnt-- == 0) 
						{
							s.unshift(this.IMThousandsSeparator);
							cnt  = this._groupingStrategy.nextGroupDigits();
						}
						s.unshift(this.mask[mi].display);
					}
				}
				
				ml = mi;
			}
			// ran out of mask, so stuff everything in current spot
			if (this.numfore.length > 0) 
			{
				if (this.bcomma) 
				{
					while (this.numfore.length > 0) 
					{
						if (cnt-- == 0) 
						{
							s.unshift(this.IMThousandsSeparator);
							cnt  = this._groupingStrategy.nextGroupDigits();
						}
						d = this.numfore.length - 1;
						s.unshift(this.numfore.charAt(d));
						this.numfore = this.numfore.substring(0,d);
					}
				} 
				else 
				{
					s.unshift(this.numfore);
				}
			}
			// take care of the rest of the literals
			a = this.mask;
			
			//this is a hack to reset the index		
			if(this.currencyIndex != -1)
				i=0;
		
			for (j=ml-1; j>=0; j--) 
			{
				/*
				 * IMPORTANT: Work around here! I think a[i] is not the correct
				 * way to judge since we're adding this.mask[j] into "s". So here
				 * I add a second check whether this.mask[j] is a class. Otherwise
				 * "XXX Object" will be added into "s".
				 */
				if ((typeof this.mask[j]) == "object")
				{
					s.unshift(this.mask[j].display);
				} else {
					s.unshift(this.mask[j]);
				}
			}
			// do the period and rest of masks
			l = this.mask.length;
			i = (this.period == -1) ? (l) : (this.period);

			mi = 0;
			for ( ; i<l; i++) 
			{
				if ((typeof a[i]) == "object") 
				{
					if (this.maft[mi] == i) 
					{
						mi++;
						if (this.numaft.length > 0) 
						{
							s.push(this.numaft.charAt(0));
							this.numaft = this.numaft.substring(1);
						} 
						else 
						{
							s.push(a[i].display);
						}
					} 
					else 
					{
						s.push(a[i].display);
					}
				} 
				else 
				{
					s.push(a[i]);
				}
			}
	
			var rv/*String*/;
			// add the sign
			if (this.bsign) 
			{
				rv = this.sign + s.join("");
			} 
			else 
			{
				rv = s.join("");
			}
			return rv;
		}
		
		_s_g_nf.FDefaultCurrencyNumber.prototype.groupingStrategy = function(strategy/*IGroupingStrategy*/)
		{
			if (this._groupingStrategy != strategy)
			{
				this._groupingStrategy = strategy;
			}
		}

})();(function() {

	sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory");
	
	sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");
	sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");
	sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultCurrencyNumber");
	sap.common.globalization.require("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");
	sap.common.globalization.require("sap.common.globalization.GlobalizationNumericUtil");
	
	
	/**
	 * Constructor. You need to pass in the original format string in document.xml.
	 * 
	 * @param formatString formating string stored in document.xml
	 */
	sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory =function(formatString/*String*/)
	{
		sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory.superclass.constructor.apply(this, [formatString]);
		
		this.__className = "sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory";
		this._displayCurrencySymbol/*String*/ = null;
		
		if (sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat(formatString))
		{
			this._parseCurrencySymbol(formatString);
		}
	}

	var _s_g_d = sap.common.globalization.defaultFormat; 
	
	_s_g_d.DefaultCurrencyFormatLocaleFactory = sap.common.globalization.extend(_s_g_d.DefaultCurrencyFormatLocaleFactory, _s_g_d.DefaultNumericFormatLocaleFactory);

	// regular expression for parsing default currency format
	_s_g_d.DefaultCurrencyFormatLocaleFactory.REG_DEFAULT_CURRENCY_FORMAT/*RegExp*/ = new RegExp('^SAP_DEFAULT_CURRENCY_FORMAT(;".*")?$', "i");
	
	/* the currency symbol. Since the currency symbol is specified by user,
	 * we need to preserve it here to parse it to the Parse/Display Locale
	 * Info.
	 */
	
	/**
	 * Check whether the given format string is a default currency format.
	 * 
	 * @param formatString format string to check.
	 * @return true if the given format string is a default currency format; false otherwise.
	 */
	_s_g_d.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat = function(formatString/*String*/)/*Boolean*/
	{
		return _s_g_d.DefaultCurrencyFormatLocaleFactory.REG_DEFAULT_CURRENCY_FORMAT.test(formatString);
	}

	/**
	 * Get default predefined number format string according to the current locale.
	 * If the PVL is available, get the predefined format string according to PVL. Otherwise,
	 * get the predefined strings according to the document locale.
	 * 
	 * @return format string for FT to parse.
	 */
	_s_g_d.DefaultCurrencyFormatLocaleFactory.prototype.getDefaultCurrencyFormat = function()/*String*/
	{
		return sap.common.globalization.GlobalizationNumericConstant.getDefaultCurrencyFormat();
	}
	
	/**
	 * Parse and set currency symbol.
	 */
	_s_g_d.DefaultCurrencyFormatLocaleFactory.prototype._parseCurrencySymbol = function(formatString/*String*/)/*void*/
	{
		if ("SAP_DEFAULT_CURRENCY_FORMAT" == formatString)
		{
			this._displayCurrencySymbol = "";
		} else {
			this._displayCurrencySymbol = formatString.slice(29, formatString.length - 1);
		}
	}
	
	_s_g_d.DefaultCurrencyFormatLocaleFactory.prototype.createFNumber = function()/*FNumber*/
	{
		// should return a default FNumber implementation
		var fNumber/*FDefaultCurrencyNumber*/ = new sap.common.globalization.numericFormat.FDefaultCurrencyNumber(this.getNumericParseLocaleInfo(), this.getNumericDisplayLocaleInfo());
		if (sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry(sap.common.globalization.GlobalizationNumericConstant.getActualLocaleForDefaultCurrencyFormat()))
		{
			fNumber._groupingStrategy = sap.common.globalization.numericFormat.TwoDigitGroupingStrategy.instance();
		}
		return fNumber;
	}
	
	_s_g_d.DefaultCurrencyFormatLocaleFactory.prototype.displayCurrencySymbol =function()/*String*/
	{
		// return the parsed display currency symbol
		return this._displayCurrencySymbol;
	}
		
})();
}; // end of sap.service.visualization.chart.ChartSourceCode.libs.sapcommonglobalization
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.ChartSourceCode.libs.saprivbase') ) {
  jQuery.sap.declare('sap.service.visualization.chart.ChartSourceCode.libs.saprivbase');
(function() {
	var undefined = void (0);
	if (window.sap !== undefined && window.sap.riv !== undefined && window.sap.riv.require !== undefined) {
		// In case of already defined
		return;
	}

	if (window.sap !== undefined && window.sap.riv !== undefined && window.sap.riv.module !== undefined) {
		// In case of already defined
		return;
	}

	var isJQueryUsed = jQuery !== undefined ? true : false

	var jQueryHoldReady = function(shouldHold) {
		if (isJQueryUsed) {
			if (jQuery.holdReady) {
				jQuery.holdReady(shouldHold);
			} else if (shouldHold) {
				jQuery.readyWait += 1;
			} else {
				jQuery.ready(true);
			}
		}
	}
	var curScript = undefined;
	var context_path = '/';
	var scripts = document.getElementsByTagName("script");
	var trace = function() {
	};
	// A ugly way to determine whether the script tag is used for
	// loading sap.riv.base.js
	// Sometimes the base js is not loaded via script tag
	if (scripts.length && scripts[scripts.length - 1].getAttribute('src')
			&& scripts[scripts.length - 1].getAttribute('src').lastIndexOf('sap.riv.base.js')) {
		curScript = scripts[scripts.length - 1];
		if (((curScript.getAttribute('trace') || '').toLowerCase() === 'true') && (typeof console !== undefined)) {
			trace = function(traceLog) {
				console.log(traceLog);
			};
		}

		var context_path = curScript.getAttribute('base-url');

		if (!context_path) {
			var src = curScript.getAttribute('src');
			context_path = src.substring(0, src.lastIndexOf('/'));
		}
		if (context_path.charAt(context_path.length - 1) !== '/')
			context_path = context_path + '/';
	}

	window.sap = window.sap || {};
	window.sap.riv = window.sap.riv || {};

	var ModuleStatus = {
		ENTRY_CREATED : 0,
		IN_LOADING : 1,
		DEFINED : 2,
		ERROR : 3
	};

	var hasOwn = Object.prototype.hasOwnProperty;

	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	var isFunction = function(obj) {
		return type(obj) === "function";
	};

	var isArray = Array.isArray || function(obj) {
		return type(obj) === "array";
	};

	var isString = function(obj) {
		return type(obj) === "string";
	};

	// A crude way of determining if an object is a window
	var isWindow = function(obj) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	};

	var isNaN = function(obj) {
		return obj == null || !/\d/.test(obj) || isNaN(obj);
	};

	var isNumber = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};

	var isDefined = function(v) {
		return typeof (v) !== 'undefined';
	};

	var isUndefined = function(v) {
		return typeof (v) === 'undefined';
	};

	var isPlainObject = function(obj) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the
		// constructor property.
		// Make sure that DOM nodes and window objects don't pass through,
		// as well
		if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
			return false;
		}

		// Not own constructor property must be Object
		if (obj.constructor && !hasOwn.call(obj, "constructor")
				&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	var isEmptyObject = function(obj) {
		for ( var name in obj) {
			return false;
		}
		return true;
	};

	var ModuleEntry = function(qname, version) {
		this._qname = qname;
		this._version = version;
		this._moduleSetupFunc = undefined;
		this._status = ModuleStatus.ENTRY_CREATED;
		this._moduleObject = undefined;
		this._exportToGlobal = false;
		this._depList = [];
		this._pendingDefTaskList = [];
		jQueryHoldReady(true);
	};
	ModuleEntry.prototype.moduleObject = function(moduleObj) {
		return this._moduleObject;
	};
	ModuleEntry.prototype.setupFunction = function(setupFunction) {
		if (isDefined(setupFunction)) {
			this._moduleSetupFunc = setupFunction;
			return this;
		} else {
			return this._moduleSetupFunc;
		}
	};
	ModuleEntry.prototype.setModuleObject = function(moduleObj) {
		this._moduleObject = moduleObj;
	};
	ModuleEntry.prototype.qname = function() {
		return this._qname;
	};
	ModuleEntry.prototype.version = function() {
		return this._version;
	};
	ModuleEntry.prototype.status = function(status) {
		if (status !== undefined) {
			this._status = status;
			return this;
		} else {
			return this._status;
		}
	};
	ModuleEntry.prototype.dependentModules = function(depList) {
		if (isDefined(depList)) {
			this._depList = depList;
			return this;
		} else {
			return this._depList;
		}
	};
	ModuleEntry.prototype.exportToGlobal = function(exportToGlobal) {
		if (isDefined(exportToGlobal)) {
			this._exportToGlobal = exportToGlobal;
			return this;
		} else {
			return this._exportToGlobal;
		}

	};

	ModuleEntry.prototype.waitUntilDefined = function(pendingDefTask) {
		this._pendingDefTaskList.push(pendingDefTask);
	};
	ModuleEntry.prototype.getPendingDefTasks = function() {
		return this._pendingDefTaskList;
	};

	// A global pool for containing all of the managed modules
	var modulesPool = {};
	// Register loaded url
	var loadedURLs = {};

	var loader = function(url) {
		if (!loadedURLs.hasOwnProperty(url)) {
			loadedURLs[url] = false;
			var head = document.getElementsByTagName("head")[0] || document.documentElement;
			var script = document.createElement("script");
			script.type = 'text/javascript';
			script.src = url;
			// Handle Script loading
			var done = false;
			// Attach handlers for all browsers
			script.onload = script.onreadystatechange = function() {
				if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
					done = true;
					// Handle memory leak in IE
					script.onload = script.onreadystatechange = null;
					if (head && script.parentNode) {
						head.removeChild(script);
					}
					loadedURLs[url] = true;
				}
			};
			if (script.addEventListener) {
				script.addEventListener('error', function() {
					throw new Error('Loading ' + url + ' failed.')
				}, true);
			}
			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709 and #4378).
			head.insertBefore(script, head.firstChild);
			// We handle everything using the script element injection
		}

		return undefined;
	};

	var isValidSemanticVersion = function(semver) {
		if (semver === undefined || typeof semver !== 'string') {
			return false;
		}
		var components = semver.split('.');
		if (components.length > 3) {
			return false;
		}
		for ( var i = 0, len = components.length; i < len; i++) {
			if (parseInt(components[i]) === NaN) {
				return false;
			}
		}
		return true;
	};

	var buildModuleURL = function(qname, version) {
		var paths = qname.split('.');
		var fileName = paths.splice(paths.length - 1, 1);
		return context_path + paths.join('/') + '/' + fileName + '.' + version + '.js';
	};

	var setupModule = function(moduleEntry) {
		var moduleObject;
		if (isFunction(moduleEntry.setupFunction())) {
			var args = [];
			for ( var i = 0, depModule, depModuleList = moduleEntry.dependentModules(), len = depModuleList.length; i < len; i++) {
				depModule = depModuleList[i];
				args.push(modulesPool[depModule.qname][depModule.version].moduleObject());
			}
			moduleObject = moduleEntry.setupFunction().apply(window, args);
		} else {
			moduleObject = moduleEntry.moduleObject();
		}
		if (moduleEntry.exportToGlobal()) {
			var qnameComps = moduleEntry.qname().split('.');
			var attachTo = window;
			for ( var i = 0, part, len = qnameComps.length; i < len; i++) {
				part = qnameComps[i];
				if (i === len - 1) {
					attachTo[part] = moduleObject;
				} else {
					attachTo[part] = attachTo[part] || {};
					attachTo = attachTo[part];
				}
			}
		}
		moduleEntry.setModuleObject(moduleObject);
		moduleEntry.status(ModuleStatus.DEFINED);
		trace(moduleEntry.qname() + ' ' + moduleEntry.version() + ' loaded')
		// Resume the definition tasks that are blocked on this module
		var pendingTasks = moduleEntry.getPendingDefTasks();
		while (pendingTasks.length) {
			var pendingTask = pendingTasks.pop();
			pendingTask(moduleEntry);
		}
		jQueryHoldReady(false)
	};

	var createPendingDefTask = function(waitedModules, moduleEntry) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				setupModule(moduleEntry);
			}
		});
	};

	sap.riv.module = function(moduleCfg, dependencies, moduleSetupFunc) {
		if (isUndefined(moduleCfg) || isUndefined(moduleCfg.qname) || isUndefined(moduleCfg.version)) {
			throw new Error('Bad Arguments: you have to specify the qname and version for the module.');
		}
		if (!isString(moduleCfg.qname) || !isValidSemanticVersion(moduleCfg.version)) {
			throw new Error('Invalid qname or version string');
		}
		if (arguments.length === 2) {
			if (!isPlainObject(dependencies) && !isFunction(dependencies)) {
				throw new Error('You must specify a plain object or a module setup function');
			}
			moduleSetupFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 3) {
			if (!isArray(dependencies) || (!isPlainObject(moduleSetupFunc) && !isFunction(moduleSetupFunc))) {
				throw new Error(
						'Dependencies must be array, and you must specify an plain object or a module setup function');
			}
		}
		var qname = moduleCfg.qname, version = moduleCfg.version, exportToGlobal = isUndefined(moduleCfg.exported) ? false
				: moduleCfg.exported, moduleEntry;

		if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool, version)) {
			modulesPool[qname] = modulesPool[qname] || {};
			modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
		}
		moduleEntry = modulesPool[qname][version];

		if (moduleEntry.status() === ModuleStatus.ENTRY_CREATED) {
			// The depending module is just created for the loading
			if (typeof moduleSetupFunc === 'object') {
				// Module is just a plain object
				moduleEntry.exportToGlobal(exportToGlobal).setModuleObject(moduleSetupFunc);
			} else {
				var depList = [];
				for ( var i = 0, depModule, len = dependencies.length; i < len; i++) {
					depModule = dependencies[i];
					if (!isString(depModule.qname) || !isValidSemanticVersion(depModule.version)) {
						throw new Error('You must specify qname and version for the depending module');
					}
					depList.push({
						qname : depModule.qname,
						version : depModule.version
					});
				}
				moduleEntry.exportToGlobal(exportToGlobal).dependentModules(depList).setupFunction(moduleSetupFunc);
			}
		}

		if (moduleEntry.status() === ModuleStatus.DEFINED || moduleEntry.status() === ModuleStatus.IN_LOADING) {
			return;
		}
		moduleEntry.status(ModuleStatus.IN_LOADING);

		if (moduleEntry.dependentModules().length === 0) {
			setupModule(moduleEntry);
			return;
		} else {
			var waitedModules = {};
			for ( var i = 0, dep, depList = moduleEntry.dependentModules(), len = depList.length; i < len; i++) {
				dep = depList[i];
				if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
						|| (modulesPool[dep.qname][dep.version].status() !== ModuleStatus.DEFINED)) {
					// The depending module is not ready, either because of not
					// loaded yet or because of pending on defining
					waitedModules[dep.qname] = waitedModules[dep.qname] || {};
					waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
						qname : dep.qname,
						version : dep.version,
						url : dep.url || buildModuleURL(dep.qname, dep.version)
					};
				}
			}
			if (isEmptyObject(waitedModules)) {
				// All the depending modules are ready
				setupModule(moduleEntry);
				return;
			} else {
				// Some of the depending modules are not ready, either because
				// of not loaded yet or because of pending on defining
				for ( var qname in waitedModules) {
					for ( var version in waitedModules[qname]) {
						if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
							// if it's a brand new module, then create a entry
							// for it
							modulesPool[qname] = modulesPool[qname] || {};
							modulesPool[qname][version] = modulesPool[qname][version]
									|| new ModuleEntry(qname, version);
							// TODO check circular dependencies
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
							// TODO handle loading error
							loader(waitedModules[qname][version].url);
						} else {
							// if it's not ready(either is loading or not), wait
							// until it's done
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
						}
					}
				}
			}
		}
	};

	var executeRequiredFunction = function(requiredFunction, requiredModules) {
		var args = [];
		for ( var i = 0, requiredModule, len = requiredModules.length; i < len; i++) {
			requiredModule = requiredModules[i];
			args.push(modulesPool[requiredModule.qname][requiredModule.version].moduleObject());
		}
		requiredFunction.apply(window, args);
	};

	var createPendingRequireTask = function(waitedModules, requiredFunc, requiredModules) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				executeRequiredFunction(requiredFunc, requiredModules);
			}
		});
	};

	sap.riv.require = function(dependencies, requireFunc) {
		if (arguments.length === 1) {
			if (!isFunction(dependencies)) {
				throw new Error('You have to specify a function to run');
			}
			requireFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 2) {
			if (!isArray(dependencies) || !isFunction(requireFunc)) {
				throw new Error(
						'the first argument has to be array of depending modules, the second argument should be function type');
			}
		}

		if (!dependencies.length) {
			// No dependencies specified, execute it right away.
			executeRequiredFunction(requireFunc, dependencies);
			return;
		}

		var waitedModules = {};
		for ( var i = 0, dep, len = dependencies.length; i < len; i++) {
			dep = dependencies[i];
			if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
					|| (modulesPool[dep.qname][dep.version].status() !== ModuleStatus.DEFINED)) {
				// The depending module is not ready, either because of not
				// loaded yet or because of pending on defining
				waitedModules[dep.qname] = waitedModules[dep.qname] || {};
				waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
					qname : dep.qname,
					version : dep.version,
					url : dep.url || buildModuleURL(dep.qname, dep.version)
				};
			}
		}
		if (isEmptyObject(waitedModules)) {
			// All the depending modules are ready
			executeRequiredFunction(requireFunc, dependencies);
			return;
		} else {
			// Some of the depending modules are not ready, either because
			// of not loaded yet or because of pending on defining
			for ( var qname in waitedModules) {
				for ( var version in waitedModules[qname]) {
					if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
						// if it's a brand new module, then create a entry
						// for it
						modulesPool[qname] = modulesPool[qname] || {};
						modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
						// TODO check circular dependencies
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
						// TODO handle loading error
						loader(waitedModules[qname][version].url);
					} else {
						// if it's not ready(either is loading or not), wait
						// until it's done
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
					}
				}
			}
		}
	};

	// Evalulates a script in a global context
	var globalEval = function(data) {
		if (data && /\S/.test(data)) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement, script = document
					.createElement("script");

			script.type = "text/javascript";

			try {
				script.appendChild(document.createTextNode(data));
			} catch (e) {
				script.text = data;
			}

			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore(script, head.firstChild);
			head.removeChild(script);
		}
	};

	sap.riv.setBaseUrl = function(url) {
		context_path = url;
	};
	// if the base js is not loaded via script tag, skip the evaluating of
	// embeded script.
	if (curScript) {
		var script = curScript.innerHTML;
		if (script) {
			globalEval(script);
		}
	}
})();
}; // end of sap.service.visualization.chart.ChartSourceCode.libs.saprivbase
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.ChartSourceCode.libs.saprivmodules') ) {
  jQuery.sap.declare('sap.service.visualization.chart.ChartSourceCode.libs.saprivmodules');
sap.riv.module(
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
function Setup() {
    var versionSearchString;
    var searchString = function(data) {
        for(var i = 0; i < data.length; i++) {
            var dataString = data[i].string;
            var dataProp = data[i].prop;
            versionSearchString = data[i].versionSearch || data[i].identity;
            if(dataString) {
                if(dataString.indexOf(data[i].subString) != -1) {
                    return data[i].identity;
                }
            } else if(dataProp) {
                return data[i].identity;
            }
        }
    };
    var seps = [';', ' '];
    var searchVersion = function(dataString) {
        var index = dataString.indexOf(versionSearchString);
        if(index == -1)
            return;
        var versionStr = dataString.substring(index + versionSearchString.length + 1);
        var i = 0, l = seps.length, sepIndex = -1;
        while(sepIndex === -1 && i < l)
        sepIndex = versionStr.indexOf(seps[i++]);
        if(sepIndex !== -1)
            versionStr = versionStr.slice(0, sepIndex);
        return versionStr;
    };
    var dataBrowser = [{
        string : navigator.userAgent,
        subString : "Chrome",
        identity : "Chrome"
    }, {
        string : navigator.userAgent,
        subString : "OmniWeb",
        versionSearch : "OmniWeb/",
        identity : "OmniWeb"
    }, {
        string : navigator.userAgent,
        subString : "Safari",
        identity : "Safari",
        versionSearch : "Version"
    }, {
        string : navigator.userAgent,
        subString : "Apple",
        identity : "UIWebView",
        versionSearch : "AppleWebKit"
    }, {
        prop : window.opera,
        identity : "Opera",
        versionSearch : "Version"
    }, {
        string : navigator.vendor,
        subString : "iCab",
        identity : "iCab"
    }, {
        string : navigator.vendor,
        subString : "KDE",
        identity : "Konqueror"
    }, {
        string : navigator.userAgent,
        subString : "Firefox",
        identity : "Firefox"
    }, {
        string : navigator.vendor,
        subString : "Camino",
        identity : "Camino"
    }, {// for newer Netscapes (6+)
        string : navigator.userAgent,
        subString : "Netscape",
        identity : "Netscape"
    }, {
        string : navigator.userAgent,
        subString : "MSIE",
        identity : "Explorer",
        versionSearch : "MSIE"
    }, {
        string : navigator.userAgent,
        subString : "Gecko",
        identity : "Mozilla",
        versionSearch : "rv"
    }, {// for older Netscapes (4-)
        string : navigator.userAgent,
        subString : "Mozilla",
        identity : "Netscape",
        versionSearch : "Mozilla"
    }];

    var dataOS = [{
        string : navigator.platform,
        subString : "Win",
        identity : "Windows"
    }, {
        string : navigator.platform,
        subString : "Mac",
        identity : "Mac"
    }, {
        string : navigator.userAgent,
        subString : "iPhone",
        identity : "iPhone/iPod"
    }, {
        string : navigator.userAgent,
        subString : "iPad",
        identity : "iPad"
    }, {
        string : navigator.platform,
        subString : "Linux",
        identity : "Linux"
    }];

    var dataRenderEngine = [{
        string : navigator.userAgent,
        subString : "Presto",
        identity : "Presto"
    }, {
        string : navigator.userAgent,
        subString : "KHTML",
        identity : "KHTML"
    }, {
        string : navigator.userAgent,
        subString : "Gecko",
        identity : "Gecko"
    }, {
        string : navigator.userAgent,
        subString : "Trident",
        identity : "Trident"
    }];
    var _userAgent = searchString(dataBrowser) || "An unknown browser",
    _version = searchVersion(navigator.userAgent) || searchVersion(navigator.appVersion) || "an unknown version",
    _isIE = searchString(dataBrowser) === "Explorer",
    _isFirefox = searchString(dataBrowser) === 'Firefox',
    _isChrome = searchString(dataBrowser) === 'Chrome',
    _isSafari = searchString(dataBrowser) === 'Safari',
    _isUIWebView = searchString(dataBrowser) === 'UIWebView',
    _os = searchString(dataOS) || "an unknown OS",
    _renderEngine = searchString(dataRenderEngine) || "An unknown RenderEngine";
    var UADetector = {
        userAgent : function() {
            return _userAgent;
        },
        version : function() {
            return _version;
        },
        isIE : function(){
            return _isIE;   
        },
        isFirefox : function() {
            return _isFirefox;
        },
        isChrome : function() {
            return _isChrome;
        },
        isSafari : function() {
            return _isSafari;
        },
        isUIWebView : function() {
            return _isUIWebView;
        },
        os : function() {
            return _os;
        },
        renderEngine : function() {
            return _renderEngine;
        }
    };
    return (UADetector);
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
function Setup() {
	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var hasOwn = Object.prototype.hasOwnProperty;
	// Used for trimming whitespace
	var rdigit = /\d/;

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	/**
	 * Type Utilities for common variable type related tasks
	 * 
	 * @name sap.riv.core.utils.TypeUtils
	 * @class
	 */
	var typeUtils = {

		/**
	     * Returns a boolean value indicating whether the parameter is of type function
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction : function(obj) {
			return type(obj) === "function";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type array
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isArray : Array.isArray || function(obj) {
			return type(obj) === "array";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type string
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isString : function(obj) {
			return type(obj) === "string";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a non-empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNonEmptyString : function(obj) {
			return this.isString(obj) && obj.length !== 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isEmptyString : function(obj) {
			return this.isString(obj) && obj.length === 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is NaN
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNaN : function(obj) {
			return obj === null || obj === undefined || !rdigit.test(obj) || isNaN(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a number
	     *
	     * @param {object}
	     * @returns {boolean} Caution: isNumber(Infinity) returns false.
	     */
		isNumber : function(n) {
			return !this.isNaN(parseFloat(n)) && isFinite(n);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is defined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isDefined : function(v) {
			return typeof (v) !== 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isUndefined : function(v) {
			return typeof (v) === 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a plain object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: A plain object is an object that has no prototype method and
	     *  no parent class. Null, undefined, DOM nodes and window object are not considered as plain object.
	     */
		isPlainObject : function(obj) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the
			// constructor property.
			// Make sure that DOM nodes and window objects don't pass through,
			// as well
			if (!obj || type(obj) !== "object" || obj.nodeType
					|| (obj && typeof obj === "object" && "setInterval" in obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor")
					&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.

			var key;
			for (key in obj) {
			}

			return key === undefined || hasOwn.call(obj, key);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: An empty is a plain object without any properties.
	     */
		isEmptyObject : function(obj) {
			for ( var name in obj) {
				return false;
			}
			return this.isPlainObject(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined or null
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isExist : function(o) {
			if ((typeof (o) === 'undefined') || (o === null)) {
				return false;
			}
			return true;
		}
	};

	return typeUtils;
});sap.riv.module(
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
}
],
function Setup(UADetector) {
    var OptMath = {
        PI : Math.PI,
        E : Math.E,
        LN10 : Math.LN10,
        LN2 : Math.LN2,
        LOG2E : Math.LOG2E,
        LOG10E : Math.LOG10E,
        SQRT1_2 : Math.SQRT1_2,
        SQRT2 : Math.SQRT2,

        abs : (function() {
            if(UADetector.isSafari() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)) {
                return function(n) {
                    return n < 0 ? -n : n;
                };
            } else {
                return Math.abs;
            }
        })(),

        acos : (function() {
            return Math.acos;
        })(),

        asin : (function() {
            return Math.asin;
        })(),

        atan : (function() {
            return Math.atan;
        })(),

        atan2 : (function() {
            return Math.atan2;
        })(),

        /**
         * Get the ceil of a number.
         *
         * @name sap.riv.core.Math#ceil
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the ceil of number
         */
        ceil : (function() {
            // if (UADetector.isFirefox()) {
            // return function(n) {
            // var i = n | 0;
            // return n <= 0 ? i : (i == n ? i : i + 1);
            // };
            // }
            // else if (UADetector.isChrome()) {
            // return function(n) {
            // return n <= 0 ? n | 0 : Math.ceil(n);
            // };
            // }
            // else {
            return Math.ceil;
            // }
        })(),

        cos : (function() {
            return Math.cos;
        })(),

        exp : (function() {
            return Math.exp;
        })(),

        /**
         * Get the floor of a number.
         *
         * @name sap.riv.core.Math#floor
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the floor of number
         */
        floor : (function() {
            // if(UADetector.isFirefox()) {
            // return function(n) {
            // var a = n | 0;
            // return n < 0 ? (a == n ? a : a - 1) : a;
            // };
            // } else
            return Math.floor;
        })(),

        log : (function() {
            return Math.log;
        })(),

        /**
         * Get the maximum number in an array.
         *
         * @name sap.riv.core.Math#max
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the maximum number in array
         */
        max : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.max;
            // } else
                // return function() {
                    // var max = arguments[0];
                    // var length = arguments.length;
                    // for(var i = 1; i < length; i++) {
                        // max = arguments[i] > max ? arguments[i] : max;
                    // }
                    // return max;
                // };
        })(),

        /**
         * Get the minimum number in an array.
         *
         * @name sap.riv.core.Math#min
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the minimum number in array
         */
        min : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.min;
			// }
			// else return function(){
		        // var min = arguments[0];
		        // var length = arguments.length;
				// for (var i=1; i<length; i++){
					// min = arguments[i] > min ? min : arguments[i];
				// }
				// return min;
            // };
        })(),

        pow : (function() {
            return Math.pow;
        })(),

        random : (function() {
            return Math.random;
        })(),

        /**
         * Get the round of a number.
         *
         * @name sap.riv.core.Math#round
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the round of number
         */
        round : (function() {
            return Math.round;
            //			if(UADetector.isFirefox() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)){
            //				return function(n) {
            //					return (n >= 0) ? (n + 0.5) | 0 : (n - 0.4999999999999999) | 0;
            //				};
            //			}
            //			else if(UADetector.isChrome()){
            //				return function(n) {
            //					return Math.floor(n + 0.5);
            //				};
            //			}
            //			else return Math.round;
        })(),

        sin : (function() {
            return Math.sin;
        })(),

        sqrt : (function() {
            return Math.sqrt;
        })(),

        tan : (function() {
            return Math.tan;
        })()
    };
    return OptMath;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.RIVExCanvasMgr',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(UADetector, Math) {
	if (UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
		// alias some functions to make (compiled) code shorter
		var m = Math;
		var mr = m.round;
		var ms = m.sin;
		var mc = m.cos;
		var abs = m.abs;
		var sqrt = m.sqrt;

		// this is used for sub pixel precision
		var Z = 10;
		var Z2 = Z / 2;

		var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];

		/**
		 * This funtion is assigned to the <canvas> elements as
		 * element.getContext().
		 * 
		 * @this {HTMLElement}
		 * @return {CanvasRenderingContext2D_}
		 */
		function getContext() {
			return this.context_ || (this.context_ = new CanvasRenderingContext2D_(this));
		}

		var slice = Array.prototype.slice;

		/**
		 * Binds a function to an object. The returned function will always use
		 * the passed in {@code obj} as {@code this}.
		 * 
		 * Example:
		 * 
		 * g = bind(f, obj, a, b) g(c, d) // will do f.call(obj, a, b, c, d)
		 * 
		 * @param {Function}
		 *            f The function to bind the object to
		 * @param {Object}
		 *            obj The object that should act as this when the function
		 *            is called
		 * @param {*}
		 *            var_args Rest arguments that will be used as the initial
		 *            arguments when the function is called
		 * @return {Function} A new function that has bound this
		 */
		function bind(f, obj, var_args) {
			var a = slice.call(arguments, 2);
			return function() {
				return f.apply(obj, a.concat(slice.call(arguments)));
			};
		}

		function encodeHtmlAttribute(s) {
			return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
		}

		function addNamespace(doc, prefix, urn) {
			if (!doc.namespaces[prefix]) {
				doc.namespaces.add(prefix, urn, '#default#VML');
			}
		}

		function addNamespacesAndStylesheet(doc) {
			addNamespace(doc, 'r_vml_', 'urn:schemas-microsoft-com:vml');
			addNamespace(doc, 'r_o_', 'urn:schemas-microsoft-com:office:office');

			// Setup default CSS. Only add one style sheet per document
			if (!doc.styleSheets['r_ex_canvas_']) {
				var ss = doc.createStyleSheet();
				ss.owningElement.id = 'r_ex_canvas_';
				ss.cssText = 'rivcanvas{display:inline-block;overflow:hidden;' +
				// default size is 300x150 in Gecko and Opera
				'text-align:left;width:300px;height:150px}';
			}
		}

		// Add namespaces and stylesheet at startup.
		addNamespacesAndStylesheet(document);

		var G_vmlCanvasManager_ = {
			init : function(opt_doc) {
				var doc = opt_doc || document;
				// Create a dummy element so that IE will allow canvas
				// elements to be
				// recognized.
				doc.createElement('rivcanvas');
				doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
			},

			init_ : function(doc) {
				// find all canvas elements
				var els = doc.getElementsByTagName('rivcanvas');
				for ( var i = 0; i < els.length; i++) {
					this.initElement(els[i]);
				}
			},

			/**
			 * Public initializes a canvas element so that it can be used as
			 * canvas element from now on. This is called automatically before
			 * the page is loaded but if you are creating elements using
			 * createElement you need to make sure this is called on the
			 * element.
			 * 
			 * @param {HTMLElement}
			 *            el The canvas element to initialize.
			 * @return {HTMLElement} the element that was created.
			 */
			initElement : function(el) {
				if (!el.getContext) {
					el.getContext = getContext;

					// Add namespaces and stylesheet to document of the
					// element.
					addNamespacesAndStylesheet(el.ownerDocument);

					// Remove fallback content. There is no way to hide text
					// nodes so we
					// just remove all childNodes. We could hide all
					// elements and remove
					// text nodes but who really cares about the fallback
					// content.
					el.innerHTML = '';

					// do not use inline function because that will leak
					// memory
					el.attachEvent('onpropertychange', onPropertyChange);
					el.attachEvent('onresize', onResize);

					var attrs = el.attributes;
					if (attrs.width && attrs.width.specified) {
						// TODO: use runtimeStyle and coordsize
						// el.getContext().setWidth_(attrs.width.nodeValue);
						el.style.width = attrs.width.nodeValue + 'px';
					} else {
						el.width = el.clientWidth;
					}
					if (attrs.height && attrs.height.specified) {
						// TODO: use runtimeStyle and coordsize
						// el.getContext().setHeight_(attrs.height.nodeValue);
						el.style.height = attrs.height.nodeValue + 'px';
					} else {
						el.height = el.clientHeight;
					}
					// el.getContext().setCoordsize_()
				}
				return el;
			}
		};

		function onPropertyChange(e) {
			var el = e.srcElement;

			switch (e.propertyName) {
			case 'width':
				el.getContext().clearRect();
				el.style.width = el.attributes.width.nodeValue + 'px';
				// In IE8 this does not trigger onresize.
				el.firstChild.style.width = el.width + 'px';
				break;
			case 'height':
				el.getContext().clearRect();
				el.style.height = el.attributes.height.nodeValue + 'px';
				el.firstChild.style.height = el.height + 'px';
				break;
			}
		}

		function onResize(e) {
			var el = e.srcElement;
			if (el.firstChild) {
				el.firstChild.style.width = el.clientWidth + 'px';
				el.firstChild.style.height = el.clientHeight + 'px';
			}
		}

		G_vmlCanvasManager_.init();

		// precompute "00" to "FF"
		var decToHex = [];
		for ( var i = 0; i < 16; i++) {
			for ( var j = 0; j < 16; j++) {
				decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
			}
		}

		function createMatrixIdentity() {
			return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
		}

		function matrixMultiply(m1, m2) {
			var result = createMatrixIdentity();

			for ( var x = 0; x < 3; x++) {
				for ( var y = 0; y < 3; y++) {
					var sum = 0;

					for ( var z = 0; z < 3; z++) {
						sum += m1[x][z] * m2[z][y];
					}

					result[x][y] = sum;
				}
			}
			return result;
		}

		function copyState(o1, o2) {
			o2.fillStyle = o1.fillStyle;
			o2.lineCap = o1.lineCap;
			o2.lineJoin = o1.lineJoin;
			o2.lineWidth = o1.lineWidth;
			o2.miterLimit = o1.miterLimit;
			o2.shadowBlur = o1.shadowBlur;
			o2.shadowColor = o1.shadowColor;
			o2.shadowOffsetX = o1.shadowOffsetX;
			o2.shadowOffsetY = o1.shadowOffsetY;
			o2.strokeStyle = o1.strokeStyle;
			o2.globalAlpha = o1.globalAlpha;
			o2.font = o1.font;
			o2.textAlign = o1.textAlign;
			o2.textBaseline = o1.textBaseline;
			o2.arcScaleX_ = o1.arcScaleX_;
			o2.arcScaleY_ = o1.arcScaleY_;
			o2.lineScale_ = o1.lineScale_;
		}

		var colorData = {
			aliceblue : '#F0F8FF',
			antiquewhite : '#FAEBD7',
			aquamarine : '#7FFFD4',
			azure : '#F0FFFF',
			beige : '#F5F5DC',
			bisque : '#FFE4C4',
			black : '#000000',
			blanchedalmond : '#FFEBCD',
			blueviolet : '#8A2BE2',
			brown : '#A52A2A',
			burlywood : '#DEB887',
			cadetblue : '#5F9EA0',
			chartreuse : '#7FFF00',
			chocolate : '#D2691E',
			coral : '#FF7F50',
			cornflowerblue : '#6495ED',
			cornsilk : '#FFF8DC',
			crimson : '#DC143C',
			cyan : '#00FFFF',
			darkblue : '#00008B',
			darkcyan : '#008B8B',
			darkgoldenrod : '#B8860B',
			darkgray : '#A9A9A9',
			darkgreen : '#006400',
			darkgrey : '#A9A9A9',
			darkkhaki : '#BDB76B',
			darkmagenta : '#8B008B',
			darkolivegreen : '#556B2F',
			darkorange : '#FF8C00',
			darkorchid : '#9932CC',
			darkred : '#8B0000',
			darksalmon : '#E9967A',
			darkseagreen : '#8FBC8F',
			darkslateblue : '#483D8B',
			darkslategray : '#2F4F4F',
			darkslategrey : '#2F4F4F',
			darkturquoise : '#00CED1',
			darkviolet : '#9400D3',
			deeppink : '#FF1493',
			deepskyblue : '#00BFFF',
			dimgray : '#696969',
			dimgrey : '#696969',
			dodgerblue : '#1E90FF',
			firebrick : '#B22222',
			floralwhite : '#FFFAF0',
			forestgreen : '#228B22',
			gainsboro : '#DCDCDC',
			ghostwhite : '#F8F8FF',
			gold : '#FFD700',
			goldenrod : '#DAA520',
			grey : '#808080',
			greenyellow : '#ADFF2F',
			honeydew : '#F0FFF0',
			hotpink : '#FF69B4',
			indianred : '#CD5C5C',
			indigo : '#4B0082',
			ivory : '#FFFFF0',
			khaki : '#F0E68C',
			lavender : '#E6E6FA',
			lavenderblush : '#FFF0F5',
			lawngreen : '#7CFC00',
			lemonchiffon : '#FFFACD',
			lightblue : '#ADD8E6',
			lightcoral : '#F08080',
			lightcyan : '#E0FFFF',
			lightgoldenrodyellow : '#FAFAD2',
			lightgreen : '#90EE90',
			lightgrey : '#D3D3D3',
			lightpink : '#FFB6C1',
			lightsalmon : '#FFA07A',
			lightseagreen : '#20B2AA',
			lightskyblue : '#87CEFA',
			lightslategray : '#778899',
			lightslategrey : '#778899',
			lightsteelblue : '#B0C4DE',
			lightyellow : '#FFFFE0',
			limegreen : '#32CD32',
			linen : '#FAF0E6',
			magenta : '#FF00FF',
			mediumaquamarine : '#66CDAA',
			mediumblue : '#0000CD',
			mediumorchid : '#BA55D3',
			mediumpurple : '#9370DB',
			mediumseagreen : '#3CB371',
			mediumslateblue : '#7B68EE',
			mediumspringgreen : '#00FA9A',
			mediumturquoise : '#48D1CC',
			mediumvioletred : '#C71585',
			midnightblue : '#191970',
			mintcream : '#F5FFFA',
			mistyrose : '#FFE4E1',
			moccasin : '#FFE4B5',
			navajowhite : '#FFDEAD',
			oldlace : '#FDF5E6',
			olivedrab : '#6B8E23',
			orange : '#FFA500',
			orangered : '#FF4500',
			orchid : '#DA70D6',
			palegoldenrod : '#EEE8AA',
			palegreen : '#98FB98',
			paleturquoise : '#AFEEEE',
			palevioletred : '#DB7093',
			papayawhip : '#FFEFD5',
			peachpuff : '#FFDAB9',
			peru : '#CD853F',
			pink : '#FFC0CB',
			plum : '#DDA0DD',
			powderblue : '#B0E0E6',
			rosybrown : '#BC8F8F',
			royalblue : '#4169E1',
			saddlebrown : '#8B4513',
			salmon : '#FA8072',
			sandybrown : '#F4A460',
			seagreen : '#2E8B57',
			seashell : '#FFF5EE',
			sienna : '#A0522D',
			skyblue : '#87CEEB',
			slateblue : '#6A5ACD',
			slategray : '#708090',
			slategrey : '#708090',
			snow : '#FFFAFA',
			springgreen : '#00FF7F',
			steelblue : '#4682B4',
			tan : '#D2B48C',
			thistle : '#D8BFD8',
			tomato : '#FF6347',
			turquoise : '#40E0D0',
			violet : '#EE82EE',
			wheat : '#F5DEB3',
			whitesmoke : '#F5F5F5',
			yellowgreen : '#9ACD32'
		};

		function getRgbHslContent(styleString) {
			var start = styleString.indexOf('(', 3);
			var end = styleString.indexOf(')', start + 1);
			var parts = styleString.substring(start + 1, end).split(',');
			// add alpha if needed
			if (parts.length != 4 || styleString.charAt(3) != 'a') {
				parts[3] = 1;
			}
			return parts;
		}

		function percent(s) {
			return parseFloat(s) / 100;
		}

		function clamp(v, min, max) {
			return Math.min(max, Math.max(min, v));
		}

		function hslToRgb(parts) {
			var r, g, b, h, s, l;
			h = parseFloat(parts[0]) / 360 % 360;
			if (h < 0)
				h++;
			s = clamp(percent(parts[1]), 0, 1);
			l = clamp(percent(parts[2]), 0, 1);
			if (s == 0) {
				r = g = b = l; // achromatic
			} else {
				var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				var p = 2 * l - q;
				r = hueToRgb(p, q, h + 1 / 3);
				g = hueToRgb(p, q, h);
				b = hueToRgb(p, q, h - 1 / 3);
			}

			return '#' + decToHex[Math.floor(r * 255)] + decToHex[Math.floor(g * 255)] + decToHex[Math.floor(b * 255)];
		}

		function hueToRgb(m1, m2, h) {
			if (h < 0)
				h++;
			if (h > 1)
				h--;

			if (6 * h < 1)
				return m1 + (m2 - m1) * 6 * h;
			else if (2 * h < 1)
				return m2;
			else if (3 * h < 2)
				return m1 + (m2 - m1) * (2 / 3 - h) * 6;
			else
				return m1;
		}

		var processStyleCache = {};

		function processStyle(styleString) {
			if (styleString in processStyleCache) {
				return processStyleCache[styleString];
			}

			var str, alpha = 1;

			styleString = String(styleString);
			if (styleString.charAt(0) == '#') {
				str = styleString;
			} else if (/^rgb/.test(styleString)) {
				var parts = getRgbHslContent(styleString);
				var str = '#', n;
				for ( var i = 0; i < 3; i++) {
					if (parts[i].indexOf('%') != -1) {
						n = Math.floor(percent(parts[i]) * 255);
					} else {
						n = +parts[i];
					}
					str += decToHex[clamp(n, 0, 255)];
				}
				alpha = +parts[3];
			} else if (/^hsl/.test(styleString)) {
				var parts = getRgbHslContent(styleString);
				str = hslToRgb(parts);
				alpha = parts[3];
			} else {
				str = colorData[styleString] || styleString;
			}
			return processStyleCache[styleString] = {
				color : str,
				alpha : alpha
			};
		}

		var DEFAULT_STYLE = {
			style : 'normal',
			variant : 'normal',
			weight : 'normal',
			size : 10,
			family : 'sans-serif'
		};

		// Internal text style cache
		var fontStyleCache = {};

		function processFontStyle(styleString) {
			if (fontStyleCache[styleString]) {
				return fontStyleCache[styleString];
			}

			var el = document.createElement('div');
			var style = el.style;
			try {
				style.font = styleString;
			} catch (ex) {
				// Ignore failures to set to invalid font.
			}

			return fontStyleCache[styleString] = {
				style : style.fontStyle || DEFAULT_STYLE.style,
				variant : style.fontVariant || DEFAULT_STYLE.variant,
				weight : style.fontWeight || DEFAULT_STYLE.weight,
				size : style.fontSize || DEFAULT_STYLE.size,
				family : style.fontFamily || DEFAULT_STYLE.family
			};
		}

		function getComputedStyle(style, element) {
			var computedStyle = {};

			for ( var p in style) {
				computedStyle[p] = style[p];
			}

			// Compute the size
			var canvasFontSize = parseFloat(element.currentStyle.fontSize), fontSize = parseFloat(style.size);

			if (typeof style.size == 'number') {
				computedStyle.size = style.size;
			} else if (style.size.indexOf('px') != -1) {
				computedStyle.size = fontSize;
			} else if (style.size.indexOf('em') != -1) {
				computedStyle.size = canvasFontSize * fontSize;
			} else if (style.size.indexOf('%') != -1) {
				computedStyle.size = (canvasFontSize / 100) * fontSize;
			} else if (style.size.indexOf('pt') != -1) {
				computedStyle.size = fontSize / .75;
			} else {
				computedStyle.size = canvasFontSize;
			}

			// Different scaling between normal text and VML text. This was
			// found using
			// trial and error to get the same size as non VML text.
			computedStyle.size *= 0.981;

			return computedStyle;
		}

		function buildStyle(style) {
			return style.style + ' ' + style.variant + ' ' + style.weight + ' ' + style.size + 'px ' + style.family;
		}

		var lineCapMap = {
			'butt' : 'flat',
			'round' : 'round'
		};

		function processLineCap(lineCap) {
			return lineCapMap[lineCap] || 'square';
		}

		/**
		 * This class implements CanvasRenderingContext2D interface as described
		 * by the WHATWG.
		 * 
		 * @param {HTMLElement}
		 *            canvasElement The element that the 2D context should be
		 *            associated with
		 */
		function CanvasRenderingContext2D_(canvasElement) {
			this.m_ = createMatrixIdentity();

			this.mStack_ = [];
			this.aStack_ = [];
			this.currentPath_ = [];

			// Canvas context properties
			this.strokeStyle = '#000';
			this.fillStyle = '#000';

			this.lineWidth = 1;
			this.lineJoin = 'miter';
			this.lineCap = 'butt';
			this.miterLimit = Z * 1;
			this.globalAlpha = 1;
			this.font = '10px sans-serif';
			this.textAlign = 'left';
			this.textBaseline = 'alphabetic';
			this.canvas = canvasElement;

			var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' + canvasElement.clientHeight
					+ 'px;overflow:hidden;position:absolute';
			var el = canvasElement.ownerDocument.createElement('div');
			el.style.cssText = cssText;
			canvasElement.appendChild(el);

			var overlayEl = el.cloneNode(false);
			// Use a non transparent background.
			overlayEl.style.backgroundColor = 'red';
			overlayEl.style.filter = 'alpha(opacity=0)';
			canvasElement.appendChild(overlayEl);

			this.element_ = el;
			this.arcScaleX_ = 1;
			this.arcScaleY_ = 1;
			this.lineScale_ = 1;
		}

		var contextPrototype = CanvasRenderingContext2D_.prototype;
		contextPrototype.clearRect = function() {
			if (this.textMeasureEl_) {
				this.textMeasureEl_.removeNode(true);
				this.textMeasureEl_ = null;
			}
			this.element_.innerHTML = '';
		};

		contextPrototype.beginPath = function() {
			// TODO: Branch current matrix so that save/restore has no
			// effect
			// as per safari docs.
			this.currentPath_ = [];
		};

		contextPrototype.moveTo = function(aX, aY) {
			var p = getCoords(this, aX, aY);
			this.currentPath_.push({
				type : 'moveTo',
				x : p.x,
				y : p.y
			});
			this.currentX_ = p.x;
			this.currentY_ = p.y;
		};

		contextPrototype.lineTo = function(aX, aY) {
			var p = getCoords(this, aX, aY);
			this.currentPath_.push({
				type : 'lineTo',
				x : p.x,
				y : p.y
			});

			this.currentX_ = p.x;
			this.currentY_ = p.y;
		};

		contextPrototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			var p = getCoords(this, aX, aY);
			var cp1 = getCoords(this, aCP1x, aCP1y);
			var cp2 = getCoords(this, aCP2x, aCP2y);
			bezierCurveTo(this, cp1, cp2, p);
		};

		// Helper function that takes the already fixed cordinates.
		function bezierCurveTo(self, cp1, cp2, p) {
			self.currentPath_.push({
				type : 'bezierCurveTo',
				cp1x : cp1.x,
				cp1y : cp1.y,
				cp2x : cp2.x,
				cp2y : cp2.y,
				x : p.x,
				y : p.y
			});
			self.currentX_ = p.x;
			self.currentY_ = p.y;
		}

		contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
			// the following is lifted almost directly from
			// http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

			var cp = getCoords(this, aCPx, aCPy);
			var p = getCoords(this, aX, aY);

			var cp1 = {
				x : this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
				y : this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
			};
			var cp2 = {
				x : cp1.x + (p.x - this.currentX_) / 3.0,
				y : cp1.y + (p.y - this.currentY_) / 3.0
			};

			bezierCurveTo(this, cp1, cp2, p);
		};

		contextPrototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			aRadius *= Z;
			var arcType = aClockwise ? 'at' : 'wa';

			var xStart = aX + mc(aStartAngle) * aRadius - Z2;
			var yStart = aY + ms(aStartAngle) * aRadius - Z2;

			var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
			var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

			// IE won't render arches drawn counter clockwise if xStart ==
			// xEnd.
			if (xStart == xEnd && !aClockwise) {
				xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use
				// something
				// that can be represented in binary
			}

			var p = getCoords(this, aX, aY);
			var pStart = getCoords(this, xStart, yStart);
			var pEnd = getCoords(this, xEnd, yEnd);

			this.currentPath_.push({
				type : arcType,
				x : p.x,
				y : p.y,
				radius : aRadius,
				xStart : pStart.x,
				yStart : pStart.y,
				xEnd : pEnd.x,
				yEnd : pEnd.y
			});

		};

		contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
			this.moveTo(aX, aY);
			this.lineTo(aX + aWidth, aY);
			this.lineTo(aX + aWidth, aY + aHeight);
			this.lineTo(aX, aY + aHeight);
			this.closePath();
		};

		contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
			var oldPath = this.currentPath_;
			this.beginPath();

			this.moveTo(aX, aY);
			this.lineTo(aX + aWidth, aY);
			this.lineTo(aX + aWidth, aY + aHeight);
			this.lineTo(aX, aY + aHeight);
			this.closePath();
			this.stroke();

			this.currentPath_ = oldPath;
		};

		contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
			var oldPath = this.currentPath_;
			this.beginPath();

			this.moveTo(aX, aY);
			this.lineTo(aX + aWidth, aY);
			this.lineTo(aX + aWidth, aY + aHeight);
			this.lineTo(aX, aY + aHeight);
			this.closePath();
			this.fill();

			this.currentPath_ = oldPath;
		};

		contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
			var gradient = new CanvasGradient_('gradient');
			gradient.x0_ = aX0;
			gradient.y0_ = aY0;
			gradient.x1_ = aX1;
			gradient.y1_ = aY1;
			return gradient;
		};

		contextPrototype.createRadialGradient = function(aX0, aY0, aR0, aX1, aY1, aR1) {
			var gradient = new CanvasGradient_('gradientradial');
			gradient.x0_ = aX0;
			gradient.y0_ = aY0;
			gradient.r0_ = aR0;
			gradient.x1_ = aX1;
			gradient.y1_ = aY1;
			gradient.r1_ = aR1;
			return gradient;
		};

		contextPrototype.drawImage = function(image, var_args) {
			var dx, dy, dw, dh, sx, sy, sw, sh;

			// to find the original width we overide the width and height
			var oldRuntimeWidth = image.runtimeStyle.width;
			var oldRuntimeHeight = image.runtimeStyle.height;
			image.runtimeStyle.width = 'auto';
			image.runtimeStyle.height = 'auto';

			// get the original size
			var w = image.width;
			var h = image.height;

			// and remove overides
			image.runtimeStyle.width = oldRuntimeWidth;
			image.runtimeStyle.height = oldRuntimeHeight;

			if (arguments.length == 3) {
				dx = arguments[1];
				dy = arguments[2];
				sx = sy = 0;
				sw = dw = w;
				sh = dh = h;
			} else if (arguments.length == 5) {
				dx = arguments[1];
				dy = arguments[2];
				dw = arguments[3];
				dh = arguments[4];
				sx = sy = 0;
				sw = w;
				sh = h;
			} else if (arguments.length == 9) {
				sx = arguments[1];
				sy = arguments[2];
				sw = arguments[3];
				sh = arguments[4];
				dx = arguments[5];
				dy = arguments[6];
				dw = arguments[7];
				dh = arguments[8];
			} else {
				throw Error('Invalid number of arguments');
			}

			var d = getCoords(this, dx, dy);

			var w2 = sw / 2;
			var h2 = sh / 2;

			var vmlStr = [];

			var W = 10;
			var H = 10;

			// For some reason that I've now forgotten, using divs didn't
			// work
			vmlStr.push(' <r_vml_:group', ' coordsize="', Z * W, ',', Z * H, '"', ' coordorigin="0,0"',
					' style="width:', W, 'px;height:', H, 'px;position:absolute;');

			// If filters are necessary (rotation exists), create them
			// filters are bog-slow, so only create them if abbsolutely
			// necessary
			// The following check doesn't account for skews (which don't
			// exist
			// in the canvas spec (yet) anyway.

			if (this.m_[0][0] != 1 || this.m_[0][1] || this.m_[1][1] != 1 || this.m_[1][0]) {
				var filter = [];

				// Note the 12/21 reversal
				filter.push('M11=', this.m_[0][0], ',', 'M12=', this.m_[1][0], ',', 'M21=', this.m_[0][1], ',', 'M22=',
						this.m_[1][1], ',', 'Dx=', mr(d.x / Z), ',', 'Dy=', mr(d.y / Z), '');

				// Bounding box calculation (need to minimize displayed area
				// so that
				// filters don't waste time on unused pixels.
				var max = d;
				var c2 = getCoords(this, dx + dw, dy);
				var c3 = getCoords(this, dx, dy + dh);
				var c4 = getCoords(this, dx + dw, dy + dh);

				max.x = m.max(max.x, c2.x, c3.x, c4.x);
				max.y = m.max(max.y, c2.y, c3.y, c4.y);

				vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
						'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(', filter.join(''),
						", sizingmethod='clip');");

			} else {
				vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
			}

			vmlStr.push(' ">', '<r_vml_:image src="', image.src, '"', ' style="width:', Z * dw, 'px;', ' height:', Z
					* dh, 'px"', ' cropleft="', sx / w, '"', ' croptop="', sy / h, '"', ' cropright="', (w - sx - sw)
					/ w, '"', ' cropbottom="', (h - sy - sh) / h, '"', ' />', '</r_vml_:group>');

			this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
		};

		contextPrototype.stroke = function(aFill) {
			var lineStr = [];
			var lineOpen = false;

			var W = 10;
			var H = 10;

			lineStr.push('<r_vml_:shape', ' filled="', !!aFill, '"', ' style="position:absolute;width:', W,
					'px;height:', H, 'px;"', ' coordorigin="0,0"', ' coordsize="', Z * W, ',', Z * H, '"',
					' stroked="', !aFill, '"', ' path="');

			var newSeq = false;
			var min = {
				x : null,
				y : null
			};
			var max = {
				x : null,
				y : null
			};

			for ( var i = 0; i < this.currentPath_.length; i++) {
				var p = this.currentPath_[i];
				var c;

				switch (p.type) {
				case 'moveTo':
					c = p;
					lineStr.push(' m ', mr(p.x), ',', mr(p.y));
					break;
				case 'lineTo':
					lineStr.push(' l ', mr(p.x), ',', mr(p.y));
					break;
				case 'close':
					lineStr.push(' x ');
					p = null;
					break;
				case 'bezierCurveTo':
					lineStr.push(' c ', mr(p.cp1x), ',', mr(p.cp1y), ',', mr(p.cp2x), ',', mr(p.cp2y), ',', mr(p.x),
							',', mr(p.y));
					break;
				case 'at':
				case 'wa':
					lineStr.push(' ', p.type, ' ', mr(p.x - this.arcScaleX_ * p.radius), ',', mr(p.y - this.arcScaleY_
							* p.radius), ' ', mr(p.x + this.arcScaleX_ * p.radius), ',', mr(p.y + this.arcScaleY_
							* p.radius), ' ', mr(p.xStart), ',', mr(p.yStart), ' ', mr(p.xEnd), ',', mr(p.yEnd));
					break;
				}

				// TODO: Following is broken for curves due to
				// move to proper paths.

				// Figure out dimensions so we can do gradient fills
				// properly
				if (p) {
					if (min.x == null || p.x < min.x) {
						min.x = p.x;
					}
					if (max.x == null || p.x > max.x) {
						max.x = p.x;
					}
					if (min.y == null || p.y < min.y) {
						min.y = p.y;
					}
					if (max.y == null || p.y > max.y) {
						max.y = p.y;
					}
				}
			}
			lineStr.push(' ">');

			if (!aFill) {
				appendStroke(this, lineStr);
			} else {
				appendFill(this, lineStr, min, max);
			}

			lineStr.push('</r_vml_:shape>');

			this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
		};

		function appendStroke(ctx, lineStr) {
			var a = processStyle(ctx.strokeStyle);
			var color = a.color;
			var opacity = a.alpha * ctx.globalAlpha;
			var lineWidth = ctx.lineScale_ * ctx.lineWidth;

			// VML cannot correctly render a line if the width is less than
			// 1px.
			// In that case, we dilute the color to make the line look
			// thinner.
			if (lineWidth < 1) {
				opacity *= lineWidth;
			}

			lineStr.push('<r_vml_:stroke', ' opacity="', opacity, '"', ' joinstyle="', ctx.lineJoin, '"',
					' miterlimit="', ctx.miterLimit, '"', ' endcap="', processLineCap(ctx.lineCap), '"', ' weight="',
					lineWidth, 'px"', ' color="', color, '" />');
		}

		function appendFill(ctx, lineStr, min, max) {
			var fillStyle = ctx.fillStyle;
			var arcScaleX = ctx.arcScaleX_;
			var arcScaleY = ctx.arcScaleY_;
			var width = max.x - min.x;
			var height = max.y - min.y;
			if (fillStyle instanceof CanvasGradient_) {
				// TODO: Gradients transformed with the transformation
				// matrix.
				var angle = 0;
				var focus = {
					x : 0,
					y : 0
				};

				// additional offset
				var shift = 0;
				// scale factor for offset
				var expansion = 1;

				if (fillStyle.type_ == 'gradient') {
					var x0 = fillStyle.x0_ / arcScaleX;
					var y0 = fillStyle.y0_ / arcScaleY;
					var x1 = fillStyle.x1_ / arcScaleX;
					var y1 = fillStyle.y1_ / arcScaleY;
					var p0 = getCoords(ctx, x0, y0);
					var p1 = getCoords(ctx, x1, y1);
					var dx = p1.x - p0.x;
					var dy = p1.y - p0.y;
					angle = Math.atan2(dx, dy) * 180 / Math.PI;

					// The angle should be a non-negative number.
					if (angle < 0) {
						angle += 360;
					}

					// Very small angles produce an unexpected result
					// because they are
					// converted to a scientific notation string.
					if (angle < 1e-6) {
						angle = 0;
					}
				} else {
					var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
					focus = {
						x : (p0.x - min.x) / width,
						y : (p0.y - min.y) / height
					};

					width /= arcScaleX * Z;
					height /= arcScaleY * Z;
					var dimension = m.max(width, height);
					shift = 2 * fillStyle.r0_ / dimension;
					expansion = 2 * fillStyle.r1_ / dimension - shift;
				}

				// We need to sort the color stops in ascending order by
				// offset,
				// otherwise IE won't interpret it correctly.
				var stops = fillStyle.colors_;
				stops.sort(function(cs1, cs2) {
					return cs1.offset - cs2.offset;
				});

				var length = stops.length;
				var color1 = stops[0].color;
				var color2 = stops[length - 1].color;
				var opacity1 = stops[0].alpha * ctx.globalAlpha;
				var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;

				var colors = [];
				for ( var i = 0; i < length; i++) {
					var stop = stops[i];
					colors.push(stop.offset * expansion + shift + ' ' + stop.color);
				}

				// When colors attribute is used, the meanings of opacity
				// and o:opacity2
				// are reversed.
				lineStr.push('<r_vml_:fill type="', fillStyle.type_, '"', ' method="none" focus="100%"', ' color="',
						color1, '"', ' color2="', color2, '"', ' colors="', colors.join(','), '"', ' opacity="',
						opacity2, '"', ' r_o_:opacity2="', opacity1, '"', ' angle="', angle, '"', ' focusposition="',
						focus.x, ',', focus.y, '" />');
			} else if (fillStyle instanceof CanvasPattern_) {
				if (width && height) {
					var deltaLeft = -min.x;
					var deltaTop = -min.y;
					lineStr.push('<r_vml_:fill', ' position="', deltaLeft / width * arcScaleX * arcScaleX, ',',
							deltaTop / height * arcScaleY * arcScaleY, '"', ' type="tile"',
							// TODO: Figure out the correct size to fit the
							// scale.
							// ' size="', w, 'px ', h, 'px"',
							' src="', fillStyle.src_, '" />');
				}
			} else {
				var a = processStyle(ctx.fillStyle);
				var color = a.color;
				var opacity = a.alpha * ctx.globalAlpha;
				lineStr.push('<r_vml_:fill color="', color, '" opacity="', opacity, '" />');
			}
		}

		contextPrototype.fill = function() {
			this.stroke(true);
		};

		contextPrototype.closePath = function() {
			this.currentPath_.push({
				type : 'close'
			});
		};

		function getCoords(ctx, aX, aY) {
			var m = ctx.m_;
			return {
				x : Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
				y : Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
			};
		}
		;

		contextPrototype.save = function() {
			var o = {};
			copyState(this, o);
			this.aStack_.push(o);
			this.mStack_.push(this.m_);
			this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
		};

		contextPrototype.restore = function() {
			if (this.aStack_.length) {
				copyState(this.aStack_.pop(), this);
				this.m_ = this.mStack_.pop();
			}
		};

		function matrixIsFinite(m) {
			return isFinite(m[0][0]) && isFinite(m[0][1]) && isFinite(m[1][0]) && isFinite(m[1][1])
					&& isFinite(m[2][0]) && isFinite(m[2][1]);
		}

		function setM(ctx, m, updateLineScale) {
			if (!matrixIsFinite(m)) {
				return;
			}
			ctx.m_ = m;

			if (updateLineScale) {
				// Get the line scale.
				// Determinant of this.m_ means how much the area is
				// enlarged by the
				// transformation. So its square root can be used as a scale
				// factor
				// for width.
				var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
				ctx.lineScale_ = sqrt(abs(det));
			}
		}

		contextPrototype.translate = function(aX, aY) {
			var m1 = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ aX, aY, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), false);
		};

		contextPrototype.rotate = function(aRot) {
			var c = mc(aRot);
			var s = ms(aRot);

			var m1 = [ [ c, s, 0 ], [ -s, c, 0 ], [ 0, 0, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), false);
		};

		contextPrototype.scale = function(aX, aY) {
			this.arcScaleX_ *= aX;
			this.arcScaleY_ *= aY;
			var m1 = [ [ aX, 0, 0 ], [ 0, aY, 0 ], [ 0, 0, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), true);
		};

		contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
			var m1 = [ [ m11, m12, 0 ], [ m21, m22, 0 ], [ dx, dy, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), true);
		};

		contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
			var m = [ [ m11, m12, 0 ], [ m21, m22, 0 ], [ dx, dy, 1 ] ];

			setM(this, m, true);
		};

		/**
		 * The text drawing function. The maxWidth argument isn't taken in
		 * account, since no browser supports it yet.
		 */
		contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
			var m = this.m_, delta = 1000, left = 0, right = delta, offset = {
				x : 0,
				y : 0
			}, lineStr = [];

			var fontStyle = getComputedStyle(processFontStyle(this.font), this.element_);

			var fontStyleString = buildStyle(fontStyle);

			var elementStyle = this.element_.currentStyle;
			var textAlign = this.textAlign.toLowerCase();
			switch (textAlign) {
			case 'left':
			case 'center':
			case 'right':
				break;
			case 'end':
				textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
				break;
			case 'start':
				textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
				break;
			default:
				textAlign = 'left';
			}

			// 1.75 is an arbitrary number, as there is no info about the
			// text baseline
			switch (this.textBaseline) {
			case 'hanging':
			case 'top':
				offset.y = fontStyle.size / 1.75;
				break;
			case 'middle':
				break;
			default:
			case null:
			case 'alphabetic':
			case 'ideographic':
			case 'bottom':
				offset.y = -fontStyle.size / 2.25;
				break;
			}

			switch (textAlign) {
			case 'right':
				left = delta;
				right = 0.05;
				break;
			case 'center':
				left = right = delta / 2;
				break;
			}

			var d = getCoords(this, x + offset.x, y + offset.y);

			lineStr.push('<r_vml_:line from="', -left, ' 0" to="', right, ' 0.05" ',
					' coordsize="100 100" coordorigin="0 0"', ' filled="', !stroke, '" stroked="', !!stroke,
					'" style="position:absolute;width:1px;height:1px;">');

			if (stroke) {
				appendStroke(this, lineStr);
			} else {
				// TODO: Fix the min and max params.
				appendFill(this, lineStr, {
					x : -left,
					y : 0
				}, {
					x : right,
					y : fontStyle.size
				});
			}

			var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' + m[0][1].toFixed(3) + ','
					+ m[1][1].toFixed(3) + ',0,0';

			var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);

			lineStr.push('<r_vml_:skew on="t" matrix="', skewM, '" ', ' offset="', skewOffset, '" origin="', left,
					' 0" />', '<r_vml_:path textpathok="true" />', '<r_vml_:textpath on="true" string="',
					encodeHtmlAttribute(text), '" style="v-text-align:', textAlign, ';font:',
					encodeHtmlAttribute(fontStyleString), '" /></r_vml_:line>');

			this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
		};

		contextPrototype.fillText = function(text, x, y, maxWidth) {
			this.drawText_(text, x, y, maxWidth, false);
		};

		contextPrototype.strokeText = function(text, x, y, maxWidth) {
			this.drawText_(text, x, y, maxWidth, true);
		};

		contextPrototype.measureText = function(text) {
			if (!this.textMeasureEl_) {
				var s = '<span style="position:absolute;' + 'top:-20000px;left:0;padding:0;margin:0;border:none;'
						+ 'white-space:pre;"></span>';
				this.element_.insertAdjacentHTML('beforeEnd', s);
				this.textMeasureEl_ = this.element_.lastChild;
			}
			var doc = this.element_.ownerDocument;
			this.textMeasureEl_.innerHTML = '';
			this.textMeasureEl_.style.font = this.font;
			// Don't use innerHTML or innerText because they allow
			// markup/whitespace.
			this.textMeasureEl_.appendChild(doc.createTextNode(text));
			return {
				width : this.textMeasureEl_.offsetWidth
			};
		};

		/** ****** STUBS ******* */
		contextPrototype.clip = function() {
			// TODO: Implement
		};

		contextPrototype.arcTo = function() {
			// TODO: Implement
		};

		contextPrototype.createPattern = function(image, repetition) {
			return new CanvasPattern_(image, repetition);
		};

		// Gradient / Pattern Stubs
		function CanvasGradient_(aType) {
			this.type_ = aType;
			this.x0_ = 0;
			this.y0_ = 0;
			this.r0_ = 0;
			this.x1_ = 0;
			this.y1_ = 0;
			this.r1_ = 0;
			this.colors_ = [];
		}

		CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
			aColor = processStyle(aColor);
			this.colors_.push({
				offset : aOffset,
				color : aColor.color,
				alpha : aColor.alpha
			});
		};

		function CanvasPattern_(image, repetition) {
			assertImageIsValid(image);
			switch (repetition) {
			case 'repeat':
			case null:
			case '':
				this.repetition_ = 'repeat';
				break;
			case 'repeat-x':
			case 'repeat-y':
			case 'no-repeat':
				this.repetition_ = repetition;
				break;
			default:
				throwException('SYNTAX_ERR');
			}

			this.src_ = image.src;
			this.width_ = image.width;
			this.height_ = image.height;
		}

		function throwException(s) {
			throw new DOMException_(s);
		}

		function assertImageIsValid(img) {
			if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
				throwException('TYPE_MISMATCH_ERR');
			}
			if (img.readyState != 'complete') {
				throwException('INVALID_STATE_ERR');
			}
		}

		function DOMException_(s) {
			this.code = this[s];
			this.message = s + ': DOM Exception ' + this.code;
		}
		var p = DOMException_.prototype = new Error;
		p.INDEX_SIZE_ERR = 1;
		p.DOMSTRING_SIZE_ERR = 2;
		p.HIERARCHY_REQUEST_ERR = 3;
		p.WRONG_DOCUMENT_ERR = 4;
		p.INVALID_CHARACTER_ERR = 5;
		p.NO_DATA_ALLOWED_ERR = 6;
		p.NO_MODIFICATION_ALLOWED_ERR = 7;
		p.NOT_FOUND_ERR = 8;
		p.NOT_SUPPORTED_ERR = 9;
		p.INUSE_ATTRIBUTE_ERR = 10;
		p.INVALID_STATE_ERR = 11;
		p.SYNTAX_ERR = 12;
		p.INVALID_MODIFICATION_ERR = 13;
		p.NAMESPACE_ERR = 14;
		p.INVALID_ACCESS_ERR = 15;
		p.VALIDATION_ERR = 16;
		p.TYPE_MISMATCH_ERR = 17;

		// set up externs
		return G_vmlCanvasManager_;
	}
	return;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(TypeUtils) {
	var msgparas = /\{(\d+)\}/g;

	var emptyFn = function() {
	};

	var funcUtils = {
		/**
		 * empty function
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#noop
		 * @function
		 */
		noop : emptyFn,

		/**
		 * function throwing unsupported exception
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#unsupported
		 * @function
		 */
		unsupported : function() {
			throw new Error('Unsupported function!');
		},

		/**
		 * function throwing unimplemented exception
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#unimplemented
		 * @function
		 */
		unimplemented : function() {
			throw new Error('Unimplemented function!');
		},

		/**
		 * function throwing error
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#error
		 * @param {String}
		 *            msg the error message
		 * @function
		 */
		error : function(msg) {
			var args = arguments;
			if (args[0]) {
				var msg = args[0].replace(msgparas, function(m, n) {
					return args[parseInt(n) + 1];
				});
				throw msg;
			} else {
				throw 'unknown error!';
			}
		},

		createCallChain : function() {
			var len = arguments.length;
			if (len > 1) {
				var callChain = [];
				for ( var i = 0; i < len; i++) {
					if (TypeUtils.isFunction(arguments[i])) {
						callChain.push(arguments[i]);
					} else {
						funcUtils.error('Could not create call chain for non-function object');
					}
				}
				return (function() {
					for ( var i = 0; i < len; i++) {
						callChain[i].apply(this, arguments);
					}
				});
			} else {
				return TypeUtils.isFunction(arguments[0]) ? arguments[0] : emptyFn;
			}
		}
	};

	return funcUtils;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var _matrixMultiplay = function(ma, mb) {
		var result = [];
		var m = mb.length, n = mb[0].length;
		for ( var r = 0, rowVec; r < m; r++) {
			rowVec = [];

			for ( var c = 0, e; c < n; c++) {
				e = 0;
				for ( var ci = 0; ci < n; ci++) {
					e += mb[r][ci] * ma[ci][c];
				}
				rowVec[c] = e;
			}
			result[r] = rowVec;
		}
		return result;
	};
	var identityMatrix = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
	/**
	 * Static Transform Utility
	 * 
	 * @name sap.riv.core.utils.TransformHelper
	 * @class
	 */
	var TransformHelper = {
		/**
		 * Get an identity matrix.
		 * 
		 * @return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
		 */
		identityMatrix : function() {
			return identityMatrix;
		},
		/**
		 * The transform that rotates the given transform matrix by given angel
		 * 
		 * @param {Number}
		 *            angle Rotation angel in radians
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied rotation to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the rotated transform matrix
		 */
		makeRotateTM : function(angle, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ Math.cos(angle), -Math.sin(angle), 0 ],
					[ Math.sin(angle), Math.cos(angle), 0 ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying rotation
		 * 
		 * @param {Number}
		 *            angle Rotation angel in radians
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied rotation to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the rotated
		 *         transform matrix
		 */
		makeRotateInvertTM : function(angle, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay(transform, [ [ Math.cos(angle), Math.sin(angle), 0 ],
					[ -Math.sin(angle), Math.cos(angle), 0 ], [ 0, 0, 1 ] ]);
			return transM;
		},
		/**
		 * The transform that scales the given transform matrix by given factor
		 * 
		 * @param {Number}
		 *            x scale factor along the x axis
		 * @param {Number}
		 *            y scale factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied scaling to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the scaled transform matrix
		 */
		makeScaleTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ x, 0, 0 ], [ 0, y, 0 ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying scaling
		 * 
		 * @param {Number}
		 *            x scale factor along the x axis
		 * @param {Number}
		 *            y scale factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied scaling to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the scaling
		 *         transform matrix
		 */
		makeScaleInvertTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay(transform, [ [ 1 / x, 0, 0 ], [ 0, 1 / y, 0 ], [ 0, 0, 1 ] ]);
			return transM;
		},
		/**
		 * The transform that skew the given transform matrix by given factor
		 * 
		 * @param {Number}
		 *            x skew factor along the x axis
		 * @param {Number}
		 *            y skew factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied scaling to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the scaled transform matrix
		 */
		makeSkewTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ 1, x, 0 ], [ y, 1, 0 ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying skewing
		 * 
		 * @param {Number}
		 *            x skew factor along the x axis
		 * @param {Number}
		 *            y skew factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied skewing to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the skewing
		 *         transform matrix
		 */
		makeInvertSkewTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var det = 1 - x * y;
			var m;
			if (det !== 0) {
				m = [ [ 1 / det, -x / det, 0 ], [ -y / det, 1 / det, 0 ], [ 0, 0, 1 ] ];
			} else {
				throw new Error('invalid affine transform matrix');
			}
			var transM = _matrixMultiplay(transform, m);
			return transM;
		},
		/**
		 * The transform that translate original of the given transform matrix
		 * by given point
		 * 
		 * @param {Number}
		 *            x the coordinate in x axis
		 * @param {Number}
		 *            y the coordinate in y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied translation to the
		 *            transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the translated transform matrix
		 */
		makeTranslateTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ 1, 0, x ], [ 0, 1, y ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying translation
		 * 
		 * @param {Number}
		 *            x the coordinate in x axis
		 * @param {Number}
		 *            y the coordinate in y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied translation to the
		 *            transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the translated
		 *         transform matrix
		 */
		makeTranslateInvertTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay(transform, [ [ 1, 0, -x ], [ 0, 1, -y ], [ 0, 0, 1 ] ]);
			return transM;
		},
		/**
		 * Apply the custom transform to the given transform matrix
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform to apply
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the result matrix
		 */
		makeCustomTM : function(tm, tsfm) {
			var transform = tsfm || identityMatrix;
			if (tm[0][0] * tm[1][1] != tm[1][0] * tm[0][1]) {
				var transM = _matrixMultiplay(tm, transform);
				return transM;
			} else {
				throw new Error('invalid affine transform matrix');
			}
		},
		/**
		 * Calculate the inversion of the transform matrix by applying custom
		 * transform
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform to apply
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the inversion of the result
		 *         matrix
		 */
		makeCustomInvertTM : function(tm, tsfm) {
			var transform = tsfm || identityMatrix;
			var a = tm[0][0], b = tm[1][0], c = tm[0][1], d = tm[1][1], e = tm[0][2], f = tm[1][2];
			var det = a * d - b * c;
			if (det != 0) {
				var transM = _matrixMultiplay(transform, [ [ d / det, -c / det, (c * f - e * d) / det ],
						[ -b / det, a / det, (e * b - a * f) / det ], [ 0, 0, 1 ] ]);
				return transM;
			} else {
				throw new Error('invalid affine transform matrix');
			}
		},
		/**
		 * Whether the two matrix is equal
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            atm one transform matrix
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            atm another transform matrix
		 * @return {Boolean}
		 */
		isEqualTransform : function(atm, btm) {
			return atm
					&& btm
					&& (atm[0][0] == btm[0][0] && atm[0][1] == btm[0][1] && atm[0][2] == btm[0][2]
							&& atm[1][0] == btm[1][0] && atm[1][1] == btm[1][1] && atm[1][2] == btm[1][2]
							&& atm[2][0] == btm[2][0] && atm[2][1] == btm[2][1] && atm[2][2] == btm[2][2]);
		},
		/**
		 * Whether the matrix is idendity matrix
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            atm the transform matrix to check
		 * @return {Boolean}
		 */
		isIdentityMatrix : function(atm) {
			return (atm[0][0] == 1 && atm[0][1] == 0 && atm[0][2] == 0 && atm[1][0] == 0 && atm[1][1] == 1
					&& atm[1][2] == 0 && atm[2][0] == 0 && atm[2][1] == 0 && atm[2][2] == 1);
		},
		/**
		 * Whether the matrix is a valid affine transform matrix
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform matrix to check
		 * @return {Boolean}
		 */
		isValidAffineTransform : function(tm) {
			if (TypeUtils.isArray(tm)) {
				return tm[0][0] * tm[1][1] != tm[1][0] * tm[0][1];
			}
			return false;
		},
		/**
		 * Calculate the new point by applying transformation
		 * 
		 * @param {Object}
		 *            point the point to be applied transformation
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##
		 * }
		 * </pre>
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform matrix to apply
		 * @return {Object} new point *
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##
		 * }
		 * </pre>
		 */
		pointApplyTransform : function(point, t) {
			var x = point.x, y = point.y;
			return {
				x : t[0][0] * x + t[0][1] * y + t[0][2],
				y : t[1][0] * x + t[1][1] * y + t[1][2]
			};
		},
		/**
		 * Calculate the new rectangle by applying transformation
		 * 
		 * @param {Object}
		 *            rect the rectangle to be applied transformation *
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform matrix to apply
		 * @return {Object} new rectangle *
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 */
		rectApplyTransform : function(rect, t) {
			var x = rect.x, y = rect.y, w = rect.width, h = rect.height;
			var xy = {
				minx : Number.MAX_VALUE,
				maxx : Number.MIN_VALUE,
				miny : Number.MAX_VALUE,
				maxy : Number.MIN_VALUE
			};
			var corners = [
					[ t[0][0] * x + t[0][1] * y + t[0][2], t[1][0] * x + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + w) + t[0][1] * y + t[0][2], t[1][0] * (x + w) + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + w) + t[0][1] * (y + h) + t[0][2], t[1][0] * (x + w) + t[1][1] * (y + h) + t[1][2] ],
					[ t[0][0] * x + t[0][1] * (y + h) + t[0][2], t[1][0] * x + t[1][1] * (y + h) + t[1][2] ] ];
			for ( var i = 0, corner; i < 4; i++) {
				corner = corners[i];
				if (xy.minx > corner[0]) {
					xy.minx = corner[0];
				}
				if (xy.miny > corner[1]) {
					xy.miny = corner[1];
				}
				if (xy.maxx < corner[0]) {
					xy.maxx = corner[0];
				}
				if (xy.maxy < corner[1]) {
					xy.maxy = corner[1];
				}
			}
			return {
				x : xy.minx,
				y : xy.miny,
				width : xy.maxx - xy.minx,
				height : xy.maxy - xy.miny
			};
		},
		/**
		 * Decomposite a 2d transform matrix by translate, scale, skew, rotate
		 * primitive transform
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            transform the transform matrix to decomposite
		 * @returns {Object} primitive transform
		 * 
		 * <pre>
		 * {
		 * 	tx : tx, //translate in x
		 * 	ty : ty, //translate in y
		 * 	sx : sx, //scale in x
		 * 	sy : sy, //scale in y
		 * 	skew : skew, //skew in xy
		 * 	rotate : rotate
		 * //rotation in radians
		 * }
		 * </pre>
		 */
		unmatrix : function(transform) {
			var a = transform[0][0], b = transform[1][0], c = transform[0][1], d = transform[1][1], tx = transform[0][2], ty = transform[1][2];
			var rotate, scaleX, scaleY, skew;
			if (a * d == b * c) {
				return false;
			} else {
				scaleX = Math.sqrt(a * a + b * b);
				a /= scaleX;
				b /= scaleX;
				skew = a * c + b * d;
				c -= a * skew;
				d -= b * skew;
				scaleY = Math.sqrt(c * c + d * d);
				c /= scaleY;
				d /= scaleY;
				skew /= scaleY;
				if (a * d - b * c < 0) {
					skew = -skew;
					scaleY = -scaleY;
				}
				rotate = Math.atan2(a, b);
			}
			return {

				tx : tx,
				ty : ty,
				sx : scaleX,
				sy : scaleY,
				skew : skew,
				rotate : rotate
			};
		}
	};
	return TransformHelper;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(TypeUtils, FuncUtils) {
	var emptyFn = function(){};
	var trimLeft = /^\s+/, trimRight = /\s+$/,
	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/, rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;

	var trim = trim ? function(text) {
		return text == null ? "" : trim.call(text);
	} :
	// Otherwise use our own trimming functionality
	function(text) {
		return text == null ? "" : text.toString().replace(trimLeft, "").replace(trimRight, "");
	};

	/**
	 * OO static utilities
	 * 
	 * @name sap.riv.core.utils
	 * @class
	 */
	var objUtils = {
		proxy : function(fn, proxy, thisObject) {
			if (arguments.length === 2) {
				if (typeof proxy === "string") {
					thisObject = fn;
					fn = thisObject[proxy];
					proxy = undefined;

				} else if (proxy && !TypeUtils.isFunction(proxy)) {
					thisObject = proxy;
					proxy = undefined;
				}
			}

			if (!proxy && fn) {
				proxy = function() {
					return fn.apply(thisObject || this, arguments);
				};
			}
			// So proxy can be declared as an argument
			return proxy;
		},

		// Copy from jQuery
		extend : function() {
			var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

			// Handle a deep copy situation
			if (typeof target === "boolean") {
				deep = target;
				target = arguments[1] || {};
				// skip the boolean and the target
				i = 2;
			}

			// Handle case when target is a string or something (possible in
			// deep
			// copy)
			if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
				target = {};
			}

			// extend jQuery itself if only one argument is passed
			if (length === i) {
				target = this;
				--i;
			}

			for (; i < length; i++) {
				// Only deal with non-null/undefined values
				if ((options = arguments[i]) != null) {
					// Extend the base object
					for (name in options) {
						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (TypeUtils.isPlainObject(copy) || (copyIsArray = TypeUtils.isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && TypeUtils.isArray(src) ? src : [];

							} else {
								clone = src && TypeUtils.isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = objUtils.extend(deep, clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
			// Return the modified object
			return target;
		},

		// args is for internal usage only
		each : function(object, callback, args) {
			var name, i = 0, length = object.length, isObj = length === undefined || TypeUtils.isFunction(object);

			if (args) {
				if (isObj) {
					for (name in object) {
						if (callback.apply(object[name], args) === false) {
							break;
						}
					}
				} else {
					for (; i < length;) {
						if (callback.apply(object[i++], args) === false) {
							break;
						}
					}
				}

				// A special, fast, case for the most common use of each
			} else {
				if (isObj) {
					for (name in object) {
						if (callback.call(object[name], name, object[name]) === false) {
							break;
						}
					}
				} else {
					for ( var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {
					}
				}
			}
			return object;
		},

		parseJSON : function(data) {
			if (typeof data !== "string" || !data) {
				return null;
			}

			// Make sure leading/trailing whitespace is removed (IE can't handle
			// it)
			data = trim(data);

			// Make sure the incoming data is actual JSON
			// Logic borrowed from http://json.org/json2.js
			if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {

				// Try to use the native JSON parser first
				return window && window.JSON && window.JSON.parse ? window.JSON.parse(data) : (new Function("return "
						+ data))();

			} else {
				TypeUtils.error("Invalid JSON: " + data);
			}
		},

		/**
		 * make the subclass derived from passed-in superclass, the superclass's
		 * constructor will be automatically called.
		 * 
		 * @name sap.riv.core.utils.derive
		 * @function
		 * @param {Function}
		 *            subcls constructor of subclass or baseclass to extend
		 * @param {Function}
		 *            supercls or overide constructor of superclass, or object
		 *            literals to overide
		 * @return {Function} the constructor of the derived class with some
		 *         additional field: 'clazz' points to current constructor,
		 *         superclazz points to superclass' constructor. superclass in
		 *         prototype points to superclass's prototype
		 */
		derive : function(subcls, supercls) {
			var ret;
			var retp;
			if (typeof subcls === 'function') {
				if (typeof supercls === 'function') {
					if (supercls.prototype.constructor == Object.prototype.constructor) {
						supercls.prototype.constructor = supercls;
					}
					emptyFn.prototype = supercls.prototype;
					var h = new emptyFn();
					var sbp = subcls.prototype;
					for (var p in sbp) {
						if (sbp.hasOwnProperty(p)) {
							h[p] = sbp[p];
						}
					}
					ret = FuncUtils.createCallChain(supercls, subcls);
					retp = ret.prototype = h;
					retp.constructor = ret;
					retp.superclass = supercls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = supercls;
					return ret;
				} else if (typeof supercls === 'object') {
					var basecls = subcls;
					var mixin = supercls;
					var bcp = basecls.prototype;

					emptyFn.prototype = bcp;
					var h = new emptyFn();
					ret = FuncUtils.createCallChain(basecls, mixin.constructor);
					retp = ret.prototype = h;
					for (p in mixin) {
						if (mixin.hasOwnProperty(p)) {
							retp[p] = mixin[p];
						}
					}
					retp.constructor = ret;
					retp.superclass = basecls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = basecls;
				}
			}
			return ret;
		}
	};
	return objUtils;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Event class for graphics
	 * 
	 * @name sap.riv.graphics.Event
	 * @constructor
	 */
	var Event = function(type, targetLayer, canBubbling) {
		this._type = type;
		this._targetLayer = this._currentLayer = targetLayer;
		this._canBubbling = canBubbling || false;
		this._timestamp = +new Date;
	};
	var Ep = Event.prototype;

	Ep._setCurrentLayer_ = function(currentLayer) {
		this._currentLayer = currentLayer;
	};
	/**
	 * Get the type of the event
	 * 
	 * @name sap.riv.graphics.Event#type
	 * @function
	 * @returns {String}
	 */
	Ep.type = function() {
		return this._type;
	};

	/**
	 * Get the timestamp of the event
	 * 
	 * @name sap.riv.graphics.Event#timestamp
	 * @function
	 * @returns {Integer}
	 */
	Ep.timestamp = function() {
		return this._timestamp;
	};
	/**
	 * Get the target layer the event is originated from
	 * 
	 * @name sap.riv.graphics.Event#targetLayer
	 * @function
	 * @returns {sap.riv.graphics.Layer}
	 */
	Ep.targetLayer = function() {
		return this._targetLayer;
	};
	/**
	 * Get the current target layer the event is currently going through it can
	 * be different with the target layer
	 * 
	 * @name sap.riv.graphics.Event#currentLayer
	 * @function
	 * @returns {sap.riv.graphics.Layer}
	 */
	Ep.currentLayer = function() {
		return this._currentLayer;
	};

	/**
	 * Whether the event is in the bubbling phase
	 * 
	 * @name sap.riv.graphics.Event#isInBubbling
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.isInBubbling = function() {
		return this._targetLayer.id() != this._currentLayer.id();
	};
	/**
	 * Whether the event should be bubbled
	 * 
	 * @name sap.riv.graphics.Event#shouldBubble
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.shouldBubble = function() {
		return this._canBubbling;
	};
	/**
	 * Stop the event propagation up through the layer hierarchy in the bubbling
	 * phase
	 * 
	 * @name sap.riv.graphics.Event#stopPropagation
	 * @function
	 * 
	 */
	Ep.stopPropagation = function() {
		this._canBubbling = false;
	};
	return Event;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.RIVExCanvasMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
}
],
function Setup(TypeUtils, FuncUtils, RIVExCanvasMgr, UADetector) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var DrawingContextWrapper = function(canvas2DContext) {
		this._canvas2DContext = canvas2DContext;
	};

	var dp = DrawingContextWrapper.prototype;

	dp.save = function() {
		this._canvas2DContext.save();
	};

	dp.restore = function() {
		this._canvas2DContext.restore();
	};

	dp.scale = function(x, y) {
		this._canvas2DContext.scale(x, y);
	};
	dp.rotate = function(a) {
		this._canvas2DContext.rotate(a);
	};
	dp.translate = function(x, y) {
		this._canvas2DContext.translate(x, y);
	};
	dp.transform = function(a, b, c, d, e, f) {
		this._canvas2DContext.transform(a, b, c, d, e, f);
	};
	dp.setTransform = function(a, b, c, d, e, f) {
		this._canvas2DContext.setTransform(a, b, c, d, e, f);
	};
	dp.setAlpha = function(alpha) {
		this._canvas2DContext.globalAlpha = alpha;
	};
	dp.setCompositeOperation = function(composition) {
		this._canvas2DContext.globalCompositeOperation = composition;
	};
	dp.setStrokeStyle = function(style) {
		this._canvas2DContext.strokeStyle = style;
	};
	dp.setFillStyle = function(style) {
		this._canvas2DContext.fillStyle = style;
	};
	dp.setLineWidth = function(lineWidth) {
		this._canvas2DContext.lineWidth = lineWidth;
	};
	dp.setLineCap = (function() {
		if (UADetector.isFirefox() && parseFloat(UADetector.version()) < 4)
			// handle for Firefox 3.X which canvas context2d does not support
			// lineCap
			return FuncUtils.noop;
		else {
			return function(lineCap) {
				this._canvas2DContext.lineCap = lineCap;
			};
		}
	})();
	dp.setLineJoin = (function() {
		if (UADetector.isFirefox() && parseFloat(UADetector.version()) < 4)
			// handle for Firefox 3.X which canvas context2d does not support
			// lineJoin
			return FuncUtils.noop;
		else {
			return function(lineJoin) {
				this._canvas2DContext.lineJoin = lineJoin;
			};
		}
	})();
	dp.setMiterLimit = function(miterLimit) {
		this._canvas2DContext.miterLimit = miterLimit;
	};
	dp.setShadowStyle = function(offsetX, offsetY, blur, color) {
		this._canvas2DContext.shadowOffsetX = offsetX;
		this._canvas2DContext.shadowOffsetY = offsetY;
		this._canvas2DContext.shadowBlur = blur;
		this._canvas2DContext.shadowColor = color;
	};
	dp.clearRect = function(x, y, width, height) {
		this._canvas2DContext.clearRect(x, y, width, height);
	};
	dp.fillRect = function(x, y, width, height) {
		this._canvas2DContext.fillRect(x, y, width, height);
	};
	dp.strokeRect = function(x, y, width, height) {
		this._canvas2DContext.strokeRect(x, y, width, height);
	};
	dp.beginPath = function() {
		this._canvas2DContext.beginPath();
	};
	dp.closePath = function() {
		this._canvas2DContext.closePath();
	};
	dp.moveTo = function(x, y) {
		this._canvas2DContext.moveTo(x, y);
	};
	dp.lineTo = function(x, y) {
		this._canvas2DContext.lineTo(x, y);
	};
	dp.quadraticCurveTo = function(cpx, cpy, x, y) {
		this._canvas2DContext.quadraticCurveTo(cpx, cpy, x, y);
	};
	dp.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		this._canvas2DContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
	};
	dp.arcTo = function(x1, y1, x2, y2, radius) {
		this._canvas2DContext.arcTo(x1, y1, x2, y2, radius);
	};
	dp.rect = function(x, y, width, height) {
		this._canvas2DContext.rect(x, y, width, height);
	};
	dp.arc = function(x, y, radius, startAngle, endAngle, antiClockwise) {
		this._canvas2DContext.arc(x, y, radius, startAngle, endAngle, antiClockwise);
	};
	dp.fill = function() {
		this._canvas2DContext.fill();
	};
	dp.stroke = function() {
		this._canvas2DContext.stroke();
	};
	dp.clip = function() {
		this._canvas2DContext.clip();
	};
	dp.setFont = function(font) {
		this._canvas2DContext.font = font;
	};
	dp.setTextAlign = function(textAlign) {
		this._canvas2DContext.textAlign = textAlign;
	};
	dp.setTextBaseline = function(textBaseline) {
		this._canvas2DContext.textBaseline = textBaseline;
	};
	dp.fillText = function(text, x, y, maxWidth) {
		if (maxWidth !== undefined) {
			this._canvas2DContext.fillText(text, x, y, maxWidth);
		} else {
			this._canvas2DContext.fillText(text, x, y);
		}
	};
	dp.strokeText = function(text, x, y, maxWidth) {
		// JY: FIREFOX doesn't accept undefined maxWidth as parameter
		if (TypeUtils.isDefined(maxWidth)) {
			this._canvas2DContext.strokeText(text, x, y, maxWidth);
		} else {
			this._canvas2DContext.strokeText(text, x, y);
		}
	};
	dp.measureText = function(text) {
		return this._canvas2DContext.measureText(text);
	};

	dp.drawImage = function(image, dx, dy) {
		if (image instanceof CanvasWraper) {
			this._canvas2DContext.drawImage(image._canvas, dx, dy);
		} else {
			this._canvas2DContext.drawImage(image, dx, dy);
		}
	};

	dp.createLinearGradient = function(x0, y0, x1, y1) {
		return this._canvas2DContext.createLinearGradient(x0, y0, x1, y1);
	};

	dp.createRadialGradient = function(x0, y0, r0, x1, y1, r1) {
		return this._canvas2DContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
	};

	var CanvasWraper = function(canvas) {
		this._jqCanvas = canvas;
		this._canvas = canvas.get(0);
		this._drawingContext = new DrawingContextWrapper(this._canvas.getContext('2d'));
	};

	CanvasWraper.prototype.getContext = function(contextId) {
		return this._drawingContext;
	};

	CanvasWraper.prototype.toDataURL = function() {
		return this._canvas.toDataURL.apply(this._canvas, arguments);
	};

	CanvasWraper.prototype.width = function(width) {
		if (width !== undefined) {
			width = ~~(width + 0.5);
			this._jqCanvas.width(width);
			this._canvas.width = width;
			return this;
		} else {
			return this._canvas.width;
		}
	};

	CanvasWraper.prototype.height = function(height) {
		if (height != undefined) {
			height = ~~(height + 0.5);
			this._jqCanvas.height(height);
			this._canvas.height = height;
			return this;
		} else {
			return this._canvas.height;
		}
	};

	CanvasWraper.prototype.bind = function(type, callback) {
		this._jqCanvas.bind(type, callback);
	};

	var id = 0;
	var nextId = function() {
		return 'can:' + id++;
	};
	var rvmlmgr = RIVExCanvasMgr;
	var createCanvas = function(width, height, appendTo) {
		width = ~~(width + 0.5);
		height = ~~(height + 0.5);
		var canEl;
		if (window.__IS_IN_RHINO) {
			var canDom = document.createElement('canvas');
			if (!height || height <= 0) {
				height = 1;
			}
			if (!width || width <= 0) {
				width = 1;
			}
			canDom.height = height;
			canDom.width = width;
			canDom.id = nextId();
			canEl = $(canDom);
			if (appendTo) {
				canEl.appendTo(appendTo);
			}
		} else if (UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
			if (typeof FlashCanvas != "undefined") {
				var canDom = document.createElement('canvas');
				canEl = $(canDom).attr('id', nextId());
				if (appendTo) {
					canEl.appendTo(appendTo);
				} else {
					$('body').append(canDom);
				}
				FlashCanvas.initElement(canDom);
				canEl.attr('height', height).attr('width', width).width(width).height(height);
			} else {
				var canDom = document.createElement('rivcanvas');
				canEl = $(canDom).attr('id', nextId()).attr('height', height).attr('width', width).width(width).height(
						height);
				if (appendTo) {
					canEl.appendTo(appendTo);
				}
				rvmlmgr.initElement(canDom);
			}
		} else {
			canEl = $(document.createElement('canvas')).attr('id', nextId()).attr('height', height)
					.attr('width', width).width(width).height(height);
			if (appendTo) {
				canEl.appendTo(appendTo);
			}
		}
		return new CanvasWraper(canEl);
	};
	var hiddenCanvasCtx = undefined;
	var getHiddenCanvasCtx = function() {
		if (!hiddenCanvasCtx) {
			hiddenCanvasCtx = createCanvas(1, 1).getContext('2d');
		}
		return hiddenCanvasCtx;
	};
	/**
	 * Static Canvas Utility
	 * 
	 * @name sap.riv.graphics.CanvasHelper
	 * @class
	 */
	var CanvasHelper = {
		/**
		 * Create a new canvas element
		 * 
		 * @param {Number}
		 *            width width of the new canvas
		 * @param {Number}
		 *            height height of the new canvas
		 * @param {Element}
		 *            (appendTo) the container of the newly created canvas
		 */
		createCanvasElement : createCanvas,

		getCanvasElement : function(canvasEl) {
			return new CanvasWraper(canvasEl);
		},
		/**
		 * Create the color style based on the color setting
		 * 
		 * @param {Object}
		 *            style
		 * 
		 * <pre>
		 * {
		 * 	t : 'css', //Required. Indicate the type of the color is CSS color value.
		 * 	v : CSSCOLOR
		 * //Optional. eg. #C0C0C0. If missing, transparent black(#000000) will be used.
		 * }
		 * </pre>
		 * <pre>
		 * {
		 *      t: ['lg'|'rg'], //Required. lg stands for Linear Gradient, rg stands for Radial Gradient.
		 *      s: POINT, //Required. The start point of the linear gradient.
		 *      e: POINT, //Required. The end point of the linear gradient.
		 *      st: [{o: ##, v: CSSCOLOR }] //Required. The array of CSS color string at different offset along the gradient.
		 * }
		 * </pre>
		 * 
		 * @returns {String|CanvasGradient}
		 */
		createColorStyle : function(style) {
			var ret;
			if (!style) {
				return '#000000';
			}
			switch (style.t) {
			case 'css':
				ret = style.v;
				break;
			case 'lg':
				// TODO support referenced gradient
				var start = style.s;
				var end = style.e;
				var stops = style.st;
				ret = getHiddenCanvasCtx().createLinearGradient(start.x, start.y, end.x, end.y);
				for ( var i = 0, len = stops.length, stop; i < len; i++) {
					stop = stops[i];
					ret.addColorStop(stop.o, stop.v);
				}
				break;
			case 'rg':
				// TODO support referenced gradient
				var start = style.s.c;
				var startR = style.s.r;
				var end = style.e.c;
				var endR = style.e.r;
				var stops = style.st;
				ret = getHiddenCanvasCtx().createRadialGradient(start.x, start.y, startR, end.x, end.y, endR);
				for ( var i = 0, len = stops.length, stop; i < len; i++) {
					stop = stops[i];
					ret.addColorStop(stop.o, stop.v);
				}
				break;
			default:
				ret = style;
			}
			return ret;
		}
	};
	return CanvasHelper;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
}
],
function Setup(ObjUtils, FuncUtils, TmHelper) {
	var shapeId = (function() {
		var id = 0;
		return function() {
			return 's:' + id++;
		};
	})();
	var identityMatrix = TmHelper.identityMatrix();
	/**
	 * The base class for any shape
	 * 
	 * @name sap.riv.graphics.Drawable
	 * @constructor
	 * @param {Object}
	 *            metadata
	 * @param {Object}
	 *            [metadata.tsfm] the transformation for the shape
	 * @param {Object}
	 *            [metadata.shdw] the shadow setting for the shape
	 * @param {Object}
	 *            [metadata.cpsn] the composite setting for the shape
	 */
	var drwbl = function(metadata) {
		this._isVisible = true;
		this._id = shapeId();
		this._shadowSetting = undefined;
		this._compositionSetting = undefined;
		this._tm = identityMatrix;
		this._itm = identityMatrix;
	};

	/**
	 * Get the unique id of the shape
	 * 
	 * @name sap.riv.graphics.Drawable#id
	 * @returns {String}
	 */
	drwbl.prototype.id = function() {
		return this._id;
	};
	/**
	 * Get or set the shape's visibility
	 * 
	 * @name sap.riv.graphics.Drawable#isVisible
	 * @param {Boolean}
	 *            isVisible
	 * @returns {Boolean|this} return the current visibility or this object to
	 *          allow function chaining
	 */
	drwbl.prototype.visible = function(isVisible) {
		if (isVisible !== undefined) {
			this._isVisible = isVisible;
			return this;
		}
		return this._isVisible;
	};

	/**
	 * An convenient method which combining the effect of translation and
	 * rotation
	 * 
	 * @name sap.riv.graphics.Drawable#rotateAt
	 * @param {Number}
	 *            x the x coordinate of the new origin.
	 * @param {Number}
	 *            y the y coordinate of the new origin.
	 * @param {Number}
	 *            angle the angle to rotate
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.rotateAt = function(x, y, angle) {
		this._tm = TmHelper.makeTranslateTM(x, y, this._tm);
		this._itm = TmHelper.makeTranslateInvertTM(x, y, this._itm);
		this._tm = TmHelper.makeRotateTM(angle, this._tm);
		this._itm = TmHelper.makeRotateInvertTM(angle, this._itm);
		return this;
	};

	/**
	 * Rotate the shape by an angle in radian around the origin of the
	 * coordinate system
	 * 
	 * @name sap.riv.graphics.Drawable#rotate
	 * @param {Number}
	 *            angle the angle to rotate
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.rotate = function(angle) {
		this._tm = TmHelper.makeRotateTM(angle, this._tm);
		this._itm = TmHelper.makeRotateInvertTM(angle, this._itm);
		return this;
	};
	/**
	 * Translate the origin of the coordinate system
	 * 
	 * @name sap.riv.graphics.Drawable#translate
	 * @param {Number}
	 *            x the x coordinate of the new origin.
	 * @param {Number}
	 *            y the y coordinate of the new origin.
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.translate = function(x, y) {
		this._tm = TmHelper.makeTranslateTM(x, y, this._tm);
		this._itm = TmHelper.makeTranslateInvertTM(x, y, this._itm);
		return this;
	};
	/**
	 * Scale the shape in x and y direction against the origin of the coordinate
	 * system
	 * 
	 * @name sap.riv.graphics.Drawable#scale
	 * @param {Number}
	 *            x the scale factor in x axis.
	 * @param {Number}
	 *            y the scale factor in y axis.
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.scale = function(x, y) {
		this._tm = TmHelper.makeScaleTM(x, y, this._tm);
		this._itm = TmHelper.makeScaleInvertTM(x, y, this._itm);
		return this;
	};

	/**
	 * Skew the shape in x and y direction against the origin of the coordinate
	 * system
	 * 
	 * @name sap.riv.graphics.Drawable#skew
	 * @param {Number}
	 *            x the skew factor in x axis.
	 * @param {Number}
	 *            y the skew factor in y axis.
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.skew = function(x, y) {
		this._tm = TmHelper.makeSkewTM(x, y, this._tm);
		this._itm = TmHelper.makeInvertSkewTM(x, y, this._itm);
		return this;
	};
	/**
	 * Transform the shape with custom transform matrix together with previous
	 * applied transform, the matrix should follow the format
	 * 
	 * <pre>
	 * [ a, c, e ][b, d, f][0, 0, 1]
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#customTransform
	 * @param {Number}
	 *            a
	 * @param {Number}
	 *            b
	 * @param {Number}
	 *            c
	 * @param {Number}
	 *            d
	 * @param {Number}
	 *            e
	 * @param {Number}
	 *            f
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.customTransform = function(a, b, c, d, e, f) {
		var m = [ [ a, c, e ], [ b, d, f ], [ 0, 0, 1 ] ];
		this._tm = TmHelper.makeCustomTM(m, this._tm);
		this._itm = TmHelper.makeCustomInvertTM(m, this._itm);
		return this;
	};
	/**
	 * Transform the shape with custom transform matrix together, the matrix
	 * should follow the format
	 * 
	 * <pre>
	 * [ a, c, e ][b, d, f][0, 0, 1]
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#setTransform
	 * @param {Number}
	 *            a
	 * @param {Number}
	 *            b
	 * @param {Number}
	 *            c
	 * @param {Number}
	 *            d
	 * @param {Number}
	 *            e
	 * @param {Number}
	 *            f
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.setTransform = function(a, b, c, d, e, f) {
		this._tm = [ [ a, c, e ], [ b, d, f ], [ 0, 0, 1 ] ];
		this._itm = TmHelper.makeCustomInvertTM(this._tm, identityMatrix);
		return this;
	};

	/**
	 * Get or set the shadow, the setting should follow
	 * 
	 * <pre>
	 * {
	 *      offsetX: ##, //Number, offset in X axis
	 *      offsetY: ##, //Number, offset in Y axis
	 *      blur: ##, //Number, shadow blur
	 *      color: ##, //CSSColor, shadow color
	 * }
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#shadow
	 * @param {Object|false}
	 *            shadow passing 'false' will remove existing shadow setting
	 * @returns {this|Object} when setting shadow the return will be this object
	 *          to allow chaining
	 */
	drwbl.prototype.shadow = function(shadow) {
		if (shadow !== undefined) {
			if (shadow !== false) {
				this._shadowSetting = {
					ox : shadow.offsetX,
					oy : shadow.offsetY,
					blur : shadow.blur,
					color : shadow.color
				};
			} else {
				this._shadowSetting = undefined;
			}
			return this;
		}
		if (this._shadowSetting) {
			return ObjUtils.extend({}, this._shadowSetting);
		}
	};
	/**
	 * Get or set the composition model, the setting should follow
	 * 
	 * <pre>
	 * {
	 *      alpha: ##, //Number, alpha when blending the color
	 *      operation: ##, //String, the blending type, default is source-over
	 * }
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#compositionMode
	 * @param {Object|false}
	 *            composition passing 'false' will remove existing composition
	 *            setting
	 * @returns {this|Object} when setting composition the return will be this
	 *          object to allow chaining
	 */
	drwbl.prototype.compositionMode = function(composition) {
		if (composition !== undefined) {
			if (composition !== false) {
				this._compositionSetting = {
					alpha : composition.alpha,
					operation : composition.operation
				};
			} else {
				this._compositionSetting = undefined;
			}
			return this;
		}
		if (this._compositionSetting) {
			return ObjUtils.extend({}, this._compositionSetting);
		}
	};

	/**
	 * Whether the point is in the shape
	 * 
	 * @name sap.riv.graphics.Drawable#pointIn
	 * @param {Object}
	 *            point
	 * @returns {Boolean}
	 */
	drwbl.prototype.pointIn = function(point) {
		var itm = this._itm;
		var x = point.x;
		var y = point.y;
		return this.doPointInTest({
			x : itm[0][0] * x + itm[0][1] * y + itm[0][2],
			y : itm[1][0] * x + itm[1][1] * y + itm[1][2]
		});
	};

	/**
	 * Do point in shape testing, subclass should override with real
	 * implementation.
	 * 
	 * @name sap.riv.graphics.Drawable#doPointInTest
	 * @param {Object}
	 *            point the point to test.
	 * @return {Boolean}
	 */
	drwbl.prototype.doPointInTest = FuncUtils.unimplemented;

	drwbl.prototype.drawTo = function(drawingContext) {
		if (!this._isVisible) {
			return;
		}
		var dCtx = drawingContext;

		if (!TmHelper.isIdentityMatrix(this._tm)) {
			var t = this._tm;
			dCtx.transform(t[0][0], t[1][0], t[0][1], t[1][1], t[0][2], t[1][2]);
		}
		if (this._shadowSetting) {
			var shdw = this._shadowSetting;
			dCtx.setShadowStyle(shdw.ox, shdw.oy, shdw.blur, shdw.color);
		}
		if (this._compositionSetting) {
			var c = this._compositionSetting;
			dCtx.setAlpha(c.alpha || 1.0);
			dCtx.setCompositeOperation(c.operation || 'source-over');
		}
		this.doDraw(dCtx);
	};

	/**
	 * This method is intended to be overridden by subclass, to do actual
	 * drawing
	 * 
	 * @name sap.riv.graphics.Drawable#doDraw
	 * @param {DrawingContext}
	 *            the drawing context for drawing
	 */
	drwbl.prototype.doDraw = FuncUtils.noop;
	return drwbl;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.MouseEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Event) {
	/**
	 * This class defines Mouse Event on layers
	 * 
	 * @name sap.riv.graphics.MouseEvent
	 * @class
	 * @augments sap.riv.graphics.Event
	 */
	var MouseEvent = ObjUtils.derive(Event,
	/**
	 * @lends sap.riv.graphics.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, globalXY, pageXY) {
			this._relatedLayer = undefined;
			this._targetLocalXY = this._currentLocalXY = this._targetLayer.convertPointFromGlobal(globalXY);
			this._pageXY = {
				x : pageXY.x,
				y : pageXY.y
			};
		},

		_setRelatedLayer_ : function(relatedLayer) {
			this._relatedLayer = relatedLayer;
		},

		_setCurrentLocalXY_ : function(currentXY) {
			this._currentLocalXY = currentXY;
		},

		/**
		 * Get the related layer if any.
		 * 
		 * @name sap.riv.graphics.MouseEvent#relatedLayer
		 * @function
		 * @returns {sap.riv.graphics.Layer}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		relatedLayer : function() {
			return this._relatedLayer;
		},

		/**
		 * Get the mouse event XY in target layer's coordinates system
		 * 
		 * @name sap.riv.graphics.MouseEvent#targetLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		targetLocalXY : function() {
			return this._targetLocalXY;
		},
		/**
		 * Get the mouse event XY in current layer's coordinates system
		 * 
		 * @name sap.riv.graphics.MouseEvent#currentLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		currentLocalXY : function() {
			return this._currentLocalXY;
		},
		/**
		 * Get the page XY of the event
		 * 
		 * @name sap.riv.graphics.MouseEvent#pageXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		pageXY : function() {
			return this._pageXY;
		}
	});
	return MouseEvent;
});sap.riv.module(
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FncUtils) {
    var noop = FncUtils.noop;
    // var noop = function() {
    // };
    Date.now = Date.now ||
    function() {
        return +new Date;
    };

    var dispatcherIdleCounter = 0;

    function callAppender(appender) {
        var logTime, logLevel, logCate, logMsg, appenderLevel;

        if(logBuffer[0].length > 0) {
            if(appender) {
                appenderLevel = appender.getLevel();
                for(var i = 0, bl = logBuffer[0].length; i < bl; i++) {
                    logTime = logBuffer[0][i];
                    logLevel = logBuffer[1][i];
                    logCate = logBuffer[2][i];
                    logMsg = logBuffer[3][i];
                    if(logBuffer[1][i] >= appenderLevel)
                        appender.doAppend(logTime, logLevel, logCate, logMsg);
                }
                return;
            }

            //call all appenders
            //var appender;
            var appenderLevelMap = {};
            for(var appenderKey in appenders) {
                appenderLevelMap[appenderKey] = appenders[appenderKey].getLevel();
            }
            while(logBuffer[0].length) {
                logTime = logBuffer[0].shift();
                logLevel = logBuffer[1].shift();
                logCate = logBuffer[2].shift();
                logMsg = logBuffer[3].shift();
                for(appenderKey in appenders) {
                    appender = appenders[appenderKey];
                    if(logLevel >= appenderLevelMap[appenderKey])
                        appender.doAppend(logTime, logLevel, logCate, logMsg);
                }
            }
            return;
        } else if(++dispatcherIdleCounter === 3)
            //pause on third time loop an empty Buffer
            pause();
    }

    function dispatcher() {
        callAppender();
        if(!paused)
            setTimeout(function() {
                dispatcher();
            }, 100);
    }

    var ConsoleAppender = function() {
        this.threshold = Logger.LEVEL.INFO;
        this.layout = new Logger.DefaultLayout();
        this.print = typeof console !== undefined ? function(msg) {
            console.log(msg);
        } : noop;
    };
    ConsoleAppender.prototype = {
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.print(this.layout.format(logTime, logLevel, logCate, logMsg));
        },
        setLayout : function(layout) {
            layout.format && (this.layout = layout);
        },
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        }
    };
    var DefaultLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    DefaultLayout.prototype.format = function(logTime, logLevel, logCate, logMsg) {
        return "[" + logTime + "]" + "[" + getLevelStr(logLevel) + "]" + "[" + (logCate || "main") + "]-" + logMsg;
    };
    var DivAppender = function(div) {
        if(!$) {
            throw "need jQuery";
        }
        this.threshold = Logger.LEVEL.INFO;
        this.divSl = $(div);
        this.layout = new HTMLLayout();
    };
    DivAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.divSl.append(this.layout.format(logTime, logLevel, logCate, logMsg));
        }
    };
    var HTMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    HTMLLayout.prototype = {
        getStyle : function(logLevel) {
            var style;
            if(logLevel === Logger.LEVEL.ERROR) {
                style = 'color:red';
            } else if(logLevel === Logger.LEVEL.WARN) {
                style = 'color:orange';
            } else if(logLevel === Logger.LEVEL.DEBUG) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.TRACE) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.INFO) {
                style = 'color:grey';
            } else {
                style = 'color:yellow';
            }
            return style;
        },
        format : function(logTime, logLevel, logCate, logMsg) {
            return "<div style=\"" + this.getStyle(logLevel) + "\">[" + logTime + "]" + "[" + getLevelStr(logLevel) + "][" + (logCate || "main") + "]-" + logMsg + "</div>";
        }
    };
    var FifoBuffer = function() {
        this.array = new Array();
    };

    FifoBuffer.prototype = {

        /**
         * @param {Object} obj any object added to buffer
         */
        push : function(obj) {
            this.array[this.array.length] = obj;
            return this.array.length;
        },
        /**
         * @return first putted in Object
         */
        pull : function() {
            if(this.array.length > 0) {
                var firstItem = this.array[0];
                for(var i = 0; i < this.array.length - 1; i++) {
                    this.array[i] = this.array[i + 1];
                }
                this.array.length = this.array.length - 1;
                return firstItem;
            }
            return null;
        },
        length : function() {
            return this.array.length;
        }
    };
    var AjaxAppender = function(url) {
        this.loggingUrl = url;
        this.isInProgress = false;
        this.threshold = Logger.LEVEL.INFO;
        this.bufferSize = 1;
        this.timeout = 2000;
        this.loggingEventMap = new FifoBuffer();
        this.layout = new Logger.JSONLayout();
        this.httpRequest = null;
    };
    AjaxAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            if(this.loggingEventMap.length() <= this.bufferSize || this.isInProgress === true) {
                this.loggingEventMap.push([logTime, logLevel, logCate, logMsg]);
            }

            if(this.loggingEventMap.length() >= this.bufferSize && this.isInProgress === false) {
                //if bufferSize is reached send the events and reset current bufferSize
                this.send();
            }
        },
        send : function() {
            if(this.loggingEventMap.length() > 0) {
                this.isInProgress = true;
                var a = [];
                var loggingEvent;
                for(var i = 0; i < this.loggingEventMap.length() && i < this.bufferSize; i++) {
                    loggingEvent = this.loggingEventMap.pull();
                    a.push(this.layout.format(loggingEvent[0], loggingEvent[1], loggingEvent[2], loggingEvent[3]));
                }

                var content = this.layout.getHeader();
                content += a.join(this.layout.getSeparator());
                content += this.layout.getFooter();

                var appender = this;
                if(this.httpRequest === null) {
                    this.httpRequest = this.getXmlHttpRequest();
                }
                this.httpRequest.onreadystatechange = function() {
                    appender.onReadyStateChanged.call(appender);
                };

                this.httpRequest.open("POST", this.loggingUrl, true);
                // set the request headers.
                //this.httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                this.httpRequest.setRequestHeader("Content-type", this.layout.getContentType());
                //REFERER will be the top-level
                // URI which may differ from the location of the error if
                // it occurs in an included .js file
                //this.httpRequest.setRequestHeader("REFERER", location.href);
                //this.httpRequest.setRequestHeader("Content-length", content.length);
                //this.httpRequest.setRequestHeader("Connection", "close");
                //console && console.log(content);
                this.httpRequest.send(content);
                appender = this;

                try {
                    setTimeout(function() {
                        appender.httpRequest.onreadystatechange = function() {
                            return;
                        };
                        appender.httpRequest.abort();
                        //this.httpRequest = null;
                        appender.isInProgress = false;

                        if(appender.loggingEventMap.length() > 0) {
                            appender.send();
                        }
                    }, this.timeout);
                } catch (e) {
                }
            }
        },
        onReadyStateChanged : function() {
            var req = this.httpRequest;
            if(this.httpRequest.readyState != 4) {
                return;
            }

            var success = (( typeof req.status === "undefined") || req.status === 0 || (req.status >= 200 && req.status < 300));

            if(success) {

                //ready sending data
                this.isInProgress = false;

            } else {
            }
        },
        getXmlHttpRequest : function() {

            var httpRequest = false;

            try {
                if(window.XMLHttpRequest) {// Mozilla, Safari, IE7...
                    httpRequest = new XMLHttpRequest();
                    if(httpRequest.overrideMimeType) {
                        httpRequest.overrideMimeType(this.layout.getContentType());
                    }
                } else if(window.ActiveXObject) {// IE
                    try {
                        httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
                    }
                }
            } catch (e) {
                httpRequest = false;
            }

            if(!httpRequest) {
                throw "browser don't support AJAX";
            }

            return httpRequest;
        }
    };
    var JSONLayout = function() {

    };
    JSONLayout.prototype = {
        /**
         * Implement this method to create your own layout format.
         * @param {Log4js.LoggingEvent} loggingEvent loggingEvent to format
         * @return formatted String
         * @type String
         */
        format : function(logTime, logLevel, logCate, logMsg) {

            var jsonString = "{\n \"LoggingEvent\": {\n";
            jsonString += "\t\"category\": \"" + (logCate || "main") + "\",\n";
            jsonString += "\t\"level\": \"" + getLevelStr(logLevel) + "\",\n";
            jsonString += "\t\"message\": \"" + logMsg + "\",\n";
            // jsonString += "\t\"referer\": \"" + referer + "\",\n";
            // jsonString += "\t\"useragent\": \"" + useragent + "\",\n";
            jsonString += "\t\"timestamp\": \"" + logTime + "\"\n";
            jsonString += "}\n}";

            return jsonString;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/json";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "{" + "\"ClientInfo\" : {\n" + "\t\"useragent\": \"" + useragent + "\",\n" + "\t\"referer\": \"" + referer + "\"\n},\n" + "\"VizLogger\": [\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "\n]}";
        },
        getSeparator : function() {
            return ",\n";
        }
    };

    /**
     * Get the XMLHttpRequest object independent of browser.
     * @private
     */
    var XMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    XMLLayout.prototype = {
        format : function(logTime, logLevel, logCate, logMsg) {

            var content = "<vizLogger:event category=\"";
            content += (logCate || "main") + "\" level=\"";
            content += getLevelStr(logLevel) + "\" timestamp=\"";
            content += logTime + "\">\n";
            content += "\t<vizLogger:message><![CDATA[" + this.escapeCdata(logMsg) + "]]></vizLogger:message>\n";
            content += "</vizLogger:event>";

            return content;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/xml";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "<vizLogger:eventSet useragent=\"" + useragent + "\" referer=\"" + referer.replace(/&/g, "&amp;") + "\">\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "</vizLogger:eventSet>\n";
        },
        getSeparator : function() {
            return "\n";
        },
        /**
         * Escape Cdata messages
         * @param str {String} message to escape
         * @return {String} the escaped message
         * @private
         */
        escapeCdata : function(str) {
            return str.replace(/\]\]>/, "]]>]]&gt;<![CDATA[");
        }
    };

    function getLevelStr(levelInt) {
        switch(levelInt) {
            case Logger.LEVEL.TRACE:
                return "TRACE";
            case Logger.LEVEL.DEBUG:
                return "DEBUG";
            case Logger.LEVEL.INFO:
                return "INFO";
            case Logger.LEVEL.WARN:
                return "WARN";
            case Logger.LEVEL.ERROR:
                return "ERROR";
        }
    }

    var enabled = false;
    var paused = false;
    var logBuffer = [[/*logTime*/], [/*level*/], [/*category*/], [/*message*/]];
    var MaxBufferSize = 2000;
    var doLog = function(level, category, message) {
        // if(enabled) {
        if(logBuffer[0].length === MaxBufferSize)
            callAppender();
        logBuffer[0].push(Date.now());
        logBuffer[1].push(level);
        logBuffer[2].push(category);
        logBuffer[3].push(message.toString());
        // }
    };
    var awakeThenLog = function(level, category, message) {
        resume();
        doLog(level, category, message);
    };
    var log = noop;
    var pause = function() {
        paused = true;
        log = awakeThenLog;
    };
    var resume = function() {
        paused = false;
        log = doLog;
        setTimeout(function() {
            dispatcher();
        }, 100);
    };
    // id for appender
    var id = 0;
    var nextId = function() {
        return id++;
    };
    var appenders = {};
    /*
     * singleton Logger
     *
     */
    var Logger = {
        LEVEL : {
            TRACE : 5000,
            DEBUG : 10000,
            INFO : 20000,
            WARN : 30000,
            ERROR : 40000,
            NO : Number.MAX_VALUE
        },
        isEnable : function() {
            return enabled;
        },
        enable : function() {
            log = doLog;
            enabled = true;
            setTimeout(function() {
                dispatcher();
            }, 100);
        },
        disable : function() {
            callAppender();
            log = noop;
            enabled = false;
        },
        toggleEnable : function() {
            enabled ? this.disable() : this.enable();
        },
        addAppender : function(/*[key,] appender*/) {
            var _nextId = nextId();
            var key, appender;
            if(arguments.length === 1) {
                key = _nextId;
                appender = arguments[0];
            } else if(arguments.length >= 2) {
                key = arguments[0];
                appender = arguments[1];
            }
            if( typeof appender === "object" && appender.doAppend) {
                if(appenders[key] !== undefined)
                    return;
                callAppender();
                appenders[key] = appender;
                return key;
            }

        },
        setAppenders : function(appenders) {
            appenders = [];
            for(var i = 0, l = appenders.length; i < l; i++) {
                var appender = appenders[i];
                if(appender.appenderKey)
                    this.addAppender(appender.appenderKey, appender.appender);
                else
                    this.addAppender(appender.appender);
            }
        },
        removeAppender : function(key) {
            if(appenders[key] === undefined)
                return false;
            //append immediately before remove
            callAppender(appenders[key]);
            return (
            delete appenders[key]);
        },
        getAppender : function(key) {
            return appenders[key];
        },
        ConsoleAppender : ConsoleAppender,
        DivAppender : DivAppender,
        AjaxAppender : AjaxAppender,
        //[time][level][category]-message [yyyy-MM-ddThh:mm:ss:ms][INFO][function1]-this is a piece of log.
        DefaultLayout : DefaultLayout,
        HTMLLayout : HTMLLayout,
        XMLLayout : XMLLayout,
        JSONLayout : JSONLayout,
        trace : function(message, category) {
            log(Logger.LEVEL.TRACE, category, message);
        },
        debug : function(message, category) {
            log(Logger.LEVEL.DEBUG, category, message);
        },
        info : function(message, category) {
            log(Logger.LEVEL.INFO, category, message);
        },
        warn : function(message, category) {
            log(Logger.LEVEL.WARN, category, message);
        },
        error : function(message, category) {
            log(Logger.LEVEL.ERROR, category, message);
        },
    };
    appenders["[default]"] = new Logger.ConsoleAppender();
    return Logger;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.ClosedShape',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, Drawable) {
	/**
	 * Abstract super class for all closed shapes to subclass. It defines border
	 * style, it cannot be drawn directly.
	 * 
	 * @name sap.riv.graphics.shape.ClosedShape
	 * @class
	 * @augments sap.riv.graphics.Drawable
	 */
	var ClosedShape = ObjectUtils.derive(Drawable, {
		constructor : function() {
			this._bdr = {
				width : 0,
				color : '#000000',
				lineJoin : 'miter',
				miterLimit : 10.0
			};
		},

		/**
		 * Get or set the border width of the closed shape, the border width
		 * should be greater or equal than zero. Setting zero means no border
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderWidth
		 * @function
		 * @param {Number}
		 *            borderWidth the border width
		 * @returns {this|Number}
		 */
		borderWidth : function(borderWidth) {
			if (borderWidth != undefined && borderWidth >= 0) {
				this._bdr.width = borderWidth;
				return this;
			}
			return this._bdr.width;
		},
		/**
		 * Get or set the border color of the closed shape, the default color is
		 * #000000, the color setting should be CSSColor serialized string or as
		 * follow to define gradient
		 * 
		 * <pre>
		 * {
		 *      t: 'lg'|'rg', //line gradient or radial gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderColor
		 * @function
		 * @param {CSSColor|Object}
		 *            borderColor the border color
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		borderColor : function(borderColor) {
			if (borderColor != undefined) {
				this._bdr.color = CanvasHelper.createColorStyle(borderColor);
				return this;
			}
			return this._bdr.color;
		},
		/**
		 * Get or set the border join style of the closed shape, the default
		 * style is miter, the available styles are miter, bevel, round. For
		 * those shapes of which borders do not have pointed join, the setting
		 * will not take effect.
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderJoin
		 * @function
		 * @param {String}
		 *            borderJoinStyle the border join style
		 * @returns {this|String}
		 */
		borderJoin : function(borderJoinStyle) {
			if (borderJoinStyle !== undefined) {
				this._bdr.lineJoin = borderJoinStyle;
				return this;
			}
			return this._bdr.lineJoin;
		},
		/**
		 * Get or set the border miter limit of the closed shape. The value
		 * should be greater than zero.
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderMiterLimit
		 * @function
		 * @param {Number}
		 *            borderMLimit the border miter limit if the join style is
		 *            miter
		 * @returns {this|Number}
		 */
		borderMiterLimit : function(borderMLimit) {
			if (borderMLimit !== undefined && borderMLimit > 0) {
				this._bdr.miterLimit = borderMLimit;
				return this;
			}
			return this._bdr.miterLimit;
		},

		/**
		 * Draw the border around the shape, if the border width is greater than
		 * zero
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#drawBorder
		 * @function
		 * @param drawingContext
		 */
		drawBorder : function(drawingContext) {
			if (this._bdr.width > 0) {
				var b = this._bdr;
				drawingContext.save();
				drawingContext.setStrokeStyle(b.color);
				drawingContext.setLineWidth(b.width || 1.0);
				drawingContext.setLineJoin(b.lineJoin || '#miter');
				if (b.lineJoin === 'miter' && b.miterLimit) {
					drawingContext.setMiterLimit(b.miterLimit);
				}
				drawingContext.stroke();
				drawingContext.restore();
			}
		}
	});
	return ClosedShape;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.ClipRegion',
  version : '1.0.0'
},
function Setup() {
	var clipRegionId = (function() {
		var id = 0;
		return function() {
			return 'cr:' + id++;
		};
	})();
	var ClipRegion = function(regionDef) {
		this._id = clipRegionId();
		this._spths = [];
		switch (regionDef.type) {
		case 'rect':
			var x = regionDef.x, y = regionDef.y, w = regionDef.w, h = regionDef.h;
			var spth = [];
			spth.push({
				pd : 'orig',
				x : x,
				y : y
			});
			spth.push({
				pd : 'lnto',
				x : x + w,
				y : y
			});
			spth.push({
				pd : 'lnto',
				x : x + w,
				y : y + h
			});
			spth.push({
				pd : 'lnto',
				x : x,
				y : y + h
			});
			this._spths.push(spth);
			break;
		case 'path':
			this._spths = regionDef.spths;
			break;
		}
	};

	ClipRegion.prototype.id = function() {
		return this._id;
	};

	ClipRegion.prototype.clip = function(drawingContext) {
		var dCtx = drawingContext;
		dCtx.beginPath();
		for ( var si = 0, sp, sps = this._spths, slen = sps.length; si < slen; si++) {
			sp = sps[si];// sub-path
			for ( var di = 0, d, dlen = sp.length; di < dlen; di++) {
				d = sp[di];
				switch (d.pd) {
				case 'orig':
					dCtx.moveTo(d.x, d.y);
					break;
				case 'lnto':
					dCtx.lineTo(d.x, d.y);
					break;
				case 'spln':
					dCtx.quadraticCurveTo(d.cx, d.cy, d.x, d.y);
					break;
				case 'bcur':
					dCtx.bezierCurveTo(d.c1x, d.c1y, d.c2x, d.c2y, d.x, d.y);
					break;
				case 'arct':
					dCtx.arcTo(d.cx, d.cy, d.x, d.y, d.r);
					break;
				case 'arc':
					dCtx.arc(d.x, d.y, d.r, d.sa, d.ea, !d.cw);
					break;
				}
			}
			dCtx.closePath();
		}
		dCtx.clip();
	};
	return ClipRegion;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * Iterator for LinkedHashMap, to get an iterator for a linkedHashMap
	 * instance, use {@link sap.riv.core.utils.LinkedHashMap#getIterator}
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator
	 * @constructor
	 */
	var lhmItr = function(lhm, reverseOrder) {
		this._lhm = lhm;
		this._reverse = reverseOrder || false;
		this._count = lhm._length;
		this._cursor = this._reverse ? this._lhm._last : this._lhm._head;
		if (this._reverse) {
			this.hasMore = this._hasMoreInReverse;
		} else {
			this.hasMore = this._hasMoreInOrder;
		}
	};

	lhmItr.prototype._hasMoreInOrder = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._head;
			} else {
				this._cursor = this._cursor.next;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};

	lhmItr.prototype._hasMoreInReverse = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._last;
			} else {
				this._cursor = this._cursor.prev;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};
	/**
	 * Find if there is more item to iterate, calling this method will move the
	 * cursor forward to next item
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#hasMore
	 * @function
	 * @returns {Boolean}
	 */
	lhmItr.prototype.hasMore = FuncUtils.noop;

	/**
	 * Get the entry at the current cursor, calling this method without calling
	 * hasMore method will return the same entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#next
	 * @function
	 * @returns {Object} with key & value property indicating the entry's key
	 *          and value object
	 */
	lhmItr.prototype.next = function() {
		var ret = {
			key : this._cursor.key,
			value : this._cursor.value
		};
		return ret;
	};
	/**
	 * Get the value of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#nextValue
	 * @function
	 * @returns {Object}
	 */
	lhmItr.prototype.nextValue = function() {
		return this._cursor.value;
	};
	/**
	 * Get the key of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#nextKey
	 * @function
	 * @returns {String}
	 */
	lhmItr.prototype.nextKey = function() {
		return this._cursor.key;
	};
	/**
	 * Reset the iterator to initial state
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#reset
	 * @function
	 * @returns
	 */
	lhmItr.prototype.reset = function() {
		this._count = this._lhm._length;
	};
	/**
	 * Create an empty LinkedHashMap
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap
	 * @constructor
	 */
	var LinkedHashMap = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	var lhmp = LinkedHashMap.prototype;

	/**
	 * Add one entry, if the key for the entry is already existing, then the old
	 * value will be replaced.
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#add
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @returns {undefined|Object} undefined if key is new, otherwise will be
	 *          the replaced value
	 */
	lhmp.add = function(key, value) {
		var m = this._map;
		var ret = null;
		var node = {
			prev : null,
			key : key,
			value : value,
			next : null
		};
		if (!this._length) {
			this._head = this._last = node;
		}
		if (!m.hasOwnProperty(key)) {
			m[key] = node;
			this._length++;
			node.prev = this._last;
			this._last.next = node;
			this._last = node;
			this._last.next = this._head;
			this._head.prev = this._last;
		} else {
			ret = m[key].value;
			m[key].value = value;
		}
		return ret;
	};
	/**
	 * Add entries from an existing linked hash map, the duplicated entry will
	 * be replaced silently
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#addAll
	 * @function
	 * @param {sap.riv.core.utils.LinkedHashMap}
	 *            linkedHashMap another linkedHashMap to added
	 * @returns
	 */
	lhmp.addAll = function(linkedHashMap) {
		var itr = linkedHashMap.getIterator();
		var entry;
		while (itr.hasMore()) {
			entry = itr.next();
			this.add(entry.key, entry.value);
		}
	};
	/**
	 * Insert the entry before one entry, if the inserted entry exists or the
	 * entry to be inserted before doesn't exist, insertion will fail silently
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#insertBefore
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            beforeKey the key of the entry to be inserted before
	 * @returns {Object} the value inserted
	 */
	lhmp.insertBefore = function(key, value, beforeKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(beforeKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[beforeKey];
			if (anode !== this._head) {
				nnode.prev = anode.prev;
				anode.prev.next = nnode;
			} else {
				this._head = nnode;
				nnode.prev = this._last;
			}
			nnode.next = anode;
			anode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Insert the entry after one entry, if the inserted entry exists or the
	 * entry to be inserted after doesn't exist, insertion will fail silently
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#insertAfter
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            afterKey the key of the entry to be inserted after
	 * @returns {Object} the value inserted
	 */
	lhmp.insertAfter = function(key, value, afterKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(afterKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[afterKey];
			if (anode !== this._last) {
				nnode.next = anode.next;
				anode.next.prev = nnode;
			} else {
				this._last = nnode;
				this._last.next = this._head;
			}
			anode.next = nnode;
			nnode.prev = anode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Replace the existing entry with new entry, including key in place
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#replace
	 * @function
	 * @param {String}
	 *            key the key for the entry to be replaced
	 * @param {withKey}
	 *            withKey the key for the entry to be added
	 * @param {Object}
	 *            andValue the value of the entry to be added
	 * @returns {Object} the value to be replaced
	 */
	lhmp.replace = function(key, withKey, andValue) {
		var m = this._map;
		if (!m.hasOwnProperty(withKey) && m.hasOwnProperty(key)) {
			var nnode = {
				prev : null,
				key : withKey,
				value : andValue,
				next : null
			};
			var rnode = m[key];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			if (this._head === rnode)
				this._head = nnode;
			if (this._last === rnode)
				this._last = nnode;
			m[withKey] = nnode;
			delete m[key];
			return rnode.value;
		}
	};
	/**
	 * Get the value for the key
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#get
	 * @function
	 * @param {String}
	 *            key the key for the entry to get
	 * 
	 * @returns {undefined|Object} the value for the key or undefined if key is
	 *          non-existing
	 */
	lhmp.get = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].value;
		}
		return null;
	};
	/**
	 * Get the first inserted entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#getFirstInsert
	 * @function
	 * 
	 * @returns {Object} the value first inserted
	 */
	lhmp.getFirstInsert = function() {
		return this._head ? this._head.value : null;
	};
	/**
	 * Get the last inserted entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#getLastInsert
	 * @function
	 * 
	 * @returns {Object} the value last inserted
	 */
	lhmp.getLastInsert = function() {
		return this._last ? this._last.value : null;
	};
	/**
	 * Move entry associated with key to the last of the link
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#moveToLast
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 * @returns
	 */
	lhmp.moveToLast = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._last.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.prev = this._last;
			node.next = this._last.next;
			this._last.next = node;
			this._last = node;
			this._head = node.next;
			this._head.prev = node;

		}
	};
	/**
	 * Move entry associated with key to the first of the link
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#moveToFirst
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 * @returns
	 */
	lhmp.moveToFirst = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._head.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = this._head;
			node.prev = this._head.prev;
			this._head.prev = node;
			this._head = node;
			this._last = node.prev;
			this._last.next = node;
		}
	};
	/**
	 * Check whether having the key
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#has
	 * @function
	 * @param {String}
	 *            key the key of the entry to check
	 * @returns {Boolean}
	 */
	lhmp.has = function(key) {
		var m = this._map;
		return m.hasOwnProperty(key);
	};
	/**
	 * Remove the entry associated with the key
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#remove
	 * @function
	 * @param {String}
	 *            key the key of the entry to remove
	 * @returns {undefined|Object} the removed item or undefined if key is
	 *          non-existing
	 */
	lhmp.remove = function(key) {
		var m = this._map;
		var ret;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;
			if (node === this._head) {
				this._head = node.next;
			} else if (node === this._last) {
				this._last = node.prev;
			} else {
				node.prev.next = node.next;
				node.next.prev = node.prev;
			}
			delete m[key];
			this._length--;
			if (this._length === 0) {
				this._head = this._last = undefined;
			}
			return ret;
		}
	};
	/**
	 * Remove all entries added before
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#purgeAll
	 * @function
	 * 
	 * @returns
	 */
	lhmp.purgeAll = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	/**
	 * Whether the map is empty
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	lhmp.isEmpty = function() {
		return this._length == 0;
	};
	/**
	 * Length of the map
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#length
	 * @function
	 * @returns {Integer}
	 */
	lhmp.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the map
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#getIterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.riv.core.utils.LinkedHashMap.Iterator}
	 */
	lhmp.getIterator = function(reverseOrder) {
		return new lhmItr(this, reverseOrder);
	};
	return LinkedHashMap;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.TouchEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Event) {
	/**
	 * Touch List class
	 * 
	 * @name sap.riv.graphics.TouchList
	 * @constructor
	 */
	var TouchList = function() {
		this.tA = [], this.tM = {};
	};
	var tlp = TouchList.prototype;
	tlp._addTouch_ = function(touch) {
		this.tA.push(touch);
		this.tM[touch.identifier()] = touch;
	};
	/**
	 * Return the length of the list
	 * 
	 * @name sap.riv.graphics.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.riv.graphics.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.riv.graphics.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * Touch class
	 * 
	 * @name sap.riv.graphics.Touch
	 * @constructor
	 */
	var Touch = function(identifier, targetLayer, globalXY, pageXY) {
		this._id = identifier;
		this._targetLayer = targetLayer;
		this._localXY = targetLayer.convertPointFromGlobal(globalXY);
		this._pageXY = pageXY;
	};
	/**
	 * Get the identifier of the touch
	 * 
	 * @name sap.riv.graphics.Touch#identifier
	 * @function
	 * @returns {Number}
	 */
	Touch.prototype.identifier = function() {
		return this._id;
	};

	/**
	 * Get the target Layer of the touch
	 * 
	 * @name sap.riv.graphics.Touch#targetLayer
	 * @function
	 * @returns {sap.riv.graphics.Layer}
	 */
	Touch.prototype.targetLayer = function() {
		return this._targetLayer;
	};

	/**
	 * Get the XY of the touch in target layer's coordinates system
	 * 
	 * @name sap.riv.graphics.Touch#localXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	Touch.prototype.localXY = function() {
		return {
			x : this._localXY.x,
			y : this._localXY.y
		};
	};

	/**
	 * Get the XY of the touch in document
	 * 
	 * @name sap.riv.graphics.Touch#pageXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	Touch.prototype.pageXY = function() {
		return {
			x : this._pageXY.x,
			y : this._pageXY.y
		};
	};

	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.riv.graphics.TouchEvent
	 * @class
	 * @augmentssap.riv.graphics.Event
	 */
	var TouchEvent = ObjUtils.derive(Event,
	/**
	 * @lends sap.riv.graphics.TouchEvent
	 * 
	 */
	{
		constructor : function(type, targetLayer, canBubbling, touches, changedTouches, targetTouches) {
			this._relatedTarget = undefined;
			this._touches = touches;
			this._targetTouches = targetTouches;
			this._changedTouches = changedTouches;
		},

		/**
		 * Get the all touches on the screen.
		 * 
		 * @namesap.riv.graphics.TouchEvent#touches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		touches : function() {
			return this._touches;
		},
		/**
		 * Get the touches initiated from the same target
		 * 
		 * @namesap.riv.graphics.TouchEvent#targetTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		targetTouches : function() {
			return this._targetTouches;
		},
		/**
		 * Get the touches lead to the event
		 * 
		 * @namesap.riv.graphics.TouchEvent#changedTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		changedTouches : function() {
			return this._changedTouches;
		}
	});
	TouchEvent.createTouch = function(identifier, targetLayer, globalXY, pageXY) {
		return new Touch(identifier, targetLayer, globalXY, pageXY);
	};
	TouchEvent.createTouchList = function() {
		return new TouchList;
	};
	return TouchEvent;
});sap.riv.module(
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(typeUtils) {
	/**
	 * To utilize observable object, You have to extend your object from it, and
	 * set the 'events' property as Array of event name to the constructor
	 * 
	 * @name sap.riv.core.utils.Observable
	 * @constructor
	 */
	var ob = function(option) {
		this._events = {};
		var cclazz = this.constructor;
		while (cclazz) {
			var events = cclazz.prototype.events, len;
			if (events) {
				len = events.length;
				while (len--) {
					this.addEvents(events[len]);
				}
			}
			cclazz = cclazz.superclazz;
		}
		if (option) {
			if (option.listeners) {
				this.addListeners(option.listeners);
				delete option.listeners;
			}
		}
	};

	var obp = ob.prototype;

	/**
	 * Add events that could be monitored
	 * 
	 * @name sap.riv.core.utils.Observable#addEvents
	 * @function
	 * @parameter {String|String|...} event1,event2,event3... variable length
	 *            arguments of String
	 */
	obp.addEvents = function(/* event1, event2,...,eventn */) {
		var es = this._events, a = arguments, len = arguments.length;
		while (len--) {
			if (typeof a[len] === 'string') {
				es[a[len]] = es[a[len]] || [];
			}
		}
	};
	/**
	 * Get the supported events
	 * 
	 * @name sap.riv.core.utils.Observable#getSupportedEvents
	 * @function
	 * @return {Array} an array of event names
	 */
	obp.getSupportedEvents = function() {
		var ret = [];
		for ( var e in this._events) {
			ret.push(e);
		}
		return ret;
	};
	/**
	 * Add event listeners
	 * 
	 * @name sap.riv.core.utils.Observable#addListeners
	 * @function
	 * @param {Object|[Object]}
	 *            o single event listener or array of event listener
	 * @param {String}
	 *            o.eventName the event to be monitored
	 * @param {Function}
	 *            o.listener the function to be called back when event is fired
	 * @param {Object}
	 *            [o.scope] the scope in which the listener will be executed
	 * @param {Object}
	 *            [o.optionalArgs] the additional arguments that will be passed
	 *            in the listener
	 */
	obp.addListeners = function(o) {
		var ls;
		if (typeUtils.isArray(o)) {
			ls = o;
		} else {
			ls = [ o ];
		}
		var len = ls.length, l, en;
		var es = this._events;
		while (len--) {
			l = ls[len];
			en = l.eventName;
			if (es.hasOwnProperty(en)) {
				var lList = es[en];
				if (!this.isListening(en, l.listener, l.scope)) {
					lList[lList.length] = {
						fn : l.listener,
						scp : l.scope,
						optArgs : l.optionalArgs
					};
				}
			}
		}
		return this;
	};

	/**
	 * Find the listener that registered before
	 * 
	 * @name sap.riv.core.utils.Observable#findListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * 
	 * 
	 * @returns {-1|Integer} returning -1 means not found otherwise return the
	 *          position order in which the listener to be invoked
	 */
	obp.findListener = function(eventName, fn, scope) {
		var es = this._events;
		if (!es.hasOwnProperty(eventName)) {
			return -1;
		}
		var lList = es[eventName], len = lList.length, lis;
		while (len--) {
			lis = lList[len];
			if (scope) {
				if (lis.fn == fn && lis.scp == scope) {
					return len;
				}
			} else {
				if (lis.fn == fn) {
					return len;
				}
			}
		}
		return -1;
	};
	/**
	 * Check whether the listener is listening on the event
	 * 
	 * @name sap.riv.core.utils.Observable#isListening
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {Boolean}
	 */
	obp.isListening = function(eventName, fn, scope) {
		return this.findListener(eventName, fn, scope) > -1;
	};

	/**
	 * Remove the previous registered listener listening on the given event
	 * 
	 * @name sap.riv.core.utils.Observable#removeListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {this} return the observable object itself
	 */
	obp.removeListener = function(eventName, fn, scope) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName];
			var len = lList.length, idx;
			while (len--) {
				idx = this.findListener(eventName, fn, scope);
				if (idx > -1) {
					lList.splice(idx, 1);
					len = lList.length;
				}
			}
		}
		return this;
	};

	/**
	 * Remove all the listeners currently watching the event
	 * 
	 * @name sap.riv.core.utils.Observable#removeAllListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {this} return the observable object itself
	 */
	obp.removeAllListeners = function(eventName) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			es[eventName] = [];
		}
		return this;
	};
	/**
	 * Check whether there is any listener watching the event
	 * 
	 * @name sap.riv.core.utils.Observable#hasListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.hasListener = function(eventName) {
		return this._events[eventName] && this._events[eventName].length > 0;
	};

	/**
	 * Purge all listeners registered on the observable object
	 * 
	 * @name sap.riv.core.utils.Observable#purgeListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.purgeListeners = function() {
		var es = this._events;
		for ( var e in es) {
			es[e] = [];
		}
	};

	/**
	 * Fire a event, with optional details attached
	 * 
	 * @name sap.riv.core.utils.Observable#fireEvent
	 * @function
	 * @param {String}
	 *            eventName name of the event to be fired
	 * @param {Object}
	 *            details variable length arguments,var1, var2..varn, the
	 *            details to be passed in each listener call.
	 */
	obp.fireEvent = function(eventName /* details */) {
		var details = Array.prototype.slice.call(arguments, 1);
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName], l;
			for ( var i = 0, len = lList.length; i < len; i++) {
				l = lList[i];
				if (l.optArgs) {
					details.push(l.optArgs);
				}
				l.fn.apply(l.scp || this || window, details);
			}
		}
	};

	/**
	 * Same as addListeners
	 * 
	 * @name sap.riv.core.utils.Observable#on
	 * @function
	 * @see sap.riv.core.utils.Observable#addListeners
	 */
	obp.on = obp.addListeners;
	/**
	 * Same as removeListener
	 * 
	 * @name sap.riv.core.utils.Observable#un
	 * @function
	 * @see sap.riv.core.utils.Observable#removeListener
	 */
	obp.un = obp.removeListener;
	return ob;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.ClipRegion',
  version : '1.0.0'
}
],
function Setup(Observable, ObjUtils, LinkedHashMap, TmHelper, CanvasHelper, ClipRegion) {
	var id = 0;
	var nextId = function() {
		return id++;
	};
	var Layer = ObjUtils.derive(Observable,
	/**
	 * @lends sap.riv.graphics.Layer
	 * 
	 */
	{
		events : [ 'contentUpdate', 'focusin', 'focusout', 'focus', 'blur', 'mouseenter', 'mouseleave', 'mousemove',
				'mousedown', 'mouseup', 'click', 'dblclick', 'touchstart', 'touchmove', 'touchend', 'touchcancel' ],
		/**
		 * @constructs
		 * @param {Object}
		 *            options the options to initialize the layer
		 * 
		 * @param {String}
		 *            [options.bgColor] the background color of the layer
		 * 
		 * @param {Object}
		 *            [options.anchor] the anchor point of the layer, default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0.5,
		 * 	y : 0.5
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.position] the position of the layer, default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0,
		 * 	y : 0
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.size] the size of layer, default is
		 * 
		 * <pre>
		 * {
		 * 	w : 0,
		 * 	h : 0
		 * }
		 * </pre>
		 */
		constructor : function(options) {
			options = options || {};
			this._id = nextId();
			this._superLayer = undefined;

			// content clip region state
			this._currentClipRegion = undefined;

			this._clipRegions = {};
			this._shape2clip = {};
			this._clip2shapes = {};
			this._content = new LinkedHashMap();

			// event related
			this._listenOnLayer = {};

			this._subLayers = new LinkedHashMap();
			this._bgColor = options.bgColor || undefined;
			this._opacity = 1.0;
			this._hidden = false;
			this._clipToBounds = false;
			this._shouldRasterized = false;
			this._rasterized = false;
			this._bitmapCache = CanvasHelper.createCanvasElement(1, 1);
			this._bounds = {
				x : 0,
				y : 0,
				width : 0,
				height : 0
			};
			this._position = {
				x : 0,
				y : 0
			};
			this._anchorPoint = {
				x : 0.5,
				y : 0.5
			};
			this._transform = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
			this._calcMatrix = {
				m : undefined,
				i : undefined
			};
			this._init(options);
		},

		_init : function(options) {
			if (options.size && options.position) {
				this._position.x = options.position.x;
				this._position.y = options.position.y;
			}
			if (options.size) {
				this._bounds.width = options.size.w;
				this._bounds.height = options.size.h;
				this._updateBitmapCache();
			}
			if (options.anchor) {
				this._anchorPoint.x = options.anchor.x;
				this._anchorPoint.y = options.anchor.y;
			}
			this._updateCalcMatrix();
		},

		_updateCalcMatrix : function() {
			this._calcMatrix.m = TmHelper.makeTranslateTM(-this._anchorPoint.x * this._bounds.width,
					-this._anchorPoint.y * this._bounds.height, TmHelper.makeCustomTM(this._transform, TmHelper
							.makeTranslateTM(this._position.x, this._position.y)));
			this._calcMatrix.i = TmHelper.makeTranslateInvertTM(-this._anchorPoint.x * this._bounds.width,
					-this._anchorPoint.y * this._bounds.height, TmHelper.makeCustomInvertTM(this._transform, TmHelper
							.makeTranslateInvertTM(this._position.x, this._position.y)));
		},
		/**
		 * Get the id of the layer
		 * 
		 * @name sap.riv.graphics.Layer#id
		 * @function
		 * @returns {String} the unique id of the component
		 */
		id : function() {
			return this._id;
		},
		/**
		 * Get and set whether the layer should be rasterized for drawing
		 * performance boost
		 * 
		 * @name sap.riv.graphics.Layer#shouldRasterized
		 * @function
		 * @param {Boolean}
		 *            [should]
		 * @returns {this|Boolean}
		 */
		shouldRasterized : function(should) {
			if (should !== undefined) {
				this._shouldRasterized = should;
				this._rasterized = false;
				this._updateBitmapCache();
				return this;
			} else {
				return this._shouldRasterized;
			}
		},

		/**
		 * Get and set whether the layer should be hided
		 * 
		 * @name sap.riv.graphics.Layer#hidden
		 * @function
		 * @param {Boolean}
		 *            [hidden]
		 * @returns {this|Boolean}
		 */
		hidden : function(hidden) {
			if (hidden !== undefined) {
				if (this._hidden !== hidden) {
					this._hidden = hidden;
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._hidden;
			}
		},

		/**
		 * Get and set the opacity of the layer
		 * 
		 * @name sap.riv.graphics.Layer#opacity
		 * @function
		 * @param {Number}
		 *            [opacity]
		 * @returns {this|Number}
		 */
		opacity : function(opacity) {
			if (opacity !== undefined) {
				if (opacity >= 0 && opacity <= 1.0 && opacity != this._opacity) {
					this._opacity = opacity;
					this._rasterized = false;
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._opacity;
			}
		},

		/**
		 * Get and set the background color of the layer
		 * 
		 * @name sap.riv.graphics.Layer#backgroundColor
		 * @function
		 * @param {String|Boolean}
		 *            [bgColor] CSS color string, false means clear background
		 *            color
		 * @returns {this|String}
		 */
		backgroundColor : function(bgColor) {
			if (bgColor !== undefined) {
				if (bgColor === false) {
					this._bgColor = undefined;
				} else {
					if (this._bgColor !== bgColor) {
						this._bgColor = bgColor;
						this._rasterized = false;
						this.fireEvent('contentUpdate');
					}
				}
				return this;
			} else {
				return this._bgColor;
			}
		},

		/**
		 * Get and set the bounds of the layer
		 * 
		 * @name sap.riv.graphics.Layer#bounds
		 * @function
		 * @param {undefined|Object}
		 *            bounds the new bounds of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		bounds : function(bounds) {
			if (bounds) {
				var ob = this._bounds, nb = bounds;
				if (ob.x !== nb.x || ob.y !== nb.y || ob.width !== nb.width || ob.height !== nb.height) {
					ob.x = nb.x;
					ob.y = nb.y;
					ob.width = nb.width;
					ob.height = nb.height;
					this._rasterized = false;
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				var b = this._bounds;
				return {
					x : b.x,
					y : b.y,
					width : b.width,
					height : b.height
				};
			}
		},
		/**
		 * Get and set the size of the layer
		 * 
		 * @name sap.riv.graphics.Layer#size
		 * @function
		 * @param {undefined|Object}
		 *            size the new size of the layer:
		 * 
		 * <pre>
		 * {
		 *      width : ##,
		 *      height : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object}
		 */
		size : function(size) {
			if (size) {
				var os = {
					width : this._bounds.width,
					height : this._bounds.height
				};
				if (os.width !== size.width || os.height !== size.height) {
					this._bounds.width = size.width;
					this._bounds.height = size.height;
					this._rasterized = false;
					this._updateCalcMatrix();
					this._updateBitmapCache();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return {
					width : this._bounds.width,
					height : this._bounds.height
				};
			}
		},
		/**
		 * Get and set the width of the layer
		 * 
		 * @name sap.riv.graphics.Layer#width
		 * @function
		 * @param {undefined|Number}
		 *            width the new width of the layer:
		 * 
		 * 
		 * @returns {this|Number}
		 */
		width : function(width) {
			if (width) {
				var ow = this._bounds.width;
				if (ow !== width) {
					this._bounds.width = width;
					this._rasterized = false;
					this._updateCalcMatrix();
					this._updateBitmapCache();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._bounds.width;
			}
		},
		/**
		 * Get and set the height of the layer
		 * 
		 * @name sap.riv.graphics.Layer#height
		 * @function
		 * @param {undefined|Number}
		 *            width the new height of the layer:
		 * 
		 * 
		 * @returns {this|Number}
		 */
		height : function(height) {
			if (height) {
				var oh = this._bounds.height;
				if (oh !== height) {
					this._bounds.height = height;
					this._rasterized = false;
					this._updateCalcMatrix();
					this._updateBitmapCache();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._bounds.height;
			}
		},

		/**
		 * Get and set the position of the layer
		 * 
		 * @name sap.riv.graphics.Layer#position
		 * @function
		 * @param {undefined|Object}
		 *            position the new position of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		position : function(position) {
			if (position) {
				var op = this._position, np = position;
				if (op.x !== np.x || op.y !== np.y) {
					op.x = np.x;
					op.y = np.y;
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return {
					x : this._position.x,
					y : this._position.y
				};
			}
		},

		/**
		 * Get and set the anchor of the layer
		 * 
		 * @name sap.riv.graphics.Layer#anchorPoint
		 * @function
		 * @param {undefined|Object}
		 *            anchorPoint the new anchor of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		anchorPoint : function(anchorPoint) {
			if (anchorPoint) {
				var oap = this._anchorPoint, nap = anchorPoint;
				if (oap.x !== nap.x || oap.y !== nap.y) {
					oap.x = nap.x;
					oap.y = nap.y;
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				var oap = this._anchorPoint;
				return {
					x : oap.x,
					y : oap.y
				};

			}
		},
		/**
		 * Get and set the frame of the layer
		 * 
		 * @name sap.riv.graphics.Layer#frame
		 * @function
		 * @param {undefined|Object}
		 *            rect the new frame of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		frame : function(rect) {
			if (rect) {
				// TODO set the layer's geometry according to
				// frame
				this._bounds.width = rect.width;
				this._bounds.height = rect.height;
				this._position.x = rect.x + this._bounds.width * this._anchorPoint.x;
				this._position.y = rect.y + this._bounds.height * this._anchorPoint.y;
				this._rasterized = false;
				this._updateCalcMatrix();
				this._updateBitmapCache();
				this.fireEvent('contentUpdate');
				return this;
			} else {
				return TmHelper.rectApplyTransform({
					x : 0,
					y : 0,
					width : this._bounds.width,
					height : this._bounds.height
				}, this._calcMatrix.m);
			}
		},

		/**
		 * Get and set the transformation to the layer
		 * 
		 * @name sap.riv.graphics.Layer#affineTransform
		 * @function
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            transform the new transformation to layer:
		 * 
		 * @returns {this|[[a,c,e],[b,d,f],[0,0,1]]}
		 */
		affineTransform : function(transform) {
			var t = this._transform;
			if (transform) {
				if (TmHelper.isValidAffineTransform(transform) || !TmHelper.isEqualTransform(t, transform)) {
					t[0][0] = transform[0][0];
					t[1][0] = transform[1][0];
					t[0][1] = transform[0][1];
					t[1][1] = transform[1][1];
					t[0][2] = transform[0][2];
					t[1][2] = transform[1][2];
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return [ [ t[0][0], t[0][1], t[0][2] ], [ t[1][0], t[1][1], t[1][2] ], [ 0, 0, 1 ] ];
			}
		},

		/**
		 * Get and set the transformation to the layer
		 * 
		 * @name sap.riv.graphics.Layer#affineTransform
		 * @function
		 * @param {Boolean}
		 *            transform the new transformation to layer
		 * 
		 * @returns {this|Boolean}
		 */
		clipToBounds : function(clipToBounds) {
			if (clipToBounds !== undefined) {
				if (this._clipToBounds != clipToBounds) {
					this._clipToBounds = clipToBounds;
					this.fireEvent('contentUpdate');
				} else {
					this._clipToBounds = clipToBounds;
				}
				return this;
			}
			return this._clipToBounds;
		},

		_setSuperLayer : function(superLayer) {
			this._superLayer = superLayer;
		},

		_removeSubLayer : function(subLayer) {
			if (subLayer && this._subLayers.has(subLayer.id())) {
				subLayer.removeAllListeners('contentUpdate');
				this._subLayers.remove(subLayer.id());
				this.fireEvent('contentUpdate');
			}
		},

		_updateBitmapCache : function() {
			if (this._shouldRasterized) {
				this._bitmapCache.width(this._bounds.width);
				this._bitmapCache.height(this._bounds.height);
			}
		},

		_getBitmapCache_ : function(reset) {
			if (reset) {
				this._updateBitmapCache();
			}
			return this._bitmapCache;
		},

		_rasterized_ : function(rasterized) {
			if (rasterized !== undefined) {
				this._rasterized = rasterized;
			} else {
				return this._rasterized;
			}
		},
		/**
		 * Does this layer have any shape content
		 * 
		 * @name sap.riv.graphics.Layer#hasContent
		 * @function
		 * 
		 * @returns {this|Boolean}
		 */
		hasContent : function() {
			return !this._content.isEmpty();
		},
		/**
		 * Add a shape onto the layer
		 * 
		 * @name sap.riv.graphics.Layer#addShape
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shapeObj the shape to be added
		 * @returns {sap.riv.graphics.Drawable} the concrete shape subclassing
		 *          {@link sap.riv.graphics.Drawable}
		 */
		addShape : function(shapeObj) {
			var shapeId = shapeObj.id();
			this._content.add(shapeId, shapeObj);
			this._rasterized = false;
			this.fireEvent('contentUpdate');
			return shapeObj;
		},
		/**
		 * Insert a shape into the layer after existing shape, so it will be
		 * drawn on top of it
		 * 
		 * @name sap.riv.graphics.Layer#insertShapeAfter
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            insertedShape the shape to be inserted
		 * @param {sap.riv.graphics.Drawable}
		 *            afterShape the existing shape on the layer inserted after
		 * @returns {sap.riv.graphics.Drawable} the concrete shape subclassing
		 *          {@link sap.riv.graphics.Drawable}
		 */
		insertShapeAfter : function(insertedShape, afterShape) {
			if (insertedShape && this._content.has(afterShape.id())) {
				var shapeId = insertedShape.id();
				this._content.insertAfter(shapeId, insertedShape, afterShape.id());
				this._rasterized = false;
				this.fireEvent('contentUpdate');
				return insertedShape;
			}
		},
		/**
		 * Insert a shape into the layer before existing shape, so it will be
		 * drawn on top of it
		 * 
		 * @name sap.riv.graphics.Layer#insertShapeBefore
		 * @function
		 * @param {String}
		 *            insertedShape the shape to be inserted
		 * @param {sap.riv.graphics.Drawable}
		 *            afterShape the existing shape on the layer inserted before
		 * @returns {sap.riv.graphics.Drawable} the concrete shape subclassing
		 *          {@link sap.riv.graphics.Drawable}
		 */
		insertShapeBefore : function(insertedShape, beforeShape) {
			if (insertedShape && this._content.has(beforeShape.id())) {
				var shapeId = insertedShape.id();
				this._content.insertBefore(shapeId, insertedShape, beforeShape.id());
				this._rasterized = false;
				this.fireEvent('contentUpdate');
				return insertedShape;
			}
		},

		/**
		 * Remove an existing shape from the layer
		 * 
		 * @name sap.riv.graphics.Layer#removeShape
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be removed
		 * 
		 */
		removeShape : function(shape) {
			if (shape) {
				var shapeId = shape.id();
				var removed = this._content.remove(shapeId);
				if (removed) {
					if (this._shape2clip.hasOwnProperty(shapeId)) {
						var clipId = this._shape2clip[shapeId];
						delete this._clip2shapes[clipId][shapeId];
						delete this._shape2clip[shapeId];
					}
					this._rasterized = false;
					this.fireEvent('contentUpdate');
				}
			}
		},
		/**
		 * Replace an existing shape with another shape, the replacing shape
		 * will have a different id other than the replaced shape
		 * 
		 * @name sap.riv.graphics.Layer#replaceShape
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be replaced
		 * @param {sap.riv.graphics.Drawable}
		 *            widthShapeType the shape to be added
		 * @return {sap.riv.graphics.Drawable} the replacing shape instance
		 */
		replaceShape : function(shape, withShape) {
			if (withShape && this._content.has(shape.id())) {
				var shapeId = withShape.id();
				this._content.replace(shape.id(), shapeId, withShape);
				if (this._shape2clip.hasOwnProperty(shape.id())) {
					var clipId = this._shape2clip[shape.id()];
					delete this._clip2shapes[clipId][shape.id()];
					this._clip2shapes[clipId][shapeId] = shapeId;
					delete this._shape2clip[shape.id()];
					this._shape2clip[shapeId] = clipId;
				}
				this._rasterized = false;
				this.fireEvent('contentUpdate');
				return withShape;
			}
		},

		/**
		 * Add clip region to the layer
		 * 
		 * @name sap.riv.graphics.Layer#addClipRegion
		 * @function
		 * @param {Object}
		 *            closedPath the clip region boundary definition
		 * @returns {String} the id of the clip region
		 * 
		 */
		addClipRegion : function(closedPath) {
			var newCr = new ClipRegion(closedPath);
			var id = newCr.id();
			this._clipRegions[id] = newCr;
			this._clip2shapes[id] = [];
			return id;
		},
		/**
		 * Assign the clip region to a shape
		 * 
		 * @name sap.riv.graphics.Layer#setClipRegion
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be applied clip
		 * @param {String}
		 *            clipRegionId the id of the clip region
		 * 
		 */
		setClipRegion : function(shape, clipRegionId) {
			if (this._clipRegions.hasOwnProperty(clipRegionId) && this._content.has(shape.id())) {
				if (this._shape2clip.hasOwnProperty(shape.id())) {
					var prevClipId = this._shape2clip[shape.id()];
					delete this._clip2shapes[prevClipId][shape.id()];
				}
				this._shape2clip[shape.id()] = clipRegionId;
				this._clip2shapes[clipRegionId][shape.id()] = shape.id();
				this._rasterized = false;
				this.fireEvent('contentUpdate');
			}
		},
		/**
		 * Remove the clip region from a shape
		 * 
		 * @name sap.riv.graphics.Layer#clearClipRegion
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to clear clip setting
		 * 
		 */
		clearClipRegion : function(shape) {
			var shapeId = shape.id();
			if (this._shape2clip.hasOwnProperty(shapeId)) {
				var crid = this._shape2clip[shapeId];
				delete this._shape2clip[shapeId];
				delete this._clip2shapes[crid][shapeId];
				this._rasterized = false;
				this.fireEvent('contentUpdate');
			}
		},
		/**
		 * Remove the clip region from layer
		 * 
		 * @name sap.riv.graphics.Layer#removeClipRegion
		 * @function
		 * @param {String}
		 *            clipRegionId the id of the clip region
		 * 
		 */
		removeClipRegion : function(clipRegionId) {
			var clipRegs = this._clipRegions;
			if (clipRegs.hasOwnProperty(clipRegionId)) {
				var s2c = this._shape2clip;
				var c2s = this._clip2shapes;
				var needUpdate = false;
				for ( var i = 0, cshapes = c2s[clipRegionId], len = cshapes.length; i < len; i++) {
					delete s2c[cshapes[i]];
					needUpdate = true;
				}
				delete c2s[clipRegionId];
				delete clipRegs[clipRegionId];
				if (needUpdate) {
					this._rasterized = false;
					this.fireEvent('contentUpdate');
				}
			}
		},
		/**
		 * Clear the content of the layer
		 * 
		 * @name sap.riv.graphics.Layer#clearContent
		 * @function
		 */
		clearContent : function() {
			this._clipRegions = {};
			this._shape2clip = {};
			this._clip2shapes = {};
			this._content.purgeAll();
			this._rasterized = false;
			this.fireEvent('contentUpdate');
		},
		/**
		 * Get parent layer
		 * 
		 * @name sap.riv.graphics.Layer#superLayer
		 * @function
		 * @returns {sap.riv.graphics.Layer}
		 */
		superLayer : function() {
			return this._superLayer;
		},
		/**
		 * Get the iterator of the sublayers, you can specify the iteration
		 * order in insertion order or reversion of insertion order.
		 * 
		 * @name sap.riv.graphics.Layer#subLayersIterator
		 * @function
		 * @param {Boolean}
		 *            invert invert the iteration
		 * @returns {sap.riv.core.utils.LinkedHashMap.Iterator}
		 */
		subLayersIterator : function(invert) {
			return this._subLayers.getIterator(invert);
		},
		/**
		 * Add one layer as its sublayer
		 * 
		 * @name sap.riv.graphics.Layer#addSubLayer
		 * @function
		 * @param {sap.riv.graphics.Layer}
		 *            subLayer
		 */
		addSubLayer : function(subLayer) {
			if (subLayer) {
				if (!this._subLayers.has(subLayer.id())) {
					this._subLayers.add(subLayer.id(), subLayer);
					// TODO - add listener to propagate the
					// event
					subLayer.on({
						eventName : 'contentUpdate',
						listener : function(layer) {
							this.fireEvent('contentUpdate');
						},
						scope : this,
						optionalArgs : subLayer
					});
					subLayer._setSuperLayer(this);
					this.fireEvent('contentUpdate');
				}
			}
		},
		/**
		 * Remove self from its parent layer
		 * 
		 * @name sap.riv.graphics.Layer#removeFromSuperLayer
		 * @function
		 */
		removeFromSuperLayer : function() {
			if (this._superLayer) {
				this._superLayer._removeSubLayer(this);
				this._superLayer = undefined;
				this.fireEvent('contentUpdate');
			}
		},

		/**
		 * Replace given subLayer with another sublayer
		 * 
		 * @name sap.riv.graphics.Layer#replaceSubLayer
		 * @function
		 * @param {sap.riv.graphics.Layer}
		 *            subLayer sublayer to be replaced
		 * @param {sap.riv.graphics.Layer}
		 *            withSubLayer sublayer to replace the other
		 */
		replaceSubLayer : function(subLayer, withSubLayer) {
			if (subLayer.id() !== withSubLayer.id()) {
				this._subLayers.replace(subLayer.id(), withSubLayer.id(), withSubLayer);
				subLayer.removeAllListeners('contentUpdate');
				withSubLayer.on({
					eventName : 'contentUpdate',
					listener : function(layer) {
						this.fireEvent('contentUpdate');
					},
					scope : this,
					optionalArgs : subLayer
				});
				subLayer._setSuperLayer(undefined);
				withSubLayer._setSuperLayer(this);
				this.fireEvent('contentUpdate');
			}
		},

		/**
		 * Set a flag that indicates the current layer needs to be refresh
		 * display. This method is typically called after your finish editing
		 * the layer's content.
		 * 
		 * @name sap.riv.graphics.Layer#setNeedsDisplay
		 * @function
		 */
		setNeedsDisplay : function() {
			this._rasterized = false;
			this.fireEvent('contentUpdate');
		},

		drawContent : function(drawingContext) {
			drawingContext.save();
			drawingContext.beginPath();
			drawingContext.rect(0, 0, this._bounds.width, this._bounds.height);
			drawingContext.closePath();
			drawingContext.clip();
			// layer's content should never exceed the layer's
			// boundary
			if (this._bgColor !== undefined) {
				drawingContext.setFillStyle(this._bgColor);
				drawingContext.fillRect(0, 0, this._bounds.width, this._bounds.height);
			}
			drawingContext.translate(-this._bounds.x, -this._bounds.y);
			var itr = this._content.getIterator(), s, sid, p;
			var cr = this._clipRegions, s2c = this._shape2clip, clipId;
			while (itr.hasMore()) {
				p = itr.next();
				s = p.value;
				sid = p.key;
				if (s2c.hasOwnProperty(sid)) {
					if (this._currentClipRegion !== undefined) {
						drawingContext.restore();
					}
					clipId = s2c[sid];
					drawingContext.save();
					this._currentClipRegion = clipId;
					cr[clipId].clip(drawingContext);
				} else if (this._currentClipRegion !== undefined) {
					this._currentClipRegion = undefined;
					drawingContext.restore();
				}

				drawingContext.save();
				s.drawTo(drawingContext);
				drawingContext.restore();
			}
			if (this._currentClipRegion !== undefined) {
				this._currentClipRegion = undefined;
				drawingContext.restore();
			}
			drawingContext.restore();
			this._needsDisplay = false;
		},

		/**
		 * Test whether the given local point(point in local coordinate system)
		 * is in the given shape on the layer
		 * 
		 * @name sap.riv.graphics.Layer#shapeContainsPoint
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be tested
		 * @param {Object}
		 *            localPoint the point to test
		 * @returns {Boolean}
		 */
		shapeContainsPoint : function(shape, localPoint) {
			if (shape && this._content.has(shape.id())) {
				return this._content.get(shape.id()).pointIn(localPoint);
			}
			return false;
		},

		/**
		 * Return the top most shape under the local point in the layer
		 * 
		 * @name sap.riv.graphics.Layer#hittedShape
		 * @function
		 * @param {Object}
		 *            localPoint the point to test
		 * @returns {sap.riv.graphics.Drawable}
		 */
		hittedShape : function(localPoint) {
			var itr = this._content.getIterator(true);
			while (itr.hasMore()) {
				if (itr.next().value.pointIn(localPoint)) {
					return itr.next().value;
				}
			}
		},
		/**
		 * Test whether the given local point(point in local coordinate system)
		 * is contained in the layer's boundary
		 * 
		 * @name sap.riv.graphics.Layer#containsPoint
		 * @function
		 * @param {Object}
		 *            localPoint the point to test
		 * @returns {Boolean}
		 */
		containsPoint : function(localPoint) {
			var bounds = this.bounds();
			return localPoint.x >= bounds.x && localPoint.x <= (bounds.x + bounds.width) && localPoint.y >= bounds.y
					&& localPoint.y <= (bounds.y + bounds.height);
		},
		/**
		 * Convert the point in super layer's coordinate system to local point
		 * 
		 * @name sap.riv.graphics.Layer#convertPointFromSuperLayer
		 * @function
		 * @param {Object}
		 *            pointInSuperLayer
		 * @returns {Object}
		 */
		convertPointFromSuperLayer : function(pointInSuperLayer) {
			var itm = this._calcMatrix.i;
			return {
				x : itm[0][0] * pointInSuperLayer.x + itm[0][1] * pointInSuperLayer.y + itm[0][2],
				y : itm[1][0] * pointInSuperLayer.x + itm[1][1] * pointInSuperLayer.y + itm[1][2]
			};
		},
		/**
		 * Convert the point in global coordinate system to local point
		 * 
		 * @name sap.riv.graphics.Layer#convertPointFromGlobal
		 * @function
		 * @param {Object}
		 *            globalPoint
		 * @returns {Object}
		 */
		convertPointFromGlobal : function(globalPoint) {
			var superLayerPath = [ this ];
			var currentLevel = this;
			var pointInProgress = globalPoint;
			while (currentLevel._superLayer) {
				superLayerPath.push(currentLevel._superLayer);
				currentLevel = currentLevel._superLayer;
			}
			while (superLayerPath.length) {
				currentLevel = superLayerPath.pop();
				pointInProgress = currentLevel.convertPointFromSuperLayer(pointInProgress);
			}
			return pointInProgress;
		},

		/**
		 * Convert the point in source layer's coordinate system to local
		 * coordinate system. Two layers should be in the one layer hierarchy.
		 * 
		 * @name sap.riv.graphics.Layer#convertPointFromLayer
		 * @function
		 * @param {POINT}
		 *            pointInSourceLayer
		 * @param {sap.riv.graphics.Layer}
		 *            sourceLayer
		 * @returns {POINT}
		 */
		convertPointFromLayer : function(pointInSourceLayer, sourceLayer) {
			return this.convertPointFromGlobal(sourceLayer.convertPointToGlobal(pointInSourceLayer));
		},
		/**
		 * Convert local point to point in super layer's coordinates system
		 * 
		 * @name sap.riv.graphics.Layer#convertPointToSuperLayer
		 * @function
		 * @param {Object}
		 *            pointInLocal
		 * @returns {Object}
		 */
		convertPointToSuperLayer : function(pointInLocal) {
			var tm = this._calcMatrix.m;
			return {
				x : tm[0][0] * pointInLocal.x + tm[0][1] * pointInLocal.y + tm[0][2],
				y : tm[1][0] * pointInLocal.x + tm[1][1] * pointInLocal.y + tm[1][2]
			};
		},

		/**
		 * Convert local point to point in global coordinates system
		 * 
		 * @name sap.riv.graphics.Layer#convertPointToGlobal
		 * @function
		 * @param {Object}
		 *            pointInLocal
		 * @returns {Object}
		 */
		convertPointToGlobal : function(pointInLocal) {
			var currentLevel = this;
			var pointInProgress = pointInLocal;
			while (currentLevel) {
				pointInProgress = currentLevel.convertPointToSuperLayer(pointInProgress);
				currentLevel = currentLevel._superLayer;
			}
			return pointInProgress;
		},
		/**
		 * Convert the point to target layer's coordinate system. Two layers
		 * should be in the one layer hierarchy.
		 * 
		 * @name sap.riv.graphics.Layer#convertPointToLayer
		 * @function
		 * @param {POINT}
		 *            pointInLocal
		 * @param {sap.riv.graphics.Layer}
		 *            targetLayer
		 * @returns {POINT}
		 */
		convertPointToLayer : function(pointInLocal, targetLayer) {
			return targetLayer.convertPointFromGlobal(this.convertPointToGlobal(pointInLocal));
		},

		/**
		 * Returns the farthest descendant layer in the hierarchy rooted at this
		 * layer, that contains the specified point.
		 * 
		 * @name sap.riv.graphics.Layer#hitTest
		 * @param {POINT}
		 *            localXY
		 * @returns {sap.riv.graphics.Layer}
		 */
		hitTest : function(localXY) {
			var pStack = [ {
				layer : this,
				pointInLocal : localXY,
				subLayerItr : this.subLayersIterator(true)
			} ];
			var levelInTest, localPoint, layer, subLayerItr;
			while (pStack.length) {
				levelInTest = pStack[pStack.length - 1];
				layer = levelInTest.layer;
				localPoint = levelInTest.pointInLocal;
				subLayerItr = levelInTest.subLayerItr;
				if (!layer.hidden()) {
					if (subLayerItr.hasMore()) {
						var subLayer = subLayerItr.next().value;
						pStack.push({
							layer : subLayer,
							pointInLocal : subLayer.convertPointFromSuperLayer(localPoint),
							subLayerItr : subLayer.subLayersIterator(true)
						});
						continue;
					} else if (layer.containsPoint(localPoint)) {
						// find the top layer which contains the
						// point and can
						// respond to event
						return layer;
					}
					pStack.pop();
				} else {
					pStack.pop();
				}
			}
		},

		_fireEvent_ : function(event) {
			this.fireEvent(event.type(), event);
			if (this._superLayer && event.shouldBubble()) {
				event._setCurrentLayer_(this._superLayer);
				this._superLayer._fireEvent_(event);
			}
		},

		_fireMouseEvent_ : function(event) {
			this.fireEvent(event.type(), event);
			if (this._superLayer && event.shouldBubble()) {
				event._setCurrentLayer_(this._superLayer);
				event._setCurrentLocalXY_(this.convertPointToSuperLayer(event.currentLocalXY()));
				this._superLayer._fireMouseEvent_(event);
			}
		},

		_fireTouchEvent_ : function(event) {
			this.fireEvent(event.type(), event);
			if (this._superLayer && event.shouldBubble()) {
				event._setCurrentLayer_(this._superLayer);
				this._superLayer._fireTouchEvent_(event);
			}
		}
	});
	return Layer;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Canvas2DSurface',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.MouseEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.TouchEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Layer, Event, MouseEvent, TouchEvent, Math, LOG) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var compositingTaskRunner = (function() {
		return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame
				|| window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.setTimeout;
	})();

	var compositor = function(dCtx, layer) {
		// Processing stack keep the current traversing state of each level
		var pStack = [ {
			processed : false,
			layer : layer,
			subLayerItr : layer.subLayersIterator()
		} ];
		var tStat, layer;// traverse state
		while (pStack.length) {
			tStat = pStack[pStack.length - 1];
			layer = tStat.layer;
			if (!layer.hidden()) {
				if (!tStat.processed) {
					if (layer.shouldRasterized()) {
						if (!layer._rasterized_()) {
							var cacheDCxt = layer._getBitmapCache_(true).getContext('2d');
							layer.drawContent(cacheDCxt);
							layer._rasterized_(true);
						}
						dCtx.save();
						// Process cLayer if haven't been processed yet.
						var layerPos = layer.position();
						var layerAnchorP = layer.anchorPoint();
						var layerAFTransfrom = layer.affineTransform();
						var layerBounds = layer.bounds();
						dCtx.translate(layerPos.x, layerPos.y);
						dCtx.transform(layerAFTransfrom[0][0], layerAFTransfrom[1][0], layerAFTransfrom[0][1],
								layerAFTransfrom[1][1], layerAFTransfrom[0][2], layerAFTransfrom[1][2]);
						dCtx.translate(-layerAnchorP.x * layerBounds.width, -layerAnchorP.y * layerBounds.height);
						dCtx.setAlpha(layer.opacity());
						dCtx.drawImage(layer._getBitmapCache_(), 0, 0);
					} else {
						dCtx.save();
						// Process cLayer if haven't been processed yet.
						var layerPos = layer.position();
						var layerAnchorP = layer.anchorPoint();
						var layerAFTransfrom = layer.affineTransform();
						var layerBounds = layer.bounds();
						dCtx.translate(layerPos.x, layerPos.y);
						dCtx.transform(layerAFTransfrom[0][0], layerAFTransfrom[1][0], layerAFTransfrom[0][1],
								layerAFTransfrom[1][1], layerAFTransfrom[0][2], layerAFTransfrom[1][2]);
						dCtx.translate(-layerAnchorP.x * layerBounds.width, -layerAnchorP.y * layerBounds.height);
						dCtx.setAlpha(layer.opacity());
						layer.drawContent(dCtx);
					}
					if (layer.clipToBounds()) {
						dCtx.beginPath();
						dCtx.rect(0, 0, layer.bounds().width, layer.bounds().height);
						dCtx.closePath();
						dCtx.clip();
					}
					tStat.processed = true;
				}
				if (tStat.subLayerItr.hasMore()) {
					var subLayer = tStat.subLayerItr.next().value;
					pStack.push({
						processed : false,
						layer : subLayer,
						subLayerItr : subLayer.subLayersIterator()
					});
				} else {
					dCtx.restore();
					pStack.pop();
				}
			} else {
				pStack.pop();
			}
		}
	};

	var compositingRequestList = [];

	var compositingTask = function() {
		var req, layer, drawingCtx;
		while (compositingRequestList.length) {
			req = compositingRequestList.shift();
			drawingCtx = req.drawingContext;
			layer = req.layer;
			//timer start
			//LOG.debug("layer["+layer.id()+"]rendering start.","perf");
			drawingCtx.clearRect(0, 0, layer.bounds().width, layer.bounds().height);
			compositor(drawingCtx, layer);
			//timer stop
			LOG.debug("layer["+layer.id()+"]rendering end.", "perf");
			req.onComplete();
		}
		queueRequest = queueRequestAndScheduleTask;
	};

	var queueRequestWithoutScheduleTask = function(compositingReq) {
		compositingRequestList.push(compositingReq);
	};

	var queueRequestAndScheduleTask = function(compositingReq) {
		compositingRequestList.push(compositingReq);
		compositingTaskRunner(compositingTask, 0);
		queueRequest = queueRequestWithoutScheduleTask;
	};

	var queueRequest = queueRequestAndScheduleTask;

	/**
	 * Each instance of this class is backed by a HTMLCanvasElement, and
	 * provides more easy to use graphic management and drawing capability
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface
	 * @constructor
	 * @param {Object}
	 *            options
	 * @param {HTMLCanvasElement}
	 *            options.canvasEl
	 * @param {String}
	 *            [options.bgColor] the background color of the canvas
	 */
	var Canvas2DSurface = function(options) {
		this._mainCanvasEl = options.canvasEl;
		this._drawingCtx = this._mainCanvasEl.getContext('2d');
		this._msTracking = [];
		this._touch2LayerTracking = {};
		this._layer2TouchTracking = {};
		this._rootLayer = new Layer({
		    id : "RootLayer",
			bgColor : options.bgColor,
			size : {
				w : this._mainCanvasEl.width(),
				h : this._mainCanvasEl.height()
			},
			anchor : {
				x : 0,
				y : 0
			},
			position : {
				x : 0,
				y : 0
			}
		});

		var inCompositing = false;

		var onCompositingComplete = function() {
			inCompositing = false;
		};

		var handleContentUpdate = function() {
			if (!inCompositing) {
				queueRequest({
					drawingContext : this._drawingCtx,
					layer : this._rootLayer,
					onComplete : onCompositingComplete
				});
				inCompositing = true;
			}
		};

		this._rootLayer.on({
			eventName : 'contentUpdate',
			listener : handleContentUpdate,
			scope : this
		});
		compositor(this._drawingCtx, this._rootLayer);
	};

	var cp = Canvas2DSurface.prototype;

	cp.dispatchComponentUIEvent = function(surfaceUIEvent) {
		var rootLayer = this._rootLayer;
		switch (surfaceUIEvent.type()) {
		case 'mousemove':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var pageXY = surfaceUIEvent.pageXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				if (this._msTracking.length) {
					if (this._msTracking[this._msTracking.length - 1] !== hittedLayer) {
						var enteredLayers = [];
						var entered = hittedLayer;
						while (entered) {
							enteredLayers.push(entered);
							entered = entered.superLayer();
						}
						var inLayerCount = 0, checkFinished = false, minLen = Math.min(this._msTracking.length,
								enteredLayers.length);
						while (true) {
							var left = undefined;
							if (!checkFinished
									&& this._msTracking[inLayerCount] === enteredLayers[enteredLayers.length - 1
											- inLayerCount]) {
								inLayerCount++;
								checkFinished = inLayerCount === minLen;
							} else {
								while (this._msTracking.length > inLayerCount) {
									left = this._msTracking.pop();
									var mlEvt = new MouseEvent('mouseleave', left, false, testPoint, pageXY);
									mlEvt._setRelatedLayer_(hittedLayer);
									left._fireMouseEvent_(mlEvt);
								}
								while (inLayerCount < enteredLayers.length) {
									var entered = enteredLayers.shift();
									left = this._msTracking[enteredLayers.length - 1];
									this._msTracking[enteredLayers.length] = entered;
									var mlEvt = new MouseEvent('mouseenter', entered, false, testPoint, pageXY);
									mlEvt._setRelatedLayer_(left);
									entered._fireMouseEvent_(mlEvt);
								}
								break;
							}
						}
					}
				} else {
					var entered = hittedLayer;
					do {
						this._msTracking.push(entered);
						entered._fireMouseEvent_(new MouseEvent('mouseenter', entered, false, testPoint, pageXY));
						entered = entered.superLayer();
					} while (entered)
					this._msTracking.reverse();
				}
				hittedLayer._fireMouseEvent_(new MouseEvent('mousemove', hittedLayer, true, testPoint, pageXY));
			} else {
				while (this._msTracking.length) {
					var left = this._msTracking.pop();
					left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, testPoint, pageXY));
				}
			}
			break;
		case 'mouseleave':
			while (this._msTracking.length) {
				var left = this._msTracking.pop();
				left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, surfaceUIEvent.targetLocalXY(),
						surfaceUIEvent.pageXY()));
			}
			break;
		case 'mouseup':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				hittedLayer._fireMouseEvent_(new MouseEvent('mouseup', hittedLayer, true, testPoint, surfaceUIEvent
						.pageXY()));
			}
			break;
		case 'mousedown':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				hittedLayer._fireMouseEvent_(new MouseEvent('mousedown', hittedLayer, true, testPoint, surfaceUIEvent
						.pageXY()));
			}
			break;
		case 'dblclick':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				if (this._focusedLayer) {
					if (this._focusedLayer.id() !== hittedLayer.id()) {
						this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
						this._focusedLayer = hittedLayer;
						this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
					}
				} else {
					this._focusedLayer = hittedLayer;
					this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
				}
				this._focusedLayer._fireMouseEvent_(new MouseEvent('dblclick', this._focusedLayer, true, testPoint,
						surfaceUIEvent.pageXY()));
			} else {
				if (this._focusedLayer) {
					this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
					this._focusedLayer = undefined;
				}
			}
			break;
		case 'click':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				if (this._focusedLayer) {
					if (this._focusedLayer.id() !== hittedLayer.id()) {
						this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
						this._focusedLayer = hittedLayer;
						this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
					}
				} else {
					this._focusedLayer = hittedLayer;
					this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
				}
				this._focusedLayer._fireMouseEvent_(new MouseEvent('click', this._focusedLayer, true, testPoint,
						surfaceUIEvent.pageXY()));
			} else {
				if (this._focusedLayer) {
					this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
					this._focusedLayer = undefined;
				}
			}
			break;
		case 'touchstart':
			var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchstart
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				var testPoint = touchOnComp.localXY();
				var hittedLayer = rootLayer.hitTest(testPoint);
				if (hittedLayer) {
					var hittedLayerId = hittedLayer.id();
					// Tracking the new touch in two important structures
					t2l[identifier] = hittedLayer;
					if (!l2t.hasOwnProperty(hittedLayerId)) {
						l2t[hittedLayerId] = {
							layer : hittedLayer,
							touchIds : [ identifier ]
						};
					} else {
						l2t[hittedLayerId].touchIds.push(identifier);
					}

					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		case 'touchmove':
			var t2l = this._touch2LayerTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchmove
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l.hasOwnProperty(identifier)) {
					var hittedLayer = t2l[identifier];
					var hittedLayerId = hittedLayer.id();
					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		case 'touchend':
			var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchend
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l.hasOwnProperty(identifier)) {
					var hittedLayer = t2l[identifier];
					var hittedLayerId = hittedLayer.id();
					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
					delete t2l[identifier];
					l2t[hittedLayerId].touchIds.splice(l2t[hittedLayerId].touchIds.indexOf(identifier), 1);
					if (!l2t[hittedLayerId].touchIds.length) {
						delete l2t[hittedLayerId];
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		case 'touchcancel':
			var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchcancel
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l.hasOwnProperty(identifier)) {
					var hittedLayer = t2l[identifier];
					var hittedLayerId = hittedLayer.id();
					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
					delete t2l[identifier];
					l2t[hittedLayerId].touchIds.splice(l2t[hittedLayerId].touchIds.indexOf(identifier), 1);
					if (!l2t[hittedLayerId].touchIds.length) {
						delete l2t[hittedLayerId];
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		}
	};

	cp._dispatchTouchEventToLayer = function(touchedLayers, surfaceTouchEvent) {
		var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
		for ( var layerId in touchedLayers) {
			// Analyze and build changedTouches of the touch start event
			var changedTouches = TouchEvent.createTouchList();
			var layer = touchedLayers[layerId].layer;
			for ( var i = 0, touchOnComp, cTs = touchedLayers[layerId].touches, len = cTs.length; i < len; i++) {
				touchOnComp = cTs[i];
				changedTouches._addTouch_(TouchEvent.createTouch(touchOnComp.identifier(), layer,
						touchOnComp.localXY(), touchOnComp.pageXY()));
			}

			// Analyze and build targetTouches of the touch start event
			var targetTouches = TouchEvent.createTouchList();
			if (l2t[layerId]) {
				var targetTouchIds = l2t[layerId].touchIds;
				for ( var i = 0, touchOnComp, allTs = surfaceTouchEvent.touches(), len = targetTouchIds.length; i < len; i++) {
					touchOnComp = allTs.identifiedTouch(targetTouchIds[i]);
					targetTouches._addTouch_(TouchEvent.createTouch(touchOnComp.identifier(), layer, touchOnComp
							.localXY(), touchOnComp.pageXY()));
				}
			}
			var touches = TouchEvent.createTouchList();
			for ( var i = 0, touchOnComp, layer, allTouches = surfaceTouchEvent.touches(), len = allTouches.length(); i < len; i++) {
				touchOnComp = allTouches.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l[identifier]) {
					// Only remove the touch that don't originate from
					// current canvas2dsurface
					layer = t2l[identifier];
					touches._addTouch_(TouchEvent.createTouch(identifier, layer, touchOnComp.localXY(), touchOnComp
							.pageXY()));
				}
			}
			layer._fireTouchEvent_(new TouchEvent(surfaceTouchEvent.type(), layer, true, touches, changedTouches,
					targetTouches));
		}
	};

	/**
	 * Get and set the size of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#size
	 * @param {undefined|Object}
	 *            [size] the new size of the canvas
	 * @returns {this|Object}
	 */
	cp.size = function(size) {
		if (size !== undefined) {
			if (this._mainCanvasEl.width() != size.width) {
				this._mainCanvasEl.width(size.width);
				this._rootLayer.width(size.width);
			}
			if (this._mainCanvasEl.height() != size.height) {
				this._mainCanvasEl.height(size.height);
				this._rootLayer.height(size.height);
			}
			return this;
		} else {
			return {
				width : this._mainCanvasEl.width(),
				height : this._mainCanvasEl.height()
			};
		}
	};
	/**
	 * Get and set the width of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#width
	 * @param {undefined|Number}
	 *            [size] the new width of the canvas
	 * @returns {this|Number}
	 */
	cp.width = function(width) {
		if (width) {
			var ow = this._mainCanvasEl.width();
			if (ow != width) {
				this._mainCanvasEl.width(width);
				this._rootLayer.width(width);
			}
			return this;
		} else {
			return this._mainCanvasEl.width();
		}
	};
	/**
	 * Get and set the height of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#height
	 * @param {undefined|Number}
	 *            [size] the new height of the canvas
	 * @returns {this|Number}
	 */
	cp.height = function(height) {
		if (height) {
			var oh = this._mainCanvasEl.height();
			if (oh != height) {
				this._mainCanvasEl.height(height);
				this._rootLayer.height(height);
			}
			return this;
		} else {
			return this._mainCanvasEl.height();
		}
	},
	/**
	 * Get the root layer of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#getRootLayer
	 * @returns {sap.riv.graphics.Layer}
	 */
	cp.getRootLayer = function() {
		return this._rootLayer;
	};
	/**
	 * Get the background color of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#backgroundColor
	 * @returns {String}
	 */
	cp.backgroundColor = function(bgColor) {
		if (bgColor) {
			this._rootLayer.backgroundColor(bgColor);
		} else {
			return this._rootLayer.backgroundColor();
		}
	};
	return Canvas2DSurface;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
    var getColorObjFromHSLA = function(h, s, l, a) {
            return colorUtils.fromHSLA(h / 360, s, l, a || 1.0);
    };
    var hue2rgb = function(p, q, t) {
        if(t < 0)
            t += 1;
        if(t > 1)
            t -= 1;
        if(t < 1 / 6)
            return p + (q - p) * 6 * t;
        if(t < 1 / 2)
            return q;
        if(t < 2 / 3)
            return p + (q - p) * (2 / 3 - t) * 6;
        return p;
    };
    var hsl2rgb = function(h, s, l) {
        var r, g, b;
        if(s == 0) {
            r = g = b = l;
            // achromatic
        } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    };
    var rgb2hsl = function(r, g, b) {r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h = 0, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0;
            // achromatic
        } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return [h, s, l];
    };
    var parsePercentage = function(value) {
        return parseInt(value.substring(0, value.lastIndexOf('%'))) / 100;
    };
    var parseRGBValue = function(value) {
        if(value.lastIndexOf('%') > 0) {
            return Math.ceil(parseInt(value.substring(0, value.lastIndexOf('%'))) * 255 / 100);
        } else {
            return parseInt(value);
        }
    };
    var toHexString = function(decimal) {
        return decimal < 16 ? '0' + decimal.toString(16) : decimal.toString(16);
    };
    /**
     * Represent a color normalized from css color setting
     *
     * @name sap.riv.core.types.Color
     * @constructor
     */
    var colorUtils = {};

    /**
     * Factory method for creating a color object from valid CSS color string.
     *
     * @param cssColorString
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromCSSColor = function(cssColorString) {
        if(cssColorString.charAt(0) == '#') {
            return this.fromRGBHexString(cssColorString);
        } else if(cssColorString.substr(0, 4).toLowerCase() == 'rgba') {
            return this.fromRGBA(cssColorString);
        } else if(cssColorString.substr(0, 3).toLowerCase() == 'rgb') {
            return this.fromRGB(cssColorString);
        } else if(cssColorString.substr(0, 4).toLowerCase() == 'hsla') {
            return this.fromHSLA(cssColorString);
        } else if(cssColorString.substr(0, 3).toLowerCase() == 'hsl') {
            return this.fromHSL(cssColorString);
        }
    };
    /**
     * Factory method for creating a color object from either valid CSS rgb
     * string or seperated r,g,b components.
     *
     * @param {String|Number}
     *            rgb css rgb string or red component
     * @param {Number}
     *            [g] the green component
     * @param {Number}
     *            [b] the blue component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromRGB = function(rgb) {
        var red = 0, green = 0, blue = 0;
        if(arguments.length == 1) {
            var comps = rgb.substring(4, rgb.lastIndexOf(')')).split(',');
            red = parseRGBValue(comps[0]);
            green = parseRGBValue(comps[1]);
            blue = parseRGBValue(comps[2]);
        } else if(arguments.length == 3) {
            red = arguments[0];
            green = arguments[1];
            blue = arguments[2];
        }
        return new colorObj(red, green, blue, 1.0);
    };
    /**
     * Factory method for creating a color object from either valid CSS rgba
     * string or seperated r,g,b,a components.
     *
     * @param {String|Number}
     *            rgb css rgb string or red component
     * @param {Number}
     *            [g] the green component
     * @param {Number}
     *            [b] the blue component
     * @param {Number}
     *            [a] the alpha component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromRGBA = function(rgba) {
        var red = 0, green = 0, blue = 0, alpha = 0;
        if(arguments.length == 1) {
            var comps = rgba.substring(5, rgba.lastIndexOf(')')).split(',');
            red = parseRGBValue(comps[0]);
            green = parseRGBValue(comps[1]);
            blue = parseRGBValue(comps[2]);
            alpha = parseFloat(comps[3]);
        } else if(arguments.length == 4) {
            red = Math.ceil(arguments[0]);
            green = Math.ceil(arguments[1]);
            blue = Math.ceil(arguments[2]);
            alpha = Math.ceil(arguments[3]);
        }
        return new colorObj(red, green, blue, alpha);
    };
    /**
     * Factory method for creating a color object from either valid CSS
     * numbering color string.
     *
     * @param {String}
     *            hexString css color string like #FFFFFF
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromRGBHexString = function(hexString) {
        var red = 0, green = 0, blue = 0, alpha = 1.0;
        red = parseInt(hexString.substr(1, 2), 16);
        green = parseInt(hexString.substr(3, 2), 16);
        blue = parseInt(hexString.substr(5, 2), 16);
        return new colorObj(red, green, blue, alpha);
    };
    /**
     * Factory method for creating a color object from either valid CSS hsl
     * color string or hue, saturation, lightness component.
     *
     * @param {String|Number}
     *            hsl css hsl string or hue component
     * @param {Number}
     *            [s] saturation component
     * @param {Number}
     *            [l] lightness component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromHSL = function(hsl) {
        if(arguments.length == 1) {
            var comps = hsl.substring(4, hsl.lastIndexOf(')')).split(',');
            var rgb = hsl2rgb((parseInt(comps[0]) % 360 + 360) % 360 / 360, parsePercentage(comps[1]), parsePercentage(comps[2]));
            return new colorObj(rgb[0], rgb[1], rgb[2], 1.0);
        } else if(arguments.length == 3) {
            rgb = hsl2rgb(arguments[0], arguments[1], arguments[2]);
            return new colorObj(rgb[0], rgb[1], rgb[2], 1.0);
        }
    };
    /**
     * Factory method for creating a color object from either valid CSS hsla
     * color string or hue, saturation, lightness, alpha component.
     *
     * @param {String|Number}
     *            hsl css hsl string or hue component
     * @param {Number}
     *            [s] saturation component
     * @param {Number}
     *            [l] lightness component
     * @param {Number}
     *            [a] alpha component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromHSLA = function(hsla) {
        if(arguments.length == 1) {
            var comps = hsla.substring(5, hsla.lastIndexOf(')')).split(',');
            var rgb = hsl2rgb((parseInt(comps[0]) % 360 + 360) % 360 / 360, parsePercentage(comps[1]), parsePercentage(comps[2]));
            return new colorObj(rgb[0], rgb[1], rgb[2], parseFloat(comps[3]));
        } else if(arguments.length == 4) {
            rgb = hsl2rgb(arguments[0], arguments[1], arguments[2]);
            return new colorObj(rgb[0], rgb[1], rgb[2], arguments[3]);
        }
    };
    /*
     * This function is used to get a series of color according to a base color
     * @param [baseColorObj] used for base color @param [type] type of color
     * string returned. rgb, rgba, hsl or hsla @return [ColorSeries]: a
     * three-dimensional array of color string
     */
    colorUtils.getColorSeries = function(baseColorObj, type) {

        var baseHSLA = [baseColorObj.hue(), baseColorObj.saturation(), baseColorObj.lightness(), baseColorObj.alpha()]
        var ColorSeriesBaseObj = new Array();

        // decrease 15 degree on hue in circle
        ColorSeriesBaseObj[0] = getColorObjFromHSLA(360 - ((360 - baseHSLA[0]) + 15) % 360, baseHSLA[1], baseHSLA[2]);
        ColorSeriesBaseObj[1] = getColorObjFromHSLA(baseHSLA[0], baseHSLA[1], baseHSLA[2]);
        // increase 15 degree on hue in circle
        ColorSeriesBaseObj[2] = getColorObjFromHSLA((baseHSLA[0] + 15) % 360, baseHSLA[1], baseHSLA[2]);

        var ColorSeries = new Array();
        ColorSeries[0] = new Array();
        ColorSeries[1] = new Array();
        ColorSeries[2] = new Array();

        for(var i = 0; i < 3; i++) {

            for(var j = 0; j < 10; j++) {
                ColorSeries[i].unshift(getColorObjFromHSLA(ColorSeriesBaseObj[i].hue(), ColorSeriesBaseObj[i].saturation(), j / 10).toColorString(type));
            }
            for(var j = 1; j <= 4; j++) {
                // decrease 20 degree on hue every time in circle
                var newHue = (360 - ((360 - ColorSeriesBaseObj[i].hue()) + (20 * j)) % 360);
                ColorSeries[i].unshift(getColorObjFromHSLA(newHue, ColorSeriesBaseObj[i].saturation(), 0.9).toColorString(type));
            }
        }
        return ColorSeries;
    };

    colorUtils.changeOpacity = function(cssColor, opacity) {
        var color = colorUtils.fromCSSColor(cssColor);
        color.alpha(opacity);
        return color.toColorString('rgba');
    };
    /*
     * get colorSeries from css color
     */
    colorUtils.getColorSeriesFromCSS = function(cssColor) {

        var baseColorObj = colorUtils.fromCSSColor(cssColor);

        var colorSeries = this.getColorSeries(baseColorObj, "rgba")

        return colorSeries;
    };
    colorUtils.getColorSeriesForBar = function(cssColor, type) {
        type = type || "rgba";

        var baseColorObj = colorUtils.fromCSSColor(cssColor);
        var colorSeries = [];

        if(baseColorObj.lightness() <= 0.75) {
            colorSeries[0] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() + 0.25), baseColorObj.alpha()).toColorString(type);
            colorSeries[1] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() + 0.15), baseColorObj.alpha()).toColorString(type);
            colorSeries[2] = baseColorObj.toColorString(type);
            colorSeries[3] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() - 0.1) > 0 ? (baseColorObj.lightness() - 0.1) : 0, baseColorObj.alpha()).toColorString(type);
        } else {
            colorSeries[0] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() + 0.1) > 1 ? 1.0 : (baseColorObj.lightness() + 0.1), baseColorObj.alpha()).toColorString(type);
            colorSeries[1] = baseColorObj.toColorString(type);
            colorSeries[2] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() - 0.15), baseColorObj.alpha()).toColorString(type);
            colorSeries[3] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() - 0.25), baseColorObj.alpha()).toColorString(type);
        }
        return colorSeries;
    }
    var colorObj = function(r, g, b, a) {
        this._r = r;
        this._g = g;
        this._b = b;
        this._hsl = rgb2hsl(r, g, b);
        this._a = a;
    };
    /**
     * Get the hue component of this color object
     *
     * @name sap.riv.core.types.Color#hue
     * @function
     * @returns {Number} hue in degree
     */
    colorObj.prototype.hue = function() {
        return this._hsl[0] * 360;
    };
    /**
     * Get the saturation component of this color object
     *
     * @name sap.riv.core.types.Color#saturation
     * @function
     * @returns {Number} saturation between [0, 1]
     */
    colorObj.prototype.saturation = function() {
        return this._hsl[1];
    };
    /**
     * Get the lightness component of this color object
     *
     * @name sap.riv.core.types.Color#lightness
     * @function
     * @returns {Number} lightness between [0, 1]
     */
    colorObj.prototype.lightness = function() {
        return this._hsl[2];
    };
    /**
     * Get the red component of this color object
     *
     * @name sap.riv.core.types.Color#red
     * @function
     * @returns {Number} red between[0,255]
     */
    colorObj.prototype.red = function(red) {
        if(TypeUtils.isNumber(red)) {
            if(0 <= red && red <= 255) {
                this._red = red;
                this._hsl = rgb2hsl(this._r, this._g, this._b);
            }
            return this;
        }
        return this._r;
    };
    /**
     * Get or set the red component of this color object
     *
     * @name sap.riv.core.types.Color#green
     * @function
     * @returns {Number|this} green between[0,255]
     */
    colorObj.prototype.green = function(green) {
        if(TypeUtils.isNumber(green)) {
            if(0 <= green && green <= 255) {
                this._g = green;
                this._hsl = rgb2hsl(this._r, this._g, this._b);
            }
            return this;
        }
        return this._g;
    };
    /**
     * Get or set the blue component of this color object
     *
     * @name sap.riv.core.types.Color#blue
     * @function
     * @returns {Number} blue between[0,255]
     */
    colorObj.prototype.blue = function(blue) {
        if(TypeUtils.isNumber(blue)) {
            if(0 <= blue && blue <= 255) {
                this._b = blue;
                this._hsl = rgb2hsl(this._r, this._g, this._b);
            }
            return this;
        }
        return this._b;
    };
    /**
     * Get or set the alpha component of this color object
     *
     * @name sap.riv.core.types.Color#alpha
     * @function
     * @returns {Number|this} alpha between[0,1]
     */
    colorObj.prototype.alpha = function(alpha) {
        if(TypeUtils.isNumber(alpha)) {
            if(0 <= alpha && alpha <= 1) {
                this._a = alpha;
            }
            return this;
        }
        return this._a;
    };
    /**
     * Return the css color string representation of this color object
     *
     * @name sap.riv.core.types.Color#toColorString
     * @function
     * @param {String}
     *            [type] valid values are 'rgb','rgba','hsl','hsla'.
     * @returns {String}
     */
    colorObj.prototype.toColorString = function(type) {
        switch (type) {
            case 'rgb':
                return 'rgb(' + this._r + ',' + this._g + ',' + this._b + ')';
            case 'rgba':
                return 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + (this._a || 1.0) + ')';
            case 'hsl':
                var hsl = rgb2hsl(this._r, this._g, this._b);
                return 'hsl(' + hsl[0] * 360 + ',' + hsl[1] * 100 + '%,' + hsl[2] * 100 + '%)';
            case 'hsla':
                var hsl = rgb2hsl(this._r, this._g, this._b);
                return 'hsla(' + hsl[0] * 360 + ',' + hsl[1] * 100 * 100 + '%,' + hsl[2] * 100 * 100 + '%,' + (this._a || 1.0) + ')';
            default:
                return '#' + toHexString(this._r) + toHexString(this._g) + toHexString(this._b);
        }
    };
    return colorUtils;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.ClosedShape',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, ClosedShape) {
	/**
	 * This class defines closed fillable shape which allows to fill the
	 * interior with color or gradient
	 * 
	 * @name sap.riv.graphics.shape.FillableShape
	 * @class
	 * @augments sap.riv.graphics.shape.ClosedShape
	 */
	var FillableShape = ObjectUtils.derive(ClosedShape, {
		constructor : function() {
			this._fill = undefined;
		},
		/**
		 * Get or set the filling color of the closed shape, the color setting
		 * should be CSSColor serialized string or as follow to define gradient
		 * 
		 * Linear Gradient:
		 * 
		 * <pre>
		 * {
		 *      t: 'lg', //line gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * Radial Gradient:
		 * 
		 * <pre>
		 * {
		 *      t: 'rg', //radial gradient
		 *      s: { c : { x:## , y:## }, r : ## }, //the start position of the radial gradient, c stands for center of the circle, r stands for radius of the circle
		 *      e: { c : { x:## , y:## }, r : ## }, //the end position of the radial gradient, c stands for center of the circle, r stands for radius of the circle
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.FillableShape#fillingColor
		 * @function
		 * @param {CSSColor|Object}
		 *            color the filling color
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		fillingColor : function(color) {
			if (color !== undefined) {
				if (color !== false) {
					this._fill = CanvasHelper.createColorStyle(color);
				} else {
					this._fill = undefined;
				}
				return this;
			}
			if (this._fill) {
				return this._fill;
			}
		},

		/**
		 * Filling the shape with color style, this method should be called
		 * inside of doDraw method.
		 * 
		 * @name sap.riv.graphics.shape.FillableShape#fillShape
		 * @function
		 * @param drawingContext
		 */
		fillShape : function(drawingContext) {
			if (this._fill) {
				drawingContext.save();
				drawingContext.setFillStyle(this._fill);
				drawingContext.fill();
				drawingContext.restore();
			}
		}
	});
	return FillableShape;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Observable) {
	var ThemeManager = new (ObjUtils.derive(Observable,
	/**
	 * A global theme manager
	 * 
	 * @lends sap.riv.vizkit.ThemeManager
	 */
	{
		events : [ 'defaultThemeChanged', 'themeSettingChanged' ],
		/**
		 * @constructs
		 * 
		 */
		constructor : function(options) {
			this._themeReg = {};
		},
		/**
		 * Get or set the global default theme
		 * 
		 * @name sap.riv.vizkit.ThemeManager#defaultTheme
		 * @function
		 * @param {String}
		 *            [theme] the name of the default theme.
		 * @return {String} the name of the current default theme
		 */
		defaultTheme : function(theme) {
			if (theme !== undefined) {
				if (this._defaultTheme !== theme && this.hasThemeInstalled(theme)) {
					var old = this._defaultTheme;
					this._defaultTheme = theme;
					this.fireEvent('defaultThemeChanged', old, theme);
				}
				return this;
			}
			return this._defaultTheme;
		},
		/**
		 * Check whether the theme has already been installed.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#hasThemeInstalled
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Boolean}
		 */
		hasThemeInstalled : function(theme) {
			return this._themeReg.hasOwnProperty(theme);
		},
		/**
		 * Install a new theme, if it's been already installed, nothing happens.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#installTheme
		 * @function
		 * @param {String}
		 *            name the name of the new theme
		 * @param {Object}
		 *            settings the settings of the theme
		 */
		installTheme : function(name, settings) {
			if (!this._themeReg.hasOwnProperty(name)) {
				this._themeReg[name] = ObjUtils.extend({}, settings);
			}
		},
		/**
		 * Get the settings of given theme.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#getThemeSettings
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Object} the settings of the theme
		 */
		getThemeSettings : function(theme) {
			if (this._themeReg.hasOwnProperty(theme)) {
				return ObjUtils.extend({}, this._themeReg[theme]);
			}
		},
		/**
		 * Update a value of a given theme's property, will fire
		 * <b>themeSettingChanged</b> event if succeed.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#updateThemeSetting
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @param {String}
		 *            key the key whose value to be updated.
		 * @param {String}
		 *            value the new value of the key
		 */
		updateThemeSetting : function(theme, key, value) {
			if (this._themeReg.hasOwnProperty(theme)) {
				var old = this._themeReg[theme][key];
				this._themeReg[theme][key] = value;
				this.fireEvent('themeSettingChanged', theme, key, old, value);
			}
		}
	}))();
	return ThemeManager;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Sector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, FillableShape, Math) {

	var preCalc = function(radius, startAngle, endAngle) {
		var sv = {
			x : radius * Math.cos(startAngle),
			y : radius * Math.sin(startAngle),
			z : 0
		}, ev = {
			x : radius * Math.cos(endAngle),
			y : radius * Math.sin(endAngle),
			z : 0
		};

		return {
			sr : radius * radius,
			sv : sv,
			ev : ev,
			z_of_sv_cross_ev : sv.x * ev.y - sv.y * ev.x
		};
	};

	/**
	 * This class defines Sector
	 * 
	 * @name sap.riv.graphics.shape.Sector
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Sector = ObjectUtils
			.derive(
					FillableShape,
					{
						constructor : function() {
							this._center = {
								x : 0,
								y : 0
							};
							this._radius = 0;
							this._startAngle = 0;
							this._endAngle = 0;
							this._clockwise = false;
						},

						/**
						 * Get or set center of the sector. The default is
						 * {0,0}.
						 * 
						 * @name sap.riv.graphics.shape.Sector#center
						 * @function
						 * @param {POINT}
						 *            center the x,y coordinates of the center
						 * @returns {this|POINT}
						 */
						center : function(center) {
							if (center !== undefined) {
								this._center.x = center.x;
								this._center.y = center.y;
								return this;
							}
							if (this._center) {
								return {
									x : this._center.x,
									y : this._center.y
								};
							}
						},
						/**
						 * Get or set radius of the sector. The default is 0.
						 * 
						 * @name sap.riv.graphics.shape.Sector#radius
						 * @function
						 * @param {Number}
						 *            radius the radius of the sector
						 * @returns {this|Number}
						 */
						radius : function(radius) {
							if (radius !== undefined) {
								if (radius > 0) {
									this._radius = radius;
									this._preCalcs = preCalc(this._radius, this._startAngle, this._endAngle);
								}
								return this;
							}
							return this._radius;
						},
						/**
						 * Get or set start angle of of the sector. The default
						 * is 0.
						 * 
						 * @name sap.riv.graphics.shape.Sector#startAngle
						 * @function
						 * @param {Number}
						 *            startAngle the start angle of the sector
						 * @returns {this|Number}
						 */
						startAngle : function(startAngle) {
							if (startAngle !== undefined) {
								this._startAngle = startAngle;
								this._preCalcs = preCalc(this._radius, this._startAngle, this._endAngle);
								return this;
							}
							return this._startAngle;
						},
						/**
						 * Get or set end angle of the sector. The default is 0.
						 * 
						 * @name sap.riv.graphics.shape.Sector#endAngle
						 * @function
						 * @param {Number}
						 *            endAngle the end angle of the sector
						 * @returns {this|Number}
						 */
						endAngle : function(endAngle) {
							if (endAngle !== undefined) {
								this._endAngle = endAngle;
								this._preCalcs = preCalc(this._radius, this._startAngle, this._endAngle);
								return this;
							}
							return this._endAngle;
						},
						/**
						 * Get or set clockwise of the sector. The default is
						 * false.
						 * 
						 * @name sap.riv.graphics.shape.Sector#clockwise
						 * @function
						 * @param {Boolean}
						 *            clockwise the clockwise of the sector
						 * @returns {this|Boolean}
						 */
						clockwise : function(clockwise) {
							if (clockwise !== undefined) {
								this._clockwise = clockwise;
								return this;
							}
							return this._clockwise;
						},

						doDraw : function(drawingContext) {
							var dCtx = drawingContext;
							var c = this._center;
							dCtx.beginPath();
							dCtx.moveTo(c.x, c.y);
							dCtx.arc(c.x, c.y, this._radius, this._startAngle, this._endAngle, !this._clockwise);
							dCtx.closePath();
							this.fillShape(dCtx);
							this.drawBorder(dCtx);
						},

						doPointInTest : function(point) {
							var sv = this._preCalcs.sv, ev = this._preCalcs.ev, sr = this._preCalcs.sr, z_of_sv_cross_ev = this._preCalcs.z_of_sv_cross_ev;
							var tv = {
								x : point.x - this._center.x,
								y : point.y - this._center.y,
								z : 0
							};
							var z_of_sv_cross_tv = sv.x * tv.y - sv.y * tv.x, z_of_tv_cross_ev = tv.x * ev.y - tv.y
									* ev.x;

							return (tv.x * tv.x + tv.y * tv.y) <= sr
									&& (this._clockwise ? (z_of_sv_cross_ev > 0 ? (z_of_sv_cross_tv > 0 && z_of_tv_cross_ev > 0)
											: !(z_of_sv_cross_tv < 0 && z_of_tv_cross_ev < 0))
											: (z_of_sv_cross_ev < 0 ? (z_of_sv_cross_tv < 0 && z_of_tv_cross_ev < 0)
													: !(z_of_sv_cross_tv > 0 && z_of_tv_cross_ev > 0)));
						}
					});
	return Sector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(TypeUtils) {
	var series = function(options) {

		this._xAxis = null;
		this._yAxis = null;
		this._data = [];
		this._seriesColor = '#000000';
		this._barMarkerSize = series.DEFAULTBARMARKERSIZE;
		this._lineMarkerSize = series.DEFAULTLINEMARKERSIZE;
		this._lineSize = series.DEFAULTLINESIZE;
		this._name = null;
		this._markerSymbol = series.CIRCLEMARKER;
		this._visible = true;
		this._parseOptions(options);
	};

	series.DEFAULTBARMARKERSIZE = undefined;// 17;
	series.DEFAULTLINEMARKERSIZE = 10;
	series.DEFAULTLINESIZE = 1;
	series.CIRCLEMARKER = 'circle';
	series.TRIANGLEMARKER = 'triangle';
	series.DIAMONDMARKER = 'diamond';
	series.PENTAGONMARKER = 'pentagon';

	/**
	 * 
	 * @param options{
	 *            color: '', markerSize: ''
	 *            markerSymbol:sap.riv.viz.shared.series.Series.CIRCLEMARKER }
	 */
	series.prototype._parseOptions = function(options) {
		if (TypeUtils.isExist(options.fillColor)) {
			this._seriesColor = options.fillColor;
		}

		if (TypeUtils.isExist(options.barMarkerSize)
				&& options.barMarkerSize > 0) {
			this._barMarkerSize = options.barMarkerSize;
		}

		if (TypeUtils.isExist(options.lineMarkerSize)
				&& options.lineMarkerSize > 0) {
			this._lineMarkerSize = options.lineMarkerSize;
		}

		if (TypeUtils.isExist(options.lineThickness)) {
			this._lineSize = options.lineThickness;
		}

		if (TypeUtils.isExist(options.lineColor)) {
			this._lineColor = options.lineColor;
		}

		if (TypeUtils.isExist(options.markerSymbol)) {
			var markerSymbol = options.markerSymbol;
			if (markerSymbol === series.CIRCLEMARKER
					|| markerSymbol === series.TRIANGLEMARKER
					|| markerSymbol === series.DIAMONDMARKER
					|| markerSymbol === series.PENTAGONMARKER) {
				this._markerSymbol = markerSymbol;
			}
		}

		if ( TypeUtils.isExist(options.visible) ) {
			this._visible = options.visible;
		}
	};

	series.prototype.isVisible = function() {
		return this._visible;
	};

	series.prototype.setVisible = function(visible) {
		this._visible = visible;
	};

	/**
	 * 
	 * @param data
	 *            Array
	 */
	series.prototype.setData = function(data) {
		this._data = data;
	};

	/**
	 * 
	 * @returns data Array
	 */
	series.prototype.getData = function() {
		return this._data;
	};

	/**
	 * 
	 * @param xAxis
	 *            sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.setXAxis = function(xAxis) {
		this._xAxis = xAxis;
	};

	/**
	 * 
	 * @param yAxis
	 *            sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.setYAxis = function(yAxis) {
		this._yAxis = yAxis;
	};

	/**
	 * 
	 * @returns xAxis sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.getXAxis = function() {
		return this._xAxis;
	};

	/**
	 * 
	 * @returns yAxis sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.getYAxis = function() {
		return this._yAxis;
	};

	/**
	 * 
	 * @param properties
	 *            Object
	 */
	series.prototype.updateProperties = function(properties) {
		if (TypeUtils.isExist(properties)) {
			this._parseOptions(properties);
			return this;
		}
	};

	/**
	 * @param name
	 */
	series.prototype.setName = function(name) {
		this._name = name;
	};

	/**
	 * @returns series name
	 */
	series.prototype.getName = function() {
		return this._name;
	};

	series.prototype.getDataRange = function() {
		var range = {
			max : Number.NEGATIVE_INFINITY,
			min : Number.POSITIVE_INFINITY
		};

		for ( var i = 0, len = this._data.length; i < len; i++) {
			if (this._data[i].value < range.min) {
				range.min = this._data[i].value;
			}
			if (this._data[i].value > range.max) {
				range.max = this._data[i].value;
			}
		}
		return range;
	};
	
	return series;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.multilayout.ColumnMultiLayout',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var basicLayout = function(size, initProps) {
		this._size = {
			width : size.width,
			height : size.height
		};
		this._layoutChanged = false;
		this._itemLength = 0;
		this._columnLength = 2;
		this._layoutInfo = null;
		this._parseOptions(initProps);
	};

	basicLayout.prototype._parseOptions = function(options) {
		if (TypeUtils.isExist(options.itemLength)) {
			this._itemLength = options.itemLength;
		}
		if (TypeUtils.isExist(options.columnLength)) {
			this._columnLength = options.columnLength > 0 ? options.columnLength : 2;
		}
		// TODO actually we didn't check whether we have changed
		this._layoutChanged = true;
	};

	basicLayout.prototype.layoutChanged = function() {
		return this._layoutChanged;
	};

	basicLayout.prototype.updateSize = function(nsize) {
		if (this._size.width != nsize.width
				|| this._size.height != nsize.height) {
			this._size.width = nsize.width;
			this._size.height = nsize.height;
			this._layoutChanged = true;
		}
	};

	basicLayout.prototype.updateSettings = function(props) {
		this._parseOptions(props);
	};

	/**
	 * return layout info array, each indicate the sub item's size and position:
	 * [{x:,y:,width:,height:}]
	 * 
	 */
	basicLayout.prototype.getLayoutInfo = function() {
		if (this._layoutInfo != null && !this._layoutChanged) {
			return this._layoutInfo;
		} else {
			// calculate a new layoutInfo
			this._layoutInfo = [];
			var li = this._layoutInfo;

			if (this._itemLength > 0) {
				var numColumns = this._columnLength;
				var numRows = Math.ceil(this._itemLength / numColumns);
				// [jyang 3/16/2012]crisp line needs each layer be positioned at
				// an integer position
				var itemWidth = Math.floor(this._size.width / numColumns);
				var itemHeight = Math.floor(this._size.height / numRows);
				for ( var i = 0; i < numRows; i++) {
					for ( var j = 0; j < numColumns; j++) {
						li.push({
							x : j * itemWidth,
							y : i * itemHeight,
							width : itemWidth,
							height : itemHeight
						});
					}
				}
			}
			this._layoutChanged = false;
			return this._layoutInfo;
		}
	};

	return basicLayout;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, FillableShape, Math) {
	/**
	 * This class defines Circle
	 * 
	 * @name sap.riv.graphics.shape.Circle
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Circle = ObjectUtils.derive(FillableShape, {
		constructor : function() {
			this._center = {
				x : 0,
				y : 0
			};
			this._radius = 0;
		},
		/**
		 * Get or set center of the sector The default is {0,0}.
		 * 
		 * @name sap.riv.graphics.Circle#center
		 * @function
		 * @param {POINT}
		 *            center the x,y coordinates of the center
		 * @returns {this|POINT}
		 */
		center : function(center) {
			if (center !== undefined) {
				this._center.x = center.x;
				this._center.y = center.y;
				return this;
			}
			if (this._center) {
				return {
					x : this._center.x,
					y : this._center.y
				};
			}
		},
		/**
		 * Get or set radius of the circle. The default is 0.
		 * 
		 * @name sap.riv.graphics.Circle#radius
		 * @function
		 * @param {Number}
		 *            radius the radius of the circle
		 * @returns {this|Number}
		 */
		radius : function(radius) {
			if (radius !== undefined) {
				if (radius > 0) {
					this._radius = radius;
				}
				return this;
			}
			return this._radius;
		},

		doDraw : function(drawingContext) {
			var dCtx = drawingContext;
			var c = this._center;
			dCtx.beginPath();
			dCtx.arc(c.x, c.y, this._radius, 0, 2 * Math.PI, false);
			dCtx.closePath();
			this.fillShape(dCtx);
			this.drawBorder(dCtx);
		},

		doPointInTest : function(point) {
			var c = this._center;
			var x = point.x - c.x;
			var y = point.y - c.y;
			return (x * x + y * y) <= this._radius * this._radius;
		}
	});
	return Circle;
});sap.riv.module(
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ColorUtils, FuncUtils, TypeUtils, LinkedHashMap, TransformHelper, Math) {
	var id = 0;
	var taskId = function() {
		return 'anim-' + id++;
	};
	var bezierCurveTiming = function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
		var ax = 0, bx = 0, cx = 0, ay = 0, by = 0, cy = 0;
		// `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
		var sampleCurveX = function(t) {
			return ((ax * t + bx) * t + cx) * t;
		};
		var sampleCurveY = function(t) {
			return ((ay * t + by) * t + cy) * t;
		};
		var sampleCurveDerivativeX = function(t) {
			return (3.0 * ax * t + 2.0 * bx) * t + cx;
		};
		// The epsilon value to pass given that the animation is going to run
		// over |dur| seconds. The longer the
		// animation, the more precision is needed in the timing function result
		// to avoid ugly discontinuities.
		var solveEpsilon = function(duration) {
			return 1.0 / (200.0 * duration);
		};
		var solve = function(x, epsilon) {
			return sampleCurveY(solveCurveX(x, epsilon));
		};
		// Given an x value, find a parametric value it came from.
		var solveCurveX = function(x, epsilon) {
			var t0, t1, t2, x2, d2, i;
			function fabs(n) {
				if (n >= 0) {
					return n;
				} else {
					return 0 - n;
				}
			}
			;
			// First try a few iterations of Newton's method -- normally very
			// fast.
			for (t2 = x, i = 0; i < 8; i++) {
				x2 = sampleCurveX(t2) - x;
				if (fabs(x2) < epsilon) {
					return t2;
				}
				d2 = sampleCurveDerivativeX(t2);
				if (fabs(d2) < 1e-6) {
					break;
				}
				t2 = t2 - x2 / d2;
			}
			// Fall back to the bisection method for reliability.
			t0 = 0.0;
			t1 = 1.0;
			t2 = x;
			if (t2 < t0) {
				return t0;
			}
			if (t2 > t1) {
				return t1;
			}
			while (t0 < t1) {
				x2 = sampleCurveX(t2);
				if (fabs(x2 - x) < epsilon) {
					return t2;
				}
				if (x > x2) {
					t0 = t2;
				} else {
					t1 = t2;
				}
				t2 = (t1 - t0) * 0.5 + t0;
			}
			return t2; // Failure.
		};
		// Calculate the polynomial coefficients, implicit first and last
		// control points are (0,0) and (1,1).
		cx = 3.0 * p1x;
		bx = 3.0 * (p2x - p1x) - cx;
		ax = 1.0 - cx - bx;
		cy = 3.0 * p1y;
		by = 3.0 * (p2y - p1y) - cy;
		ay = 1.0 - cy - by;
		// Convert from input time to parametric value in curve, then from that
		// to output time.
		return solve(t, solveEpsilon(duration));
	};

	var TimingFunctionFactory = (function() {
		var makeCustomTimingFunction = function(cp1x, cp1y, cp2x, cp2y) {
			return function(x) {
				return bezierCurveTiming(x, cp1x, cp1y, cp2x, cp2y, 100);
			};
		};
		var easings = {
			Linear : function(x) {
				return x;
			},
			EaseIn : function(x) {
				return bezierCurveTiming(x, 0.42, 0.0, 1.0, 1.0, 100);
			},
			EaseOut : function(x) {
				return bezierCurveTiming(x, 0.0, 0.0, 0.58, 1.0, 100);
			},
			EaseInEaseOut : function(x) {
				return bezierCurveTiming(x, 0.42, 0.0, 0.58, 1.0, 100);
			}
		};
		return {
			getTimingFunction : function(type) {
				if (easings.hasOwnProperty(type)) {
					return easings[type];
				} else if (TypeUtils.isArray(type) && type.length == 2) {
					return makeCustomTimingFunction(type[0].x, type[0].y, type[1].x, type[1].y);
				}
			}
		};
	})();

	var FloatLinearInterpolator = function(source, dest, easingFunc) {
		this._source = source;
		this._dest = dest;
		this._range = this._dest - this._source;
		this._easingFunc = easingFunc;
	};
	FloatLinearInterpolator.prototype.interpolateAt = function(pos) {
		return this._source + this._easingFunc(pos) * this._range;
	};
	var ColorLinearInterpolator = function(source, dest, _easingFunc) {
		// TODO consider the difference between interpolations of RGB & HSL
		this._source = ColorUtils.fromCSSColor(source);
		this._dest = ColorUtils.fromCSSColor(dest);
		this._redRange = this._dest.red() - this._source.red();
		this._greenRange = this._dest.green() - this._source.green();
		this._blueRange = this._dest.blue() - this._source.blue();
		this._alphaRange = this._dest.alpha() - this._source.alpha();
		this._easingFunc = _easingFunc;
	};
	ColorLinearInterpolator.prototype.interpolateAt = function(pos) {
		var factor = this._easingFunc(pos);
		var sr = this._source.red(), sg = this._source.green(), sb = this._source.blue(), sa = this._source.alpha();
		return ColorUtils.fromRGBA(sr + this._redRange * factor, sg + this._greenRange * factor, sb
				+ this._blueRange * factor, sa + this._alphaRange * factor);
	};
	var PointLinearInterpolator = function(source, dest, easingFunc) {
		this._source = source;
		this._dest = dest;
		this._range = [ dest[0] - source[0], dest[1] - source[1] ];
		this._easingFunc = easingFunc;
	};
	PointLinearInterpolator.prototype.interpolateAt = function(pos) {
		var factor = this._easingFunc(pos);
		return [ this._source[0] + this._range[0] * factor, this._source[1] + this._range[1] * factor ];
	};
	var RectLinearInterpolator = function(source, dest, easingFunc) {
		this._source = source;
		this._dest = dest;
		this._range = {
			x : dest.x - source.x,
			y : dest.y - source.y,
			w : dest.w - source.w,
			h : dest.h - source.h
		};
		this._easingFunc = easingFunc;
	};
	RectLinearInterpolator.prototype.interpolateAt = function(pos) {
		var factor = this._easingFunc(pos);
		return {
			x : this._source.x + this._range.x * factor,
			y : this._source.x + this._range.y * factor,
			w : this._source.x + this._range.w * factor,
			h : this._source.x + this._range.h * factor
		};
	};

	var TransformLinearInterpolator = function(source, dest, easingFunc) {
		this._source = TransformHelper.unmatrix(source);
		this._dest = TransformHelper.unmatrix(dest);
		this._range = {
			tx : this._dest.tx - this._source.tx,
			ty : this._dest.ty - this._source.ty,
			sx : this._dest.sx - this._dest.sx,
			sy : this._dest.sy - this._dest.sy,
			skew : this._dest.skew - this._source.skew,
			rotate : this._dest.rotate - this._source.rotate
		};
		this._easingFunc = easingFunc;
	};

	TransformLinearInterpolator.prototype.interpolateAt = function(pos) {
		var tmHelper = TransformHelper;
		var factor = this._easingFunc(pos);
		var tx = this._source.tx + this._range.tx * factor;
		var ty = this._source.ty + this._range.ty * factor;
		var sx = this._source.sx + this._range.sx * factor;
		var sy = this._source.sy + this._range.sy * factor;
		var skew = this._source.skew + this._source.skew * factor;
		var rotate = this._source.rotate + this._source.rotate * factor;
		return tmHelper.makeScaleTM(sx, sy, tmHelper.makeSkewTM(skew, skew, tmHelper.makeRotateTM(rotate, tmHelper
				.makeTranslateTM(tx, ty))));

	};

	var InterpolatorFactory = {
		getInterpolator : function(type, source, dest, easing) {
			switch (type) {
			case 'POINT':
				return new PointLinearInterpolator(source, dest, easing);
			case 'RECT':
				return new RectLinearInterpolator(source, dest, easing);
			case 'FLOAT':
				return new FloatLinearInterpolator(source, dest, easing);
			case 'COLOR':
				return new ColorLinearInterpolator(source, dest, easing);
			case 'TRANSFORM':
				throw new TransformLinearInterpolator(source, dest, easing);
			default:
				throw new Error('Unknown type for interpolation');
			}
		}
	};

	var JobState = {
		submitted : 0,
		running : 1,
		stopped : 2,
		paused : 3,
		cancelled : 4,
		aborted : 5
	};

	var AnimationJob = function(values, startWhen, endWhen, onStep, onComplete) {
		this._id = taskId();
		this._state = JobState.submitted;
		this._values = values;
		this._startWhen = startWhen;
		this._pauseWhen = 0;
		this._resumeWhen = 0;
		this._endWhen = endWhen;
		this._duration = endWhen - startWhen;
		this._onStep = onStep;
		this._onComplete = onComplete;
	};

	/**
	 * Singleton object for animating value(s) during a period of time
	 * 
	 * @name sap.riv.core.Animator
	 * @class
	 */
	var Animator = (function() {
		var _jobQueue = new LinkedHashMap();
		var _fps = 50;
		var _interval = 20;
		var _timer = false;
		var _processAnimStep = function(animJob, animTimePassed) {
			var interpolatePos = animTimePassed / animJob._duration;
			var stepValues = [];
			for ( var i = 0, value, values = animJob._values, len = values.length; i < len; i++) {
				value = values[i];
				stepValues.push(value.interpolator.interpolateAt(interpolatePos));
			}
			animJob._onStep(stepValues);
		};
		var _processingTask = function(animJob, nextState, currentTime) {
			switch (animJob._state) {
			case JobState.submitted:
				switch (nextState) {
				case JobState.running:
					if (currentTime >= animJob._startWhen) {
						animJob._state = JobState.running;
						var animTimePassed = Math.min(currentTime - animJob._startWhen - animJob._resumeWhen
								+ animJob._pauseWhen, animJob._duration);
						_processAnimStep(animJob, animTimePassed);
					}
					break;
				case JobState.stopped:
					animJob._state = JobState.stopped;
					_processAnimStep(animJob, animJob._duration);
					animJob._onComplete();
					break;
				case JobState.aborted:
					animJob._state = JobState.aborted;
					break;
				case JobState.cancelled:
					animJob._state = JobState.cancelled;
					break;
				}
				break;
			case JobState.running:
				switch (nextState) {
				case JobState.running:
					if (currentTime < animJob._endWhen + animJob._resumeWhen - animJob._pauseWhen) {
						var animTimePassed = currentTime - animJob._startWhen - animJob._resumeWhen
								+ animJob._pauseWhen;
						_processAnimStep(animJob, animTimePassed);
					} else {
						animJob._state = JobState.stopped;
						_processAnimStep(animJob, animJob._duration);
						animJob._onComplete();
					}
					break;
				case JobState.paused:
					animJob._state = JobState.Paused;
					animJob._pauseWhen = currentTime;
					break;
				case JobState.stopped:
					animJob._state = JobState.stopped;
					_processAnimStep(animJob, animJob._duration);
					animJob._onComplete();
					break;
				case JobState.aborted:
					animJob._state = JobState.aborted;
					break;
				case JobState.cancelled:
					animJob._state = JobState.cancelled;
					_processAnimStep(animJob, 0);
					break;
				}
				break;
			case JobState.paused:
				switch (nextState) {
				case JobState.running:
					animJob._resumeWhen = currentTime;
					animJob._state = JobState.running;
					break;
				case JobState.stopped:
					animJob._state = JobState.stopped;
					_processAnimStep(animJob, animJob._duration);
					animJob._onComplete();
					break;
				case JobState.aborted:
					animJob._state = JobState.aborted;
					break;
				case JobState.cancelled:
					animJob._state = JobState.cancelled;
					_processAnimStep(animJob, 0);
					break;
				}
				break;
			break;
		}
	}	;
		var _processor = function() {
			var _currentTime = (new Date()).getTime();
			var _jobItr = _jobQueue.getIterator();
			var _job;
			var _finJobs = [];
			while (_jobItr.hasMore()) {
				_job = _jobItr.nextValue();
				if (_job._state === JobState.submitted || _job._state === JobState.running) {
					_processingTask(_job, JobState.running, _currentTime);
				}
				if (_job._state === JobState.aborted || _job._state === JobState.cancelled
						|| _job._state === JobState.stopped) {
					_finJobs.push(_job._id);
				}
			}
			for ( var i = 0, len = _finJobs.length; i < len; i++) {
				_jobQueue.remove(_finJobs[i]);
			}
			if (!_jobQueue.isEmpty()) {
				_schedualProcessing();
			} else {
				_timer = false;
			}
		};
		var _schedualProcessing = function() {
			_timer = setTimeout(_processor, _interval);
		};
		return {
			/**
			 * Set or Get the frame ratio for the animator, default is 50fps.
			 * 
			 * @param [Integer]
			 *            fps the frame ratio, the valid range is (0, 100]
			 * @returns [Integer|this] the current frame ratio or this object to
			 *          allow chaining function call
			 */
			fps : function(fps) {
				if (fps !== undefined) {
					if (fps !== _fps && fps > 0 && fps <= 100) {
						_fps = fps;
						_interval = Math.ceil(1000 / fps);
					}
					return this;
				}
				return _fps;
			},
			/**
			 * Submit a value animation job, the job definition has the
			 * following variants
			 * 
			 * <pre>
			 * {
			 *     values : [
			 *                  {
			 *                      type : 'POINT' | 'RECT' | 'FLOAT' | 'TRANSFORM' | 'COLOR',
			 *                      from : POINT | RECT | FLOAT | TRANSFORM | COLOR,
			 *                      to : POINT | RECT | FLOAT | TRANSFORM | COLOR
			 *                  },
			 *                  ...
			 *              ], //The values to be animated.
			 *     duration : DURATION, //The duration setting for this animation, see duration setting for details.
			 *     easing : 'Linear' | 'EaseIn' | 'EaseOut' | 'EaseInOut' | [ POINT, POINT ], //The easing type of this animation, there are four built-in types. You can also pass an array of two points to define custom esing function.
			 *     onStep : Function, //This function will be called during animation with array of current interpolated values as its argument, the values will preserve the same order as the definition.
			 *     onComplete : Function, //This function will be called when complete normally or immediately(force to stop).
			 * } // Multiple Values Animation Definition
			 * </pre>
			 * 
			 * The <b>Duration</b> setting comes with 3 flavors as follows:
			 * 
			 * <pre>
			 * 1) Integer: The animation will start immediately and with the number in millisecond as duration.
			 * </pre>
			 * <pre>
			 * 2)
			 * {
			 *    startWhen : Integer, millisecond since epoch.
			 *    duration : Integer, the number in millisecond as duration.
			 * }
			 * </pre>
			 * <pre>
			 * 3)
			 * {
			 *    startWhen : Integer, millisecond since epoch.
			 *    endWhen : Integer, millisecond since epoch, must greater than startWhen
			 * }
			 * </pre>
			 * 
			 * @param {Object}
			 *            animation the animation job definition
			 * @return {String} id of the job, you can use the job id to
			 *         manipulate the on-going job. The job id will be
			 *         invalidated silently after the animation finishing.
			 */
			animate : function(animation) {
				var dur = animation.duration;
				var startWhen, endWhen;
				var animValues = [];
				var easingFunc = TimingFunctionFactory.getTimingFunction(animation.easing || 'Linear');
				for ( var i = 0, v, len = animation.values.length; i < len; i++) {
					v = animation.values[i];
					animValues.push({
						type : v.type,
						from : v.from,
						to : v.to,
						interpolator : InterpolatorFactory.getInterpolator(v.type, v.from, v.to, easingFunc)
					});
				}
				if (TypeUtils.isNumber(dur) && dur > 0) {
					startWhen = (new Date()).getTime();
					endWhen = startWhen + dur;
				} else {
					startWhen = dur.startWhen;
					if (dur.hasOwnProperty('duration')) {
						endWhen = startWhen + dur.duration;
					} else {
						endWhen = dur.endWhen;
					}
				}
				var animJob = new AnimationJob(animValues, startWhen, endWhen, animation.onStep
						|| FuncUtils.noop, animation.onComplete || FuncUtils.noop);
				_jobQueue.add(animJob._id, animJob);
				if (!_timer) {
					_schedualProcessing();
				}
				return animJob._id;
			},
			/**
			 * About a given job. If the job has been done, canceled or aborted,
			 * nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			abortAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.aborted, (new Date()).getTime());
				}
			},
			/**
			 * Pause a given job. If the job has been done, canceled or aborted,
			 * nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			pauseAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.paused, (new Date()).getTime());
				}
			},
			/**
			 * Resume a given job. If the job has been done, canceled or
			 * aborted, nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			resumeAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.running, (new Date()).getTime());
				}
			},
			/**
			 * Cancel a given job. If the job has been done, canceled or
			 * aborted, nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			cancelAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.cancelled, (new Date()).getTime());
				}
			},

			/**
			 * Abort the animator execution, all the running jobs will be
			 * aborted as well.
			 * 
			 */
			abortAll : function() {
				var _job,
					_jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.aborted, (new Date()).getTime());
				}
			},
			/**
			 * Pause the animator execution, all the running jobs will be paused
			 * as well.
			 * 
			 */
			pauseAll : function() {
				var _job,
				    _jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.paused, (new Date()).getTime());
				}
			},
			/**
			 * Resume the animator execution, all the paused jobs will be
			 * resumed as well.
			 * 
			 */
			resumeAll : function() {
				var _job,
				    _jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.running, (new Date()).getTime());
				}
			},
			/**
			 * Cancel the animator execution, all the running jobs will be
			 * cancelled as well.
			 * 
			 */
			cancelAll : function() {
				var _job,
				    _jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.cancelled, (new Date()).getTime());
				}
			}
		};
	})();
	return Animator;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Represents a group of arbitrary number of chart series, usually wrapped
	 * in a chart instance.
	 */
	var seriesGroup = function() {
		/** Stores a number of plot series */
		this._seriesList = [];
	};

	seriesGroup.prototype = {
		/**
		 * Adds a plot series.
		 * 
		 * @param {Object}
		 *            [series] - Instance of the <code>Series</code> object
		 */
		addSeries : function(series) {
			this._seriesList.push(series);
		},

		/**
		 * Returns the list of plot series.
		 * 
		 * @returns {Array} Series list
		 */
		getSeriesList : function() {
			return this._seriesList;
		},

		updateProperties : function(props) {
			var seriesList = this._seriesList;
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				seriesList[i].updateProperties(props[i]);
			}
		}
	};

	return seriesGroup;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, LOG) {
    /**
     * Props Manager which accepts an initial propbag and encapsulate property
     * update logic, all supported property values are
     * String/Number/boolean/function
     * 
     * <pre>
     * e.g. initial propbag is:
     * {
     *      title: {
     *          main:{
     *              text:
     *              font:
     *              color:
     *          },
     *          sub:{
     *              text:
     *              font:
     *              color:
     *          }
     *      },
     *      measures:[
     *          {
     *              color: '',
     *              property_o:{
     *                  p_n: ''
     *              }
     *          },{
     *              color: '',
     *              property_o:{
     *                  p_n:
     *              }
     *          }
     *      ]
     * }
     * </pre>
     * 
     * to update it, we can pass: {title:{sub:{font:}}} to update font value of
     * property title/sub. for updating array values, see VISUAL-1205
     */
    var props =  function(descriptor) {
        this._descriptor = descriptor;
        this._local = {};
    };
    
    var propsPro = props.prototype;
    
    /**
     * 
     * @param propBag
     *            json object
     * 
     * If validation failed, an exception will be thrown. If some property is
     * defined in descriptor but not in user's property, default value should 
     * be used to replace user's.
     */
    propsPro.validate = function(propBag) {
        var result = {};
        var props = ObjUtils.extend(true, {}, propBag);
        for (var iname in this._descriptor) {
            if (this._descriptor.hasOwnProperty(iname)) {
                result[iname] = this.validateObject(props[iname], this._descriptor[iname]);
            }
        }
        return result;
    };

    /**
     * 
     * @param props
     *            chart properties object
     * @param propsDescriptor
     *            chart properties description
     * 
     * For all the inner properties, we should validate it and keep it
     * consistent with chart description contract. if not, throw a validation
     * exception
     */
    propsPro.validateObject = function(props, propsDescriptor) {
        var result;
        if(propsDescriptor.supportedValueType === 'Object') {
            result = {};
            if(!TypeUtils.isExist(props)) {
                props = {};
            }
            //validation the type of props, if it is not object, throw exception
            else if(typeof(props) != 'object'){
            	//throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
            }
            var supportedValues = propsDescriptor.supportedValues;
            for(var i = supportedValues.length; i--; ) {
                var iname = supportedValues[i].name;
                result[iname] = this.validateObject(props[iname], supportedValues[i]);
            }
        } else if(propsDescriptor.supportedValueType === 'ObjectArray'){
			result = [];
            if(!TypeUtils.isExist(props)) {
                props = [];
            }
           //validation the type of props, if it is not array, throw exception
            else if(!TypeUtils.isArray(props)){
            	//throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
            }
            var supportedValues = propsDescriptor.supportedValues;
            for(var i = props.length; i--; ) {
				result[i] = {};
                result[i] = this.validateObject(props[i], supportedValues[0]);
            }
		} else {
            result = this.validateItem(props, propsDescriptor);
        }
        return result;
    };
    
    propsPro.validateItem = function(props, propsDescriptor) {
        var type;
        // we should deal with the type that contain [], like
        // IntArray[4]
        // check the length and check the inner properties.
        if(propsDescriptor.supportedValueType.indexOf('[') != -1) {
            // get the length of this type. if the length is
            // not equal than the requirement, then failed to check
            // the propertie.
            var len = propsDescriptor.supportedValueType.substring(propsDescriptor.supportedValueType.indexOf('[') + 1, propsDescriptor.supportedValueType.indexOf(']'));
            //if(TypeUtils.isArray(props) && props.length !== parseInt(len))
            	//throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);

            if(propsDescriptor.supportedValueType.indexOf('IntArray') != -1) {
                // It is int array type
                type = 'IntArray';
            } else if(propsDescriptor.supportedValueType.indexOf('ColorArray') != -1) {
                // it is color array type.
                type = 'ColorArray';
            }

        } else {
            type = propsDescriptor.supportedValueType;
        }

        /*
        switch (type) {
            case 'Int':
                if(!this.validateInt(props, propsDescriptor))
                    throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'PositiveInt':
                if(!this.validatePositiveInt(props, propsDescriptor))
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'Number':
                if(!this.validateNumber(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'String':
                if(!this.validateString(props, propsDescriptor))
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'Color':
                if(!this.validateColor(props, propsDescriptor))
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'Boolean':
                if(!this.validateBoolean(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'Font':
                if(!this.validateFont(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'List':
                if(!this.validateList(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'StringArray':
                if(!this.validateStringArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'ObjectArray':
                if(!this.validateObjectArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'IntArray':
                if(!this.validateIntArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'ColorArray':
                if(!this.validateColorArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
            case 'Function':
            	if(!this.validateFunction(props, propsDescriptor)){
            		throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
            	}
            default:
                break;
        }
        */
        
        
        if (!TypeUtils.isExist(props)) {
            props = propsDescriptor.defaultValue;
        }
        return props;
    };


    
    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * special case: ignore the null and undefined value. we will create a
     * regular expression to test the property whether it is an Int. if not,
     * return false.
     */
    propsPro.validateInt = (function() {
    	var reg = new RegExp(/^-?\d+$/);
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return (!TypeUtils.isString(props)&&TypeUtils.isNumber(props)&&reg.test(props))| props === Number.POSITIVE_INFINITY | props === Number.NEGATIVE_INFINITY;
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not large than 0, return false;
     */
    propsPro.validatePositiveInt = (function() {
        var reg = new RegExp(/^(0|[1-9][0-9]*)$/);
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return  (!TypeUtils.isString(props)&&TypeUtils.isNumber(props)&&reg.test(props))| props === Number.POSITIVE_INFINITY;
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not less than 0, return false;
     */
    propsPro.validateNegativeInt = (function() {
        var reg = new RegExp(/^\-[1-9][0-9]*$/);
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return  (!TypeUtils.isString(props)&&TypeUtils.isNumber(props)&&reg.test(props))|props === Number.NEGATIVE_INFINITY;
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a number, return false;
     */
    propsPro.validateNumber = function(props, propsDescriptor) {
        return !TypeUtils.isString(props)&&TypeUtils.isNumber(props);
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a boolean, return false;
     */
    propsPro.validateBoolean = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        return props === true | props === false;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a string, return false;
     */
    propsPro.validateString = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        return TypeUtils.isString(props);
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a valid color string, return false;
     */
    propsPro.validateColor = (function() {
    	var hexReg = new RegExp(/(^#[0-9a-fA-F]{6}$)|(^#[0-9a-fA-F]{3}$)/);
        var rgbReg = new RegExp("^[rR][gG][Bb][\\s]*[\(]([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){2}[\\s]*(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)[\\s]*[\)]{1}$");
        var rgbaReg = new RegExp("^[rR][gG][Bb][Aa][\\s]*[\(]([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){3}[\\s]*(1|0.[0-9]*)[\\s]*[\)]{1}$");
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return hexReg.test(props)|rgbReg.test(props)|rgbaReg.test(props);
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * Font style only two format: 
     *  1. fontWeight + fontSize + fontFamily
     *  2. fontSize + fontFamily
     */
    propsPro.validateFont = (function() {
        var fontWeighRreg = new RegExp('^bold$|^normal$|^bolder$|^lighter$|^100$|^200$|^300$|^400$|^500$|^600$|^700$|^800$|^900$');
        var fontSizeReg = new RegExp('^\\d{1,9}\\d(px|pt|em)?$');
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            //trim the props value, as we may get the size 3 like ' 16px Arial'.
            //props = props.replace(/^\s+|\s+$/g,"");
            props = props.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); //The regular expression is more faster than the above one.
            var infs = props.split(' ');
            //If the font size is large than 3, means it do not meet the format of font style
            if(infs.length < 2){
                return false;
            }else if(infs.length >= 2){
            	if(fontSizeReg.test(infs[0])){
            		//FontStyle format: fontSize + fontFamily
            		
            		//Ian To be implement, as in font style, it may like this 14px Arial, Helvetica, it has three element, the the last two is font family,
                    //now only check the combination value of last two is whether or not string.
                	var fontFamily;
                	for(var i=1, len = infs.length; i<len; i++){
                		fontFamily += infs[i];
                	}
                	
                	return this.validateString(fontFamily);
            	}else{
            		 //Ian To be implement, as in font style, it may like this bold 14px Arial, Helvetica, it has four element, the the last two is font family,
                    //now only check the combination value of last two is whether or not string.
                	var fontFamily;
                	for(var i=2, len = infs.length; i<len; i++){
                		fontFamily += infs[i];
                	}
                    return fontWeighRreg.test(infs[0]) && fontSizeReg.test(infs[1]) && this.validateString(fontFamily);
            	}
            }
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the props. If it is in supported list, return true, else return false;
     */
    propsPro.validateList = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        var supportedValues = propsDescriptor.supportedValues;
        for ( var i = supportedValues.length; i--;) {
            if (supportedValues[i] === props)
                return true;
        }
        return false;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the inner values of array, it all the values in array is string, return true, else return false;
     */
    propsPro.validateStringArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateString(props[i], null))
                return false;
        }
        return true;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * validate the inner properties in object.
     */
    propsPro.validateObjectArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateObject(props[i], propsDescriptor))
                return false;
        }
        return true;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the properties in array. If all value is int, return true, else return false;
     */
    propsPro.validateIntArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateInt(props[i], null))
                return false;
        }
        return true;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the values in array, if all meet the format of color, return true, else return false;
     */
    propsPro.validateColorArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateColor(props[i], null))
                return false;
        }
        return true;
    };
    
    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * if the props is undefined and Fcuntion, return true. Otherwise, return false.
     */
    propsPro.validateFunction = function(props, propsDescriptor){
    	  if (!TypeUtils.isExist(props))
              return true;
    	  return TypeUtils.isFunction(props);
    };
    
    propsPro.properties = function(propBag) {
        if (propBag) {
            propBag = ObjUtils.extend(true, this._local, propBag);
            this._local = this.validate(propBag);
        }
        return ObjUtils.extend(true, {}, this._local);
    };

    /**
     * TODO add unit test: var p = new
     * sap.riv.viz.shared.misc.PropsMgr({title:{main:{color:'#11ddff','text':'default
     * title'},sub:{color:'#aaddff','text':'default sub'}},
     * measures:[{color:'#2233dd',render:{type:'bar',
     * width:5}},{color:'#112233', render:{type:'line', width:4}}]});
     * p.properties({title:{main:{text:'changed title'}}});
     * p.properties({title:{main:{text:'changed title'},sub:{color:'changed
     * color', text:'changed sub title'}}});
     * p.properties({title:{main:{text:'changed title 111'}},
     * measures:[{color:'changed color', render:{type:'changed type'}}]});
     */
    return props;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, Drawable, Math) {
	/**
	 * This class defines Line
	 * 
	 * @name sap.riv.graphics.shape.Line
	 * @class
	 * @augments sap.riv.graphics.Drawable
	 */
	var Line = ObjectUtils.derive(Drawable, {
		constructor : function(metadata) {
			this._start = {
				x : 0,
				y : 0
			};
			this._end = {
				x : 0,
				y : 0
			};
			this._width = 1.0;
			this._capStyle = 'butt';
			this._color = '#000000';
		},

		_calcForHitTest : function(startPoint, endPoint, width) {
			this._preCalc = {
				A : (endPoint.y - startPoint.y),
				B : (startPoint.x - endPoint.x),
				C : startPoint.y * endPoint.x - startPoint.x * endPoint.y,
				D : Math.sqrt((endPoint.y - startPoint.y) * (endPoint.y - startPoint.y) + (startPoint.x - endPoint.x)
						* (startPoint.x - endPoint.x)),
				delta : width > 2.0 ? width / 2.0 : 1.0
			};
		},

		/**
		 * Get or set the start position of the line segment, The default start
		 * position is {0,0}.
		 * 
		 * @name sap.riv.graphics.shape.Line#from
		 * @function
		 * @param {POINT}
		 *            startPosition the x,y coordinates of the start position
		 * @returns {this|POINT}
		 */
		from : function(startPosition) {
			if (startPosition !== undefined) {
				this._start.x = startPosition.x;
				this._start.y = startPosition.y;
				this._calcForHitTest(startPosition, this._end, this._width);
				return this;
			}
			return {
				x : this._start.x,
				y : this._start.y
			};
		},
		/**
		 * Get or set the end position of the line segment, The default end
		 * position is {0,0}.
		 * 
		 * @name sap.riv.graphics.shape.Line#to
		 * @function
		 * @param {POINT}
		 *            endPosition the x,y coordinates of the end position
		 * @returns {this|POINT}
		 */
		to : function(endPosition) {
			if (endPosition !== undefined) {
				this._end.x = endPosition.x;
				this._end.y = endPosition.y;
				this._calcForHitTest(this._start, endPosition, this._width);
				return this;
			}
			return {
				x : this._end.x,
				y : this._end.y
			};
		},

		/**
		 * Get or set the color of the line segment, the default color is
		 * #000000, the color setting should be CSSColor serialized string or as
		 * follow to define gradient
		 * 
		 * <pre>
		 * {
		 *      t: 'lg'|'rg', //line gradient or radial gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.Line#color
		 * @function
		 * @param {CSSColor|Object}
		 *            lineColor the line segment color setting
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		color : function(lineColor) {
			if (lineColor != undefined) {
				this._color = CanvasHelper.createColorStyle(lineColor);
				return this;
			}
			return this._color;
		},

		/**
		 * Get or set the width of the line segment, the width should be greater
		 * or equal than 1.0. The default width is 1.0
		 * 
		 * @name sap.riv.graphics.shape.Line#width
		 * @function
		 * @param {Number}
		 *            lineWidth the width of the line segment
		 * @returns {this|Number}
		 */
		width : function(lineWidth) {
			if (lineWidth != undefined) {
				if (lineWidth >= 1.0) {
					this._width = lineWidth;
					this._calcForHitTest(this._start, this._end, lineWidth);
				}
				return this;
			}
			return this._width;
		},

		/**
		 * Get or set the cap style of the line segment, the default style is
		 * butt, the available styles are butt, square, round.
		 * 
		 * @name sap.riv.graphics.shape.Line#cap
		 * @function
		 * @param {String}
		 *            capStyle the line segment cap style
		 * @returns {this|String}
		 */
		cap : function(capStyle) {
			if (capStyle != undefined) {
				this._capStyle = capStyle;
				return this;
			}
			return this._capStyle;
		},

		/**
		 * Draws the line to canvas.
		 * Caution: If the layer to which the line is added starts at a coordination 
		 * whose x and y are both integers, SDK will perform crisp line optimization 
		 * when line width is an odd number.
		 * 
		 * @name sap.riv.graphics.shape.Line#doDraw
		 * @param {DrawingContext}
		 *            the drawing context for drawing
		 */
		doDraw : function(drawingContext) {
			// Add crisp line optimization
        	var xEquals = (this._start.x === this._end.x);
        	var yEquals = (this._start.y === this._end.y);
        	
        	// If the line to draw is horizontally or vertically straight
        	if(xEquals || yEquals){ 
        		if(xEquals){
        			this._start.x = this._end.x = Math.floor(this._start.x);
        			
        			if(this._width%2 === 1){
        				this._start.x = this._end.x = this._start.x+0.5;
        			}
        			
        			this._start.y = Math.round(this._start.y);
        			this._end.y = Math.round(this._end.y);
        		} 
        		
        		if(yEquals){
        			this._start.y = this._end.y = Math.floor(this._start.y);
        			
        			if(this._width%2 === 1){
        				this._start.y = this._end.y = this._start.y+0.5;
        			}
        			
        			this._start.x = Math.round(this._start.x);
        			this._end.x = Math.round(this._end.x);
        		}
        	}
        	
			var dCtx = drawingContext;
			dCtx.setLineWidth(this._width);
			dCtx.setLineCap(this._capStyle);
			dCtx.setStrokeStyle(this._color);
			dCtx.beginPath();
			dCtx.moveTo(this._start.x, this._start.y);
			dCtx.lineTo(this._end.x, this._end.y);
			dCtx.stroke();
		},

		doPointInTest : function(point) {
			var pc = this._preCalc;
			var x = point.x;
			var y = point.y;
			var s = this._start;
			var e = this._end;
			if (s.x == e.x) {
				// perpendicular line
				return (Math.abs(x - s.x) < pc.delta) && ((s.y < y && y < e.y) || (s.y > y && y > e.y));
			}
			return ((s.x < x && x < e.x) || (s.x > x && x > e.x))
					&& Math.abs((pc.A * x + pc.B * y + pc.C) / pc.D) < pc.delta;
		}
	});
	return Line;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var pCalculator = function() {
	};

	// --------------------------------------------------------------------------
	// static Methods
	// --------------------------------------------------------------------------

	/**
	 * The position calculation function that should be used in most cases. It
	 * determines the position based on the bounds of the axis, the actual data,
	 * the size of the axis, the line scaling, and whether the value should be a
	 * percentage.
	 * 
	 * @param currentData
	 *            a particular value whose position should be determined
	 * @param minValue
	 *            the minimum value of the target axis
	 * @param maxValue
	 *            the maximum value of the target axis
	 * @param distance
	 *            the length of the target axis
	 * @param scaling
	 *            the line scaling of the target axis (linear, logarithmic,
	 *            etc.)
	 * @param percentage
	 *            a flag for whether the value will be a percentage or not
	 * @return the position in pixels on the axis in which the item should
	 *         appear
	 */
	pCalculator.calculateStandardPosition = function(currentData, minValue,
			maxValue, distance, scaling, percentage) {

		var position = 0;
		if (scaling == 'linear') {
			var multiplier = pCalculator.generateLinearMultiplier(minValue,
					maxValue, distance);
			position = pCalculator.calculateLinearPosition(currentData,
					multiplier, minValue);
		} else {
			var multiplier = pCalculator.generateLogarithmicMultiplier(
					minValue, maxValue, distance);
			if (percentage)
				currentData *= 100;
			if (currentData <= 0)
				currentData = 1;

			position = pCalculator.calculateLogarithmicPosition(currentData,
					multiplier, minValue);
		}

		return pCalculator.validatePosition(position, distance, true);
	};

	/**
	 * Generates a conversion multiplier between values and actual pixel
	 * positions on a linear scale.
	 * 
	 * @param minValue
	 *            the minimum value of the target axis
	 * @param maxValue
	 *            the maximum value of the target axis
	 * @param distance
	 *            the length of the target axis
	 * @return a value to use for converting between data values and pixel
	 *         positions
	 */
	pCalculator.generateLinearMultiplier = function(minValue, maxValue,
			distance) {
		return distance / (maxValue - minValue);
	};

	/**
	 * Using a multiplier, determines the position of a data value based on the
	 * minimum value of the target axis on a linear scale.
	 * 
	 * @param value
	 *            the value whose position should be determined
	 * @param multiplier
	 *            the Number used to convert from the value to a position
	 * @param minValue
	 *            the minimum value of the target axis
	 * @return the position of the data value
	 */
	pCalculator.calculateLinearPosition = function(value, multiplier, minValue) {
		return multiplier * (value - minValue);
	};

	/**
	 * The inverse of <code>calculateLinearPosition</code>
	 * 
	 * @param position
	 *            the position whose value should be calculated
	 * @param multiplier
	 *            the Number used to convert from the value to a position
	 * @param minValue
	 *            the minimum value of the target axis
	 * 
	 * @return the data value of the position
	 * 
	 * @see calculateLinearPosition
	 */
	pCalculator.calculateLinearValue = function(position, multiplier, minValue) {
		return (position / multiplier) + minValue;
	};

	/**
	 * Generates a conversion multiplier between values and actual pixel
	 * positions on a logarithmic scale.
	 * 
	 * @param minValue
	 *            the minimum value of the target axis
	 * @param maxValue
	 *            the maximum value of the target axis
	 * @param distance
	 *            the length of the target axis
	 * @return a value to use for converting between data values and pixel
	 *         positions
	 */
	pCalculator.generateLogarithmicMultiplier = function(minValue, maxValue,
			distance) {
		if (minValue <= 0) {
			minValue = 1;
			if (maxValue <= minValue)
				maxValue = 2;
		}

		var minLog = Math.log(minValue);
		var maxLog = Math.log(maxValue);

		return distance / (maxLog - minLog);
	};

	/**
	 * Using a multiplier, determines the position of a data value based on the
	 * minimum value of the target axis on a logarithmic scale.
	 * 
	 * @param value
	 *            the value whose position should be determined
	 * @param multiplier
	 *            the Number used to convert from the value to a position
	 * @param minValue
	 *            the minimum value of the target axis
	 * @return the position of the data value
	 */
	pCalculator.calculateLogarithmicPosition = function(value, multiplier,
			minValue) {
		if (value == 0 || minValue == 0)
			return 0;
		return multiplier * (Math.log(value) - Math.log(minValue));
	};

	/**
	 * Checks if the position is invalid (NaN) or outside of the bounds and sets
	 * it to zero or the maximum distance.
	 * 
	 * @param position
	 *            the desired position
	 * @param distance
	 *            the length of the target axis
	 * @param invalidToZero
	 *            if invalid, go to zero. otherwise, go to distance
	 * @return a valid position in the range of the axis
	 */
	pCalculator.validatePosition = function(position, distance, invalidToZero) {

		if (position < 0)
			position = 0;
		else if (position > distance)
			position = distance;
		if (TypeUtils.isNaN(position)) {
			if (invalidToZero)
				position = 0;
			else
				position = distance;
		}
		return position;
	};

	return pCalculator;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.DrawableRect',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.ClosedShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, ClosedShape, Math) {
	/**
	 * Abstract super class for all rect-bounded shape.
	 * 
	 * @name sap.riv.graphics.shape.DrawableRect
	 * @class
	 * @augments sap.riv.graphics.shape.ClosedShape
	 */
	var DrawableRect = ObjectUtils.derive(ClosedShape, {
		constructor : function() {
			this._anchor = 'tl';
			this._width = 0;
			this._height = 0;
			this._cornerRadius = 0;
			this._vtx = [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ];// tl,tr,br,bl
		},

		_calcVertices : function(anchor, position) {
			var p = position;
			var vtx = this._vtx;
			var width = this._width;
			var height = this._height;
			switch (anchor) {
			case 'tl':
				vtx[0][0] = p[0];
				vtx[0][1] = p[1];
				vtx[1][0] = p[0] + width;
				vtx[1][1] = p[1];
				vtx[2][0] = p[0] + width;
				vtx[2][1] = p[1] + height;
				vtx[3][0] = p[0];
				vtx[3][1] = p[1] + height;
				break;
			case 'tc':
				vtx[0][0] = p[0] - width / 2;
				vtx[0][1] = p[1];
				vtx[1][0] = p[0] + width / 2;
				vtx[1][1] = p[1];
				vtx[2][0] = p[0] + width / 2;
				vtx[2][1] = p[1] + height;
				vtx[3][0] = p[0] - width / 2;
				vtx[3][1] = p[1] + height;
				break;
			case 'tr':
				vtx[0][0] = p[0] - width;
				vtx[0][1] = p[1];
				vtx[1][0] = p[0];
				vtx[1][1] = p[1];
				vtx[2][0] = p[0];
				vtx[2][1] = p[1] + height;
				vtx[3][0] = p[0] - width;
				vtx[3][1] = p[1] + height;
				break;
			case 'rc':
				vtx[0][0] = p[0] - width;
				vtx[0][1] = p[1] - height / 2;
				vtx[1][0] = p[0];
				vtx[1][1] = p[1] - height / 2;
				vtx[2][0] = p[0];
				vtx[2][1] = p[1] + height / 2;
				vtx[3][0] = p[0] - width;
				vtx[3][1] = p[1] + height / 2;
				break;
			case 'br':
				vtx[0][0] = p[0] - width;
				vtx[0][1] = p[1] - height;
				vtx[1][0] = p[0];
				vtx[1][1] = p[1] - height;
				vtx[2][0] = p[0];
				vtx[2][1] = p[1];
				vtx[3][0] = p[0] - width;
				vtx[3][1] = p[1];
				break;
			case 'bc':
				vtx[0][0] = p[0] - width / 2;
				vtx[0][1] = p[1] - height;
				vtx[1][0] = p[0] + width / 2;
				vtx[1][1] = p[1] - height;
				vtx[2][0] = p[0] + width / 2;
				vtx[2][1] = p[1];
				vtx[3][0] = p[0] - width / 2;
				vtx[3][1] = p[1];
				break;
			case 'bl':
				vtx[0][0] = p[0];
				vtx[0][1] = p[1] - height;
				vtx[1][0] = p[0] + width;
				vtx[1][1] = p[1] - height;
				vtx[2][0] = p[0] + width;
				vtx[2][1] = p[1];
				vtx[3][0] = p[0];
				vtx[3][1] = p[1];
				break;
			case 'lc':
				vtx[0][0] = p[0];
				vtx[0][1] = p[1] - height / 2;
				vtx[1][0] = p[0] + width;
				vtx[1][1] = p[1] - height / 2;
				vtx[2][0] = p[0] + width;
				vtx[2][1] = p[1] + height / 2;
				vtx[3][0] = p[0];
				vtx[3][1] = p[1] + height / 2;
				break;
			case 'c':
				vtx[0][0] = p[0] - width / 2;
				vtx[0][1] = p[1] - height / 2;
				vtx[1][0] = p[0] + width / 2;
				vtx[1][1] = p[1] - height / 2;
				vtx[2][0] = p[0] + width / 2;
				vtx[2][1] = p[1] + height / 2;
				vtx[3][0] = p[0] - width / 2;
				vtx[3][1] = p[1] + height / 2;
				break;
			}
		},

		_adjustVertices : function() {
			var vtx = this._vtx;
			var w = vtx[1][0] - vtx[0][0];
			var h = vtx[3][1] - vtx[0][1];
			switch (this._anchor) {
			case 'tl':
				this._calcVertices('tl', vtx[0]);
				break;
			case 'tc':
				this._calcVertices('tc', [ vtx[0][0] + w / 2, vtx[0][1] ]);
				break;
			case 'tr':
				this._calcVertices('tr', vtx[1]);
				break;
			case 'rc':
				this._calcVertices('rc', [ vtx[1][0], vtx[1][1] + h / 2 ]);
				break;
			case 'br':
				this._calcVertices('br', vtx[2]);
				break;
			case 'bc':
				this._calcVertices('bc', [ vtx[2][0] - w / 2, vtx[2][1] ]);
				break;
			case 'bl':
				this._calcVertices('bl', vtx[3]);
				break;
			case 'lc':
				this._calcVertices('lc', [ vtx[3][0], vtx[3][1] - h / 2 ]);
				break;
			case 'c':
				this._calcVertices('c', [ vtx[0][0] + w / 2, vtx[0][1] + h / 2 ]);
				break;
			}
			this._cornerRadius = Math.min(this._width / 2, this._height / 2, this._cornerRadius);
		},

		/**
		 * Get or set the width of the rectangle area, the width should be
		 * greater zero.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#width
		 * @function
		 * @param {Number}
		 *            width the rectangle bound width
		 * @returns {this|Number}
		 */
		width : function(width) {
			if (width !== undefined) {
				if (width > 0) {
					this._width = width;
					this._adjustVertices();
				}
				return this;
			}
			return this._width;
		},
		/**
		 * Get or set the height of the rectangle area, the height should be
		 * greater zero.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#height
		 * @function
		 * @param {Number}
		 *            height the rectangle bound height
		 * @returns {this|Number}
		 */
		height : function(height) {
			if (height !== undefined) {
				if (height > 0) {
					this._height = height;
					this._adjustVertices();
				}
				return this;
			}
			return this._height;
		},
		/**
		 * Get or set the top left corner position, and set the anchor to top
		 * left.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#topLeft
		 * @function
		 * @param {[x,y]}
		 *            tl top left corner coordinates
		 * @returns {this|[x,y]}
		 */
		topLeft : function(tl) {
			if (tl !== undefined) {
				this._anchor = 'tl';
				this._calcVertices('tl', tl);
				return this;
			}
			return {
				x : this._vtx[0][0],
				y : this._vtx[0][1]
			};
		},
		/**
		 * Get or set the top center corner position, and set the anchor to top
		 * center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#topCenter
		 * @function
		 * @param {[x,y]}
		 *            tc top center corner coordinates
		 * @returns {this|[x,y]}
		 */
		topCenter : function(tc) {
			if (tc !== undefined) {
				this._anchor = 'tc';
				this._calcVertices('tc', tc);
				return this;
			}
			return {
				x : this._vtx[0][0] + this._width / 2,
				y : this._vtx[0][1]
			};
		},
		/**
		 * Get or set the top right corner position, and set the anchor to top
		 * right.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#topRight
		 * @function
		 * @param {[x,y]}
		 *            tr top right corner coordinates
		 * @returns {this|[x,y]}
		 */
		topRight : function(tr) {
			if (tr !== undefined) {
				this._anchor = 'tr';
				this._calcVertices('tr', tr);
				return this;
			}
			return {
				x : this._vtx[1][0],
				y : this._vtx[1][1]
			};
		},
		/**
		 * Get or set the right center corner position, and set the anchor to
		 * right center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#rightCenter
		 * @function
		 * @param {[x,y]}
		 *            rc rignt center corner coordinates
		 * @returns {this|[x,y]}
		 */
		rightCenter : function(rc) {
			if (rc !== undefined) {
				this._anchor = 'rc';
				this._calcVertices('rc', rc);
				return this;
			}
			return {
				x : this._vtx[1][0],
				y : this._vtx[1][1] + this._height / 2
			};
		},
		/**
		 * Get or set the bottom right corner position, and set the anchor to
		 * bottom right.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#bottomRight
		 * @function
		 * @param {[x,y]}
		 *            br bottom right corner coordinates
		 * @returns {this|[x,y]}
		 */
		bottomRight : function(br) {
			if (br !== undefined) {
				this._anchor = 'br';
				this._calcVertices('br', br);
				return this;
			}
			return {
				x : this._vtx[2][0],
				y : this._vtx[2][1]
			};
		},
		/**
		 * Get or set the bottom center corner position, and set the anchor to
		 * bottom center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#bottomCenter
		 * @function
		 * @param {[x,y]}
		 *            bc bottom center corner coordinates
		 * @returns {this|[x,y]}
		 */
		bottomCenter : function(bc) {
			if (bc !== undefined) {
				this._anchor = 'bc';
				this._calcVertices('bc', bc);
				return this;
			}
			return {
				x : this._vtx[2][0] - this._width / 2,
				y : this._vtx[2][1]
			};
		},
		/**
		 * Get or set the bottom left corner position, and set the anchor to
		 * bottom left.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#bottomLeft
		 * @function
		 * @param {[x,y]}
		 *            bl bottom left corner coordinates
		 * @returns {this|[x,y]}
		 */
		bottomLeft : function(bl) {
			if (bl !== undefined) {
				this._anchor = 'bl';
				this._calcVertices('bl', bl);
				return this;
			}
			return {
				x : this._vtx[3][0],
				y : this._vtx[3][1]
			};
		},
		/**
		 * Get or set the left center corner position, and set the anchor to
		 * left center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#leftCenter
		 * @function
		 * @param {[x,y]}
		 *            lc left center corner coordinates
		 * @returns {this|[x,y]}
		 */
		leftCenter : function(lc) {
			if (lc !== undefined) {
				this._anchor = 'lc';
				this._calcVertices('lc', lc);
				return this;
			}
			return {
				x : this._vtx[3][0],
				y : this._vtx[3][1] - this._height / 2
			};
		},
		/**
		 * Get or set the center position, and set the anchor to center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#center
		 * @function
		 * @param {[x,y]}
		 *            c center coordinates
		 * @returns {this|[x,y]}
		 */
		center : function(c) {
			if (c !== undefined) {
				this._anchor = 'c';
				this._calcVertices('c', c);
				return this;
			}
			return {
				x : this._vtx[0][0] + this._width / 2,
				y : this._vtx[0][1] + this._height / 2
			};
		},
		/**
		 * Get or set the corner radius. Value should be greater or equals to
		 * zero. Zero means no rounded corner.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#cornerRadius
		 * @function
		 * @param {Number}
		 *            radius the corner radius
		 * @returns {this|Number}
		 */
		cornerRadius : function(radius) {
			if (radius !== undefined) {
				if (radius >= 0) {
					var minwh = Math.min(this._width / 2, this._height / 2);
					this._cornerRadius = radius > minwh ? minwh : radius;
				}
				return this;
			}
			return this._cornerRadius;
		},

		_antialiasForMin : function(s, t) {
			if (window.__IS_IN_RHINO == true) {
				return parseInt(t);
			}
			var tr = Math.round(t);
			var sr = Math.round(s);
			tr = tr + sr / 2;// ensure not exceeding the margin
			// for iOS only, line doesn't show up in 0.5 for width = 1
			if (tr == 0.5 && sr == 1)
				tr = 1.5;
			return tr;
		},
		
		_antialiasForMax : function(s, t) {
			if (window.__IS_IN_RHINO == true) {
				return parseInt(t);
			}
			var tr = Math.round(t);
			var sr = Math.round(s);
			tr = tr - sr / 2;// ensure not exceeding the margin
			// for iOS only, line doesn't show up in 0.5 for width = 1
			if (tr == 0.5 && sr == 1)
				tr = 1.5;
			return tr;
		},

		doDraw : function(drawingContext) {
			var vtx = this._vtx;
			var minx = vtx[0][0], midx = (vtx[0][0] + vtx[1][0]) / 2, maxx = vtx[1][0];
			var miny = vtx[0][1], midy = (vtx[0][1] + vtx[3][1]) / 2, maxy = vtx[3][1];
			// Antialiasing
			if (this.borderWidth() > 0) {
				var bdw = this.borderWidth();
				minx = this._antialiasForMin(bdw, minx);
				maxx = this._antialiasForMax(bdw, maxx);
				miny = this._antialiasForMin(bdw, miny);
				maxy = this._antialiasForMax(bdw, maxy);
			}
			else {
				minx = Math.round(minx);
				maxx = Math.round(maxx);
				miny = Math.round(miny);
				maxy = Math.round(maxy);
			}
			
			var dCtx = drawingContext;
			dCtx.save();
			dCtx.beginPath();
			if (this._cornerRadius > 0) {
				var radius = this._cornerRadius;
				dCtx.moveTo(minx, midy);
				dCtx.arcTo(minx, miny, midx, miny, radius);
				dCtx.arcTo(maxx, miny, maxx, midy, radius);
				dCtx.arcTo(maxx, maxy, midx, maxy, radius);
				dCtx.arcTo(minx, maxy, minx, midy, radius);
			} else {
				dCtx.moveTo(minx, miny);
				dCtx.lineTo(maxx, miny);
				dCtx.lineTo(maxx, maxy);
				dCtx.lineTo(minx, maxy);
			}
			dCtx.closePath();
			// Move the origin to the top-left corner of the rectangle
			dCtx.translate(minx, miny);
			this.drawInRect(dCtx);
			this.drawBorder(dCtx);
			dCtx.restore();
		},

		/**
		 * This method is intended to be overriden by subclass.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#drawInRect
		 * @function
		 * @param {DrawingContext}
		 *            drawingContext the current drawing context
		 */
		drawInRect : FunctionUtils.unimplemented,

		doPointInTest : function(point) {
			var x = point.x;
			var y = point.y;
			var vtx = this._vtx;
			return vtx[0][0] <= x && x <= vtx[2][0] && vtx[0][1] <= y && y <= vtx[2][1];
		}
	});
	return DrawableRect;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.RIVExCanvasMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(UADetector, RIVExCanvasMgr, Math) {
    var rvmlmgr = RIVExCanvasMgr;
    var hiddenCanvasCtx = undefined;
    var getHiddenCanvasCtx = function() {
        if(hiddenCanvasCtx) {
            return hiddenCanvasCtx;
        }
        var canDom;
        var body = document.body;
        if(window.__IS_IN_RHINO) {
            canDom = document.createElement('canvas');
			//Sun xuetao 2010/4/27  on ui5 check these two varibles are global,  and the code could not be exec, comment out.
            //canDom.height = height;
            //canDom.width = width;
            body.appendChild(canDom);
        } else if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
            if( typeof FlashCanvas != "undefined") {
                canDom = document.createElement('canvas');
                body.appendChild(canDom);
                FlashCanvas.initElement(canDom);
                canDom.setAttribute('height', 1);
                canDom.setAttribute('width', 1);
                canDom.style.width = '1px';
                canDom.style.height = '1px';
                canDom.style.display = 'none';
            } else {
                canDom = document.createElement('rivcanvas');
                canDom.setAttribute('height', 1);
                canDom.setAttribute('width', 1);
                canDom.style.width = '1px';
                canDom.style.height = '1px';
                body.appendChild(canDom);
                rvmlmgr.initElement(canDom);
            }
        } else {
            canDom = document.createElement('canvas');
            canDom.setAttribute('height', 1);
            canDom.setAttribute('width', 1);
            canDom.style.width = '1px';
            canDom.style.height = '1px';
            canDom.style.display = 'none';
            body.appendChild(canDom);
        }
        hiddenCanvasCtx = canDom.getContext('2d');
        return hiddenCanvasCtx;
    };
    var p = /(\d+)(px|em|pt|%)/i;
    var fsp = /(x{1,2}-)?(small|medium|large)/i;
    var w = /\d+\b|bold|[\s\t]normal/i;
    var sizeMap ={
        "x-small" : 9,
        "xx-small" : 10,
        "small" : 13,
        "medium" : 16,
        "large" : 18,
        "x-large" : 24,
        "xx-large" : 32
    };
    /**
     * Text Ruler
     *
     * @name sap.riv.core.utils.TextRuler
     * @class
     */
    var TextRuler = {
        /**
         * Measure the text width in given font setting
         *
         * @function
         * @param {String}
         *            font the css font string
         * @param {String}
         *            text the text to be measured
         * @returns {Number} the actual width of the text in px
         */
        measureWidth : window.measureWidth ||
        function(font, text) {
            var canvasCtx = getHiddenCanvasCtx();
            canvasCtx.save();
            canvasCtx.font = font;
            var width = canvasCtx.measureText(String(text)).width + 2;
            canvasCtx.restore();
            return width;
        },

        /**
         * Measure the text height in given font setting approximately, the
         * supported units of font-size setting could be in em, px, pt, %. When
         * specified as relative font size like ##em, ##&, the text height will
         * be calculated against 10 px by default. If the font string is
         * invalid, undefined will be returned.
         *
         * @function
         * @param {String}
         *            font the valid css font string
         * @param {Number}
         *            [baseSize] the base font size used to calculate relative
         *            font size, like em, percentage. Default is 10 px.
         * @returns {Number} the height of the bounding box of the font setting
         *          in px
         */
        measureHeight : function(font, baseSize) {
            var m = p.exec(font);
            var bs = baseSize || 10;
            if(m) {
                var s = 0;
                switch (m[2]) {
                    case 'em':
                        s = parseFloat(m[1]) * bs;
                        break;
                    case '%':
                        s = parseFloat(m[1]) * bs / 100;
                        break;
                    case 'pt':
                        // One point(pt) is approximately equal to 1.33 px
                        s = parseFloat(m[1]) * 1.33;
                        break;
                    case 'px':
                        s = parseInt(m[1]);
                        break;
                }
                return Math.ceil(s * 1.2);
            }else {
                m = fsp.exec(font);
                if(m){
                    return Math.ceil(sizeMap[m[0]] *1.2);
                }
            }
            return undefined;
        },
        /**
         * Measure the weight of the text in given font while drawing on Canvas
         *
         * @param {String}
         *            font the valid css font string

         * @returns {Number} the weight of the bounding box of the font setting.
         */
        measureWeight : function(font) {
            var m = w.exec(font);
            var p = 400;
            if(m) {
                switch (m[0]) {
                    // add a white space before 'normal to ignore first normal,
                    // which is define font-style, not weight'
                    case ' normal':
                    case '500':
                        p = 400;
                        break;
                    case 'bold':
                    case 'bolder':
                    case '600':
                    case '700':
                    case '800':
                    case '900':
                        // 400 is normal, and 700 is bold. Those are the only
                        // numeric values that most text rendering engines support.
                        p = 700;
                }
            }
            return p;
        },
        /**
         * Measure the dimension of the text in given font while drawing on
         * Canvas
         *
         * @param {String}
         *            font the font to draw the text in
         * @param {String}
         *            text the text to be measured
         * @returns {Object}
         */
        measureText : function(font, text) {
            var dim = {};
            dim.width = TextRuler.measureWidth(font, text);
            dim.height = TextRuler.measureHeight(font);
            return dim;
        }
    };
    return TextRuler;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, FillableShape, Math) {
	/**
	 * This class defines closed paths
	 * 
	 * @name sap.riv.graphics.shape.Paths
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Paths = ObjectUtils.derive(FillableShape,
			{
				constructor : function() {
					this._subPaths = [];
					this._interpolatedVertices = [];
				},

				_inplotArc : function(c0, sa, ea, r, vtx) {
					// TODO - optimize the interpolation algorithm
					var min = Math.min(sa, ea);
					var max = Math.max(sa, ea);
					var step = (max - min) / 50;
					for ( var i = min; i <= max; i += step) {
						var sinofhas = Math.sin(i);
						var cosofhas = Math.cos(i);
						vtx.push([ c0[0] + cosofhas * r, c0[1] + sinofhas * r ]);
					}
					if (i != max) {
						var sinofhas = Math.sin(max);
						var cosofhas = Math.cos(max);
						vtx.push([ c0[0] + cosofhas * r, c0[1] + sinofhas * r ]);
					}
				},

				_inplotSpline : function(p0, p1, p2, vtx) {
					// TODO - optimize the interpolation algorithm
					var sqrt = Math.sqrt;
					var dx1 = p1[0] - p0[0], dy1 = p1[1] - p0[1], dx2 = p2[0] - p1[0], dy2 = p2[1] - p1[1];
					var ns = Math.floor((sqrt(dx1 * dx1 + dy1 * dy1) + sqrt(dx2 * dx2 + dy2 * dy2)) * 0.25);
					for ( var s = 1; s <= ns; s++) {
						var t = 1 / ns * s, tu = 1 - t;
						var a = tu * tu, b = 2 * t * tu, c = t * t;
						vtx.push([ a * p0[0] + b * p1[0] + c * p2[0], a * p0[1] + b * p1[1] + c * p2[1] ]);
					}
				},

				_inplotBezier : function(p0, p1, p2, p3, vtx) {
					// TODO - optimize the interpolation algorithm
					var sqrt = Math.sqrt;
					var dx1 = p1[0] - p0[0], dy1 = p1[1] - p0[1], dx2 = p2[0] - p1[0], dy2 = p2[1] - p1[1], dx3 = p3[0]
							- p2[0], dy3 = p3[1] - p2[1];
					var ns = Math.floor((sqrt(dx1 * dx1 + dy1 * dy1) + sqrt(dx2 * dx2 + dy2 * dy2) + sqrt(dx3 * dx3
							+ dy3 * dy3)) * 0.25);
					for ( var s = 1; s <= ns; s++) {
						var t = 1 / ns * s, tu = 1 - t;
						var a = tu * tu * tu, b = 3 * t * tu * tu, c = 3 * t * t * tu, d = t * t * t;
						vtx.push([ a * p0[0] + b * p1[0] + c * p2[0] + d * p3[0],
								a * p0[1] + b * p1[1] + c * p2[1] + d * p3[1] ]);
					}
				},

				/**
				 * Create a new subpath with the specified point as its first
				 * (and only) point
				 * 
				 * @name sap.riv.graphics.shape.Paths#moveTo
				 * @function
				 * @param {Number}
				 *            x
				 * @param {Number}
				 *            y
				 * @returns {this}
				 */
				moveTo : function(x, y) {
					if (x !== undefined && y !== undefined) {
						if (this._subPaths.length > 0) {
							this._interpolatedVertices[this._interpolatedVertices.length - 1]
									.push(this._interpolatedVertices[this._interpolatedVertices.length - 1][0]);// close
							// the
							// hit
							// test
							// vertices
							// array
						}
						this._subPaths.push([ {
							cmd : 'orig',
							x : x,
							y : y
						} ]);
						this._interpolatedVertices.push([ [ x, y ] ]);
						return this;
					}
				},
				/**
				 * Mark the last subpath as closed, create a new subpath whose
				 * first point is the same as the previous subpath's first
				 * point, and finally add this new subpath to the path
				 * 
				 * @name sap.riv.graphics.shape.Paths#closeSubPath
				 * @function
				 * @returns {this}
				 */
				closeSubPath : function() {
					if (this._subPaths.length > 0) {
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'close'
						});
						var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
						iVtx.push(iVtx[0]);// close the hit test vertices array
						this.moveTo(iVtx[0][0], iVtx[0][1]);
						return this;
					}
				},
				/**
				 * Connect the last point in the subpath to the given point (x,
				 * y) using a straight line, and must then add the given point
				 * (x, y) to the subpath.
				 * 
				 * @name sap.riv.graphics.shape.Paths#lineTo
				 * @function
				 * @param {Number}
				 *            x
				 * @param {Number}
				 *            y
				 * @returns {this}
				 */
				lineTo : function(x, y) {
					if (x !== undefined && y !== undefined) {
						if (this._subPaths.length == 0) {
							this.moveTo(x, y);
						} else {
							this._subPaths[this._subPaths.length - 1].push({
								cmd : 'lnto',
								x : x,
								y : y
							});
							this._interpolatedVertices[this._interpolatedVertices.length - 1].push([ x, y ]);
						}
						return this;
					}
				},
				/**
				 * Connect the last point in the subpath to the given point (x,
				 * y) using a quadratic Bezier curve with control point (cpx,
				 * cpy), and must then add the given point (x, y) to the subpath
				 * 
				 * @name sap.riv.graphics.shape.Paths#splineTo
				 * @function
				 * @param {POINT}
				 *            controlPoint
				 * @param {POINT}
				 *            point
				 * @returns {this}
				 */
				splineTo : function(controlPoint, point) {
					if (controlPoint !== undefined && point !== undefined) {
						if (this._subPaths.length == 0) {
							this.moveTo(controlPoint.x, controlPoint.y);
						}
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'spln',
							cx : controlPoint.x,
							cy : controlPoint.y,
							x : point.x,
							y : point.y
						});
						var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
						this._inplotSpline(iVtx[iVtx.length - 1], [ controlPoint.x, controlPoint.y ], [ point.x,
								point.y ], iVtx);
						return this;
					}
				},
				/**
				 * connect the last point in the subpath to the given point (x,
				 * y) using a cubic Bezier curve with control points (cp1x,
				 * cp1y) and (cp2x, cp2y). Then, it must add the point (x, y) to
				 * the subpath
				 * 
				 * @name sap.riv.graphics.shape.Paths#bezierCurveTo
				 * @function
				 * @param {POINT}
				 *            controlPoint1
				 * @param {POINT}
				 *            controlPoint2
				 * @param {POINT}
				 *            point
				 * @returns {this}
				 */
				bezierCurveTo : function(controlPoint1, controlPoint2, point) {
					if (controlPoint1 !== undefined && controlPoint2 !== undefined && point !== undefined) {
						if (this._subPaths.length == 0) {
							this.moveTo(controlPoint1.x, controlPoint1.y);
						}
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'bcur',
							c1x : controlPoint1.x,
							c1y : controlPoint1.y,
							c2x : controlPoint2.x,
							c2y : controlPoint2.y,
							x : point.x,
							y : point.y
						});
						var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
						this._inplotBezier(iVtx[iVtx.length - 1], [ controlPoint1.x, controlPoint1.y ], [
								controlPoint2.x, controlPoint2.y ], [ point.x, point.y ], iVtx);
						return this;
					}
				},
				/**
				 * Draw arc using control point and radius.
				 * 
				 * @name sap.riv.graphics.shape.Paths#arcTo
				 * @function
				 * @param {POINT}
				 *            controlPoint1
				 * @param {POINT}
				 *            controlPoint2
				 * @param {Number}
				 *            radius
				 * @returns {this}
				 */
				arcTo : function(point1, point2, radius) {
					if (point1 !== undefined && point2 !== undefined && radius > 0) {
						if (this._subPaths.length == 0) {
							this.moveTo(point1.x, point1.y);
						}
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'arct',
							c1x : point1.x,
							c1y : point1.y,
							c2x : point2.x,
							c2y : point2.y,
							r : radius
						});
						// TODO interpolate the intermediate point
						this._interpolatedVertices[this._interpolatedVertices.length - 1].push([ point2.x, point2.y ]);
						return this;
					}
				},
				/**
				 * Draw arc using a set of parameters.
				 * 
				 * @name sap.riv.graphics.shape.Paths#arc
				 * @function
				 * @param {POINT}
				 *            point
				 * @param {Number}
				 *            radius
				 * @param {Number}
				 *            startAngle
				 * @param {Number}
				 *            endAngle
				 * @param {Boolean}
				 *            [clockwise]
				 * @returns {this}
				 */
				arc : function(point, radius, startAngle, endAngle, clockwise) {
					if (point !== undefined && startAngle !== undefined && radius > 0 && endAngle !== undefined) {
						if (startAngle !== endAngle) {
							if (this._subPaths.length == 0) {
								this._subPaths.push([ {
									cmd : 'arc',
									x : point.x,
									y : point.y,
									sa : startAngle,
									ea : endAngle,
									r : radius,
									cw : clockwise !== undefined ? clockwise : false
								} ]);
								var iVtx = [];
								this._inplotArc([ point.x, point.y ], startAngle, endAngle, radius, iVtx);
								this._interpolatedVertices.push(iVtx);
							} else {
								this._subPaths[this._subPaths.length - 1].push({
									cmd : 'arc',
									x : point.x,
									y : point.y,
									sa : startAngle,
									ea : endAngle,
									r : radius,
									cw : clockwise !== undefined ? clockwise : false
								});
								var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
								this._inplotArc([ point.x, point.y ], startAngle, endAngle, radius, iVtx);
							}
						}
						return this;
					}
				},
				/**
				 * Create a new subpath containing just the four points (x, y),
				 * (x+w, y), (x+w, y+h), (x, y+h), with those four points
				 * connected by straight lines, and must then mark the subpath
				 * as closed. It must then create a new subpath with the point
				 * (x, y) as the only point in the subpath.
				 * 
				 * @name sap.riv.graphics.shape.Paths#rect
				 * @function
				 * @param {Number}
				 *            x
				 * @param {Number}
				 *            y
				 * @param {Number}
				 *            w
				 * @param {Number}
				 *            h
				 * @returns {this}
				 */
				rect : function(x, y, w, h) {
					if (x !== undefined && y !== undefined && w > 0 && h > 0) {
						this._subPaths.push([ {
							cmd : 'rect',
							x : x,
							y : y,
							w : w,
							h : h
						} ]);
						this._interpolatedVertices.push([ [ x, y ], [ x + w, y ], [ x + w, y + h ], [ x, y + h ],
								[ x, y ] ]);
						this.moveTo(x, y);
						return this;
					}
				},
				/**
				 * Reset the paths to empty.
				 * 
				 * @name sap.riv.graphics.shape.Paths#reset
				 * @function
				 * 
				 * @returns {this} this object
				 */
				reset : function() {
					this._subPaths.splice(0, this._subPaths.length);
					this._interpolatedVertices.splice(0, this._subPaths.length);
				},

				doDraw : function(drawingContext) {
					var dCtx = drawingContext;
					dCtx.beginPath();
					for ( var si = 0, spth, spths = this._subPaths, slen = spths.length; si < slen; si++) {
						spth = spths[si];// sub-path
						for ( var di = 0, d, dlen = spth.length; di < dlen; di++) {
							d = spth[di];
							switch (d.cmd) {
							case 'orig':
								dCtx.moveTo(d.x, d.y);
								break;
							case 'close':
								dCtx.closePath();
								break;
							case 'lnto':
								dCtx.lineTo(d.x, d.y);
								break;
							case 'spln':
								dCtx.quadraticCurveTo(d.cx, d.cy, d.x, d.y);
								break;
							case 'bcur':
								dCtx.bezierCurveTo(d.c1x, d.c1y, d.c2x, d.c2y, d.x, d.y);
								break;
							case 'arct':
								dCtx.arcTo(d.c1x, d.c1y, d.c2x, d.c2y, d.r);
								break;
							case 'arc':
								dCtx.arc(d.x, d.y, d.r, d.sa, d.ea, !d.cw);
								break;
							case 'rect':
								dCtx.rect(d.x, d.y, d.w, d.h);
								break;
							}
						}
					}

					if (this.fillingColor()) {
						// we won't close path enthusiastically, but if you want
						// to fill, we close path for you
						dCtx.closePath();
						this.fillShape(dCtx);
					}
					this.drawBorder(dCtx);
				},

				doPointInTest : (function() {
					var isLeft = function(sp, ep, tp) {
						return ((ep[0] - sp[0]) * (tp[1] - sp[1]) - (tp[0] - sp[0]) * (ep[1] - sp[1]));
					};
					return function(point) {
						var wn = 0;
						var x = point.x, y = point.y;
						var p = [ x, y ];
						for ( var i = 0, vtx = this._interpolatedVertices, elen = vtx.length; i < elen; i++) {
							for ( var j = 0, spvtx = vtx[i], selen = spvtx.length - 1; j < selen; j++) {
								if (spvtx[j][1] <= y) {
									if (spvtx[j + 1][1] > y)
										if (isLeft(spvtx[j], spvtx[j + 1], p) > 0)
											++wn;
								} else {
									if (spvtx[j + 1][1] <= y)
										if (isLeft(spvtx[j], spvtx[j + 1], p) < 0)
											--wn;
								}
							}
							if (wn != 0) {
								return true;
							}
						}
						return false;
					};
				})()
			});
	return Paths;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.DrawableRect',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, DrawableRect) {
	/**
	 * This class defines Rectangle
	 * 
	 * @name sap.riv.graphics.shape.Rectangle
	 * @class
	 * @augments sap.riv.graphics.shape.DrawableRect
	 */
	var Rectangle = ObjectUtils.derive(DrawableRect, {
		constructor : function() {
			this._fill = undefined;
		},

		/**
		 * Get or set the color of the rectangle, the color setting should be
		 * CSSColor serialized string or as follow to define gradient
		 * 
		 * <pre>
		 * {
		 *      t: 'lg'|'rg', //line gradient or radial gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.Rectangle#color
		 * @function
		 * @param {CSSColor|Object}
		 *            color the color of the rectangle
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		color : function(color) {
			if (color !== undefined) {
				if (color !== false) {
					this._fill = CanvasHelper.createColorStyle(color);
				} else {
					this._fill = undefined;
				}
				return this;
			}
			if (this._fill) {
				return this._fill;
			}
		},

		drawInRect : function(drawingContext) {
			if (this._fill) {
				drawingContext.save();
				drawingContext.setFillStyle(this._fill);
				drawingContext.fill();
				drawingContext.restore();
			}
		}
	});
	return Rectangle;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(Observable, ObjectUtils, LinkedHashMap, FuncUtils) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}

	/**
	 * The mask used to specify the auto resizing behavior
	 * 
	 * @name sap.riv.vizkit.UIComponent.Autosizing
	 * @class
	 */
	var ar = {
		/**
		 * Mark width & height is not flexible when its parent component's size
		 * changed
		 * 
		 * @field
		 * 
		 */
		None : 0,
		/**
		 * Mark the left margin is flexible
		 * 
		 * @field
		 */
		FlexibleLeftMargin : 1 << 0,
		/**
		 * Mark the width is flexible
		 * 
		 * @field
		 */
		FlexibleWidth : 1 << 1,
		/**
		 * Mark the right margin is flexible
		 * 
		 * @field
		 */
		FlexibleRightMargin : 1 << 2,
		/**
		 * Mark the top margin is flexible
		 * 
		 * @field
		 */
		FlexibleTopMargin : 1 << 3,
		/**
		 * Mark the height is flexible
		 * 
		 * @field
		 */
		FlexibleHeight : 1 << 4,
		/**
		 * Mark the bottom margin is flexible
		 * 
		 * @field
		 */
		FlexibleBottomMargin : 1 << 5
	};

	var id = 0;
	var nextId = function() {
		return id++;
	};

	/**
	 * This class defines UI component which serves as the super class of every
	 * controls
	 * 
	 * @name sap.riv.vizkit.UIComponent
	 * @class
	 * @augments sap.riv.core.utils.Observable
	 */
	var UIComponent = ObjectUtils
			.derive(
					Observable,
					/**
					 * @lends sap.riv.vizkit.UIComponent
					 * 
					 */
					{
						events : [ 'widthChanged', 'heightChanged', 'sizeChanged', 'positionChanged', 'anchorChanged',
								'beforeShow', 'afterShow', 'beforeHide', 'afterHide', 'focusin', 'focusout', 'focus',
								'blur', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'click',
								'dblclick', 'touchstart', 'touchmove', 'touchend', 'touchcancel' ],
						/**
						 * @constructs
						 * @param {Object}
						 *            options the options to initialize the UI
						 *            component
						 * @param {Boolean}
						 *            [options.hidden] whether the UI component
						 *            is hidden
						 * @param {Integer}
						 *            [options.autoresizingMask] the bitwise
						 *            combination of the autoresizing mask,
						 *            default is
						 *            {@link  sap.riv.vizkit.UIComponent.Autosizing#None}
						 * @param {Object}
						 *            [options.anchor] the anchor point of the
						 *            UI component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0.5,
						 * 	y : 0.5
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.position] the position of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0,
						 * 	y : 0
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.size] the size of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	w : 0,
						 * 	h : 0
						 * }
						 * </pre>
						 */
						constructor : function(options) {
							options = options || {};

							var _nextId = nextId();

							this._id = options.id ? options.id + '_' + _nextId : _nextId;

							this._attached = false;// a internal flag indicates
							// if the underlying div is
							// attached to DOM tree

							this._container = undefined;// DOM div container for
							// this ui component

							this._superComp = undefined;

							this._subComps = new LinkedHashMap();

							this._hidden = false;

							this._clipToBound = true;

							this._parentVisible = false;

							this._printable = true;

							this._autoresizeSubComponents = true;

							this._autoresizingMask = ar.None;

							this._gestureDetectors = [];

							this._bounds = {
								x : 0,
								y : 0,
								width : 1,
								height : 1
							};
							this._position = {
								x : 0,
								y : 0
							};
							this._anchorPoint = {
								x : 0.5,
								y : 0.5
							};
							this._init_(options);
						},

						_init_ : function(options) {
							this._container = $(document.createElement('div')).attr('id', this._id).css('position',
									'absolute').css({
								'font-size' : '10px',
								'box-sizing' : 'border-box',
								'-moz-box-sizing' : 'border-box',
								'-ms-box-sizing' : 'border-box',
								'-webkit-box-sizing' : 'border-box'
							}).data('selfComp', this);
							if (options.clipToBound === false) {
								this._container.css('overflow', 'visible');
								this._clipToBound = false;
							} else {
								this._container.css('overflow', 'hidden');
							}
							if (options.hidden === true) {
								this._container.css('display', 'none');
								this._hidden = true;
							}
							if (options.autoSizingMask != undefined) {
								this._autoresizingMask = options.autoSizingMask;
							}
							if (options.anchor) {
								this._anchorPoint.x = options.anchor.x;
								this._anchorPoint.y = options.anchor.y;
								delete options.anchor;
							}
							if (options.position) {
								this._position.x = options.position.x;
								this._position.y = options.position.y;

								this._container
										.css('left', this._position.x - this._anchorPoint.x * this._bounds.width);
								this._container
										.css('top', this._position.y - this._anchorPoint.y * this._bounds.height);
								delete options.position;
							}

							if (options.size) {
								this._bounds.width = options.size.w;
								this._bounds.height = options.size.h;
								this._container.width(this._bounds.width);
								this._container.height(this._bounds.height);
								delete options.size;
							}

							this._registerMandatoryHandler();

						},

						_registerMandatoryHandler : function() {
							this.on([ {
								eventName : 'sizeChanged',
								listener : this._updateContainerSize,
								scope : this
							}, {
								eventName : 'heightChanged',
								listener : this._updateContainerHeight,
								scope : this
							}, {
								eventName : 'widthChanged',
								listener : this._updateContainerWidth,
								scope : this
							}, {
								eventName : 'positionChanged',
								listener : this._updateContainerPos,
								scope : this
							}, {
								eventName : 'anchorChanged',
								listener : this._updateContainerAnchor,
								scope : this
							} ]);
						},

						_updateContainerSize : function(os, ns) {
							this._container.width(ns.width);
							this._container.height(ns.height);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * ns.width);
								this._container.css('top', this._position.y - this._anchorPoint.y * ns.height);
							}
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerWidth : function(ow, nw) {
							this._container.width(nw);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * nw);
							}
							var os = {
								height : this._bounds.height,
								width : ow
							}, ns = {
								height : this._bounds.height,
								width : nw
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerHeight : function(oh, nh) {
							this._container.height(nh);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('top', this._position.y - this._anchorPoint.y * nh);
							}
							var os = {
								height : oh,
								width : this._bounds.width
							}, ns = {
								height : nh,
								width : this._bounds.width
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerPos : function(op, np) {
							this._container.css('left', np.x - this._anchorPoint.x * this._bounds.width);
							this._container.css('top', np.y - this._anchorPoint.y * this._bounds.height);
						},

						_updateContainerAnchor : function(oap, nap) {
							this._container.css('left', this._position.x - nap.x * this._bounds.width);
							this._container.css('top', this._position.y - nap.y * this._bounds.height);
						},

						_markAttached_ : function() {
							this._attached = true;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markAttached_();
							}
							this._handleSubCompShow(this);
						},

						_markDetached_ : function() {
							this._attached = false;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markDetached_();
							}
						},

						/**
						 * Get the id of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#id
						 * @function
						 * @returns {String} the unique id of the component
						 */
						id : function() {
							return this._id;
						},
						/**
						 * Mark the component as hidden, if the component is
						 * already marked as hidden, nothing will happen;
						 * Whether the component will be shown and whether the
						 * events <b>beforeHide</b>, <b>afterHide</b> and the
						 * call-back methods <b>doBeforeHide</b>,
						 * <b>doAfterHide</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.riv.vizkit.UIComponent#markHide
						 * @function
						 * @returns {this}
						 */
						markHide : function() {
							if (this._hidden === false) {
								if (this._attached && this._parentVisible) {
									this.doBeforeHide();
									this.fireEvent('beforeHide');
								}
								this._hidden = true;
								this._container.css('display', 'none');
								if (this._attached && this._parentVisible) {
									this.doAfterHide();
									this.fireEvent('afterHide');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompHide(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompHide : function(comp) {
							if (comp._parentVisible && !comp._hidden) {
								comp.doBeforeHide();
								comp.fireEvent('beforeHide');
								comp.doAfterHide();
								comp.fireEvent('afterHide');
							}
							// mark all the descendant components's
							// parentVisible as false.
							comp._parentVisible = false;
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompHide(subCompItr.next().value);
							}
						},

						/**
						 * Mark the component as shown, if the component is
						 * already marked as shown, nothing will happen; Whether
						 * the component will be shown and whether the events
						 * <b>beforeShow</b>, <b>afterShow</b> and the
						 * call-back methods <b>doBeforeShow</b>,
						 * <b>doAfterShow</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.riv.vizkit.UIComponent#markShow
						 * @function
						 * @returns {this}
						 */
						markShow : function() {
							if (this._hidden === true) {
								if (this._attached && this._parentVisible) {
									this.doBeforeShow();
									this.fireEvent('beforeShow');
								}
								this._hidden = false;
								this._container.css('display', 'block');
								if (this._attached && this._parentVisible) {
									this.doAfterShow();
									this.fireEvent('afterShow');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompShow(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompShow : function(comp) {
							// whether parent is visible
							var superComp = comp.superComponent();
							comp._parentVisible = !superComp._hidden && superComp._parentVisible;
							if (comp._parentVisible && !comp._hidden) {
								// whether needs to show
								comp.doBeforeShow();
								comp.fireEvent('beforeShow');
								comp.doAfterShow();
								comp.fireEvent('afterShow');
							}
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompShow(subCompItr.next().value);
							}
						},

						clipToBound : function(clipToBound) {
							if (clipToBound !== undefined) {
								if (this._clipToBound !== clipToBound) {
									this._clipToBound = clipToBound;
									if (this._clipToBound) {
										this._container.css('overflow', 'hidden');
									} else {
										this._container.css('overflow', 'visible');
									}
								}
								return this;
							} else {
								return this._clipToBound;
							}
						},

						/**
						 * Get the current visibility of the component, the
						 * visibility is affected by the component's
						 * hidden/shown status, whether it's attached to DOM,
						 * whether it's ancestor components are shown.
						 * 
						 * 
						 * @name sap.riv.vizkit.UIComponent#visibility
						 * @function
						 * @returns {Boolean}
						 */
						visibility : function() {
							return !this._hidden && this._attached && this._parentVisible;
						},

						/**
						 * Get and set the printable property of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            printable
						 * @returns {this|Boolean}
						 */
						printable : function(printable) {
							if (printable !== undefined) {
								if (this._printable !== printable) {
									this._printable = printable;
								}
								return this;
							} else {
								return this._printable;
							}
						},

						/**
						 * Get and set whether the component should resize
						 * automatically when its parent's size changed
						 * 
						 * @name sap.riv.vizkit.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            autoresize
						 * @returns {this|Boolean}
						 */
						autoresizeSubComponents : function(autoresize) {
							if (autoresize !== undefined) {
								if (this._autoresizeSubComponents !== autoresize) {
									this._autoresizeSubComponents = autoresize;
								}
								return this;
							} else {
								return this._autoresizeSubComponents;
							}
						},

						/**
						 * Get and set the autoresizing mask of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#autoresizingMask
						 * @function
						 * @param {undefined|Integer}
						 *            mask
						 * @returns {this|Integer}
						 */
						autoresizingMask : function(mask) {
							if (mask !== undefined) {
								if (this._autoresizingMask !== mask) {
									this._autoresizingMask = mask;
								}
								return this;
							} else {
								return this._autoresizingMask;
							}
						},
						/**
						 * Get and set the bounds of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#bounds
						 * @function
						 * @param {undefined|Object}
						 *            bounds the new bounds of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						bounds : function(bounds) {
							if (bounds) {
								var ob = this._bounds, nb = bounds;
								this._bounds.x = nb.x;
								this._bounds.y = nb.y;
								if (ob.width !== nb.width || ob.height !== nb.height) {
									var os = {
										width : ob.width,
										height : ob.height
									};
									var ns = {
										width : nb.width,
										height : nb.height
									};
									this._bounds.width = nb.width;
									this._bounds.height = nb.height;
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._bounds);
							}
						},
						/**
						 * Get the position of the component, the position is in
						 * Page coordinate system
						 * 
						 * @name sap.riv.vizkit.UIComponent#pagePosition
						 * @function
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {Object}
						 */
						pagePosition : function() {
							var offset = this._container.offset();
							return {
								x : offset.left,
								y : offset.top
							};
						},
						/**
						 * Get and set the position of the component, the
						 * position is in it's direct super component's
						 * coordinate system
						 * 
						 * @name sap.riv.vizkit.UIComponent#position
						 * @function
						 * @param {undefined|Object}
						 *            position the new position of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						position : function(position) {
							if (position) {
								var op = this._position, np = position;
								if (op.x !== np.x || op.y !== np.y) {
									var o = {
										x : op.x,
										y : op.y
									};
									var n = {
										x : np.x,
										y : np.y
									};
									op.x = np.x;
									op.y = np.y;
									this.fireEvent('positionChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._position);
							}
						},
						/**
						 * Get and set the size of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#size
						 * @function
						 * @param {undefined|Object}
						 *            size the new size of the component:
						 * 
						 * <pre>
						 * {
						 *      width : ##,
						 *      height : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object}
						 */
						size : function(size) {
							if (size) {
								var os = {
									width : this._bounds.width,
									height : this._bounds.height
								};
								if (os.width !== size.width || os.height !== size.height) {
									this._bounds.width = size.width;
									this._bounds.height = size.height;
									this.fireEvent('sizeChanged', os, size);
								}
								return this;
							} else {
								return {
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get and set the width of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#width
						 * @function
						 * @param {undefined|Number}
						 *            width the new width of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						width : function(width) {
							if (width) {
								var ow = this._bounds.width;
								if (ow !== width) {
									this._bounds.width = width;
									this.fireEvent('widthChanged', ow, width);
								}
								return this;
							} else {
								return this._bounds.width;
							}
						},
						/**
						 * Get and set the height of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#height
						 * @function
						 * @param {undefined|Number}
						 *            height the new height of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						height : function(height) {
							if (height) {
								var oh = this._bounds.height;
								if (oh !== height) {
									this._bounds.height = height;
									this.fireEvent('heightChanged', oh, height);
								}
								return this;
							} else {
								return this._bounds.height;
							}
						},
						/**
						 * Get and set the anchor of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#anchorPoint
						 * @function
						 * @param {undefined|Object}
						 *            anchorPoint the new anchor of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						anchorPoint : function(anchorPoint) {
							if (anchorPoint) {
								var oap = this._anchorPoint, nap = anchorPoint;
								if (oap.x !== nap.x || oap.y !== nap.y) {
									var o = {
										x : oap.x,
										y : oap.y
									};
									var n = {
										x : nap.x,
										y : nap.y
									};
									oap.x = nap.x;
									oap.y = nap.y;
									this.fireEvent('anchorChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._anchorPoint);

							}
						},
						/**
						 * Get and set the frame of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#frame
						 * @function
						 * @param {undefined|Object}
						 *            rect the new frame of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						frame : function(rect) {
							if (rect) {
								var ob = this._bounds, op = this._position;
								var npx = rect.x + rect.width * this._anchorPoint.x;
								var npy = rect.y + rect.height * this._anchorPoint.y;
								var posChanged = false, o = undefined, n = undefined, sizeChanged = false, os = undefined, ns = undefined;
								if (ob.width !== rect.width || ob.height !== rect.height) {
									os = {
										width : ob.width,
										height : ob.height
									};
									ns = {
										width : rect.width,
										height : rect.height
									};
									ob.width = rect.width;
									ob.height = rect.height;
									sizeChanged = true;
								}
								if (op.x !== npx || op.y !== npy) {
									o = {
										x : op.x,
										y : op.y
									};
									n = {
										x : npx,
										y : npy
									};
									op.x = npx;
									op.y = npy;
									posChanged = true;
								}
								if (posChanged) {
									this.fireEvent('positionChanged', o, n);
								}
								if (sizeChanged) {
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return {
									x : this._position.x - this._anchorPoint.x * this._bounds.width,
									y : this._position.y - this._anchorPoint.y * this._bounds.height,
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.riv.vizkit.UIComponent#superComponent
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 * 
						 */
						superComponent : function() {
							return this._superComp;
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.riv.vizkit.UIComponent#subComponents
						 * @function
						 * @param {sap.riv.core.utils.LinkedHashMap}
						 * 
						 */
						subComponents : function() {
							return this._subComps;
						},
						/**
						 * Add a component as a child component, the visibility
						 * related events and call-back methods will get
						 * triggered on the component tree rooted at the
						 * detached component, if the component in the tree is
						 * visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#addSubComponent
						 * @function
						 * @param {this}
						 *            return this component
						 * @throws {ExistedParent}
						 */
						addSubComponent : function(subComp) {
							if (subComp) {
								if (subComp._superComp === undefined) {
									subComp._superComp = this;
									this._subComps.add(subComp.id(), subComp);
									this._container.append(subComp._container);
									if (this._attached) {
										subComp._markAttached_();
									}
									return this;
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Detach this component from its parent, the detached
						 * component is not destroyed and could be reattached
						 * later. the visibility related events and call-back
						 * methods will get triggered on the component tree
						 * rooted at the detached component, if the component in
						 * the tree is visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#detachFromSuperComponent
						 * @function
						 */
						detachFromSuperComponent : function() {
							if (this._superComp) {
								if (this._superComp._attached) {
									this._superComp._handleSubCompHide(this);
									this._markDetached_();
								}
								this._superComp._subComps.remove(this.id());
								this._container.detach();
								this._superComp = undefined;
							}
						},
						/**
						 * Remove this component from its parent, the remove
						 * component is destroyed including its subcomponent,
						 * and should not intend for reuse.
						 * 
						 * @name sap.riv.vizkit.UIComponent#detachFromSuperComponent
						 * @function
						 */
						removeFromSuperComponent : function() {
							if (this._superComp) {
								this._superComp._subComps.remove(this.id());
								this._container.remove();
								if (this._superComp._attached)
									this._markDetached_();
								this._superComp = undefined;

							}
						},
						/**
						 * Insert a component as a child component before other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#insertBeforeSubComponent
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.riv.vizkit.UIComponent}
						 *            beforeComp the component to be inserted
						 *            before
						 */
						insertBeforeSubComponent : function(subComp, beforeComp) {
							if (subComp && beforeComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var beforeKey = beforeComp.id();
									if (this._subComps.has(beforeKey) && newKey !== beforeKey) {
										subComp._superComp = this;
										this._subComps.insertBefore(newKey, subComp, beforeKey);
										subComp._container.before(beforeComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Insert a component as a child component after other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#insertAfterSubComponent
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.riv.vizkit.UIComponent}
						 *            afterComp the component to be inserted
						 *            before
						 */
						insertAfterSubComponent : function(subComp, afterComp) {
							if (subComp && afterComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var afterKey = afterComp.id();
									if (this._subComps.has(afterKey) && newKey !== afterKey) {
										subComp._superComp = this;
										this._subComps.insertAfter(newKey, subComp, afterKey);
										subComp._container.after(afterComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Bring the sub component to the front of other sub
						 * components
						 * 
						 * @name sap.riv.vizkit.UIComponent#bringToFront
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the sub component to move
						 */
						bringToFront : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getLastInsert().id() !== subComp.id()) {
								this._subComps.moveToLast(subComp.id());
								subComp._container.detach();
								this._container.append(subComp._container);
							}
						},
						/**
						 * Send the sub component to the back of other sub
						 * component
						 * 
						 * @name sap.riv.vizkit.UIComponent#sendToBack
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the sub component to move
						 */
						sendToBack : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getFirstInsert().id() !== subComp.id()) {
								this._subComps.moveToFirst(subComp.id());
								subComp._container.detach();
								this._container.prepend(subComp._container);
							}
						},

						/**
						 * Convert the point in parent's coordinate system to
						 * local point
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointFromSuper
						 * @function
						 * @param {Object}
						 *            pointInSuper
						 * @returns {Object}
						 */
						convertPointFromSuper : function(pointInSuper) {
							var frame = this.frame();
							return {
								x : pointInSuper.x - frame.x,
								y : pointInSuper.y - frame.y
							};
						},
						/**
						 * Convert the point to point in parent's coordinate
						 * system
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointToSuper
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToSuper : function(pointInLocal) {
							var frame = this.frame();
							return {
								x : pointInLocal.x + frame.x,
								y : pointInLocal.y + frame.y
							};
						},
						/**
						 * Convert the point in global coordinate system to
						 * local point
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointFromGlobal
						 * @function
						 * @param {Object}
						 *            globalPoint
						 * @returns {Object}
						 */
						convertPointFromGlobal : function(globalPoint) {
							var path = [ this ];
							var currentLevel = this;
							var pointInProgress = globalPoint;
							while (currentLevel._superComp) {
								path.push(currentLevel._superComp);
								currentLevel = currentLevel._superComp;
							}
							while (path.length) {
								currentLevel = path.pop();
								pointInProgress = currentLevel.convertPointFromSuper(pointInProgress);
							}
							return pointInProgress;
						},

						/**
						 * Convert the point to point in global coordinate
						 * system
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointToGlobal
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToGlobal : function(pointInLocal) {
							var currentLevel = this;
							var pointInProgress = pointInLocal;
							while (currentLevel) {
								pointInProgress = currentLevel.convertPointToSuper(pointInProgress);
								currentLevel = currentLevel._superComp;
							}
							return pointInProgress;
						},

						/**
						 * Convert the point in source component's coordinate
						 * system to local coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointFromComp
						 * @function
						 * @param {Object}
						 *            pointInSourceComp
						 * @param {sap.riv.vizkit.UIComponent}
						 *            sourceComp
						 * @returns {Object}
						 */
						convertPointFromComp : function(pointInSourceComp, sourceComp) {
							return this.convertPointFromGlobal(sourceComp.convertPointToGlobal(pointInSourceComp));
						},

						/**
						 * Convert the point in local coordinate system to
						 * target Component's coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointToComp
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @param {sap.riv.vizkit.UIComponent}
						 *            targetComp
						 * @returns {Object}
						 */
						convertPointToComp : function(pointInLocal, targetComp) {
							return targetComp.convertPointFromGlobal(this.convertPointToGlobal(pointInLocal));
						},

						_resizeSubComp : function(subComp, oldsize, newsize) {
							var origFrame = subComp.frame();
							var x = origFrame.x, y = origFrame.y, width = origFrame.width, height = origFrame.height;
							var ml = x, mr = oldsize.width - x - width, mt = y, mb = oldsize.height - y - height;
							var wdiff = newsize.width - oldsize.width, hdiff = newsize.height - oldsize.height;
							var arMask = subComp._autoresizingMask;
							var horizontalMask = ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin;
							var verticalMask = ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin;
							switch (arMask & horizontalMask) {
							case ar.None:
								if (ml !== 0) {
									x += wdiff * ml / (ml + mr);
								}
								break;
							case ar.FlexibleLeftMargin:
								x += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleRightMargin:
							case ar.FlexibleRightMargin:
								break;
							case ar.FlexibleWidth:
								width += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth:
								if (width !== 0) {
									x += wdiff * ml / (ml + width);
									width += wdiff * width / (ml + width);
								}
								break;
							case ar.FlexibleRightMargin | ar.FlexibleWidth:
								if (width !== 0) {
									width += wdiff * width / (mr + width);
								}
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin:
								if (oldsize.width !== 0) {
									var r = wdiff / oldsize.width;
									x += x * r;
									width += width * r;
								}
								break;
							}
							switch (arMask & verticalMask) {
							case ar.None:
								if (mt !== 0) {
									y += hdiff * mt / (mt + mb);
								}
								break;
							case ar.FlexibleTopMargin:
								y += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleBottomMargin:
							case ar.FlexibleBottomMargin:
								break;
							case ar.FlexibleHeight:
								height += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight:
								if (height !== 0) {
									y += hdiff * mt / (mt + height);
									height += hdiff * height / (mt + height);
								}
								break;
							case ar.FlexibleBottomMargin | ar.FlexibleHeight:
								if (height != 0) {
									height += hdiff * height / (mb + height);
								}
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin:
								if (oldsize.height) {
									var r = hdiff / oldsize.height;
									y += y * r;
									height += height * r;
								}
								break;
							}
							return {
								x : x,
								y : y,
								height : height,
								width : width
							};
						},

						_layout : function(oldsize, newsize) {
							if (this._autoresizeSubComponents) {
								var subCompItr = this._subComps.getIterator();
								var subComp, newFrame;
								while (subCompItr.hasMore()) {
									subComp = subCompItr.next().value;
									newFrame = this._resizeSubComp(subComp, oldsize, newsize);
									subComp.frame(newFrame);
								}
							} else if (this.doLayout != FuncUtils.noop && this.doLayout !== undefined) {
								this.doLayout();
							}
						},

						_fireEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireEvent_(event);
							}
						},

						_fireMouseEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								event._setCurrentLocalXY_({
									x : event.currentLocalXY().x + this._position.x - this._anchorPoint.x
											* this._bounds.width,
									y : event.currentLocalXY().y + this._position.y - this._anchorPoint.y
											* this._bounds.height
								});
								this._superComp._fireMouseEvent_(event);
							}
						},

						_fireTouchEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireTouchEvent_(event);
							}
						},

						/**
						 * Remove all listeners currently attached to the
						 * component
						 * 
						 * @name sap.riv.vizkit.UIComponent#purgeListeners
						 * @function
						 */
						purgeListeners : function() {
							this.callParent('purgeListeners');
							this._registerMandatoryHandler();
						},
						/**
						 * Remove all listeners currently listening on the given
						 * event
						 * 
						 * @name sap.riv.vizkit.UIComponent#removeAllListeners
						 * @function
						 * @param {String}
						 *            eventName
						 */
						removeAllListeners : function(eventName) {
							this.callParent('removeAllListeners', eventName);
							switch (eventName) {
							case 'sizeChanged':
								this.on({
									eventName : 'sizeChanged',
									listener : this._updateContainerSize,
									scope : this
								});
								break;
							case 'heightChanged':
								this.on({
									eventName : 'heightChanged',
									listener : this._updateContainerHeight,
									scope : this
								});
								break;
							case 'widthChanged':
								this.on({
									eventName : 'widthChanged',
									listener : this._updateContainerWidth,
									scope : this
								});
								break;
							case 'positionChanged':
								this.on({
									eventName : 'positionChanged',
									listener : this._updateContainerPos,
									scope : this
								});
								break;
							case 'anchorChanged':
								this.on({
									eventName : 'anchorChanged',
									listener : this._updateContainerAnchor,
									scope : this
								});
								break;
							}
						},
						/**
						 * Add a gesture detector to this component
						 * 
						 * @name sap.riv.vizkit.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.riv.vizkit.GestureDetector}
						 *            detector
						 */
						addGestureDetector : function(detector) {
							if (detector !== undefined) {
								detector._setOwnerComp_(this);
								this._gestureDetectors.push(detector);
							}
						},
						/**
						 * remove a previously added gesture detector to this
						 * component
						 * 
						 * @name sap.riv.vizkit.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.riv.vizkit.GestureDetector}
						 *            detector
						 */
						removeGestureDetector : function(detector) {
							for ( var i = 0, len = this._gestureDetectors.length; i < len; i++) {
								if (this._gestureDetectors[i] === detector) {
									this._gestureDetectors.splice(i, 1);
									detector._setOwnerComp_(undefined);
									len--;
								}
							}
						},

						/**
						 * Returns the farthest descendant uicomponent in the
						 * hierarchy rooted at this component, that contains the
						 * specified point.
						 * 
						 * @name sap.riv.vizkit.UIComponent#hitTest
						 * @param {POINT}
						 *            localXY
						 * @returns {sap.riv.vizkit.UIComponent#}
						 */
						hitTest : function(localXY) {
							var pStack = [ {
								comp : this,
								pointInLocal : localXY,
								subCompsItr : this._subComps.getIterator(true)
							} ];
							var levelInTest, localPoint, comp, subCompsItr;
							while (pStack.length) {
								levelInTest = pStack[pStack.length - 1];
								comp = levelInTest.comp;
								localPoint = levelInTest.pointInLocal;
								subCompsItr = levelInTest.subCompsItr;
								if (comp.visibility()) {
									if (subCompsItr.hasMore()) {
										var subComp = subCompsItr.next().value;
										pStack.push({
											comp : subComp,
											pointInLocal : subComp.convertPointFromSuper(localPoint),
											subCompsItr : subComp._subComps.getIterator(true)
										});
										continue;
									} else if (comp.containsPoint(localPoint)) {
										// find the top layer which contains the
										// point and can
										// respond to event
										return comp;
									}
									pStack.pop();
								} else {
									pStack.pop();
								}
							}
						},

						/**
						 * Test whether the given local point(point in local
						 * coordinate system) is contained in the component's
						 * boundary
						 * 
						 * @name sap.riv.vizkit.UIComponent#containsPoint
						 * @function
						 * @param {Object}
						 *            localPoint the point to test
						 * @returns {Boolean}
						 */
						containsPoint : function(localPoint) {
							var bounds = this.bounds();
							return localPoint.x >= bounds.x && localPoint.x <= (bounds.x + bounds.width)
									&& localPoint.y >= bounds.y && localPoint.y <= (bounds.y + bounds.height);
						},

						printTo : function(drawingCtx) {
							drawingCtx.clearRect(0, 0, this._bounds.width, this._bounds.height);
							this.doPrint(drawingCtx);
						},

						/**
						 * Implement this method to do adhoc sub-components
						 * layout, this method will be called on super component
						 * when its size changed.
						 * 
						 * @name sap.riv.vizkit.UIComponent#doLayout
						 * @function
						 */
						doLayout : FuncUtils.noop,

						/**
						 * Resize component's visual content, when the
						 * component's size changed, this method will be invoked
						 * before layout sub components
						 * 
						 * @name sap.riv.vizkit.UIComponent#doContentResize
						 * @function
						 * @param {Object}
						 *            os the old size of the component
						 * @param {Object}
						 *            ns the new size of the component
						 */
						doContentResize : FuncUtils.noop,

						/**
						 * Print the component visual content into the passed-in
						 * drawing context
						 * 
						 * @name sap.riv.vizkit.UIComponent#doPrint
						 * @function
						 * @param {sap.riv.graphic.DrawingContext}
						 */
						doPrint : FuncUtils.noop,

						/**
						 * This method will get called before the component
						 * becoming hidden
						 * 
						 * @name sap.riv.vizkit.UIComponent#doBeforeHide
						 * @function
						 */
						doBeforeHide : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * hided
						 * 
						 * @name sap.riv.vizkit.UIComponent#doAfterHide
						 * @function
						 */
						doAfterHide : FuncUtils.noop,
						/**
						 * This method will get called before the component
						 * becoming visible
						 * 
						 * @name sap.riv.vizkit.UIComponent#doBeforeShow
						 * @function
						 */
						doBeforeShow : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * visible
						 * 
						 * @name sap.riv.vizkit.UIComponent#doAfterShow
						 * @function
						 */
						doAfterShow : FuncUtils.noop
					});
	UIComponent.Autosizing = ar;
	return UIComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FunctionUtils) {
	var baseRenderer = function(layer, options) {
		this._mainLayer = layer;
		this._seriesGroup = [];
		this._eventLisntener = {};
		this._seriesShapes = [];
		this._highlights = [];

		this._initialize(options);
	};

	/**
	 * initialize the base renderer
	 */
	baseRenderer.prototype._initialize = function(options) {

	};

	/**
	 * 
	 * @param seriesGroup
	 *            sap.riv.viz.shared.series.SeriesGroup
	 */
	baseRenderer.prototype.addSeriesGroup = function(seriesGroup) {
		this._seriesGroup.push(seriesGroup);
	};

	/**
	 * Returns series groups.
	 * 
	 * @returns Array SeriesGroup
	 */
	baseRenderer.prototype.getSeriesGroups = function() {
		return this._seriesGroup;
	};

	/**
	 * 
	 * @returns Array SeriesGroup
	 */
	baseRenderer.prototype.resetSeriesGroup = function() {
		this._seriesGroup = [];
	};

	baseRenderer.prototype.getSeriesShapes = function() {
		return this._seriesShapes;
	};

	baseRenderer.prototype.findShape = function(path) {
		if (this._seriesShapes[path.measureIndex]
				&& this._seriesShapes[path.measureIndex][path.dimensionItemIndex]) {
			return this._seriesShapes[path.measureIndex][path.dimensionItemIndex];
		}
	};

	/**
	 * Sets to-highlight paths for the renderer. Renderer is expected to perform
	 * the highlights during chart initialization and re-drawing.
	 * 
	 * @param {Array}
	 *            highlights - To-highlight indexes
	 * 
	 * @param {Boolean}
	 *            layerPrioritization - Whether to prioritize the presence of
	 *            the logical layer of the highlighted shape
	 */
	baseRenderer.prototype.setHighlights = function(highlights, layerPrioritization) {
		this._highlights = highlights;
		this._layerPrioritization = layerPrioritization;
	};

	baseRenderer.prototype.getHighlights = function () {
		return this._highlights;
	};
	
	/**
	 * private function. register event listener
	 * 
	 * @param eventType
	 * @param evnetListener
	 */
	baseRenderer.prototype._addEventListener = function(eventType,
			evnetListener) {
		this._eventLisntener[eventType] = evnetListener;
	};

	/**
	 * 
	 * @returns Event Listener Array
	 */
	baseRenderer.prototype.getEventListener = function() {
		return this._eventLisntener;
	};

	/**
	 * 
	 * @returns layer sap.riv.graphics.Layer
	 */
	baseRenderer.prototype.getLayer = function() {
		return this._mainLayer;
	};

	baseRenderer.prototype.refresh = function() {
		this._mainLayer.setNeedsDisplay();
	};

	/* optional functions */
	/**
	 * @param point
	 *            {x,y} coordination in this.getLayer()
	 * @return dataContextObjects [{seriesIndex:0, dataPointIndex:1, series:
	 *         sap.riv.viz.shared.series.Series }] | null
	 */
	baseRenderer.prototype.getDataContextOnPoint = FunctionUtils.noop;

	/**
	 * 
	 */
	baseRenderer.prototype.highlight = FunctionUtils.noop;

	baseRenderer.prototype.removeHighlights = FunctionUtils.noop;

	/**
	 * @param point
	 *            {x,y} coordination in this.getLayer()
	 * @return dataContextObjects [{seriesIndex:0, dataPointIndex:1, series:
	 *         sap.riv.viz.shared.series.Series }] | null
	 */
	baseRenderer.prototype.hoverOnPoint = FunctionUtils.noop;

	/**
	 * reset the status of hover on point
	 */
	baseRenderer.prototype.onblur = FunctionUtils.noop;

	return baseRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Canvas2DSurface',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
}
],
function Setup(ObjUtils, CanvasHelper, Canvas2DSurface, UIComponent) {
	/**
	 * Base class for all graphics framework powered component
	 * 
	 * @name sap.riv.vizkit.Canvas2DSurfaceComponent
	 * @class
	 * @augments sap.riv.vizkit.UIComponent
	 */
	var Canvas2DSurfaceComponent = ObjUtils.derive(UIComponent,
	/**
	 * @lends sap.riv.vizkit.Canvas2DSurfaceComponent
	 */
	{
		constructor : function(options) {
			this._canvasElement = CanvasHelper.createCanvasElement(this.width(), this.height(), this._container);
			this._canvasSurface = new Canvas2DSurface({
				canvasEl : this._canvasElement
			});
			this._registerEventDispatcher();
		},

		_canvasSurfaceEventDispatcher : function(vizkitUIEvent) {
			this._canvasSurface.dispatchComponentUIEvent(vizkitUIEvent);
		},

		_registerEventDispatcher : function() {

			this.on({
				eventName : 'click',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'dblclick',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mouseup',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mousedown',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mousemove',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mouseleave',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'touchstart',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'touchmove',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'touchend',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});

			this.on({
				eventName : 'touchcancel',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
		},

		purgeListeners : function() {
			this.callParent('purgeListeners');
			this._registerEventDispatcher();
		},

		removeAllListeners : function(eventName) {
			this.callParent('removeAllListeners', eventName);
			switch (eventName) {
			case 'click':
				this.on({
					eventName : 'click',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'dblclick':
				this.on({
					eventName : 'dblclick',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mouseup':
				this.on({
					eventName : 'mouseup',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mousedown':
				this.on({
					eventName : 'mousedown',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mousemove':
				this.on({
					eventName : 'mousemove',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mouseleave':
				this.on({
					eventName : 'mouseleave',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchstart':
				this.on({
					eventName : 'touchstart',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchmove':
				this.on({
					eventName : 'touchmove',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchend':
				this.on({
					eventName : 'touchend',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchcancel':
				this.on({
					eventName : 'touchcancel',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			}
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
			if (oldSize.width !== newSize.width) {
				this._canvasSurface.width(newSize.width);
			}
			if (oldSize.height !== newSize.height) {
				this._canvasSurface.height(newSize.height);
			}
		},

		/**
		 * This function returns a 2D surface for displaying visual content.
		 * Subclass could use this surface to draw anything belonging to the
		 * component
		 * 
		 * @final
		 * @name sap.riv.vizkit.Canvas2DSurfaceComponent#getCanvasSurface
		 * @function
		 * @returns {sap.riv.graphics.Canvas2DSurface}
		 */
		getCanvasSurface : function() {
			return this._canvasSurface;
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		}
	});
	return Canvas2DSurfaceComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.BasicModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
}
],
function Setup(ObjUtils,FunctionUtils, Observable) {
	var BasicModule = ObjUtils.derive(Observable, {
		constructor : function(options) {
			this._chart_options = ObjUtils.extend(true, {}, options);
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;
			this._defaultSelectionArmed = true;
			this.addEvents(this.getSupportedAppEvents());
		},

		init : function() {
			this.buildData();
			this.initSeries();
		},

		updateProperties : function(propBag){
			var options = {};
			options.properties = propBag;
			this._chart_options = options;
		},
		
		updateOptions : function(options) {
			this._chart_options = options;
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;
			this._hasDrawed = false;
		},

		/* mandatory functions, should be implemented by sub classes */

		buildData : FunctionUtils.unsupported,
		
		initSeries : FunctionUtils.unsupported,

		drawSeries : FunctionUtils.unsupported,

		doChartLayout : FunctionUtils.unsupported,

		bindRenderer : FunctionUtils.unsupported,
		
		applyTheme : FunctionUtils.unsupported,

		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : FunctionUtils.unsupported,

		/* optional functions */

		marqueeOverPoint : FunctionUtils.noop,

		hoverOnPoint : FunctionUtils.noop,

		clickOnPoint : FunctionUtils.noop
	});
	return BasicModule;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TextRuler, CanvasHelper, Drawable, Math) {
    var decorateText = function(textLine, drawingContext) {
        drawingContext.save();
        var x = textLine._vtx[0][0], y = textLine._vtx[0][1];
        var height = textLine._height;
        // get proper longness for decoration line
        var width = (textLine._width < textLine._textOriginalWidth) ? textLine._width : textLine._textOriginalWidth;
        drawingContext.beginPath();
        var roundXStart = Math.round(x), roundXEnd = Math.round(x + width), roundY;

        //To make a crisp line, if the thickness is even, the start point coords should be integers,
        // else, should be integers plus 0.5, another way is to use fillrect() instead of stroke()
        var startPointOffset = (textLine._decorationLineThickness % 2 === 0) ? 0 : 0.5;

        switch(textLine._textDecoration) {
            case 'overline' :
                roundY = Math.round(y + height / 30) + startPointOffset;
                // drawingContext.fillRect(x, roundY, width, textLine._decorationLineThickness);
                drawingContext.moveTo(roundXStart, roundY);
                drawingContext.lineTo(roundXEnd, roundY);
                break;
            case 'underline':
                roundY = Math.round(y + height * 5 / 6) + startPointOffset;
                // drawingContext.fillRect(x, roundY, width, textLine._decorationLineThickness);
                drawingContext.moveTo(roundXStart, roundY);
                drawingContext.lineTo(roundXEnd, roundY);
                break;
            case 'line-through':
                roundY = Math.round(y + height / 2) + startPointOffset;
                // drawingContext.fillRect(x, roundY, width, textLine._decorationLineThickness);
                drawingContext.moveTo(roundXStart, roundY);
                drawingContext.lineTo(roundXEnd, roundY);
                break;
            default:
        }
        drawingContext.setLineWidth(textLine._decorationLineThickness);
        drawingContext.setStrokeStyle(textLine._textColor);
        drawingContext.stroke();
        drawingContext.restore();
    };
    /**
     * This class defines Text Line
     *
     * @name sap.riv.graphics.shape.TextLine
     * @class
     * @augments sap.riv.graphics.Drawable
     */
    var TextLine = ObjectUtils.derive(Drawable, {
        constructor : function() {
            this._anchor = 'tl';
            this._cornerRadius = 0;
            this._vtx = [[0, 0], [0, 0], [0, 0], [0, 0]];
            // tl,tr,br,bl
            this._font = '10px sans-serif';
            this._height = TextRuler.measureHeight(this._font);
            //this is border width
            this._width = 30;
            this._text = '';
            this._textAlign = 'l';
            this._textColor = '#000000';
            this._strokeAnchor = [0, 0];
            this._adjustVertices();
            this._weight = TextRuler.measureWeight(this._font);
            //the width of complete text
            this._textOriginalWidth = TextRuler.measureWidth(this._font, this._text);
            this._decorationLineThickness = Math.round(this._height * (this._weight === 700 ? 1.5 : 1) / 25);
            this._textDecoration = null;
        },
        _calcVertices : function(anchor, position) {
            var p = position;
            var vtx = this._vtx;
            var width = this._width;
            var height = this._height;
            switch (anchor) {
                case 'tl':
                    vtx[0][0] = p[0];
                    vtx[0][1] = p[1];
                    vtx[1][0] = p[0] + width;
                    vtx[1][1] = p[1];
                    vtx[2][0] = p[0] + width;
                    vtx[2][1] = p[1] + height;
                    vtx[3][0] = p[0];
                    vtx[3][1] = p[1] + height;
                    break;
                case 'tc':
                    vtx[0][0] = p[0] - width / 2;
                    vtx[0][1] = p[1];
                    vtx[1][0] = p[0] + width / 2;
                    vtx[1][1] = p[1];
                    vtx[2][0] = p[0] + width / 2;
                    vtx[2][1] = p[1] + height;
                    vtx[3][0] = p[0] - width / 2;
                    vtx[3][1] = p[1] + height;
                    break;
                case 'tr':
                    vtx[0][0] = p[0] - width;
                    vtx[0][1] = p[1];
                    vtx[1][0] = p[0];
                    vtx[1][1] = p[1];
                    vtx[2][0] = p[0];
                    vtx[2][1] = p[1] + height;
                    vtx[3][0] = p[0] - width;
                    vtx[3][1] = p[1] + height;
                    break;
                case 'rc':
                    vtx[0][0] = p[0] - width;
                    vtx[0][1] = p[1] - height / 2;
                    vtx[1][0] = p[0];
                    vtx[1][1] = p[1] - height / 2;
                    vtx[2][0] = p[0];
                    vtx[2][1] = p[1] + height / 2;
                    vtx[3][0] = p[0] - width;
                    vtx[3][1] = p[1] + height / 2;
                    break;
                case 'br':
                    vtx[0][0] = p[0] - width;
                    vtx[0][1] = p[1] - height;
                    vtx[1][0] = p[0];
                    vtx[1][1] = p[1] - height;
                    vtx[2][0] = p[0];
                    vtx[2][1] = p[1];
                    vtx[3][0] = p[0] - width;
                    vtx[3][1] = p[1];
                    break;
                case 'bc':
                    vtx[0][0] = p[0] - width / 2;
                    vtx[0][1] = p[1] - height;
                    vtx[1][0] = p[0] + width / 2;
                    vtx[1][1] = p[1] - height;
                    vtx[2][0] = p[0] + width / 2;
                    vtx[2][1] = p[1];
                    vtx[3][0] = p[0] - width / 2;
                    vtx[3][1] = p[1];
                    break;
                case 'bl':
                    vtx[0][0] = p[0];
                    vtx[0][1] = p[1] - height;
                    vtx[1][0] = p[0] + width;
                    vtx[1][1] = p[1] - height;
                    vtx[2][0] = p[0] + width;
                    vtx[2][1] = p[1];
                    vtx[3][0] = p[0];
                    vtx[3][1] = p[1];
                    break;
                case 'lc':
                    vtx[0][0] = p[0];
                    vtx[0][1] = p[1] - height / 2;
                    vtx[1][0] = p[0] + width;
                    vtx[1][1] = p[1] - height / 2;
                    vtx[2][0] = p[0] + width;
                    vtx[2][1] = p[1] + height / 2;
                    vtx[3][0] = p[0];
                    vtx[3][1] = p[1] + height / 2;
                    break;
                case 'c':
                    vtx[0][0] = p[0] - width / 2;
                    vtx[0][1] = p[1] - height / 2;
                    vtx[1][0] = p[0] + width / 2;
                    vtx[1][1] = p[1] - height / 2;
                    vtx[2][0] = p[0] + width / 2;
                    vtx[2][1] = p[1] + height / 2;
                    vtx[3][0] = p[0] - width / 2;
                    vtx[3][1] = p[1] + height / 2;
                    break;
            }
            switch (this._textAlign) {
                case 'l':
                    this._strokeAnchor[0] = vtx[0][0];
                    this._strokeAnchor[1] = vtx[0][1] + height / 2;
                    break;
                case 'c':
                    this._strokeAnchor[0] = vtx[0][0] + width / 2;
                    this._strokeAnchor[1] = vtx[0][1] + height / 2;
                    break;
                case 'r':
                    this._strokeAnchor[0] = vtx[0][0] + width;
                    this._strokeAnchor[1] = vtx[0][1] + height / 2;
                    break;
            }
        },
        _adjustVertices : function() {
            var vtx = this._vtx;
            var w = vtx[1][0] - vtx[0][0];
            var h = vtx[3][1] - vtx[0][1];
            switch (this._anchor) {
                case 'tl':
                    this._calcVertices('tl', vtx[0]);
                    break;
                case 'tc':
                    this._calcVertices('tc', [vtx[0][0] + w / 2, vtx[0][1]]);
                    break;
                case 'tr':
                    this._calcVertices('tr', vtx[1]);
                    break;
                case 'rc':
                    this._calcVertices('rc', [vtx[1][0], vtx[1][1] + h / 2]);
                    break;
                case 'br':
                    this._calcVertices('br', vtx[2]);
                    break;
                case 'bc':
                    this._calcVertices('bc', [vtx[2][0] - w / 2, vtx[2][1]]);
                    break;
                case 'bl':
                    this._calcVertices('bl', vtx[3]);
                    break;
                case 'lc':
                    this._calcVertices('lc', [vtx[3][0], vtx[3][1] - h / 2]);
                    break;
                case 'c':
                    this._calcVertices('c', [vtx[0][0] + w / 2, vtx[0][1] + h / 2]);
                    break;
            }
            this._cornerRadius = Math.min(this._width / 2, this._height / 2, this._cornerRadius);
        },
        /**
         * Get or set the top left corner.
         *
         * @name sap.riv.graphics.shape.TextLine#topLeft
         * @function
         * @param {[x,y]}
         *            tl top left corner coordinates
         * @returns {this|[x,y]}
         */
        topLeft : function(tl) {
            if(tl !== undefined) {
                this._anchor = 'tl';
                this._calcVertices('tl', tl);
                return this;
            }
            return {
                x : this._vtx[0][0],
                y : this._vtx[0][1]
            };
        },
        /**
         * Get or set the top center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#topCenter
         * @function
         * @param {[x,y]}
         *            tc top center corner coordinates
         * @returns {this|[x,y]}
         */
        topCenter : function(tc) {
            if(tc !== undefined) {
                this._anchor = 'tc';
                this._calcVertices('tc', tc);
                return this;
            }
            return {
                x : this._vtx[0][0] + this._width / 2,
                y : this._vtx[0][1]
            };
        },
        /**
         * Get or set the top right corner.
         *
         * @name sap.riv.graphics.shape.TextLine#topRight
         * @function
         * @param {[x,y]}
         *            tr top right corner coordinates
         * @returns {this|[x,y]}
         */
        topRight : function(tr) {
            if(tr !== undefined) {
                this._anchor = 'tr';
                this._calcVertices('tr', tr);
                return this;
            }
            return {
                x : this._vtx[1][0],
                y : this._vtx[1][1]
            };
        },
        /**
         * Get or set the right center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#rightCenter
         * @function
         * @param {[x,y]}
         *            rc rignt center corner coordinates
         * @returns {this|[x,y]}
         */
        rightCenter : function(rc) {
            if(rc !== undefined) {
                this._anchor = 'rc';
                this._calcVertices('rc', rc);
                return this;
            }
            return {
                x : this._vtx[1][0],
                y : this._vtx[1][1] + this._height / 2
            };
        },
        /**
         * Get or set the bottom right corner.
         *
         * @name sap.riv.graphics.shape.TextLine#bottomRight
         * @function
         * @param {[x,y]}
         *            br bottom right corner coordinates
         * @returns {this|[x,y]}
         */
        bottomRight : function(br) {
            if(br !== undefined) {
                this._anchor = 'br';
                this._calcVertices('br', br);
                return this;
            }
            return {
                x : this._vtx[2][0],
                y : this._vtx[2][1]
            };
        },
        /**
         * Get or set the bottom center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#bottomCenter
         * @function
         * @param {[x,y]}
         *            bc bottom center corner coordinates
         * @returns {this|[x,y]}
         */
        bottomCenter : function(bc) {
            if(bc !== undefined) {
                this._anchor = 'bc';
                this._calcVertices('bc', bc);
                return this;
            }
            return {
                x : this._vtx[2][0] - this._width / 2,
                y : this._vtx[2][1]
            };
        },
        /**
         * Get or set the bottom left corner.
         *
         * @name sap.riv.graphics.shape.TextLine#bottomLeft
         * @function
         * @param {[x,y]}
         *            bl bottom left corner coordinates
         * @returns {this|[x,y]}
         */
        bottomLeft : function(bl) {
            if(bl !== undefined) {
                this._anchor = 'bl';
                this._calcVertices('bl', bl);
                return this;
            }
            return {
                x : this._vtx[3][0],
                y : this._vtx[3][1]
            };
        },
        /**
         * Get or set the left center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#leftCenter
         * @function
         * @param {[x,y]}
         *            lc left center corner coordinates
         * @returns {this|[x,y]}
         */
        leftCenter : function(lc) {
            if(lc !== undefined) {
                this._anchor = 'lc';
                this._calcVertices('lc', lc);
                return this;
            }
            return {
                x : this._vtx[3][0],
                y : this._vtx[3][1] - this._height / 2
            };
        },
        /**
         * Get or set the center.
         *
         * @name sap.riv.graphics.shape.TextLine#center
         * @function
         * @param {[x,y]}
         *            c center coordinates
         * @returns {this|[x,y]}
         */
        center : function(c) {
            if(c !== undefined) {
                this._anchor = 'c';
                this._calcVertices('c', c);
                return this;
            }
            return {
                x : this._vtx[0][0] + this._width / 2,
                y : this._vtx[0][1] + this._height / 2
            };
        },
        /**
         * Get or set the corner radius. Value should be greater or equals to
         * zero. Zero means no rounded corner.
         *
         * @name sap.riv.graphics.shape.TextLine#cornerRadius
         * @function
         * @param {Number}
         *            radius the corner radius
         * @returns {this|Number}
         */
        cornerRadius : function(radius) {
            if(radius !== undefined) {
                if(radius >= 0) {
                    this._cornerRadius = Math.min(this._width / 2, this._height / 2, radius);
                }
                return this;
            }
            return this._cornerRadius;
        },
        /**
         * Get or set the text font. Value should be in css font serialized
         * string.
         *
         * @name sap.riv.graphics.shape.TextLine#font
         * @function
         * @param {CSSFONT}
         *            cssFont the css font
         * @returns {this|CSSFONT}
         */
        font : function(cssFont) {
            if(cssFont !== undefined) {
                this._font = cssFont;
                var newHeight = TextRuler.measureHeight(this._font);
                var newWeight = TextRuler.measureWeight(this._font);
                var newTextOriginalWidth = TextRuler.measureWidth(this._font, this._text);
                if(this._height !== newHeight) {
                    this._height = newHeight;
                    this._adjustVertices();
                }
                if(this._weight !== newWeight) {
                    this._weight = newWeight;
                }
                if(this._textOriginalWidth !== newTextOriginalWidth) {
                    this._textOriginalWidth = newTextOriginalWidth;
                }
                var newDecorationLineThickness = Math.round(this._height * (this._weight === 700 ? 1.5 : 1) / 25);
                if(this._decorationLineThickness !== newDecorationLineThickness) {
                    this._decorationLineThickness = newDecorationLineThickness;
                }
                return this;
            }
            return this._font;
        },
        /**
         * Get or set the width of the text line. The value should be greater
         * than zero. The default width is 30px.
         *
         * @name sap.riv.graphics.shape.TextLine#width
         * @function
         * @param {Number}
         *            width the width of the text line
         * @returns {this|Number}
         */
        width : function(width) {
            if(width !== undefined) {
                if(this._width > 0 && this._width !== width) {
                    this._width = width;
                    this._adjustVertices();
                }
                return this;
            }
            return this._width;
        },
        /**
         * Get or set the text.
         *
         * @name sap.riv.graphics.shape.TextLine#text
         * @function
         * @param {String}
         *            text the text to draw
         * @returns {this|String}
         */
        text : function(text) {
            if(text !== undefined) {
                this._text = text.toString();
                return this;
            }
            return this._text;
        },
        /**
         * Get or set the text alignment. The possible values are 'l','c','r'
         * representing left, center, right respectively.
         *
         * @name sap.riv.graphics.shape.TextLine#textAlign
         * @function
         * @param {String}
         *            textAlign the text alignment to set
         * @returns {this|String}
         */
        textAlign : function(textAlign) {
            if(textAlign !== undefined) {
                this._textAlign = textAlign;
                return this;
            }
            return this._textAlign;
        },
        /**
         * Get or set the filling color of the text line, the color setting
         * should be CSSColor serialized string or as follow to define gradient
         *
         * <pre>
         * {
         *      t: 'lg'|'rg', //line gradient or radial gradient
         *      s: { x:## , y:## }, //the start position of the gradient
         *      e: { x:## , y:## }, //the end position of the gradient
         *      st: [
         *              {
         *                  o: //the stop offset
         *                  v: //the stop color
         *              },...
         *          ] //the color stops of the gradient
         * }
         * </pre>
         *
         * @name sap.riv.graphics.shape.TextLine#textColor
         * @function
         * @param {CSSColor|Object}
         *            color the filling color
         * @returns {this|CSSColor|CanvasGradient}
         */
        textColor : function(color) {
            if(color !== undefined) {
                if(color !== false) {
                    this._textColor = CanvasHelper.createColorStyle(color);
                } else {
                    this._textColor = undefined;
                }
                return this;
            }
            if(this._textColor) {
                return this._textColor;
            }
        },
        /**
         * Get or set the css text decoration, the avaliable values are
         * overline, line-through, underline and blink
         *
         * @name sap.riv.graphics.TextLine#textDecoration
         * @function
         * @param {String}
         * @return {this|String}
         */
        textDecoration : function(decoration) {
            if(decoration !== undefined && (decoration === null || decoration === "overline" || decoration === "underline" || decoration === "line-through")) {
                this._textDecoration = decoration;
                return this;
            }
            if(this._textDecoration) {
                return this._textDecoration;
            }
        },
        doDraw : function(drawingContext) {
            var dCtx = drawingContext;
            dCtx.setFont(this._font);
            switch (this._textAlign) {
                case 'r':
                    dCtx.setTextAlign('right');
                    break;
                case 'c':
                    dCtx.setTextAlign('center');
                    break;
                case 'l':
                default:
                    dCtx.setTextAlign('left');
                    break;
            }

            dCtx.setTextBaseline('middle');
            dCtx.setFillStyle(this._textColor);
            decorateText(this, dCtx);
            dCtx.save();
            dCtx.beginPath();
            var vtx = this._vtx;
            if(this._cornerRadius > 0) {
                var radius = this._cornerRadius;
                dCtx.moveTo(vtx[0][0], (vtx[0][1] + vtx[3][1]) / 2);
                dCtx.arcTo(vtx[0][0], vtx[0][1], (vtx[0][0] + vtx[1][0]) / 2, vtx[0][1], radius);
                dCtx.arcTo(vtx[1][0], vtx[0][1], vtx[1][0], (vtx[0][1] + vtx[3][1]) / 2, radius);
                dCtx.arcTo(vtx[1][0], vtx[3][1], (vtx[0][0] + vtx[1][0]) / 2, vtx[3][1], radius);
                dCtx.arcTo(vtx[0][0], vtx[3][1], vtx[0][0], (vtx[0][1] + vtx[3][1]) / 2, radius);
            } else {
                dCtx.moveTo(vtx[0][0], vtx[0][1]);
                dCtx.lineTo(vtx[1][0], vtx[1][1]);
                dCtx.lineTo(vtx[2][0], vtx[2][1]);
                dCtx.lineTo(vtx[3][0], vtx[3][1]);
            }
            dCtx.closePath();
            dCtx.clip();
            dCtx.fillText(this._text, this._strokeAnchor[0], this._strokeAnchor[1]);
            dCtx.restore();
        },
        doPointInTest : function(point) {
            var x = point.x;
            var y = point.y;
            var vtx = this._vtx;
            return vtx[0][0] <= x && x <= vtx[2][0] && vtx[0][1] <= y && y <= vtx[2][1];
        }
    });
    return TextLine;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.PieRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Sector',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ColorUtils, BaseRenderer, Math, Series, TextRuler, ObjectUtils, Animator, ThemeManager,
		Paths, Circle, TextLine, Sector) {
	var textPhrase = "The quick brown fox jumps over the lazy dog";
	var pieRenderer = ObjectUtils.derive(BaseRenderer, {

		constructor : function(layer, options, multiMode) {
			// default values
			this._fontFamily = 'Arial';
			this._donutType = 'donut';
			this._pieType = 'pie';
			this._donutMeasureFont = 'bold 14px Arial';
			this._donutMeasureColor = '#000';
			this._donutBackground = '#FFF';
			this._innerShadowBlur = 20;
			this._multiMode = multiMode;
			this._subChartTitleVisible = false;
			this._centralSeriesNameVisible = false;
			this._truncReplacement = '...';
			// ///////////end default
			// values//////////////////////

			// ///////////internal
			// members////////////////////////
			this._isDrawn = false;
			this._shapes = {
				pieSectors : [],
				centerCircle : null,
				measureLabel : null,
				sectorInnerShadow : [],
				sectorOuterShadow : [],
				cover : null,
				subChartTitle : null
			};
			this._isShowInnerShadow = false;
			this._isShowOuterShadow = false;

			this._tooltip = {
				shape : null,
				dimensionLabel : null,
				valueLabel : null,
				percentLabel : null
			};

			this._meta = {
				center : null,
				radiusInner : null,
				radiusOutter : null
			};

			/**
			 * array of { value: percent: displayPercent: color: }
			 */
			this._values = [];
			// ////////////end internal
			// members////////////////////

			// ////////////to be removed out of renderer
			// [eye]///////////
			this._allSelectable = true;
			this._allDeSelectable = true;

			this._defaultSelectedSectorIndexes = [];
			this._interactionStatus = {
				mouseDown : false,
				mouseOnPieIndex : null,
				selected : []
			};
			// ////////////to be removed out of
			// renderer///////////

			this._parseOptions(options);
			this._initialize();
		},

		/**
		 * 
		 * @param options
		 *            parse pie renderer options
		 */
		_parseOptions : function(propi) {
			this._options = propi.properties;
			// ////////////to be removed out of renderer
			// [eye]///////////
			this._selectionMode = this._options.selectionMode;
			this._allSelectable = this._options.allSelectable;
			this._allDeSelectable = this._options.allDeSelectable;
			this._defaultSelectedSectorIndexes = this._options.selectedDataIndexes;
			// ////////////end of to be removed out of renderer
			// [eye]////

			this._isShowInnerShadow = this._options.isShowPieInnerShadow;
			this._isShowOuterShadow = this._options.isShowPieOuterShadow;

			this._subChartTitleVisible = this._multiMode && this._options.subChartTitle.visible;
			// [JYANG, 3/29/2012] we split the visible
			// controlling of measureLabel from centerCircle as
			// we have special
			// behavior for measureLabel in multiple pie
			this._centralSeriesNameVisible = (this._options.pieType === this._donutType) && (!this._multiMode);
			this._colorList = this._options._additional.colorList;

			this._type = this._options.pieType;
			this._toolTipTextFont = this._options.tooltip.text.font;
			this._toolTipTextFontColor = this._options.tooltip.text.color;
			this._toolTipTextFormatString = this._options._additional.tooltipeTextNumberFormat;

			this._toolTipMainValueFont = this._options.tooltip.mainValue.font;
			this._toolTipMainValueFontColor = this._options.tooltip.mainValue.color;
			this._toolTipMainValueFormatString = this._options._additional.tooltipeMainValueNumberFormat;

			this._toolTipSubValueFont = this._options.tooltip.subValue.font;
			this._toolTipSubValueFontColor = this._options.tooltip.subValue.color;
			this._toolTipSubValueFormatString = this._options._additional.tooltipeSubValueNumberFormat;
		},

		/**
		 * for pie renderer, we only draw the first series of the first series
		 * group of series groups
		 */
		_getSeries : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}
			var series = seriesList[0];
			return series;
		},

		draw : function() {
			this._reset();
			var series = this._getSeries();
			if (series) {
				this._initSeries(series);
				this._isDrawn = true;
				this._update();
			}
		},

		redraw : function() {
			this._reCalculateSize();
			this._update();
			this.refresh();
		},

		_update : function() {
			var series = this._getSeries();
			if (series) {
				this._drawSeries(series);
			}
		},

		_reCalculateSize : function() {
			delete this._meta;
			this._meta = {
				center : null,
				radiusInner : null,
				radiusOutter : null
			};
			var layer = this.getLayer();
			var newSize = layer.size();
			var subChartTitleHeight = 0;
			if (this._subChartTitleVisible) {
				// we are using series name as multi title
				var series = this._getSeries();
				if (series) {
					var name = series.getName();
					var font = this._options.subChartTitle.font;
					subChartTitleHeight = TextRuler.measureHeight(font, name);
				}
			}
			var pieHeight = newSize.height - subChartTitleHeight;
			this._meta.center = {
				x : newSize.width / 2,
				y : pieHeight / 2
			};
			var radius = (newSize.width < pieHeight) ? newSize.width : pieHeight;
			this._meta.radiusInner = radius / ((1.5 + 1) * 2);
			this._meta.radiusOutter = this._meta.radiusInner * 2.3;
		},

		/**
		 * 
		 * @param values
		 *            object array. {dimensionItemIndex: 0, measureIndex: 0,
		 *            value: 34108752}
		 */
		_initSeries : function(series) {
			var values = series.getData();
			this._reCalculateSize(series);
			var layer = this.getLayer();
			var total = 0;
			for ( var i = 0; i < values.length; i++) {
				var o = {
					'vo' : values[i]
				};
				this._values.push(o);
				total += values[i].value;
			}

			var tempSum = 0, percent = 0;
			for ( var i = 0; i < values.length; i++) {
				this._values[i].percent = this._values[i].vo.value / total;
				this._values[i].color = this._colorList[this._values[i].vo.dimensionItemIndex];
				this._shapes.sectorOuterShadow.push(layer.addShape(new Paths()));
				this._shapes.pieSectors.push(layer.addShape(new Sector()));
				// this._shapes.sectorInnerShadow.push(layer.addShape('pths'));
				this._shapes.sectorInnerShadow.push(layer.addShape(new Sector()));
			}

			// initial center circle
			this._shapes.centerCircle = layer.addShape(new Circle());
			// initial measure label
			this._shapes.measureLabel = layer.addShape(new TextLine());
			if (this._type == this._pieType) {
				this._shapes.centerCircle.visible(false);
			}

			this._shapes.subChartTitle = layer.addShape(new TextLine()).visible(this._subChartTitleVisible);

			this._tooltip.shape = layer.addShape(new Paths());
			this._tooltip.dimensionLabel = layer.addShape(new TextLine());
			this._tooltip.valueLabel = layer.addShape(new TextLine());
			this._tooltip.percentLabel = layer.addShape(new TextLine());
		},

		/**
		 * 
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 */
		_drawSeries : function(series) {
			var radius = this._meta.radiusOutter;
			// [Chrisyt] Use Robin images.
			// this._shapes.cover.width(225).height(225).scale((2*radius)/225,
			// (2*radius)/225)//center([this._meta.center.x,
			// this._meta.center.y]);
			// .translate(this._meta.center.x-radius*(2*radius)/225,
			// this._meta.center.y-radius*(2*radius)/225);

			for ( var i = 0, start = 0, end = 0; i < this._shapes.pieSectors.length; i++) {
				end = start + this._values[i].percent * Math.PI * 2;
				this._shapes.pieSectors[i].center(this._meta.center).radius(this._meta.radiusOutter).clockwise(true)
						.startAngle(start).endAngle(end).borderWidth(1).borderColor("#fff").fillingColor(
								this._values[i].color);

				this._shapes.sectorOuterShadow[i].reset();
				this._shapes.sectorOuterShadow[i].visible(this._isShowOuterShadow).arc(this._meta.center,
						this._meta.radiusOutter, start, end, true).borderWidth(2).borderColor("#fff").shadow({
					offsetX : 1,
					offsetY : 1,
					blur : 8,
					color : '#000'
				});

				var innerBlur = this._innerShadowBlur;
				this._shapes.sectorInnerShadow[i].visible(this._isShowInnerShadow).center(this._meta.center).radius(
						this._meta.radiusOutter).clockwise(true).startAngle(start).endAngle(end).fillingColor({
					t : 'rg',
					s : {
						c : this._meta.center,
						r : radius
					},
					e : {
						c : this._meta.center,
						r : (radius - innerBlur < 0) ? 0 :  radius - innerBlur
					},
					st : [ {
						o : 0,
						v : '#000'
					}, {
						o : 1,
						v : '#fff'
					} ]
				}).compositionMode({
					alpha : 0.2
				});

				start = end;
			}

			if (this._subChartTitleVisible) {
				// we are using series name as multi title
				var name = series.getName();
				var font = this._options.subChartTitle.font;
				var color = this._options.subChartTitle.color;
				var layer = this.getLayer();
				var newSize = layer.size();
				var subChartTitleHeight = TextRuler.measureHeight(font, name);
				var subChartTitleWidth = TextRuler.measureWidth(font, name);
				this._shapes.subChartTitle.center([ this._meta.center.x, newSize.height - subChartTitleHeight / 2 ]).width(
						subChartTitleWidth).text(name).font(font).textColor(color);
			}

			if (this._type == this._donutType) {
				// FIXME: JY, which color do we want to fill in
				// the
				// centerCircle? maybe the background color
				var measureName = series.getName();
				this._shapes.centerCircle.center(this._meta.center).radius(this._meta.radiusInner).fillingColor(
						this._donutBackground);
				this._shapes.measureLabel.width(TextRuler.measureWidth(this._donutMeasureFont, measureName)).text(
						measureName).font(this._donutMeasureFont).center([ this._meta.center.x, this._meta.center.y ])
						.textColor(this._donutMeasureColor);
				if (this._shapes.pieSectors.length < 1) {
					this._shapes.centerCircle.visible(false);
				}
			}

			// [JYANG, 3/29/2012] we split the visible
			// controlling of measureLabel from centerCircle as
			// we have special
			// behavior for measureLabel in multiple pie
			this._shapes.measureLabel.visible(this._centralSeriesNameVisible);

			this._hideTooltip();

			// In case user/client resizes/re-layouts chart
			// components which triggers
			// doContentResize(), thus duplicates the
			// _interactionStatus states if possible, the
			// _defaultSelectedSectorIndexes field must be set
			// empty here.
			this._defaultSelectedSectorIndexes = [];
			
			// Nick. As requested by POs, there should be one default font size for each part of tooltip if user has 
			// no settings for this.
			if(!TypeUtils.isExist(this._toolTipMainValueFont)){
				this._toolTipMainValueFont = 'bold 12px Arial';
			}
			if(!TypeUtils.isExist(this._toolTipTextFont)){
				this._toolTipTextFont =  'normal 12px Arial';
			}
			if(!TypeUtils.isExist(this._toolTipSubValueFont)){
				this._toolTipSubValueFont =  'normal 12px Arial';
			} 
			
			this.getTooltipFontStyle();
			this._refresh();
		},

		autoResizeTooltipFont : function(){
 
			var fontStyleArray = ['bold ',' Arial'];			
			var	labelFontStyleArray = ['normal ',' Arial'];
			var percentFontStyleArray = ['normal ',' Arial'];
		 
			
			var newFontStyle, maxWidth = 0, values = [];
			var longestNumber = this._getValueWithLongestNumberOfDigits(values);
			
			var j = 9;
			for (var i = 0; i < values.length; i++) {
				// Only the number with longest length is
				// considered, after test, the width of 9999 is
				// smaller than the width of 11111
				if (values[i].toString().length === longestNumber) {
					
					while(j >= 9) {
						var fontStyle = fontStyleArray[0] + j + 'px' + fontStyleArray[1];
						var fontWidth = TextRuler.measureWidth(fontStyle, values[i]);
						if (fontWidth >= (this._meta.radiusInner * 2)) {
							j--;
							break;
						}
						j++;
					}
					// In case, the values array has two values
					// that have the same number of digits, the
					// one with longer width is taken.
					if (fontWidth > maxWidth) {
						maxWidth = fontWidth;
						newFontStyle = fontStyle;
					}
					var labelFontStyle = labelFontStyleArray[0] + j + 'px' + labelFontStyleArray[1];
					var percentFontStyle = percentFontStyleArray[0] + j + 'px' + percentFontStyleArray[1];
				}
			}
			this._applyTooltipFontStyleSetting(labelFontStyle, newFontStyle, percentFontStyle);
		},
		
		/**
		 * 	format values of tooltip and find the one with longest length
		 */
		_getValueWithLongestNumberOfDigits : function(values){
			// Nick.Sun - 16.04.2012
			var tooltipFT, longestNumber = 0;
			for ( var i = 0; i < this._values.length; i++) {
				tooltipFT = sap.common.globalization.NumericFormatManager
						.getFormat(this._toolTipMainValueFormatString[i]);
				values.push((TypeUtils.isExist(tooltipFT) ? tooltipFT.display(this._values[i].vo.value)
						: this._values[i].vo.value));
				if (values[i].toString().length >= longestNumber) {
					longestNumber = values[i].toString().length;
				}
			}
			return longestNumber;
			
		},
		
		/**
		 * Apply the new font style to all tooltip members
		 * @param labelFontStyle
		 * @param newFontStyle
		 * @param percentFontStyle
		 */
		_applyTooltipFontStyleSetting : function(labelFontStyle, newFontStyle, percentFontStyle){
			// Nick.Sun - 16.04.2012
			this._toolTipTextFont = TypeUtils.isExist(labelFontStyle) ? labelFontStyle : this._toolTipTextFont;
			this._toolTipMainValueFont = TypeUtils.isExist(newFontStyle) ? newFontStyle : this._toolTipMainValueFont;
			this._toolTipSubValueFont = TypeUtils.isExist(percentFontStyle) ? percentFontStyle : this._toolTipSubValueFont;
		},
		
		
		getTooltipFontStyle : function() {
			// 03/22/2012 - Nick.Sun
			// Find the 'best' font style for the value of
			// tooltip. The 'best' means the font style that
			// makes the width of value closest to the diameter
			// of tooltip circle.
			var p = /(\d+)(px|em|pt|%)/i;
			var m = p.exec(this._toolTipMainValueFont);
			var m1 = p.exec(this._toolTipTextFont);
			var m2 = p.exec(this._toolTipSubValueFont);
			var fontStyleArray = this._toolTipMainValueFont.split(m[0]);
			
			var labelFontStyleArray = ['normal ',' Arial'];
			var percentFontStyleArray = ['normal ',' Arial'];
			if(TypeUtils.isExist(m1)){
				labelFontStyleArray = this._toolTipTextFont.split(m1[0]);
			}
			if(TypeUtils.isExist(m2)){
				percentFontStyleArray = this._toolTipSubValueFont.split(m2[0]);
			}

			// format values of tooltip and find the one with
			// longest length
			var newFontStyle, maxWidth = 0, values = [];
			var longestNumber= this._getValueWithLongestNumberOfDigits(values);

			for (var i = 0; i < values.length; i++) {
				// Only the number with longest length is
				// considered, after test, the width of 9999 is
				// smaller than the width of 11111
				if (values[i].toString().length === longestNumber) {
					for ( var j = m[1]; j >= 9; j--) {
						var fontStyle = fontStyleArray[0] + j + 'px' + fontStyleArray[1];
						var fontWidth = TextRuler.measureWidth(fontStyle, values[i]);
						if (fontWidth <= (this._meta.radiusInner * 2)) {
							break;
						}
					}
					// In case, the values array has two values
					// that have the same number of digits, the
					// one with longer
					// width is taken.
					if (fontWidth > maxWidth) {
						maxWidth = fontWidth;
						newFontStyle = fontStyle;
					}
					var labelFontStyle = labelFontStyleArray[0] + j + 'px' + labelFontStyleArray[1];
					var percentFontStyle = percentFontStyleArray[0] + j + 'px' + percentFontStyleArray[1];
				}
			}

			this._applyTooltipFontStyleSetting(labelFontStyle, newFontStyle, percentFontStyle);
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var globalStyle = settings.global;
			var pieStyle = settings['pie'];

			var donutStyle = pieStyle.donut;
			var measureStyle = ObjectUtils.extend(true, {}, globalStyle, donutStyle.measureLabel);
			this._donutMeasureFont = measureStyle['font-weight'] + " " + measureStyle['font-size'] + " "
					+ measureStyle['font-family'];
			this._donutMeasureColor = measureStyle['color'];
			this._donutBackground = TypeUtils.isExist(donutStyle.background) ? donutStyle.background
					: settings.background;

			var isShowOuterShadow = this._isShowOuterShadow = pieStyle['isShowOuterShadow'];
			var isShowInnerShadow = this._isShowInnerShadow = pieStyle['isShowInnerShadow'];

			var tooltipStyle = pieStyle.tooltip;
			var dimensionStyle = ObjectUtils.extend(true, {}, globalStyle, tooltipStyle.dimensionLabel);
			this._toolTipTextFont = dimensionStyle['font-weight'] + " " + dimensionStyle['font-size'] + " "
					+ dimensionStyle['font-family'];
			this._toolTipTextFontColor = dimensionStyle['color'];
			var valueStyle = ObjectUtils.extend(true, {}, globalStyle, tooltipStyle.valueLabel);
			this._toolTipMainValueFont = valueStyle['font-weight'] + " " + valueStyle['font-size'] + " "
					+ valueStyle['font-family'];
			this._toolTipMainValueFontColor = valueStyle['color'];
			var percentStyle = ObjectUtils.extend(true, {}, globalStyle, tooltipStyle.percentLabel);
			this._toolTipSubValueFont = percentStyle['font-weight'] + " " + percentStyle['font-size'] + " "
					+ percentStyle['font-family'];
			this._toolTipSubValueFontColor = percentStyle['color'];

			// Update shape view.
			if (this._isDrawn) {
				this._shapes.centerCircle.fillingColor(this._donutBackground);
				if (this._type == this._donutType) {
					this._shapes.measureLabel.width(
							TextRuler.measureWidth(this._donutMeasureFont, this._getSeries().getName())).font(
							this._donutMeasureFont).textColor(this._donutMeasureColor);
				}
				var sectorOuterShadowShape = this._shapes.sectorOuterShadow;
				var sectorInnerShadowShape = this._shapes.sectorInnerShadow;
				var sectorLength = this._shapes.pieSectors.length;
				for ( var i = 0; i < sectorLength; i++) {
					sectorOuterShadowShape[i].visible(isShowOuterShadow);
					sectorInnerShadowShape[i].visible(isShowInnerShadow);
				}

				// [Christy]Remove selected sector's outer
				// shadow.
				var selectedList = this._interactionStatus.selected;
				for ( var i = 0, length = selectedList.length; i < length; i++) {
					sectorOuterShadowShape[selectedList[i]].visible(false);
				}

				if (this._interactionStatus.mouseOnPieIndex !== null) {
					var value = this._mainValueFT
							.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.value);
					this._tooltip.valueLabel.font(this._toolTipMainValueFont)
							.textColor(this._toolTipMainValueFontColor).width(
									TextRuler.measureWidth(this._toolTipMainValueFont, value));
					var dimensionItem = this._textValueFT
							.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItem);
					this._tooltip.dimensionLabel.font(this._toolTipTextFont).textColor(this._toolTipTextFontColor)
							.width(TextRuler.measureWidth(this._toolTipTextFont, dimensionItem));
					var percent = this._subValueFT
							.display(this._values[this._interactionStatus.mouseOnPieIndex].percent);
					this._tooltip.percentLabel.font(this._toolTipSubValueFont)
							.textColor(this._toolTipSubValueFontColor).width(
									TextRuler.measureWidth(this._toolTipSubValueFont, percent));
				}
			}
			this.getTooltipFontStyle();
			this._refresh();
		},

		_reset : function() {
			delete this._values;
			this._values = [];
			this._resetShapes();
		},

		_resetShapes : function() {
			var layer = this.getLayer();
			var shapes = this._shapes.pieSectors;
			var innerShadow = this._shapes.sectorInnerShadow;
			var outerShadow = this._shapes.sectorOuterShadow;
			for ( var i = 0, len = shapes.length; i < len; i++) {
				layer.removeShape(shapes[i]);
				layer.removeShape(outerShadow[i]);
				layer.removeShape(innerShadow[i]);
			}
			layer.removeShape(this._shapes.centerCircle);
			layer.removeShape(this._shapes.measureLabel);
			layer.removeShape(this._shapes.subChartTitle);

			layer.removeShape(this._tooltip.shape);
			layer.removeShape(this._tooltip.dimensionLabel);
			layer.removeShape(this._tooltip.valueLabel);
			layer.removeShape(this._tooltip.percentLabel);

			delete this._shapes;
			this._shapes = {
				pieSectors : [],
				centerCircle : null,
				measureLabel : null,
				sectorInnerShadow : [],
				sectorOuterShadow : [],
				cover : null,
				subChartTitle : null
			};
			delete this._tooltip;
			this._tooltip = {
				shape : null,
				dimensionLabel : null,
				valueLabel : null,
				percentLabel : null
			};
		},

		_refresh : function() {
			this.getLayer().setNeedsDisplay();
		},

		// /////////////some of them to be removed out of
		// renderer[eeye]////

		_mouseMoveOnPie : function(evt) {
			this._moveOnPie(evt.currentLocalXY());
		},

		_mouseDownOnPie : function(evt) {
			this._clickOnPie(evt.currentLocalXY());
		},

		_touchStartOnPie : function(evt) {
			// TODO: need investigate why length not equal 1
			var touch = evt.targetTouches().item(0);
			this._moveOnPie(touch.localXY());
		},

		_touchEndOnPie : function(evt) {
			if (evt.changedTouches().length() != 1) {
				return;
			}

			var touch = evt.changedTouches().item(0);
			this._clickOnPie(touch.localXY());
		},

		_touchMoveOnPie : function(evt) {
			if (evt.targetTouches().length() != 1) {
				return;
			}

			var touch = evt.targetTouches().item(0);
			this._moveOnPie(touch.localXY());
		},

		_getPieIndexByPos : function(pos) {
			var pieIndex = null;
			if (this._type == this._donutType && this._shapes.centerCircle.doPointInTest(pos)) {
				// ignore the event if it happens in inner
				// circle
				return pieIndex;
			}

			for ( var i = 0; i < this._shapes.pieSectors.length; i++) {
				if (this._shapes.pieSectors[i].doPointInTest(pos)) {
					pieIndex = i;
					break;
				}
			}
			return pieIndex;
		},

		_moveOnPie : function(pos) {
			var pieIndex = this._getPieIndexByPos(pos);
			var lastIndex = this._interactionStatus.mouseOnPieIndex;
			this._interactionStatus.mouseOnPieIndex = pieIndex;
			if (this._interactionStatus.mouseOnPieIndex == null) {
				this._hideTooltip();
				return;
			}

			if (lastIndex != this._interactionStatus.mouseOnPieIndex) {
				this._hideTooltip();
				this._showTooltip();
			}

			// get data context and return
			return {
				dimensionAxisIndex : 0, // reserved for multiple
				// charts
				dimensionIndex : 0, // reserved for multiple
				// charts
				dimensionItemIndex : this._values[pieIndex].vo.dimensionItemIndex,
				measureIndex : this._values[pieIndex].vo.measureIndex,
				dimensionLabel : this._values[pieIndex].vo.dimensionItem, // display
				// value
				// in
				// the
				// chart
				measureValue : this._values[pieIndex].vo.value
			// display value in the chart
			};
		},

		_clickOnPie : function(pos) {
			var layer = this.getLayer();
			var currentIndex = this._getPieIndexByPos(pos);

			var selected = null;
			for ( var i = 0; i < this._interactionStatus.selected.length; i++) {
				if (this._interactionStatus.selected[i] === currentIndex) {
					selected = i;
					break;
				}
			}

			if (currentIndex != null) {
				if (selected == null) {
					// If sectors ain't select-able according to
					// chart options, event processing just
					// ends here and ignores further executions.
					if (!this._allSelectable) {
						return;
					}
					if (this._selectionMode === 'single') {
						this._deselectPies(this._interactionStatus.selected);
						this._interactionStatus.selected = [];
						selected = null;
					}
					this._interactionStatus.selected.push(currentIndex);
					this._selectPie(currentIndex);

					// [jyang 03/13/2012] we return all selected
					// data context here
					// and we create new each time so that we
					// can return it directly
					// to client
					var dataContextRet = [];
					for ( var i = 0, len = this._interactionStatus.selected.length; i < len; i++) {
						var index = this._interactionStatus.selected[i];
						var dctx = {
							measureIndex : this._values[index].vo.measureIndex,
							dimensionLabel : this._values[index].vo.dimensionItem, // display
							// value
							// in
							// the
							// chart
							measureValue : this._values[index].vo.value
						// display value in the chart
						};
						if (TypeUtils.isExist(this._values[index].vo.dimensionPath)) {
							dctx.dimensionPath = this._values[index].vo.dimensionPath;
						} else {
							dctx.dimensionItemIndex = this._values[index].vo.dimensionItemIndex;
						}
						dataContextRet.push(dctx);
					}
					return dataContextRet;
				} else {
					// Client doesn't allow de-selection, so the
					// remaining execution will be ignored.
					if (!this._allDeSelectable) {
						return;
					}
					this._interactionStatus.selected.splice(selected, 1);
					this._deselectPies([ currentIndex ]);
				}
			} else {
				// User could click some blank area of the pie
				// canvas component which will trigger
				// de-selection.
				if (!this._allDeSelectable) {
					return;
				}
				this._deselectPies(this._interactionStatus.selected);
				this._interactionStatus.selected = [];
			}
		},

		_showTooltip : function() {
			//hide measure name in donut
			this._shapes.measureLabel.visible(false);
			var currentPie = this._shapes.pieSectors[this._interactionStatus.mouseOnPieIndex];
			var pointAngle = (currentPie.endAngle() + currentPie.startAngle()) / 2;
			var radius = this._meta.radiusInner * 1.2;
			var tooltipFT;
			var dimensionItemIndex = this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItemIndex;

			this._tooltip.shape.reset();
			this._tooltip.shape.visible(true).arc(this._meta.center, this._meta.radiusInner, pointAngle - 0.15,
					pointAngle + 0.15, false).lineTo(this._meta.center.x + radius * Math.cos(pointAngle),
					this._meta.center.y + radius * Math.sin(pointAngle)).shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 5,
				color : '#000000'
			});
			this._tooltip.shape.fillingColor('#FFFFFF');
			tooltipFT = sap.common.globalization.NumericFormatManager
					.getFormat(this._toolTipMainValueFormatString[dimensionItemIndex]);
			var value = TypeUtils.isExist(tooltipFT) ? tooltipFT
					.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.value)
					: this._values[this._interactionStatus.mouseOnPieIndex].vo.value;
			var fontHeight = TextRuler.measureText(this._toolTipMainValueFont, value).height;
			this._tooltip.valueLabel.visible(true).width(TextRuler.measureWidth(this._toolTipMainValueFont, value))
					.text(value).font(this._toolTipMainValueFont).textColor(this._toolTipMainValueFontColor).center(
							[ this._meta.center.x, this._meta.center.y ]);

			tooltipFT = sap.common.globalization.NumericFormatManager
					.getFormat(this._toolTipTextFormatString[dimensionItemIndex]);
			var dimensionItem = TypeUtils.isExist(tooltipFT) ? tooltipFT
					.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItem)
					: this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItem;

			var dimensionItemWidth = TextRuler.measureWidth(this._toolTipTextFont, dimensionItem);
			var unitHeight = TextRuler.measureText(this._toolTipTextFont, textPhrase).height;
			// unitHeight means how many pixels 1em is for current font style

			var availableHeight = this._meta.radiusInner - fontHeight / 2;
			var showTooltipLabel = true;
			// if height for label is less than 1em, just hide
			// the label.
			if (availableHeight < unitHeight) {
				showTooltipLabel = false;
			}
			// 1em padding in total (left and right)
			if (dimensionItemWidth > (this._meta.radiusInner * 2 - unitHeight)) {
				var referenceCharacter = 'r'; // The widest
				// alphabet
				var truncReplacementWidth = TextRuler.measureWidth(this._toolTipTextFont, this._truncReplacement);
				var unitWidth = TextRuler.measureText(this._toolTipTextFont, referenceCharacter).width;
				// Calculate the number of letters can be
				// applied here. The available width = (the
				// diameter of tooltip circle - padding - width
				// of '...')
				var lineCapacity = Math.floor((this._meta.radiusInner * 2 - unitHeight - truncReplacementWidth)
						/ unitWidth);
				// Make the new dimension label
				dimensionItem = dimensionItem.substring(0, lineCapacity) + this._truncReplacement;
			}

			this._tooltip.dimensionLabel.visible(showTooltipLabel).width(
					TextRuler.measureWidth(this._toolTipTextFont, dimensionItem)).text(dimensionItem).font(
					this._toolTipTextFont).textColor(this._toolTipTextFontColor)
					.bottomCenter(
							[ this._tooltip.valueLabel.topCenter().x,
									this._tooltip.valueLabel.topCenter().y - fontHeight / 4 ]);

			tooltipFT = sap.common.globalization.NumericFormatManager
					.getFormat(this._toolTipSubValueFormatString[dimensionItemIndex]);
			var percent = TypeUtils.isExist(tooltipFT) ? tooltipFT
					.display(this._values[this._interactionStatus.mouseOnPieIndex].percent)
					: this._values[this._interactionStatus.mouseOnPieIndex].percent;
			this._tooltip.percentLabel.visible(true).width(TextRuler.measureWidth(this._toolTipSubValueFont, percent))
					.text(percent).font(this._toolTipSubValueFont).textColor(this._toolTipSubValueFontColor).topCenter(
							[ this._tooltip.valueLabel.bottomCenter().x,
									this._tooltip.valueLabel.bottomCenter().y + fontHeight / 4 ]);

			this._refresh();
		},

		_hideTooltip : function() {
			if (!this._tooltip || this._tooltip.shape == null) {
				return;
			}
			this._tooltip.shape.visible(false);
			this._tooltip.dimensionLabel.visible(false);
			this._tooltip.valueLabel.visible(false);
			this._tooltip.percentLabel.visible(false);
			this._shapes.measureLabel.visible(this._centralSeriesNameVisible);
			this._refresh();
		},

		_selectPie : function(index) {
			var pieShape = this._shapes.pieSectors[index];
			var innerShadowShape = this._shapes.sectorInnerShadow[index];
			var innerBlur = this._innerShadowBlur;
			var radius = this._meta.radiusOutter;
			var self = this;

			// [Christy | 2012/3/13] Hide Selected sector outer
			// shadow.
			if (this._isShowOuterShadow) {
				self._shapes.sectorOuterShadow[index].visible(false);
			}
			self._refresh();

			var pointAngle = (pieShape.endAngle() + pieShape.startAngle()) / 2;
			Animator.animate({
				values : [ {
					type : 'POINT',
					from : [ self._meta.center.x, self._meta.center.y ],
					to : [ self._meta.center.x + 10 * Math.cos(pointAngle),
							self._meta.center.y + 10 * Math.sin(pointAngle) ]
				} ],
				duration : 200,
				onStep : function(values) {
					var centerPoint = {
						x : values[0][0],
						y : values[0][1]
					};
					pieShape.center(centerPoint);
					innerShadowShape.center(centerPoint)
						.fillingColor({
									t : 'rg',
									s : {
										c : centerPoint,
										r : radius
									},
									e : {
										c : centerPoint,
										r : radius - innerBlur
									},
									st : [ {
										o : 0,
										v : '#000'
									}, {
										o : 1,
										v : '#fff'
									} ]
								});
					self._refresh();
				}
			});
		},

		_deselectPies : function(indexes) {
			var innerBlur = this._innerShadowBlur;
			var radius = this._meta.radiusOutter;
			var self = this;
			var animationValues = [];
			for ( var i = 0; i < indexes.length; i++) {
				var pieShape = this._shapes.pieSectors[indexes[i]];
				animationValues.push({
					type : 'POINT',
					from : [ pieShape.center().x, pieShape.center().y ],
					to : [ self._meta.center.x, self._meta.center.y ]
				});
			}

			Animator.animate({
				values : animationValues,
				duration : 200,
				onStep : function(values) {
					var pieShape, innerShadowShape, centerPoint;
					for ( var i = 0; i < indexes.length; i++) {
						centerPoint = {
							x : values[i][0],
							y : values[i][1]
						};
						innerShadowShape = self._shapes.sectorInnerShadow[indexes[i]];
						innerShadowShape.center(centerPoint).fillingColor({
							t : 'rg',
							s : {
								c : centerPoint,
								r : radius
							},
							e : {
								c : centerPoint,
								r : radius - innerBlur
							},
							st : [ {
								o : 0,
								v : '#000'
							}, {
								o : 1,
								v : '#fff'
							} ]
						});

						pieShape = self._shapes.pieSectors[indexes[i]];
						pieShape.center(centerPoint);
					}
					self._refresh();
				},
				onComplete : function() {
					var isShowOuterShadow = self._isShowOuterShadow;
					for ( var i = 0; i < indexes.length; i++) {
						if (isShowOuterShadow) {
							self._shapes.sectorOuterShadow[indexes[i]].visible(true);
						}
					}
				}
			});
		},
		// /////////////end of some of them to be removed out of
		// renderer///

		updateProperties : function(propBag) {
			this._selectionMode = propBag.selectionMode;
			if (this._selectionMode == 'single' && this._interactionStatus.selected.length > 1) {
				var uncheck = this._interactionStatus.selected.slice(0, this._interactionStatus.selected.length - 1);
				this._interactionStatus.selected.splice(0, this._interactionStatus.selected.length - 1);
				this._deselectPies(uncheck);
			}

			this._colorList = propBag._additional.colorList;
			for ( var i = 0, len = this._shapes.pieSectors.length; i < len; i++) {
				// the length should be same as colorList, and
				// this._values
				this._values[i].color = this._colorList[this._values[i].vo.dimensionItemIndex];
				this._shapes.pieSectors[i].fillingColor(this._values[i].color);
			}

			this._type = propBag.pieType;
			this._centralSeriesNameVisible = (this._type === this._donutType) && (!this._multiMode);

			if (this._type == this._pieType) {
				this._shapes.centerCircle.visible(false);
			} else {
				this._shapes.centerCircle.visible(true);
			}

			this._isShowInnerShadow = propBag.isShowPieInnerShadow;
			this._isShowOuterShadow = propBag.isShowPieOuterShadow;

			this._toolTipTextFont = propBag.tooltip.text.font;
			this._toolTipTextFontColor = propBag.tooltip.text.color;
			this._toolTipTextFormatString = propBag.tooltip.text.numberFormat;
			this._toolTipTextFormatString = propBag._additional.tooltipeTextNumberFormat;

			this._toolTipMainValueFont = propBag.tooltip.mainValue.font;
			this._toolTipMainValueFontColor = propBag.tooltip.mainValue.color;
			this._toolTipMainValueFormatString = propBag.tooltip.mainValue.numberFormat;
			this._toolTipMainValueFormatString = propBag._additional.tooltipeMainValueNumberFormat;

			this._toolTipSubValueFont = propBag.tooltip.subValue.font;
			this._toolTipSubValueFontColor = propBag.tooltip.subValue.color;
			this._toolTipSubValueFormatString = propBag.tooltip.subValue.numberFormat;
			this._toolTipSubValueFormatString = propBag._additional.tooltipeSubValueNumberFormat;

			this._refresh();
		},

		updateOptions : function(pie) {
			this._resetShapes();
			this._shapes = {
				pieSectors : [],
				centerCircle : null,
				measureLabel : null,
				sectorInnerShadow : [],
				sectorOuterShadow : [],
				cover : null,
			};
			this._isShowInnerShadow = false;
			this._isShowOuterShadow = false;

			this._interactionStatus = {
				mouseDown : false,
				mouseOnPieIndex : null,
				selected : []
			};
			this._tooltip = {
				shape : null,
				dimensionLabel : null,
				valueLabel : null,
				percentLabel : null
			};
			this._parseOptions(pie);
		},

		/**
		 * 
		 * @override sap.riv.viz.shared.series.BaseRenderer.highlightOnPoint
		 */
		highlightOnPoint : function(point) {
			var dataContextOnPoint = this._clickOnPie(point);
			return dataContextOnPoint;
		},

		/**
		 * 
		 * @override sap.riv.viz.shared.series.BaseRenderer.hoverOnPoint
		 */
		hoverOnPoint : function(point) {
			var dataContextOnPoint = this._moveOnPie(point);
			return dataContextOnPoint;
		}
	});

	return pieRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.BasicAxisRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, Math, TextRuler, TypeUtils, FunctionUtils, Layer, PositionCalculator, ThemeManager, Line,
		TextLine) {

	var basicAxisRenderer = function(options) {

		this._baxr_options = options;

		/**
		 * label metrics
		 */
		this._labelMetrics = {
			top : 2,
			left : 2,
			right : 2,
			bottom : 2
		};

		/*
		 * font direction: horizontal or vertical
		 */
		this._direction = 'horizontal';

		/*
		 * show or hide major tick mark of axis
		 */
		this._showMajorTicks = false;

		/*
		 * show or hide minor tick mark of axis
		 */
		this._showMinorTicks = false;

		/*
		 * minor divisions
		 */
		this._minorDivisions = 3;

		/*
		 * major tick mark size
		 */
		this._majorMarkSize = 8;

		/*
		 * minor tick mark size
		 */
		this._minorMarkSize = 4;

		/*
		 * whether to show axis line
		 */
		this._showAxisLine = true;

		/*
		 * axis line size
		 */
		this._lineThickness = 1;

		/*
		 * line color
		 */
		this._lineColor = '#ffffff';

		/*
		 * margin of all lables
		 */
		this._textMargin = {
			top : 4,
			left : 4,
			right : 4,
			bottom : 4
		};

		/*
		 * axis position, hb ht vl or vr
		 */
		this._position = 'hb';

		/*
		 * whether to show or hidden overlapping lables
		 */
		this._hideOverlappingLabels = true;

		/*
		 * axis martics
		 */
		this._axisMatrics = {
			top : 0,
			right : 0,
			left : 0,
			bottom : 0
		};

		/*
		 * axis title options
		 */
		this._title = {
			show : false,
			value : '',
			style : 'bold 13px Arial',
			color : '#ffffff',
			formatString : '',
			margin : {
				top : 4,
				left : 4,
				right : 4,
				bottom : 4
			}
		};

		/*
		 * axis label options
		 */
		this._labels = {
			show : true,
			itemsValue : [],
			color : '#ffffff',
			font : 'normal 11px Arial',
			formatString : '',
			itemsPosition : []
		};

		this._shapeRenderer = {
			title : null,
			axisLine : null,
			majorTicks : [],
			minorTicks : [],
			labels : []
		};

		// Visible range options
		this._visibleStart = 0;
		this._visibleEnd = Number.POSITIVE_INFINITY;
		this._scaled = false;

		this._baxr_initialize();
	};

	/*
	 * init the axis render options
	 */
	basicAxisRenderer.prototype._baxr_initialize = function() {
		var opts = this._baxr_options;
		this._position = TypeUtils.isExist(opts.position) ? opts.position : 'hb';
		this._lineScaling = TypeUtils.isExist(opts.lineScaling) ? opts.lineScaling : 'linear';
		this._distance = opts.distance;
		this._direction = TypeUtils.isExist(opts.direction) ? opts.direction : 'horizontal';
		this._lineColor = TypeUtils.isExist(opts.lineColor) ? opts.lineColor : this._lineColor;
		this._labels.color = TypeUtils.isExist(opts.labelColor) ? opts.labelColor : this._labels.color;
		this._labels.font = TypeUtils.isExist(opts.labelFont) ? opts.labelFont : this._labels.font;
		this._labels.formatString = (TypeUtils.isExist(opts.labelsFormatString) && opts.labelsFormatString.length !== 0) ? opts.labelsFormatString
				: this._labels.formatString;
		this._lineThickness = TypeUtils.isExist(opts.lineThickness) ? opts.lineThickness : this._lineThickness;
		this._showMajorTicks = TypeUtils.isExist(this._baxr_options.showMajorTicks) ? this._baxr_options.showMajorTicks
				: false;
		; // disable show the major mark and minor mark
		this._showMinorTicks = TypeUtils.isExist(this._baxr_options.showMinorTicks) ? this._baxr_options.showMinorTicks
				: false;
		if (TypeUtils.isExist(opts.showTitle)) {
			this._title.show = opts.showTitle;
			if ( TypeUtils.isExist(opts.title) ) {
				this._title.value = opts.title;
			}
			if (TypeUtils.isExist(opts.titleFont)) {
				this._title.style = opts.titleFont;
			}
			if (TypeUtils.isExist(opts.titleColor)) {
				this._title.color = opts.titleColor;
			}
			if (TypeUtils.isExist(opts.titleNumberFormat)) {
				this._title.formatString = opts.titleFormatString;
			}
			this._titleFT = sap.common.globalization.NumericFormatManager.getFormat(this._title.formatString);
		}
		var labelsEM = TextRuler.measureWidth(this._labels.font, 'M');
		var labelsPadding = Math.round(0.2 * labelsEM);
		this._textMargin = {
			top : labelsPadding,
			left : labelsPadding + 2,
			right : labelsPadding,
			bottom : labelsPadding
		};
		var titleEM = TextRuler.measureWidth(this._title.style, 'M');
		var titlePadding = Math.round(0.2 * titleEM);
		this._title.margin = {
			top : titlePadding,
			bottom : titlePadding,
			left : titlePadding,
			right : titlePadding
		};
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.setLayer = function(layer) {
		this._layer = layer;
		layer.clipToBounds(true);

		var bounds = layer.bounds();
		this._subLayer = new Layer({
			anchor : {
				x : 0,
				y : 0
			},
			size : {
				w : bounds.width,
				h : bounds.height
			}
		});
		this._layer.addSubLayer(this._subLayer);
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.getSubLayer = function() {
		return this._subLayer;
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.getPreferredSize = function() {
		return this._getPreferredSize();
	};

	/*
	 * return the preferred size of asix
	 */
	basicAxisRenderer.prototype._getPreferredSize = function() {
		var tu = TextRuler;

		var h = 0;
		var w = 0;

		// vertical left or vertical right
		if (this._position == 'vl' || this._position == 'vr') {
			// if the direction is vertical, measure the width of chart axis

			w = this._measureWidth();
			h = this._distance;

			this._axisMatrics.bottom = this._axisMatrics.top = tu.measureHeight(this._labels.font) / 2;

			h += this._axisMatrics.top;
			h += this._axisMatrics.bottom;
		}
		// horizontal bottom or horizontal top
		else {
			// if the direction is horizontal, measure the height of chart axis
			h = this._measureHeight();
			w = this._distance;

			this._axisMatrics.left = tu.measureWidth(this._labels.font, this._labels.itemsValue[0].value()) / 2;
			this._axisMatrics.right = tu.measureWidth(this._labels.font, this._labels.itemsValue[0].value()) / 2;

			w += this._axisMatrics.left;
			w += this._axisMatrics.right;
		}

		return {
			width : w,
			height : h
		};
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.getPreferredWidth = function() {
		if (this._position == 'vl' || this._position == 'vr') {
			this._preferredWidth = this._measureWidth();
			return this._preferredWidth;
		} else {
			if (TypeUtils.isExist(this._distance) && this._distance != 0) {
				this._preferredWidth = this._distance;

				this._preferredWidth += this._axisMatrics.left;
				this._preferredWidth += this._axisMatrics.right;

				return this._preferredWidth;
			}
			return 0;
		}
	};

	basicAxisRenderer.prototype.getPreferredHeight = function() {
		if (this._position == 'hb' || this._position == 'ht') {
			this._preferredHeight = this._measureHeight();
			return this._preferredHeight;
		} else {
			if (TypeUtils.isExist(this._distance) && this._distance != 0) {
				this._preferredHeight = this._distance;

				this._preferredHeight += this._axisMatrics.top;
				this._preferredHeight += this._axisMatrics.bottom;

				return this._preferredHeight;
			}
			return 0;
		}
	};

	/**
	 * 
	 */
	basicAxisRenderer.prototype._measureHeight = function() {
		var tu = TextRuler;

		var h = 0;

		if (this._showMajorTicks) {

			if (this._showMinorTicks) {
				if (this._majorMarkSize >= this._minorMarkSize && this._majorMarkSize >= this._lineThickness) {
					h += this._majorMarkSize;
				} else if (this._majorMarkSize < this._minorMarkSize && this._minorMarkSize >= this._lineThickness) {
					h += this._minorMarkSize;
				} else {
					h += this._lineThickness;
				}
			} else {
				if (this._majorMarkSize >= this._lineThickness) {
					h += this._majorMarkSize;
				} else {
					h += this._lineThickness;
				}
			}
		} else if (this._showMinorTicks) {
			if (this._minorMarkSize >= this._lineThickness) {
				h += this._minorMarkSize;
			} else {
				h += this._lineThickness;
			}
		} else {
			h += this._lineThickness;
		}

		// add the text label top margin
		h += this._textMargin.top;

		if (this._direction === 'vertical') {
			// TODO: Now if the label is already vertical, we will do not change
			// the direction. it is mostly happen in pinch.
			// if in first status, the labels is in vertical direction, we will
			// keep it.
		} else if (!this._isLabelHorizontal()) {
			this._direction = 'vertical';
		} else {
			this._direction = 'horizontal';
		}

		if (this._direction == 'horizontal') {
			h += tu.measureHeight(this._labels.font);
		} else {
			// find the longest str
			h += this._getLongestWidth();
		}

		// add the text label bottom margin
		h += this._textMargin.bottom;

		if (this._title.show) {
			h += this._title.margin.top;
			h += tu.measureHeight(this._title.style);
			h += this._title.margin.bottom;
		}

		return h;
	};

	basicAxisRenderer.prototype._isLabelHorizontal = function() {

		if (this._position == 'vl' || this._position == 'vr') {
			return true;
		}

		var tu = TextRuler;
		var labelpositions = this._labels.itemsPosition;

		// test whether we can draw all the label vertical
		var lw = tu.measureWidth(this._labels.font, this._labels.itemsValue[0].value());
		var lp = labelpositions[0];

		var rw = tu
				.measureWidth(this._labels.font, this._labels.itemsValue[this._labels.itemsValue.length - 1].value());
		var rp = labelpositions[labelpositions.length - 1];

		var w = 0;
		var p = 0;
		var isFitable = true;

		// 3/20/2012 - N.Sun
		// The following logic is to check two boundary cases:
		// (1) if half width of the first label is longer than the distance
		// [between first label position and starting point of axis], the lable
		// is vertical
		// (2) if half width of the last label is longer than the distance
		// [between last label position and end point of axis], the lable is
		// vertical
		// if the first label position is 0, it should be value axis, just
		// ignore the check here.
		if (lp != 0 && (lw / 2 > lp || rw / 2 > this._distance - rp)) {
			isFitable = false;
		}
		if (this._direction == 'horizontal' && isFitable) {
			for ( var i = 1, cLabelsText = this._labels.itemsValue, len = cLabelsText.length; i < len; i++) {
				w = tu.measureWidth(this._labels.font, cLabelsText[i].value());
				p = labelpositions[i];

				if ((lp + lw / 2) > (p - w / 2)) {
					isFitable = false;
					break;
				}
				lw = w;
				lp = p;
			}
		} else {
			return false;
		}

		if (isFitable)
			return true;

		return false;

	};

	/**
	 * measure with of axis
	 */
	basicAxisRenderer.prototype._measureWidth = function() {
		var tu = TextRuler;

		var w = 0;

		if (this._title.show) {
			w += this._title.margin.top;

			w += tu.measureHeight(this._title.style);

			w += this._title.margin.bottom;
		}

		if (this._showMajorTicks) {

			if (this._showMinorTicks) {
				if (this._majorMarkSize >= this._minorMarkSize && this._majorMarkSize >= this._lineThickness) {
					w += this._majorMarkSize;
				} else if (this._majorMarkSize < this._minorMarkSize && this._minorMarkSize >= this._lineThickness) {
					w += this._minorMarkSize;
				} else {
					w += this._lineThickness;
				}
			} else {
				if (this._majorMarkSize >= this._lineThickness) {
					w += this._majorMarkSize;
				} else {
					w += this._lineThickness;
				}
			}
		} else if (this._showMinorTicks) {
			if (this._minorMarkSize >= this._lineThickness) {
				w += this._minorMarkSize;
			} else {
				w += this._lineThickness;
			}
		} else {
			w += this._lineThickness;
		}

		// add the text right margin
		w += this._textMargin.right;

		w += this._getLongestWidth();

		w += this._textMargin.left;

		return w;
	};

	/**
	 * if the preferredHeight and preferredWidth is undefined, call
	 * _measureHeight and _measureWidth
	 * 
	 */
	basicAxisRenderer.prototype.draw = function(reset) {

		if (!reset) {
			this._resetShapes();
			this.createRenderer();

			if (this._scaled === false) {
				this.getSubLayer().size(this._layer.size());
				this.getSubLayer().position({
					x : 0,
					y : 0
				});
			}

		}

		if (this._position == 'hb' || this._position == 'ht') {
			if (!TypeUtils.isExist(this._preferredHeight) || this._preferredHeight == 0)
				this._preferredHeight = this._measureHeight();
		} else {
			if (!TypeUtils.isExist(this._preferredWidth) || this._preferredWidth == 0)
				this._preferredWidth = this._measureWidth();
		}

		this._draw(this.getSubLayer());
	};

	/**
	 * draw title, axis line, major ticks, minor ticks and labels
	 */
	basicAxisRenderer.prototype._draw = function(layer) {
		var tu = TextRuler;

		var baseLine = 0;

		if (this._position == 'hb') {

			baseLine += this._drawLineAndTick(layer, baseLine);

			// add the text top margin
			baseLine += this._textMargin.top;

			this._drawLabels(layer, baseLine);

			if (this._direction == 'horizontal') {
				baseLine += tu.measureHeight(this._labels.font);
			} else {
				baseLine += this._getLongestWidth();
			}

			baseLine += this._textMargin.bottom;

			// add title margin top
			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, (this._axisMatrics.left + this._distance + this._axisMatrics.right) / 2,
						baseLine);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

		} else if (this._position == 'ht') {

			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, (this._axisMatrics.left + this._distance + this._axisMatrics.right) / 2,
						baseLine);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

			baseLine += this._textMargin.top;

			this._drawLabels(layer, baseLine);

			if (this._direction == 'horizontal') {
				baseLine += tu.measureHeight(this._labels.font);
			} else {
				baseLine += this._getLongestWidth();
			}

			// add the bottom margin
			baseLine += this._textMargin.bottom;

			baseLine += this._drawLineAndTick(layer, baseLine);

		} else if (this._position == 'vl') {

			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, baseLine,
						(this._axisMatrics.top + this._distance + this._axisMatrics.bottom) / 2);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

			var axisTop = this._axisMatrics.top;

			baseLine += this._textMargin.left;

			baseLine += this._getLongestWidth();

			this._drawLabels(layer, baseLine);
			// add the right margin
			baseLine += this._textMargin.right;

			baseLine += this._drawLineAndTick(layer, baseLine);

		} else if (this._position == 'vr') {

			var axisTop = this._axisMatrics.top;

			baseLine += this._drawLineAndTick(layer, baseLine);

			// add the left margin
			baseLine += this._textMargin.left;

			this._drawLabels(layer, baseLine);

			baseLine += this._getLongestWidth();

			baseLine += this._textMargin.right;

			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, baseLine,
						(this._axisMatrics.top + this._distance + this._axisMatrics.bottom) / 2);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

		}
	};

	basicAxisRenderer.prototype.createRenderer = function() {

		this._shapeRenderer.backgroundAxisLine = this._layer.addShape(new Line());

		var subLayer = this.getSubLayer();
		if (this._title.show) {
			this._shapeRenderer.title = subLayer.addShape(new TextLine());
		}

		this._shapeRenderer.axisLine = subLayer.addShape(new Line());

		if (this._showMajorTicks) {
			var majorTickPositions = this.getMajorTicks();
			for ( var i = 0, len = majorTickPositions.length; i < len; i++) {
				this._shapeRenderer.majorTicks[i] = subLayer.addShape(new Line());
				// [Ian 2012-2-13] Current, we will do not show first tick
				if (i == 0) {
					this._shapeRenderer.majorTicks[i].visible(false);
				}
				// End
			}
		}

		if (this._showMinorTicks) {
			var minorTicksPositions = this.getMinorTicks();
			for ( var i = 0, len = minorTicksPositions.length; i < len; i++) {
				this._shapeRenderer.minorTicks[i] = subLayer.addShape(new Line());
			}
		}

		for ( var i = 0, cLabelsText = this._labels.itemsValue, len = cLabelsText.length; i < len; i++) {
			this._shapeRenderer.labels[i] = subLayer.addShape(new TextLine());
		}

	};

	/**
	 * draw axis line and major ticks and minor ticks
	 */
	basicAxisRenderer.prototype._drawLineAndTick = function(layer, baseLine) {
		if (this._showMajorTicks) {
			if (this._showMinorTicks) {
				if (this._majorMarkSize >= this._minorMarkSize && this._majorMarkSize >= this._lineThickness) {
					this._drawLine(layer, baseLine + this._majorMarkSize / 2);
					this._drawMajorTickMarks(layer, baseLine + this._majorMarkSize / 2);
					this._drawMinorTickMarks(layer, baseLine + this._majorMarkSize / 2);
					baseLine += this._majorMarkSize;
				} else if (this._majorMarkSize < this._minorMarkSize && this._minorMarkSize >= this._lineThickness) {
					this._drawLine(layer, baseLine + this._minorMarkSize / 2);
					this._drawMajorTickMarks(layer, baseLine + this._minorMarkSize / 2);
					this._drawMinorTickMarks(layer, baseLine + this._minorMarkSize / 2);
					baseLine += this._minorMarkSize;
				} else {
					/*
					 * mark size is less than line size
					 */
					this._drawLine(layer, baseLine + this._lineThickness / 2);
					this._drawMajorTickMarks(layer, baseLine + this._lineThickness / 2);
					this._drawMinorTickMarks(layer, baseLine + this._lineThickness / 2);
					baseLine += this._lineThickness;
				}
			} else {
				if (this._majorMarkSize > this._lineThickness) {
					this._drawLine(layer, baseLine + this._majorMarkSize / 2);
					this._drawMajorTickMarks(layer, baseLine + this._majorMarkSize / 2);
					baseLine += this._majorMarkSize;
				} else {
					/*
					 * mark size is less than line size
					 */
					this._drawLine(layer, baseLine + this._lineThickness / 2);
					this._drawMajorTickMarks(layer, baseLine + this._lineThickness / 2);
					baseLine += this._lineThickness;
				}
			}
		} else if (this._showMinorTicks) {
			if (this._minorMarkSize >= this._lineThickness) {
				this._drawLine(layer, baseLine + this._minorMarkSize / 2);
				this._drawMinorTickMarks(layer, baseLine + this._minorMarkSize / 2);
				baseLine += this._minorMarkSize;
			} else {
				this._drawLine(layer, baseLine + this._lineThickness / 2);
				this._drawMinorTickMarks(layer, baseLine + this._lineThickness / 2);
				baseLine += this._lineThickness;
			}
		} else {
			baseLine += this._drawLine(layer, baseLine + this._lineThickness / 2);
		}

		return baseLine;
	};

	/*
	 * draw the axis line
	 */
	basicAxisRenderer.prototype._drawLine = function(layer, baseLine) {
		// add shape line

		if (this._showAxisLine) {
			var line = this._shapeRenderer.axisLine;
			line.color(this._lineColor);
			line.width(this._lineThickness);

			if (this._position == 'hb' || this._position == 'ht') { // horizontal
				// bottom or
				// horizontal
				// top

				line.from({
					x : this._axisMatrics.left,
					y : baseLine
				}).to({
					x : this._axisMatrics.left + this._distance,
					y : baseLine
				});

			} else { // vertical left or vertical right

				line.from({
					x : baseLine,
					y : this._axisMatrics.top
				}).to({
					x : baseLine,
					y : this._axisMatrics.top + this._distance
				});

			}

			// draw back ground axis line
			var backgrouldLine = this._shapeRenderer.backgroundAxisLine;
			backgrouldLine.color(this._lineColor);
			backgrouldLine.width(this._lineThickness);

			if (this._position == 'hb' || this._position == 'ht') { // horizontal
				// bottom or
				// horizontal
				// top

				backgrouldLine.from({
					x : this._axisMatrics.left,
					y : baseLine
				}).to({
					x : this._layer.size().width - this._axisMatrics.right,
					y : baseLine
				});

			} else { // vertical left or vertical right

				backgrouldLine.from({
					x : baseLine,
					y : this._axisMatrics.top
				}).to({
					x : baseLine,
					y : this._layer.size().height - this._axisMatrics.bottom
				});

			}

			return this._lineThickness;
		}
		return 0;
	};

	/*
	 * draw the axis labels
	 * 
	 */
	basicAxisRenderer.prototype._drawLabel = function(render, layer, value, x, y, align) {

		if (this._direction == 'horizontal') {
			render.visible(true).width(TextRuler.measureWidth(this._labels.font, value)).text(value).font(
					this._labels.font).textColor(this._labels.color);

			if (align == 'topCenter')
				render.topCenter([ x, y ]);
			else if (align == 'rightCenter')
				render.rightCenter([ x, y ]);
			else if (align == 'leftCenter') {
				render.leftCenter([ x, y ]);
			}
		} else {
			var tu = TextRuler;

			render.visible(true).font(this._labels.font).textColor(this._labels.color);

			if (this._position == 'hb') {
				render.width(tu.measureWidth(this._labels.font, value)).translate(x, y).text(value).rightCenter(
						[ 0, 0 ]).rotate(-Math.PI / 2);
			} else if (this._position == 'ht') {
				render.width(this._longestWidth).translate(x, y + this._longestWidth).text(value).leftCenter([ 0, 0 ])
						.rotate(3 * Math.PI / 2);
			}
		}
	};

	basicAxisRenderer.prototype._drawLabels = function(layer, baseLine) {
		var majorTicks = this.getMajorTicks();

		if (this._position == 'hb') {
			var axisLeft = this._axisMatrics.left;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), majorTicks[i],
							baseLine, 'topCenter');
				}
			}
		} else if (this._position == 'ht') {
			var axisLeft = this._axisMatrics.left;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), majorTicks[i],
							baseLine, 'topCenter');
				}
			}
		} else if (this._position == 'vl') {
			var axisTop = this._axisMatrics.top;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), baseLine,
							majorTicks[i], 'rightCenter');
				}
			}
		} else {
			var axisTop = this._axisMatrics.top;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), baseLine,
							majorTicks[i], 'leftCenter');
				}
			}
		}
	};

	basicAxisRenderer.prototype._drawSignalTickMark = function(render, layer, x, y, tickSize) {

		render.color(this._lineColor);
		render.width(this._lineThickness);

		if (this._position == 'hb' || this._position == 'ht') {
			render.from({
				x : x,
				y : y - tickSize / 2
			}).to({
				x : x,
				y : y + tickSize / 2
			});
		} else {
			render.from({
				x : x - tickSize / 2,
				y : y
			}).to({
				x : x + tickSize / 2,
				y : y
			});
		}
	};

	/**
	 * 
	 * @param layer
	 * @param baseLine
	 */
	basicAxisRenderer.prototype._drawMajorTickMarks = function(layer, baseLine) {

		var majorTickPositions = this.getMajorTicks();
		if (this._position == 'hb' || this._position == 'ht') {
			for ( var i = 0, len = majorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.majorTicks[i], layer, majorTickPositions[i], baseLine,
						this._majorMarkSize);
			}
		} else {
			for ( var i = 0, len = majorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.majorTicks[i], layer, baseLine, majorTickPositions[i],
						this._majorMarkSize);
			}
		}
	};

	/**
	 * 
	 * @param layer
	 * @param baseLine
	 */
	basicAxisRenderer.prototype._drawMinorTickMarks = function(layer, baseLine) {
		var minorTickPositions = this.getMinorTicks();
		if (this._position == 'hb' || this._position == 'ht') {
			for ( var i = 0, len = minorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.minorTicks[i], layer, minorTickPositions[i], baseLine,
						this._minorMarkSize);
			}
		} else {
			for ( var i = 0, len = minorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.minorTicks[i], layer, baseLine, minorTickPositions[i],
						this._minorMarkSize);
			}
		}
	};

	/**
	 * 
	 * 
	 * @param layer
	 * @param baseLine
	 */
	basicAxisRenderer.prototype._drawAxisTitle = function(layer, x, y) {

		if (this._title.show) {
			var label = this._shapeRenderer.title;
			var formattedTitle = TypeUtils.isExist(this._titleFT) ? this._titleFT.display(this._title.value)
					: this._title.value;
			if (this._position == 'hb' || this._position == 'ht') {
				label.visible(true).width(TextRuler.measureWidth(this._title.style, formattedTitle)).text(
						formattedTitle).font(this._title.style).textColor(this._title.color).topCenter([ x, y ]);

			} else {
				label.visible(true).width(TextRuler.measureWidth(this._title.style, formattedTitle)).text(
						formattedTitle).font(this._title.style).textColor(this._title.color);

				if (this._position == 'vl') {
					label.translate(x, y).topCenter([ 0, 0 ]).rotate(-Math.PI / 2);
				} else if (this._position == 'vr') {
					label.translate(x, y).topCenter([ 0, 0 ]).rotate(3 * Math.PI / 2);
				}

			}
		}

	};

	/*
	 * return the position
	 */
	basicAxisRenderer.prototype.u2p = function(value) {

		if (this._lineScaling == "linear") {
			if (this._position == 'hb' || this._position == 'ht') {
				return PositionCalculator.calculateLinearPosition(value, this._positionMultiplier, this._minValue);
			} else {
				return this.getMajorTicks()[0]
						- PositionCalculator.calculateLinearPosition(value, this._positionMultiplier, this._minValue);
			}
		} else {
			if (this._position == 'hb' || this._position == 'ht') {
				return PositionCalculator.calculateLogarithmicPosition(value, this._positionMultiplier, this._minValue);
			} else {
				return this.getMajorTicks()[0]
						- PositionCalculator.calculateLogarithmicPosition(value, this._positionMultiplier,
								this._minValue);
			}
		}

	};

	/*
	 * return the value
	 */
	basicAxisRenderer.prototype.p2u = function(position) {
		var pCalculator = PositionCalculator;

		if (this._lineScaling == "linear") {
			if (this._position == 'hb' || this._position == 'ht') {
				return pCalculator.calculateLinearValue(position, this._positionMultiplier, this._minValue)
						- this._axisMatrics.left;
			} else {
				return pCalculator.calculateLinearPosition(position, this._positionMultiplier, this._minValue)//where get the value?
						- this._axisMatrics.top;
			}
		} else {
			if (this._position == 'hb' || this._position == 'ht') {
				return pCalculator.calculateLogarithmicValue(position, this._positionMultiplier, this._minValue)
						- this._axisMatrics.left;
			} else {
				return pCalculator.calculateLogarithmicValue(position, this._positionMultiplier, this._minValue)
						- this._axisMatrics.top;
			}
		}
	};

	/**
	 * 
	 * @returns {Array} return major tick based on the label positions
	 */
	basicAxisRenderer.prototype.getMajorTicks = function() {
		if (!TypeUtils.isExist(this._majorTickPositions) || this._majorTickPositions.length == 0) {
			var majorTicks = this._majorTickPositions = [];
			var labelpositions = this._labels.itemsPosition;
			if (this._position == 'hb' || this._position == 'ht') {
				var axisLeft = this._axisMatrics.left;
				for ( var i = 0, cLabelsText = this._labels.itemsValue, len = labelpositions.length; i < len; i++) {
					majorTicks[i] = axisLeft + labelpositions[i];
				}
			} else {
				var axisTop = this._axisMatrics.top;
				for ( var cLabelsText = this._labels.itemsValue, len = labelpositions.length, i = 0; i < len; i++) {
					majorTicks[i] = axisTop + labelpositions[len - i - 1];
				}
			}
		}
		return this._majorTickPositions;
	};

	/**
	 * 
	 * @returns {Array} return minor tick based on the minor interval and label
	 *          position
	 */
	basicAxisRenderer.prototype.getMinorTicks = function() {
		if (!TypeUtils.isExist(this._minorTickPositions) || this._minorTickPositions.length == 0) {
			var minorTicks = this._minorTickPositions = [];
			var majorTicks = this.getMajorTicks();
			var majorInterval = majorTicks[1] - majorTicks[0]; // always there
			// are two major
			// tick, min and
			// max
			var minorInterval = majorInterval / this._minorDivisions;
			for ( var i = 0, len = majorTicks.length; i < len; i++) {
				if (i != len - 1) {
					for ( var j = 0, dlen = this._minorDivisions - 1; j < dlen; j++) {
						minorTicks[i * dlen + j] = majorTicks[i] + minorInterval * (j + 1);
					}
				}
			}
		}

		return this._minorTickPositions;
	};

	basicAxisRenderer.prototype.getTickInterval = function() {
		// 09-Apr-2012 Nick.Sun remove the selection of minor tick position. It will cause 
		// the wrong calculation of interval.
		var axisMajorTicks = this.getMajorTicks();
		var tickInterval;
		if (axisMajorTicks.length > 1) {
			tickInterval = Math.abs(axisMajorTicks[1] - axisMajorTicks[0]);
		} else {
			tickInterval = this._distance;
		}
		return tickInterval;
	};

	basicAxisRenderer.prototype.getMajorTickWidth = function() {
		if (this._showMajorTicks) {
			return this._majorMarkSize;
		}
		return 0;
	};
	/**
	 * remove all the shape on the layer
	 */
	basicAxisRenderer.prototype._resetShapes = function() {
		var shapeRenderer = this._shapeRenderer;
		var layer = this.getSubLayer();
		var mainLayer = this._layer;

		if (shapeRenderer.backgroundAxisLine) {
			mainLayer.removeShape(shapeRenderer.backgroundAxisLine);
		}

		// remove title renderer
		if (shapeRenderer.title) {
			layer.removeShape(shapeRenderer.title);
		}

		// remove axis line renderer
		if (shapeRenderer.axisLine) {
			layer.removeShape(shapeRenderer.axisLine);
		}

		// remove major tick renderers
		for ( var i = 0, majorTicks = shapeRenderer.majorTicks, len = majorTicks.length; i < len; i++) {
			layer.removeShape(majorTicks[i]);
		}

		// remove minor tick renderers
		for ( var i = 0, minorTicks = shapeRenderer.minorTicks, len = minorTicks.length; i < len; i++) {
			layer.removeShape(minorTicks[i]);
		}

		// remove label renderers
		for ( var i = 0, labels = shapeRenderer.labels, len = labels.length; i < len; i++) {
			layer.removeShape(labels[i]);
		}
	};

	basicAxisRenderer.prototype.reset = function() {
		this._majorTickPositions = null;
		this._minorTickPositions = null;
		this._positionMultiplier = null;
		this._preferredHeight = null;
		this._preferredWidth = null;
		this._direction = 'horizontal';
	};

	/**
	 * 
	 * @param xoffset
	 * @param yoffset
	 */
	basicAxisRenderer.prototype.position = function(xoffset, yoffset) {
		this.getSubLayer().position({
			x : xoffset,
			y : yoffset
		});
	};

	basicAxisRenderer.prototype.parseOptions = function(options) {

		if (options && options.distance === this.distance) {

		}

	};

	basicAxisRenderer.prototype.updateProperties = function(propertyBag) {

		this.parseOptions();

	};

	/**
	 * 
	 * @returns axis width. when show major mark, the width do not contain the
	 *          major mark size
	 */
	basicAxisRenderer.prototype.getAxisWidth = function() {
		if (this._position == 'hb' || this._position == 'ht') {
			if (this._showMajorTicks) {
				return this.getPreferredHeight() - this._majorMarkSize / 2;
			} else {
				return this.getPreferredHeight();
			}
		} else {
			if (this._showMajorTicks) {
				return this.getPreferredWidth() - this._majorMarkSize / 2;
			} else {
				return this.getPreferredWidth();
			}
		}
	};

	/**
	 * 
	 * @returns Number the first tick offset
	 */
	basicAxisRenderer.prototype.getFirstTickOffset = function() {
		return this.getMajorTicks()[0];
	};

	basicAxisRenderer.prototype.getLastTickOffset = function() {
		var majorTicks = this.getMajorTicks();
		return majorTicks[majorTicks.length - 1];
	};

	basicAxisRenderer.prototype.getLineThickness = function() {
		return this._lineThickness;
	};

	basicAxisRenderer.prototype.zoom = FunctionUtils.noop;

	/*
	 * return position Multiplier
	 */
	basicAxisRenderer.prototype._calculatePositionMultiplier = function() {
		if (!TypeUtils.isExist(this._positionMultiplier)) {

			this._positionMultiplier = PositionCalculator.generateLinearMultiplier(this._minValue, this._maxValue,
					this._distance);
		}

		return this._positionMultiplier;
	};

	basicAxisRenderer.prototype.applyTheme = function(theme) {
		var settings = ThemeManager.getThemeSettings(theme);
		var globalStyle = settings.global;
		var axisStyle = settings.axis;

		var titleStyle = ObjectUtils.extend(true, {}, globalStyle, axisStyle.title);
		this._title.style = titleStyle['font-weight'] + " " + titleStyle['font-size'] + " " + titleStyle['font-family'];
		this._title.color = titleStyle['color'];

		var labelStyle = ObjectUtils.extend(true, {}, globalStyle, axisStyle.label);
		this._labels.font = labelStyle['font-weight'] + " " + labelStyle['font-size'] + " " + labelStyle['font-family'];
		this._labels.color = labelStyle['color'];

		this._lineColor = axisStyle.lineColor;

		// Update Axis View
		if (this._shapeRenderer.title) {
			this._shapeRenderer.title.font(this._title.style).textColor(this._title.color);
		}
		if ((this._shapeRenderer.labels) && (this._shapeRenderer.labels.length)) {
			for ( var i = 0, len = this._shapeRenderer.labels.length; i < len; i++) {
				this._shapeRenderer.labels[i].font(this._labels.font).textColor(this._labels.color);
			}
		}
		if (this._shapeRenderer.axisLine) {
			this._shapeRenderer.axisLine.color(this._lineColor);
		}
		if (this._shapeRenderer.backgroundAxisLine) {
			this._shapeRenderer.backgroundAxisLine.color(this._lineColor);
		}
		if ((this._shapeRenderer.majorTicks) && (this._shapeRenderer.majorTicks.length)) {
			for ( var i = 0, len = this._shapeRenderer.majorTicks.length; i < len; i++) {
				this._shapeRenderer.majorTicks[i].color(this._lineColor);
			}
		}
		if ((this._shapeRenderer.minorTicks) && (this._shapeRenderer.minorTicks.length)) {
			for ( var i = 0, len = this._shapeRenderer.minorTicks.length; i < len; i++) {
				this._shapeRenderer.minorTicks[i].color(this._lineColor);
			}
		}
	};

	basicAxisRenderer.prototype.Label = function() {
		this._value = '';
		this._visible = true;
	};

	basicAxisRenderer.prototype.Label.prototype.value = function(value) {
		if (TypeUtils.isExist(value)) {
			this._value = value;
			return this;
		}
		return this._value;
	};

	basicAxisRenderer.prototype.Label.prototype.visible = function(visible) {
		if (TypeUtils.isExist(visible)) {
			this._visible = visible;
			return this;
		}
		return this._visible;
	};

	return basicAxisRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.MultiPieModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.BasicModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.multilayout.ColumnMultiLayout',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.PieRenderer',
  version : '1.0.0'
}
],
function Setup(ObjUtils,TypeUtils,BasicModule,SeriesGroup,Series,ColumnMultiLayout,Layer,PieRenderer) {
	var MultiPieModule = ObjUtils.derive(BasicModule, {
		events : [ 'selectData' ],
		constructor : function(options) {
			this._seriesGroups = null;
			this._multiLayout = null;
			this._layoutModeType = null;
			this._pieRenderers = [];
			this._mainLayer = null;
			this._subLayers = [];
			this._hasDrawed = false;
			this._options = options;
		},
		
		buildData : function () {
			this._data = [];
			//[jyang 3/15/2012] for pie now we support up to 2 axis, for single axis
        	//we will use it to feed pie sectors. for dual axes, we will use the first(as well as measures)
        	//as multiplier and the second as feed of pie sectors
			var axisNum = this._metaData.axisNum;
			var dataTree = this._dataTree;
			var sectorFeedAxis = 0;
        	if ( axisNum === 2) {
        		sectorFeedAxis = 1;
        	}
			//for each dimension in multiplierFeedAxis we go through each path of their cartesian product of dimension items
        	var cartesianPath = [];//it's used for iterate tree
        	var namePath = [];//it's used for title of each sub pie, include measure name
			var dimensions = this._metaData.dimension;
			for ( var i = 0, len = dimensions.length; i < len; i++ ){
        		var dt = dimensions[i];
        		if ( dt.analysisAxisIndex !== sectorFeedAxis ) {
        			if ( cartesianPath.length === 0 ) {
        				var members = dataTree.getSubMembersAt();
        				var memberLabels = dataTree.getSubMemberLabels();
        				for ( var j = 0, jlen = members.length; j < jlen; j++ ){
        					cartesianPath.push([members[j]]);
        					namePath.push([memberLabels[j]]);
        				}
        			} else {
        				var tempCartesianPath = [];
        				var tempNamePath = [];
        				for ( var j = 0, jlen = cartesianPath.length; j < jlen; j++ ) {
        					var pathIter = cartesianPath[j];
        					var membersAtPathIter = dataTree.getSubMembersAt(pathIter);
        					var memberLabelsAtPathIter = dataTree.getSubMemberLabels(pathIter);
        					for ( var k = 0, klen = membersAtPathIter.length; k < klen; k++ ) {
        						tempCartesianPath.push(pathIter.concat(membersAtPathIter[k]));
        						tempNamePath.push(namePath[j].concat(memberLabelsAtPathIter[k]));
        					}
        				}
        				cartesianPath = tempCartesianPath;
        				namePath = tempNamePath;
        			}
        		} else {
        			if ( cartesianPath.length === 0 ) {
        				//we haven't found any multiplier feed axis, we just
        				//read the root path.
        				cartesianPath.push([]);
        				namePath.push([]);
        			}
        			//jyang, 3/16/2012 currently we only support one dimension in sectorFeedAxis
        			//so we only read one and try to get its measure values on the tree
        			//if we want to support more dimensions in sectorFeedAxis, we can 
        			//#1, move extra dimensions to multiplier
        			//#2, do cartesian product 
        			for ( var j = 0, jlen = cartesianPath.length; j < jlen; j++ ) {
        				var pathIter = cartesianPath[j];
        				var membersAtPathIter = dataTree.getSubMembersAt(pathIter);
        				var memberLabelsAtPathIter = dataTree.getSubMemberLabels(pathIter);
        				var measureValues = {};
        				for ( var k = 0, klen = membersAtPathIter.length; k < klen; k++ ) {
        					//measuresAtPathIter is an object instead of array returned from datatree
        					var measuresAtPathIter = dataTree.getMeasuresAt(
        							pathIter.concat(membersAtPathIter[k]));
        					for ( var eachMeasure in measuresAtPathIter ) {
        						if ( measuresAtPathIter.hasOwnProperty(eachMeasure) ) {
        							if ( !TypeUtils.isExist(measureValues[eachMeasure]) ) {
        								measureValues[eachMeasure] = {
        									'namePath': namePath[j].concat(eachMeasure),
        									'data': []
        								};
        							}
        							var value = measuresAtPathIter[eachMeasure].sum.result;
        							measureValues[eachMeasure].data.push({
        								'value': (TypeUtils.isNumber(value)) ? value : 'NaN',
        								'dimensionPath': measuresAtPathIter[eachMeasure].sum.tags.dimensionPath,
        								'measureIndex': measuresAtPathIter[eachMeasure].sum.tags.measureIndex,
        								'dimensionItem': memberLabelsAtPathIter[k],
        								'dimensionItemIndex': k
        							});
        						}
        					}
        				}
        				for ( var item in measureValues ) {
        					this._data.push(measureValues[item]);
        				}
        			}
        		}
        	}
		},
		
		initSeries : function() {
			//TODO Jyang 3/15/2012 how to set property for multi chart?
			var seriesOption = this._chart_options.properties.measures;
			var seriesDefault = this._chart_options.properties.measureDefault;
			this._seriesGroups = [];

			for ( var i = 0, len = this._data.length; i < len; i++) {
				var data = this._data[i];
				var seriesGroup = new SeriesGroup();
				var o = ObjUtils.extend(true, {}, seriesDefault, seriesOption[i]);
				//TODO JY: HOW TO STORE PROPERTIES INSIDE SERIES? WE NEED SEPERATE PROPERTY OBJECT?
				var s = new Series(o);
				s.setName(data.namePath.join('/'));
				//[jy 03/13/2012]for pie chart we won't draw any invalid values (NaN or less than 0)
				var seriesData = [];
				var dataCandidateArray = data.data;
				for ( var j = 0, jlen = dataCandidateArray.length; j < jlen; j++ ) {
					var valueCandidate = dataCandidateArray[j];
					if ( valueCandidate.value !== 'NaN' && valueCandidate.value > 0 ) {
						seriesData.push(valueCandidate);
					}
				}
				this._processData(seriesData);
				s.setData(seriesData);
				seriesGroup.addSeries(s);
				this._seriesGroups.push(seriesGroup);
			}
		},

		// See PieModule._processData()
		_processData : function ( array ) {
			var replica = array.slice();
			replica.sort(function ( a, b ) { return a - b; });
			var maxValue = replica[replica.length - 1];
			
			for ( var i = 0, len = array.length; i < len; i++ ) {
				if ( (array[i] / maxValue - 0.0001) < 0 ) {
					array[i] = 0;
				}
			}
		},
		
		bindRenderer : function(layer) {
			//jyang, 3/16/2012,  we rely on multi layout to create sub layer and bind it to pie renderer
			//what info do we need for multi layout? especially for multi of multi series stacked bar chart in the future?
			this._mainLayer = layer;
			if(this._multiLayout == null){
				this._layoutModeType = this._options.properties.layoutMode.type;
				//TODO JYANG 3/16/2012, we need support different multi layout, now we only support column
				switch(this._layoutModeType){
					case 'column':
					default:
						this._multiLayout = new ColumnMultiLayout(layer.size(), {
							'itemLength': this._seriesGroups.length,
							'columnLength': this._options.properties.layoutMode.columnLength
						})
						break;
				}
			}
			for(var i = 0, len = this._seriesGroups.length; i < len; i++){
				var subLayer = new Layer({
                    anchor : {
                        x : 0,
                        y : 0
                    }
                });
				this._subLayers.push(subLayer);
                layer.addSubLayer(subLayer);
                
				var seriesGroup = this._seriesGroups[i];
				var pieRenderer = this._pieRenderers[i];
				if (!TypeUtils.isExist(pieRenderer)) {
					pieRenderer = new PieRenderer(subLayer, this._options, true);
					this._pieRenderers[i] = pieRenderer;
				} else {
					pieRenderer.resetSeriesGroup();
				}
				pieRenderer.addSeriesGroup(seriesGroup);
			}
		},
		
		drawSeries : function() {
			if (!this._hasDrawed) {
				for(var i = 0, len = this._pieRenderers.length; i < len; i++){
					var pieRenderer = this._pieRenderers[i];
					pieRenderer.draw();
				}
				this._hasDrawed = true;
			} else {
				for(var i = 0, len = this._pieRenderers.length; i < len; i++){
					var pieRenderer = this._pieRenderers[i];
					pieRenderer.redraw();
				}
			}
			
			if ( this._defaultSelectionArmed ) {
				var defaultSelectedSlices = this._chart_options.properties.selectedDataIndexes;
				if ( this._chart_options.properties.allSelectable 
						&& defaultSelectedSlices.length > 0 ) {
					for ( i = 0; i < this._pieRenderers.length; i++ ) {
						for ( var j = 0, jlen = defaultSelectedSlices.length; j < jlen; j++ ) {
							if ( !this._pieRenderers[i]._shapes.pieSectors[defaultSelectedSlices[j]] ) {
								continue;
							}
							if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
									&& j === 1 ) {
								break;
							}
							this._pieRenderers[i]._selectPie(defaultSelectedSlices[j]);
							this._pieRenderers[i]._interactionStatus.selected.push(defaultSelectedSlices[j]);
						}
					}
				}
				this._defaultSelectionArmed = false;
			}
			var selections;
			for ( i = 0, len = this._pieRenderers.length; i < len; i++ ) {
				selections = this._pieRenderers[i]._interactionStatus.selected;
				if ( TypeUtils.isExist(selections) && selections.length > 0 ) {
					for ( var j = 0, jlen = selections.length; j < jlen; j++ ) {
						if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
								&& j === 1 ) {
							break;
						}
						this._pieRenderers[i]._selectPie(selections[j]);
					}
				}
			}
		},
		
		doChartLayout : function(nsize, seriesMaskLayer, seriesLayer) {
			//do main layout
			seriesMaskLayer.size(nsize);
			seriesMaskLayer.position({
				x : 0,
				y : 0
			});
			seriesLayer.size(nsize);
			seriesLayer.position({
				x : 0,
				y : 0
			});
			
			//do sub layout
			this._multiLayout.updateSize(nsize);
			this._relayoutSubItems();
		},
		
		_relayoutSubItems : function(){
			if(this._multiLayout.layoutChanged()){
				var layoutInfo = this._multiLayout.getLayoutInfo();
				for(var i = 0, len = this._subLayers.length; i < len; i++){
					this._subLayers[i].position({
						'x': layoutInfo[i].x,
						'y': layoutInfo[i].y
					});
					this._subLayers[i].size({
						'width': layoutInfo[i].width,
						'height': layoutInfo[i].height
					});
				}
			}
		},
		
		updateProperties : function(propBag){
			this.callParent('updateProperties', propBag);
			
			//update layout
			var layer = this._mainLayer;
			var newtype = this._options.properties.layoutMode.type;
			if(newtype !== this._layoutModeType){
				this._layoutModeType = newtype;
				//TODO JYANG 3/16/2012, we need support different multi layout, now we only support column
				switch(this._layoutModeType){
					case 'column':
					default:
						this._multiLayout = new ColumnMultiLayout(layer.size(), {
							'itemLength': this._seriesGroups.length,
							'columnLength': this._options.properties.layoutMode.columnLength
						})
						break;
				}
			}else{
				//update current layout
				this._multiLayout.updateSettings(this._options.properties.layoutMode);
			}
			this._relayoutSubItems();
			
			//[jyang 3/12/2012] how to update properties? 
			//store properties in series group or renderer?
			//now we just pass it to renderer, need refactor
			for(var i = 0, len = this._pieRenderers.length; i < len; i++){
				this._pieRenderers[i].updateProperties(propBag);
			}
			
			var seriesOption = this._chart_options.properties.measures;
			var defaultOption = this._chart_options.properties.measureDefault;
			var seriesProperties = [];
			
			for ( var i = 0, len = seriesOption.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {}, defaultOption, seriesOption[i]);
				seriesProperties.push(opts);
			}
			
			for(var i = 0, len = this._seriesGroups.length; i < len; i++){
				this._seriesGroups[i].updateProperties(seriesProperties);
			}						
		},

		/**
		 * @return events 'selectData'
		 * @override sap.riv.viz.pie.BasicModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData' ];
		},

		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		clickOnPoint : function(point) {
			//check which sublayer contains this point  containsPoint
			for(var i = 0, len = this._subLayers.length; i < len; i++){
				var subLayer = this._subLayers[i];
				var pointOnSubLayer = subLayer.convertPointFromSuperLayer(point);
				if(subLayer.containsPoint(pointOnSubLayer)){
					var dataCtxOnPoint = this._pieRenderers[i].highlightOnPoint(pointOnSubLayer);
					//[jyang 3/13/2012] dataCtx is an array for multi selection case
					//and it's safe we return dataCtxOnPoint directly here as we create
					//new inside renderer
					if (dataCtxOnPoint) {
						this.fireEvent('selectData', {
							name : 'selectData',
							data : dataCtxOnPoint
						});
					}
				}
			}
		},
		
		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		hoverOnPoint : function(point) {
			//check which sublayer contains this point  containsPoint
			for(var i = 0, len = this._subLayers.length; i < len; i++){
				var subLayer = this._subLayers[i];
				var pointOnSubLayer = subLayer.convertPointFromSuperLayer(point);
				if(subLayer.containsPoint(pointOnSubLayer)){
					//currently we don't need dataCtx returned from this API
					this._pieRenderers[i].hoverOnPoint(pointOnSubLayer);
				}
			}
		},
		
		/**
		 * @override sap.riv.viz.pie.BasicModule.applyTheme
		 */
		applyTheme : function(theme){
			for(var i = 0, len = this._pieRenderers.length; i < len; i++){
				this._pieRenderers[i].applyTheme(theme);
			}
		},
		
		updateOptions : function(options) {
			this.callParent('updateOptions', options);
			for(var i = 0, len = this._pieRenderers.length; i < len; i++){
				var pieRenderer = this._pieRenderers[i];
				pieRenderer.updateOptions(options);
			}
		},
	});
	return MultiPieModule;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.descriptor.Descriptor',
  version : '1.0.0'
},
function Setup() {

	var des = {

		getCommonChartProperties : function() {
			var json = {
				type: {
					name: 'type',
					supportedValueType: 'String',
					supportedValues: 'combination',
					defaultValue: 'combination',
					description: 'internal property to determine which chart module we should use',
					isExported: false
				},
				theme : {
					name : 'theme',
					supportedValueType : 'List',
					supportedValues : [ 'classic-day', 'classic-night' ],
					defaultValue : null,
					description : 'Set theme of chart. Be noted that theme can only be updated through applyTheme().'
				},
				background : {
					name : 'background',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'color',
						supportedValueType : 'Color',
						defaultValue : '#000000',
						description : 'Set background color of chart.'
					}, {
						name : 'visible',
						supportedValueType : 'Boolean',
						defaultValue : true,
						description : 'Set visibility of background.'
					} ],
					description : 'Set background of chart.'
				},
				legend : {
					name : 'legend',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'position',
								supportedValueType : 'List',
								supportedValues : [ 'left', 'right', 'top',
										'bottom' ],
								defaultValue : 'right',
								description : 'Set legend position.'
							},
							{
								name : 'verticalOffset',
								supportedValueType : 'Int',
								defaultValue : 0,
								description : 'Set vertical offset of legend only if legend position is left or right.'
							},
							{
								name : 'horizontalOffset',
								supportedValueType : 'Int',
								defaultValue : 0,
								description : 'Set horizontal offset of legend only if legend position is top or bottom.'
							},
							{
								name : 'visible',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set visibility of legend.'
							},
							{
								name : 'labelFont',
								supportedValueType : 'Font',
								defaultValue : 'bold 16px Arial',
								description : 'Set label font style of legend label.'
							},
							{
								name : 'labelColor',
								supportedValueType : 'Color',
								defaultValue : '#ffffff',
								description : 'Set label color of legend label.'
							},
							{
								name : 'titleFont',
								supportedValueType : 'Font',
								defaultValue : 'bold 16px Arial',
								description : 'Set title font style of legend title.',
								isExported: false
							},
							{
								name : 'titleColor',
								supportedValueType : 'Color',
								defaultValue : '#ffffff',
								description : 'Set title color of legend title.',
								isExported: false
							},
							{
								name : 'formatString',
								supportedValueType : 'StringArray',
								defaultValue : [ '' ],
								description : 'Set format string of legend and re-use the last one in the array.'
							} ],
					description : 'Set legend related properties. The labels come from measure names for Bar/Column/Line/Combination chart and dimension names for Pie chart.'
				},
				layout : {
					name : 'layout',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'padding',
								supportedValueType : 'IntArray[4]',
								defaultValue : [ 0, 0, 0, 0 ],
								description : 'Set padding of layout. The padding clears an area inside of chart. The corresponding directions of padding are top, right, bottom, left.'

							},
							{
								name : 'legendFirst',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set whether the layout is legend first.',
								isExported : false
							} ],
					description : 'Set the layout related properties.'
				},
				tooltip : {
					name : 'tooltip',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'text',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font style of tooltip text. '
										},
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip text.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : "Set number format of tooltip text."
										} ],
								description : 'Set display properties of tooltip text.'
							},
							{
								name : 'mainValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font style of tooltip main value.'
										},
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set font color of tooltip main value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : "Set number format of tooltip main value and re-use the last one in the array."
										} ],
								description : 'Set display properties of tooltip main value.'
							},
							{
								name : 'subValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font style of sub value.'
										},
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set font color of tooltip sub value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '0.00%' ],
											description : "Set number format of tooltip sub value."
										} ],
								description : 'Set display property of tooltip sub value.'
							} ],
					description : 'Set tooltip related properties.'
				},
				title : {
					name : 'title',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'main',
						supportedValueType : 'Object',
						supportedValues : [ {
							name : 'text',
							supportedValueType : 'String',
							defaultValue : 'Default Chart Title',
							description : 'Set text value of main title.'
						}, {
							name : 'font',
							supportedValueType : 'Font',
							defaultValue : 'bold 16px Arial',
							description : 'Set font style of main title.'
						}, {
							name : 'color',
							supportedValueType : 'Color',
							defaultValue : '#ffffff',
							description : 'Set font color of main title.'
						}, {
							name : 'visible',
							supportedValueType : 'Boolean',
							defaultValue : false,
							description : 'Set visibility of main title.'
						}, {
							name : 'horizontalAlign',
							supportedValueType : 'List',
							supportedValues : [ 'center', 'left', 'right' ],
							defaultValue : 'center',
							description : 'Set horizontal align of main title.'
						}, {
							name : 'formatString',
							supportedValueType : 'String',
							defaultValue : '',
							description : 'Set format string of main title.'
						} ],
						description : 'Set main title related properties.'
					}, {
						name : 'sub',
						supportedValueType : 'Object',
						supportedValues : [ {
							name : 'text',
							supportedValueType : 'String',
							defaultValue : 'Default Sub Title',
							description : 'Set text value of sub title.'
						}, {
							name : 'font',
							supportedValueType : 'Font',
							defaultValue : 'bold 14px Arial',
							description : 'Set font style of sub title.'
						}, {
							name : 'color',
							supportedValueType : 'Color',
							defaultValue : '#ffffff',
							description : 'Set font color of sub title.'
						}, {
							name : 'visible',
							supportedValueType : 'Boolean',
							defaultValue : false,
							description : 'Set visibility of sub title.'
						}, {
							name : 'horizontalAlign',
							supportedValueType : 'List',
							supportedValues : [ 'center', 'left', 'right' ],
							defaultValue : 'center',
							description : 'Set horizontal align of sub title.'
						}, {
							name : 'formatString',
							supportedValueType : 'String',
							defaultValue : '',
							description : 'Set format string of sub title.'
						} ],
						description : 'Set sub title related properties.'
					} ],
					description : 'Set the title related properties.'
				},
				selectability : {
					name : 'selectability',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mode',
								supportedValueType : 'List',
								supportedValues : [ 'single', 'multiple',
										'none' ],
								defaultValue : 'single',
								description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'deSelectable',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'defaultSelectedItems',
								supportedValueType : 'ObjectArray',
								supportedValues : [
										{
											name : 'measureIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected measure items. Be noted that it cannot be updated after chart initialization.'
										},
										{
											name : 'dimensionItemIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected dimension items. Be noted that it cannot be updated after chart initialization.'
										} ],
								defaultValue : [],
								description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
							} ],
					description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
					isExported : false
				},
				xAxis : {
					name : 'xAxis',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'xAxis member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'title',
									supportedValueType : 'String',
									defaultValue : 'X1',
									description : 'Set value of X axis title.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'set line thickness of X axis.'
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set line color of X axis.'
								},
								{
									name : 'labelColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set label color of X axis.'
								},
								{
									name : 'titleColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set X axis title color.'
								},
								{
									name : 'labelFont',
									supportedValueType : 'Font',
									defaultValue : 'normal 11px Arial',
									description : 'Set label color of X axis.'
								},
								{
									name : 'titleFont',
									supportedValueType : 'Font',
									defaultValue : 'bold 13px Arial',
									description : 'Set label color of X axis.'
								},
								{
									name : 'showTitle',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide X axis title.'
								},
								{
									name : 'titleFormatString',
									supportedValueType : 'String',
									defaultValue : '',
									description : 'Set title format string.'
								},
								{
									name : 'showMajorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide X axis majorTicks.'
								},
								{
									name : 'showMinorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide X axis minorTicks.'
								},
								{
									name : 'labelsFormatString',
									supportedValueType : 'StringArray',
									defaultValue : [ '' ],
									description : 'Set X axis labels format string, re-use the last one in the array.'
								},
								{
									name : 'gridLine',
									supportedValueType : 'Object',
									supportedValues : [
											{
												name : 'showMajor',
												supportedValueType : 'Boolean',
												defaultValue : undefined,
												description : 'Show/hide major grid line and only works on value axis'
											},
											{
												name : 'majorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set the major grid line color.'
											},
											{
												name : 'majorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the major grid line thickness.'
											},
											{
												name : 'showMinor',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide minor grid line and only works on value axis. If showMajor is false, this option will not work'
											},
											{
												name : 'minorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set the minor grid line color.'
											},
											{
												name : 'minorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the minor grid line thickness.'
											},
											{
												name : 'showSub',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide sub grid line and only works on dimension axis'
											},
											{
												name : 'subColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set sub grid line color.'
											} ],
									description : 'Set the grid line releated properties.' +
												  'For value axis, only showMajor and showMinor options work. If showSub is set to true on value axis, it takes effect but the behavior is unexpected.' +
												  'For dimension axis, only showSub option works. If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.'
												  
								} ]
					} ],
					description : 'Set X axis releated properties.'
				},
				yAxis : {
					name : 'yAxis',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'yAxis member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'title',
									supportedValueType : 'String',
									defaultValue : 'Y1',
									description : 'Set value of Y axis title.'
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set line color of Y axis.'
								},
								{
									name : 'lineTickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set line thickness of Y axis.'
								},
								{
									name : 'labelColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set label color of Y axis.'
								},
								{
									name : 'titleColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set Y axis title color.'
								},
								{
									name : 'labelFont',
									supportedValueType : 'String',
									defaultValue : 'normal 11px Arial',
									description : 'Set label font style of Y axis.'
								},
								{
									name : 'titleFont',
									supportedValueType : 'String',
									defaultValue : 'bold 13px Arial',
									description : 'Set title font style of Y axis.'
								},
								{
									name : 'showTitle',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide Y axis title.'
								},
								{
									name : 'titleFormatString',
									supportedValueType : 'String',
									defaultValue : '',
									description : 'set the title format string.'
								},
								{
									name : 'showMajorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide Y axis majorTicks.'
								},
								{
									name : 'showMinorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide Y axis minorTicks.'
								},
								{
									name : 'labelsFormatString',
									supportedValueType : 'StringArray',
									defaultValue : [ '' ],
									description : 'Set Y axis labels fromat string and re-use the last one in the array.'
								},
								{
									name : 'gridLine',
									supportedValueType : 'Object',
									supportedValues : [
											{
												name : 'showMajor',
												supportedValueType : 'Boolean',
												defaultValue : undefined,
												description : 'Show/hide major grid line and only works on value axis'
											},
											{
												name : 'majorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set the major grid line color.'
											},
											{
												name : 'majorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the major grid line thickness.'
											},
											{
												name : 'showMinor',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide the minor grid line and only works on value axis. If showMajor is false, this option will not work'
											},
											{
												name : 'minorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set minor grid line color.'
											},
											{
												name : 'minorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the minor grid line thickness.'
											},
											{
												name : 'showSub',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide sub grid line and only works on dimension axis'
											},
											{
												name : 'subColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set sub grid line color.'
											} ],
								description : 'Set the grid line releated properties.' +
											  'For value axis, only showMajor and showMinor options work. If showSub is set to true on value axis, it takes effect but the behavior is unexpected.' +
											  'For dimension axis, only showSub option works. If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.'
								} ]
					} ],
					description : 'Set Y axis releated properties.'
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'type',
									supportedValueType : 'List',
									supportedValues : [ 'bar', 'line' ],
									defaultValue : 'line',
									description : 'Set measure type'
								},
								{
									name : 'valueAxis',
									supportedValueType : 'Int',
									defaultValue : '',
									description : 'Set index value for the axis.'
								},
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set barMarker color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'An internal properties, as it does not make sense to set size per series. Set barMarker size of measure member.',
									isExported: false
								},
								{
									name : 'lineMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : 10,
									description : 'An internal properties, as it does not make sense to set size per series. Set lineMarker size of measure member.',
									isExported: false
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : '#000000',
									description : 'Set line color of measure member.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set line thickness of measure member.'
								},
								{
									name : 'markerSymbol',
									supportedValueType : 'List',
									supportedValues : [ 'circle', 'triangle',
											'diamond' ],
									defaultValue : 'circle',
									description : 'Set line markerSymbol of measure member.'
								} ],
						description : 'Set measure member related properties.'
					} ],
					description : 'Set measures related properties.'
				},
				visibleRange : {
					name : 'visibleRange',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'start',
						supportedValueType : 'Int',
						defaultValue : 0,
						description : 'Set start value of visible range.'
					}, {
						name : 'end',
						supportedValueType : 'Int',
						defaultValue : Number.POSITIVE_INFINITY,
						description : 'Set end value of visible range.'
					} ],
					description : 'Set the visible range releated propertie.',
					isExported: false
				}
			};
			return json;
		},

		getBarDescriptor : function() {
			var json = {
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				selectability : {
					name : 'selectability',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mode',
								supportedValueType : 'List',
								supportedValues : [ 'single', 'none' ],
								defaultValue : 'single',
								description : 'Set selection mode. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'deSelectable',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'defaultSelectedItems',
								supportedValueType : 'ObjectArray',
								supportedValues : [
										{
											name : 'measureIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected measure items. Be noted that it cannot be updated after chart initialization.'
										},
										{
											name : 'dimensionItemIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected dimension items. Be noted that it cannot be updated after chart initialization.'
										} ],
								defaultValue : [],
								description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
							} ],
					description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.'
				},
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				bar : {
					name : 'bar',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'barMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : undefined,
						description : 'Set bar marker size of bar.'
					} ],
					description : 'It is applied for all bar series.'
				},
				visibleRange : this.getCommonChartProperties().visibleRange,
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					} ],
					description : 'Set measure releated properties.',
					isExported: false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'An internal properties, as it does not make sense to set size per series. Set the bar marker size of measure member.',
									isExported: false
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure member.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure member.',
									isExported: false
								} ],
						description : 'Set the measure member releated properties.'
					} ],
					description : 'Set the measures releated properties.'
				}
			};
			return json;
		},

		getCombinationDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				selectability : {
                    name : 'selectability',
                    supportedValueType : 'Object',
                    supportedValues : [
                            {
                                name : 'mode',
                                supportedValueType : 'List',
                                supportedValues : [ 'single', 'none' ],
                                defaultValue : 'none',
                                description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'deSelectable',
                                supportedValueType : 'Boolean',
                                defaultValue : true,
                                description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'defaultSelectedItems',
                                supportedValueType : 'ObjectArray',
                                supportedValues : [
                                        {
                                            name : 'measureIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected measure items.'
                                        },
                                        {
                                            name : 'dimensionItemIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected dimension items.'
                                        } ],
                                defaultValue : [],
                                description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
                            } ],
                    description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
                    isExported : false
                },
				line : {
					name : 'line',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'lineMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : 10,
						description : 'Set line marker size of series.'
					}, {
						name : 'lineThickness',
						supportedValueType : 'PositiveInt',
						defaultValue : 1,
						description : 'Set line thinkness of series.'
					} ],
					description : 'Set line releated properties.'
				},
				bar : {
					name : 'bar',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'barMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : undefined,
						description : 'Set bar marker size of series.'
					} ],
					description : 'Set bar releated properties.'
				},
				visibleRange : this.getCommonChartProperties().visibleRange,
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					} ],
					description : 'Set measure releated properties.',
					isExported: false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'type',
									supportedValueType : 'List',
									supportedValues : [ 'bar', 'line' ],
									defaultValue : 'line',
									description : 'Set the measure type. Be noted that it cannot be updated after chart initialization.'
								},
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'An internal properties, as it does not make sense to set size per series. Set the bar marker size of measure member.',
									isExported: false
								},
								{
									name : 'lineMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : 10,
									description : 'An internal properties, as it does not make sense to set size per series. Set the line marker size of measure member.',
									isExported: false
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the line color of measure member.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set the line size of measure member.'
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure member.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure member.',
									isExported: false
								},
								{
									name : 'markerSymbol',
									supportedValueType : 'List',
									supportedValues : [ 'circle', 'triangle',
											'diamond' ],
									defaultValue : 'circle',
									description : 'Set marker symbol of measure member.'
								} ],
						description : 'Set the measure member releated properties'
					} ],
					description : 'Set the measures releated properties.'
				}
			};

			return json;
		},

		getMultiPieDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				title : this.getCommonChartProperties().title,
				layout : this.getCommonChartProperties().layout,
				pieType : {
					name : 'pieType',
					supportedValueType : 'List',
					supportedValues : [ 'pie', 'donut' ],
					defaultValue : 'pie',
					description : 'Set display type of every sub pie.'
				},
				selectionMode : {
					name : 'selectionMode',
					supportedValueType : 'List',
					supportedValues : [ 'single', 'multiple' ],
					defaultValue : 'single',
					description : 'Set the selection mode of every sub pie.'
				},
				allSelectable : {
					name : 'allSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether every sub pie is selectable. Be noted that it cannot be updated after chart initialization.'
				},
				allDeSelectable : {
					name : 'allDeSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether every sub pie is deselectable. Be noted that it cannot be updated after chart initialization.'
				},
				selectedDataIndexes : {
					name : 'selectedDataIndexes',
					supportedValueType : 'IntArray',
					defaultValue : [],
					description : 'Set the default selected sector. Be noted that it cannot be updated after chart initialization.'
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues: [{
							name : 'sectorColors',
							supportedValueType : 'ColorArray',
							defaultValue : [ "#113975", "#e06f00", "#5a92e2",
									"#624628", "#e03c2f", "#ffbe7f", "#96a8c3",
									"#a9a9a9", "#830b00", "#344b6d", "#e2ce44",
									"#ff6657" ],
							description : 'Color palette to be used for sectors of each sub pie.'
						}],
						description : 'Set measure member for each sub pie.'
					} ],
					description : 'Set measure properties.'
				},
				tooltip : {
					name : 'tooltip',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mainValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip main value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip main value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip main value.'
										} ],
								description : 'Set properties of tooltip main value (data value) for every sub pie. '
							},
							{
								name : 'subValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip sub value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip sub value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip sub value.'
										} ],
								description : 'Set properties of tooltip sub value (percentage) for every sub pie.'
							},
							{
								name : 'text',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip text.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip text.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringObject',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip text.'
										} ],
								description : 'Set properties of tooltip text (dimension label) for every sub pie.'
							} ],
					description : 'Set tooltip properties for every sub pie.'
				},
				layoutMode : {
					name : 'layoutMode',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'type',
						supportedValueType : 'List',
						supportedValues : [ 'column' ],
						defaultValue : 'column',
						description : 'Set the layout mode of multi-pie.'
					}, {
						name : 'columnLength',
						supportedValueType : 'PositiveInt',
						defaultValue : 2,
						description : 'Set the column number of column layout mode.'
					} ],
					description : 'Set layout mode of multi-pie.'
				},
				subChartTitle : {
					name : 'subChartTitle',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visible',
						supportedValueType : 'Boolean',
						defaultValue : true,
						description : 'Set the visibility of sub chart title.'
					}, {
						name : 'font',
						supportedValueType : 'Font',
						defaultValue : 'normal 14px Arial',
						description : 'Set font of sub chart title.'
					}, {
						name : 'color',
						supportedValueType : 'Color',
						defaultValue : '#ffffff',
						description : 'Set color of sub chart title.'
					} ],
					description : 'Set sub chart title releated properties of multi-pie.'
				}
			};
			return json;
		},

		getPieDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				title : this.getCommonChartProperties().title,
				layout : this.getCommonChartProperties().layout,
				pieType : {
					name : 'pieType',
					supportedValueType : 'List',
					supportedValues : [ 'pie', 'donut' ],
					defaultValue : 'pie',
					description : 'Set display type of pie chart.'
				},
				selectionMode : {
					name : 'selectionMode',
					supportedValueType : 'List',
					supportedValues : [ 'single', 'multiple' ],
					defaultValue : 'single',
					description : 'Set the selection mode of pie chart.'
				},
				allSelectable : {
					name : 'allSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether the pie chart is selectable. Be noted that it cannot be updated after chart initialization.'
				},
				allDeSelectable : {
					name : 'allDeSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether the pie chart is deselectable. Be noted that it cannot be updated after chart initialization.'
				},
				selectedDataIndexes : {
					name : 'selectedDataIndexes',
					supportedValueType : 'IntArray',
					defaultValue : [],
					description : 'Set the default selected sector. Be noted that it cannot be updated after chart initialization.'
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues: [{
							name : 'sectorColors',
							supportedValueType : 'ColorArray',
							defaultValue : [ "#113975", "#e06f00", "#5a92e2",
									"#624628", "#e03c2f", "#ffbe7f", "#96a8c3",
									"#a9a9a9", "#830b00", "#344b6d", "#e2ce44",
									"#ff6657" ],
							description : 'Color palette to be used for sectors of each sub pie.'
						}],
						description : 'Set measure member for each sub pie.'
					} ],
					description : 'Set measure properties.'
				},
				tooltip : {
					name : 'tooltip',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mainValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : '#000000',
											description : 'Set color of tooltip main value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip main value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip main value.'
										} ],
								description : 'Set properties of tooltip main value (data value).'
							},
							{
								name : 'subValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : '#000000',
											description : 'Set color of tooltip sub value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip sub value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip sub value.'
										} ],
								description : 'Set properties of tooltip sub value (percentage).'
							},
							{
								name : 'text',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : '#000000',
											description : 'Set color of tooltip text.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip text.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip text.'
										} ],
								description : 'Set properties of tooltip text (dimension label).'
							} ],
					description : 'Set tooltip properties of pie chart.'
				}
			};
			return json;
		},

		getColumnDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				visibleRange : this.getCommonChartProperties().visibleRange,
				selectability : {
                    name : 'selectability',
                    supportedValueType : 'Object',
                    supportedValues : [
                            {
                                name : 'mode',
                                supportedValueType : 'List',
                                supportedValues : [ 'single', 'none' ],
                                defaultValue : 'none',
                                description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'deSelectable',
                                supportedValueType : 'Boolean',
                                defaultValue : true,
                                description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'defaultSelectedItems',
                                supportedValueType : 'ObjectArray',
                                supportedValues : [
                                        {
                                            name : 'measureIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected measure items.'
                                        },
                                        {
                                            name : 'dimensionItemIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected dimension items.'
                                        } ],
                                defaultValue : [],
                                description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
                            } ],
                    description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
                    isExported : false
                },
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					}, {
						name : 'type',
						supportedValueType : 'String',
						defaultValue : '',
						description : 'Top level type of element shapes',
						isExported : false
					} ],
					description : 'Set the measure releated properties.',
					isExported : false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'Set the bar marker size of measure member.',
									isExported: false
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure member.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure member.',
									isExported: false
								} ],
						description : 'Set the measure member releated properties.'
					} ],
					description : 'Set the measures releated properties.'
				},
				bar : {
					name : 'bar',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'barMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : undefined,
						description : 'Set bar marker size of series.'
					} ],
					description : 'Set bar releated properties.'
				}
			};
			return json;
		},

		getLineDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				selectability : {
                    name : 'selectability',
                    supportedValueType : 'Object',
                    supportedValues : [
                            {
                                name : 'mode',
                                supportedValueType : 'List',
                                supportedValues : [ 'single', 'none' ],
                                defaultValue : 'none',
                                description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'deSelectable',
                                supportedValueType : 'Boolean',
                                defaultValue : true,
                                description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'defaultSelectedItems',
                                supportedValueType : 'ObjectArray',
                                supportedValues : [
                                        {
                                            name : 'measureIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected measure items.'
                                        },
                                        {
                                            name : 'dimensionItemIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected dimension items.'
                                        } ],
                                defaultValue : [],
                                description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
                            } ],
                    description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
                    isExported : false
                },
				line : {
					name : 'line',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'lineMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : 10,
						description : 'Set line marker size of series.'
					}, {
						name : 'lineThickness',
						supportedValueType : 'PositiveInt',
						defaultValue : 1,
						description : 'Set line thinkness of series.'
					} ],
					description : 'Set the line releated properties.'
				},
				visibleRange : this.getCommonChartProperties().visibleRange,
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					} ],
					description : 'Set the measure releated properties.',
					isExported : false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'lineMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : 10,
									description : 'An internal properties, as it does not make sense to set size per series. Set the line marker size of measure member.',
									isExported: false
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the line color of measure mmeber.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set the line size of measure mmeber.'
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure mmeber.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure mmeber.',
									isExported: false
								},
								{
									name : 'markerSymbol',
									supportedValueType : 'List',
									supportedValues : [ 'circle', 'triangle',
											'diamond' ],
									defaultValue : 'circle',
									description : 'Set marker symbol of measure mmeber.'

								} ],
						description : 'Set the measure mmeber releated properties.'
					} ],
					description : 'Set the measures releated properties.'
				}

			};

			return json;
		},

	};

	return des;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PieModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.BasicModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.PieRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
}
],
function Setup ( ObjUtils, TypeUtils, BasicModule, PieRenderer, Series, SeriesGroup ) {
	var PieModule = ObjUtils.derive(BasicModule, {
		events : [ 'selectData' ],
		constructor : function(options) {
			this._seriesGroup = null;
			this._pieRenderer = null;
			this._hasDrawed = false;
		},
		
		buildData : function() {
			this._data = [];
			var dimensionList = this._dataTree.getSubMembersAt();
			var dimensionLabels = this._dataTree.getSubMemberLabels();
			
			var initialData = [];
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++ ) {
				var measure = this._metaData.measureMembers[i];
				for ( var j = 0, jlen = dimensionList.length; j < jlen; j++ ) {
					var dimension = [ dimensionList[j] ];
					var sum = this._dataTree.getMeasuresAt(dimension)[measure].sum;
					initialData.push(sum.result);
				}
			}
			
			this._processData(initialData);
			
			for ( i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var subData = [];
				var measure = this._metaData.measureMembers[i];
				for ( var j = 0, jLen = dimensionList.length; j < jLen; j++) {
					var d = [ dimensionList[j] ];
					var sumObj = this._dataTree.getMeasuresAt(d)[measure].sum;
					var dimensionPathArr = sumObj.tags.dimensionPath;
					//[jyang, 20/3/2012]FIXME for pie module, we only use the first dimension path
					//but we need extra steps to support multi dimensions in single pie chart
					var dimensionPath = dimensionPathArr.length > 0 ? dimensionPathArr[0] : {};
					var value = initialData[j];
					subData.push({
							value : TypeUtils.isNumber(value) ? value : 'NaN',
							dimensionItemIndex : dimensionPath.dimensionItemIndex,
							measureIndex : sumObj.tags.measureIndex,
							dimensionItem: dimensionLabels[j]
						});
				}
				this._data.push(subData);
			}
		},
		
		// Filters out irrational data when the data is technically
		// valid but semantically meaningless, say, in case of a huge 
		// magical number exists. Here we set the threshold value of 
		// ratio between largest and smallest number to 1/10000, below
		// which numbers will be set to 0 and simply bypassed.
		_processData : function ( array ) {
			for ( var i = 0, len = array.length; i < len; i++ ) { 
				if ( array[i] === 'NaN' || array[i] < 0 ) array[i] = 0;
			}
			
			var replica = array.slice();
			replica.sort(function ( a, b ) { return a - b; });
			var maxValue = replica[replica.length - 1];
			
			for ( var i = 0, len = array.length; i < len; i++ ) {
				if ( (array[i] / maxValue - 0.0001) < 0 ) {
					array[i] = 0;
				}
			}
		},
		
		initSeries : function() {
			var seriesOption = this._chart_options.properties.measures;
			var measureMembers = this._metaData.measureMembers;
			var seriesDefault = this._chart_options.properties.measureDefault;
			this._seriesGroup = new SeriesGroup();

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = ObjUtils.extend(true, {}, seriesDefault, seriesOption[i]);
				//TODO JY: HOW TO STORE PROPERTIES INSIDE SERIES? WE NEED SEPERATE PROPERTY OBJECT?
				var s = new Series(o);
				s.setName(measureMembers[i]);
				//[jy 03/13/2012]for pie chart we won't draw any invalid values (NaN or less than 0)
				var seriesData = [];
				var dataCandidateArray = this._data[i];
				for(var j = 0, jlen = dataCandidateArray.length; j < jlen; j++){
					var valueCandidate = dataCandidateArray[j];
					if(valueCandidate.value !== 'NaN' && valueCandidate.value > 0){
						seriesData.push(valueCandidate);
					}
				}
				s.setData(seriesData);
				this._seriesGroup.addSeries(s);
			}
		},

		bindRenderer : function(layer) {
			if (this._pieRenderer == null) {
				this._pieRenderer = new PieRenderer(layer, this._chart_options, false);
			} else {
				this._pieRenderer.resetSeriesGroup();
			}
			this._pieRenderer.addSeriesGroup(this._seriesGroup);
		},
		
		drawSeries : function() {
			if (!this._hasDrawed) {
				this._pieRenderer.draw();
				this._hasDrawed = true;
			} else {
				this._pieRenderer.redraw();
			}
			
			if ( this._defaultSelectionArmed ) {
				var defaultSelectedSlices = this._chart_options.properties.selectedDataIndexes;
				if ( this._chart_options.properties.allSelectable && defaultSelectedSlices.length > 0 ) {
					for ( var index = 0; index < defaultSelectedSlices.length; index++ ) {
						if ( !this._pieRenderer._shapes.pieSectors[defaultSelectedSlices[index]] ) {
							continue;
						}
						if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
								&& index === 1 ) {
							break;
						}
						this._pieRenderer._selectPie(defaultSelectedSlices[index]);
						this._pieRenderer._interactionStatus.selected.push(defaultSelectedSlices[index]);
					}
				}
				this._defaultSelectionArmed = false;
			} else {
				var selections = this._pieRenderer._interactionStatus.selected;
				if ( TypeUtils.isExist(selections) && selections.length > 0 ) {
					for ( var i = 0; i < selections.length; i++ ) {
						if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
								&& i === 1 ) {
							break;
						}
						this._pieRenderer._selectPie(selections[i]);	
					}
				}
			}
		},
		
		doChartLayout : function(nsize, seriesMaskLayer, seriesLayer) {

			seriesMaskLayer.size(nsize);
			seriesMaskLayer.position({
				x : 0,
				y : 0
			});
			seriesLayer.size(nsize);
			seriesLayer.position({
				x : 0,
				y : 0
			});
		},
		
		updateProperties : function(propBag){
			this.callParent('updateProperties', propBag);
			//[jyang 3/12/2012] how to update properties? 
			//store properties in series group or renderer?
			//now we just pass it to renderer, need refactor			
			this._pieRenderer.updateProperties(propBag);
			
			var seriesOption = this._chart_options.properties.measures;
			var defaultOption = this._chart_options.properties.measureDefault;
			var seriesProperties = [];
			
			for ( var i = 0, len = seriesOption.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {}, defaultOption, seriesOption[i]);
				seriesProperties.push(opts);
			}
			this._seriesGroup.updateProperties(seriesProperties);
			
			
		},

		/**
		 * @return events 'selectData'
		 * @override sap.riv.viz.pie.BasicModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData' ];
		},

		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		clickOnPoint : function(point) {
			if (this._pieRenderer == null) {
				ObjUtils.error('No renderer to handle event!');
			}
			var dataCtxOnPoint = this._pieRenderer.highlightOnPoint(point);
			//[jyang 3/13/2012] dataCtx is an array for multi selection case
			//and it's safe we return dataCtxOnPoint directly here as we create
			//new inside renderer
			if (dataCtxOnPoint) {
				this.fireEvent('selectData', {
					name : 'selectData',
					data : dataCtxOnPoint
				});
			}
		},
		
		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		hoverOnPoint : function(point) {
			if (this._pieRenderer == null) {
				ObjUtils.error('No renderer to handle event!');
			}
			//currently we don't need dataCtx returned from this API
			this._pieRenderer.hoverOnPoint(point);
		},
		
		applyTheme : function(theme){
			this._pieRenderer.applyTheme(theme);
		},
		
		updateOptions : function(options) {
			this.callParent('updateOptions', options);
			this._pieRenderer.updateOptions(options);
		},
	});
	return PieModule;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.title.TitleCanvasComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, TextRuler, Canvas2DSurfaceComponent, PropsMgr, ThemeManager, TextLine,NumericFormatManager) {
	/**
	 * Default options for drawing chart titles. See usage example below:
	 * 
	 * <pre>
	 * {
	 * 	main : {
	 * 		text : 'This is the main title',
	 * 		font : 'bold 16px Arial',
	 * 		color : '#000000',
	 * 		horizontalAlign : 'center',
	 * 		visible : false
	 * 	},
	 * 	sub : {
	 * 		text : 'This is the sub title',
	 * 		font : 'normal 14px Arial',
	 * 		color : '#000000',
	 * 		horizontalAlign : 'center',
	 * 		visible : false
	 * 	}
	 * }
	 * </pre>
	 * 
	 * Note that the font size here represents a preferred size, it will be
	 * automatically adjusted if the container can't contain such big font.
	 */
	var defaultOptions = {
		main : {
			"text" : 'Default Chart Title',
			"font" : 'bold 16px Arial',
			"color" : '#ffffff',
			"horizontalAlign" : 'center',
			"formatString" : '',
			"visible" : false
		},
		sub : {
			"text" : 'Default Sub Title',
			"font" : 'normal 14px Arial',
			"color" : '#ffffff',
			"horizontalAlign" : 'center',
			"formatString" : '',
			"visible" : false
		}
	};
	
	var trimString = function ( str ) {
		return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	};

	/**
	 * Represents a light weight text processor who provides similar
	 * functionalities of a word processor.
	 * @author eye
	 */
	var TextProcessor = function ( inputString, prefs ) {
		this._text = inputString;
		this._lineCapacity = prefs.lineWidth;
		this._wordWrap = prefs.wordWrap;
	};

	TextProcessor.prototype = {
		constructor : this,	

		/**
		 * Returns lines of word-wrapped sliced text string.
		 * @returns {Array} lineData - Text string sliced in lines
		 */
		getLines : function () {
			// String lines
			this._lineData = [];
		
			// Converts text string to character array.
			this._text = trimString(this._text + '');
			var characters = this._text.split('');
			
			if ( this._wordWrap ) {
				if ( characters.length <= this._lineCapacity ) {
					this._lineData.push(this._text);
					return this._lineData;
				}
			
				var space = ' ';
				var spaceSlots = []; // Stores space indexes.
				for ( var i = 0; i < characters.length; i++ ) 
					if ( characters[i] === space ) 
						spaceSlots.push(i);
				
				// Append additional space index which helps find the last few "lefts".
				spaceSlots.push(characters.length);
				
				var cursor = 0; // Cursor marks start of the unprocessed char array.
				var sentinel = this._lineCapacity;
				var 
					// Stores line string. 
					line, 
					// Current measurement means the current range starting from right after
					// the last processed character to the next space, against which the
					// line width will be compared.
					currentMeasurement, 
					// Progress marks the last processed space (characters before has been
					// added to lines) as a line string ending, which helps determine 
					// if there's unprocessed short ones.
					progress; 
				for ( i = 0; i < spaceSlots.length; i++ ) {
					currentMeasurement = spaceSlots[i] - cursor;
					if ( currentMeasurement === sentinel ) {
						line = characters.slice(cursor, spaceSlots[i]).join('');
						this._lineData.push(line);
						cursor = spaceSlots[i];
						progress = spaceSlots[i]; // File progress
					} else if ( currentMeasurement > sentinel ) {
						line = characters.slice(cursor, spaceSlots[i - 1]).join('');
						this._lineData.push(line);
						cursor = spaceSlots[i - 1] + 1;
						progress = spaceSlots[i - 1]; // File progress
					} else {
						continue;
					}
				}
				
				if ( TypeUtils.isDefined(progress)
						&& trimString(this._lineData.join('')).length < characters.length ) {
					line = characters.slice(progress + 1, characters.length);
					this._lineData.push(line.join(''));
				}
				
				return this._lineData;
			}
		},
		
		setText : function ( inputString ) {
			this._text = inputString;
		},
		
		setWidth : function ( width ) {
			this._lineCapacity = width;
		},
		
		setWordWrapEnabled : function ( enabled ) {
			this._wordWrap = enabled;
		}
	};

	/**
	 * Represents a <code>Canvas2DSurfaceComponent</code> object been used to
	 * draw chart titles.
	 */
	var TitleCanvasComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.titleOptions;

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();
			
			// Container of main and sub title shapes
			this._textShapes = [];
			
			// Line painting anchor
			this._anchor = { x : 0, y : 0 };
			
			this._textProcessor;
			this._theme;
		},
		
		/**
		 * Paints the title with given <code>attributes</code>. This painting job has the assumption
		 * of the stable state of paint-ability, i.e., the canvas is always empty and ready for
		 * painting.
		 * 
		 * @param {Object} attributes - Title settings
		 * @author eye
		 */
		paint : function ( attributes ) {
			for ( var i = 0; i < this._textShapes.length; i++ ) {
				this._layer.removeShape(this._textShapes[i]);
			}
			
			if ( !attributes || !attributes.main || !attributes.main.visible ) {
				this._refresh();
				return;
			}
			
			this._textShapes.splice(0, this._textShapes.length);
			this._anchor = { x : 0, y : 0 };
			
			var mainTitleLines = this.wrapWord(attributes.main.text,
					this.getLineCapacity(attributes.main.font));
			
			var mainTitleShape;
			for ( i = 0; i < mainTitleLines.length; i++ ) {
				mainTitleShape = this._layer.addShape(new TextLine());
				this.paintln({
					text : mainTitleLines[i],
					font : attributes.main.font,
					color : attributes.main.color,
					align : attributes.main.horizontalAlign
				}, mainTitleShape);
				this._textShapes.push(mainTitleShape);
			}
			
			if ( attributes.sub && attributes.sub.visible ) {
				var subTitleLines = this.wrapWord(attributes.sub.text, 
						this.getLineCapacity(attributes.sub.font));
				
				var subTitleShape;
				for ( i = 0; i < subTitleLines.length; i++ ) {
					subTitleShape = this._layer.addShape(new TextLine());
					this.paintln({
						text : subTitleLines[i],
						font : attributes.sub.font,
						color : attributes.sub.color,
						align : attributes.sub.horizontalAlign
					}, subTitleShape);
					this._textShapes.push(subTitleShape);
				}
			}
			
			this._refresh();
		},
		
		/**
		 * Paints and appends a line of text on the last painted line if any onto the target
		 * painting area which can be a layer or shape and at least an instance of a 
		 * <code>Drawable</code> object.
		 * 
		 * @param {Object} titleLine 
		 * - Title line data including text, font, color and horizontal alignment.
		 * 
		 * @param {Object} target - Instance of a <code>Shape</code>
		 * 
		 * @author eye
		 */
		paintln : function ( titleLine, target ) {
			if ( !titleLine || !target ) return;
			
			var titleWidth = TextRuler.measureWidth(titleLine.font, titleLine.text);
			target.text(titleLine.text).font(titleLine.font).textColor(titleLine.color).width(titleWidth).visible(true);
			
			var centerX = this._containerSize.width / 2;
			var height = TextRuler.measureHeight(titleLine.font);

			switch ( titleLine.align.toLowerCase() ) {
			case "center" :
				this._anchor.x = centerX;
				target.center([ this._anchor.x, this._anchor.y + height / 2 ]);
				break;
			case "left" :
				this._anchor.x = 0;
				target.leftCenter([ this._anchor.x, this._anchor.y + height / 2 ]);
				break;
			case "right" :
				this._anchor.x = this._containerSize.width;
				target.rightCenter([ this._anchor.x, this._anchor.y + height / 2 ]);
				break;
			default :
				this._anchor.x = centerX;
				target.center([ this._anchor.x, this._anchor.y + height / 2 ]);
			}
			this._anchor.y += height;
		},
	
		/**
		 * Helper function that slices a string of text into pieces within
		 * the <code>threshold</code>, a.k.a., a word wrap function.
		 * 
		 * @param {String} inputString - Input text string
		 * @param {Integer} width - Carriage return threshold
		 * 
		 * @author eye
		 */
		wrapWord : function ( inputString, width ) {
			if ( this._textProcessor ) {
				this._textProcessor.setText(inputString);
				this._textProcessor.setWidth(width);
				this._textProcessor.setWordWrapEnabled(true);
				return this._textProcessor.getLines();
			} else {
				this._textProcessor = new TextProcessor(
						inputString, { lineWidth : width, wordWrap : true });
				return this._textProcessor.getLines();
			}
		},
		
		/**
		 * Calculates and returns the actual size of the title texts
		 * according to user settings. This function determines title
		 * width by picking up the longer one, and title height will
		 * always be the addition of the two titles, if sub title is set.
		 * 
		 * @param {Object} settings 
		 * - User settings on title texts in terms of text value and font value
		 * 							
		 * @returns {Object} preferred size in JSON object
		 * 
		 * @author eye
		 */
		getPreferredSize : function ( containerSize, settings ) {
			if ( !containerSize || !settings || !settings.main ) {
				//utils.error("Container size or main title property setting is required.");
				return;
			}
			
			this._containerSize = containerSize;
			
			var returnSize = { width : 0, height : 0 }, 
				lineCapacity, 
				mtWidth, stWidth; // Main and sub title width
			
			if ( TypeUtils.isExist(settings.main.visible) && !settings.main.visible ) {
				return returnSize;
			}
			
			// Width
			lineCapacity = this.getLineCapacity(settings.main.font);
			if ( settings.main.text.length >= lineCapacity ) {
				returnSize.width = mtWidth = this._containerSize.width;
			} else {
				if ( settings.sub && settings.sub.visible ) {
					lineCapacity = this.getLineCapacity(settings.sub.font);
					if ( settings.sub.text.length >= lineCapacity ) {
						returnSize.width = stWidth = this._containerSize.width;
					} else {
						mtWidth = TextRuler.measureWidth(settings.main.font, settings.main.text);
						stWidth = TextRuler.measureWidth(settings.sub.font, settings.sub.text);
						
						mtWidth > stWidth ? returnSize.width = mtWidth : 
							returnSize.width = stWidth;
					}
				}
			}
			
			// Height
			lineCapacity = this.getLineCapacity(settings.main.font);
			var mtLines = this.wrapWord(settings.main.text, lineCapacity);
			returnSize.height += (mtLines.length * TextRuler.measureHeight(settings.main.font));
			
			lineCapacity = this.getLineCapacity(settings.sub.font);
			var stLines = this.wrapWord(settings.sub.text, lineCapacity);
			returnSize.height += (stLines.length * TextRuler.measureHeight(settings.sub.font));

			return returnSize;
		},
		
		setPreferredSize : function ( size ) {
			this._containerSize = size;
		},
		
		/**
		 * Calculates line character containment threshold by given font information.
		 * 
		 * @param {String} fontString 
		 * - The font that will be applied
		 * 
		 * @returns {Number} lineCapacity 
		 * - Number of line capacity of character containment
		 * 
		 * @author eye
		 */
		getLineCapacity : function ( fontString ) {
			var lineCapacity = 0;
			var referenceCharacter = 'r'; // The widest alphabet
			
			var unitWidth = TextRuler.measureText(fontString, referenceCharacter).width;
			// Conservative estimate is employed here.
			lineCapacity = Math.floor(this._containerSize.width / unitWidth);
			
			return lineCapacity;
		},
		
		_refresh : function () {
			this._layer.setNeedsDisplay();
		},
		
		updateProperties : function( props ) {
			delete this._options;
			this._options = props.title;
			
			var mainTitleTextFormat =  TypeUtils.isExist(this._options.main.formatString) ? this._options.main.formatString : defaultOptions.main.formatString;
			var mainTitileFT = sap.common.globalization.NumericFormatManager.getFormat(mainTitleTextFormat);
			
			var subTitleTextFormat = TypeUtils.isExist(this._options.sub.formatString) ? this._options.sub.formatString : defaultOptions.sub.formatString;
			var subTitleFT =  sap.common.globalization.NumericFormatManager.getFormat(subTitleTextFormat);
			
			this._options.main.text = TypeUtils.isExist(mainTitileFT) ? mainTitileFT.display(this._options.main.text) : this._options.main.text;
			this._options.sub.text = TypeUtils.isExist(subTitleFT) ? subTitleFT.display(this._options.sub.text) : this._options.sub.text;
			
			this.paint( this._options );
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent( 'doContentResize', oldSize, newSize );
			
			var mainTitleTextFormat =  TypeUtils.isExist(this._options.main.formatString) ? this._options.main.formatString : defaultOptions.main.formatString;
			var mainTitileFT = sap.common.globalization.NumericFormatManager.getFormat(mainTitleTextFormat);
			
			var subTitleTextFormat = TypeUtils.isExist(this._options.sub.formatString) ? this._options.sub.formatString : defaultOptions.sub.formatString;
			var subTitleFT =  sap.common.globalization.NumericFormatManager.getFormat(subTitleTextFormat);
			
			this._options.main.text = TypeUtils.isExist(mainTitileFT) ? mainTitileFT.display(this._options.main.text) : this._options.main.text;
			this._options.sub.text = TypeUtils.isExist(subTitleFT) ? subTitleFT.display(this._options.sub.text) : this._options.sub.text;
			
			this.paint( this._options );
		},

		/**
		 * Applies a set of theme values into the component. This function
		 * simply modifies title properties. Graphics related function invocations
		 * are not allowed here because the title component is ignorant of
		 * shape owners, i.e., difference between main or sub title.
		 * 
		 * @param {Object} theme - Theme items
		 */
		applyTheme : function ( theme ) {
			this._theme =  ThemeManager.getThemeSettings(theme);
			
			var font, color, space = ' ';
			
			var mtStyle = ObjUtils.extend(true, {}, this._theme.global, this._theme.title.mainTitle);
			var stStyle = ObjUtils.extend(true, {}, this._theme.global, this._theme.title.subTitle);
			
			font = mtStyle["font-weight"] + space + mtStyle["font-size"] + space + mtStyle["font-family"];
			color = mtStyle["color"];
			
			this._options.main.font = font;
			this._options.main.color = color;
			
			if ( this._options.sub ) {
				font = stStyle["font-weight"] + space + stStyle["font-size"] + space + stStyle["font-family"];
				color = stStyle["color"];
				
				this._options.sub.font = font;
				this._options.sub.color = color;
			}
			
			if ( this._textShapes.length !== 0 ) {
				// Repaints the titles due to the theme change.
				this.paint(this._options);
			}
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		}
	});
	TitleCanvasComponent.getDefaultOption = function() {
		return defaultOptions;
	};
	return TitleCanvasComponent;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TypeUtils, FillableShape, Math) {
	var _crispLineOptimization = function(start, end, width){
		
		var xEquals = (start[0] === end[0]);
    	var yEquals = (start[1] === end[1]);
    	
    	if(xEquals || yEquals){ 
    		if(xEquals){
    			start[0] = end[0] = Math.floor(start[0]);
    			
    			if(width%2 === 1){
    				start[0] = end[0] = start[0]+0.5;
    			}
    		} 
    		
    		if(yEquals){
    			start[1] = end[1] = Math.floor(start[1]);
    			
    			if(width%2 === 1){
    				start[1] = end[1] = start[1]+0.5;
    			}
    		}
    	}
    	
    	return {start:[start[0], start[1]], end:[end[0], end[1]]};
	};
	
	/**
	 * This class defines Polygon
	 * 
	 * @name sap.riv.graphics.shape.Polygon
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Polygon = ObjectUtils.derive(FillableShape, {
		constructor : function() {
			this._isClosed = false;
			this._vertices = [];
			this._hitTestVertices = [];
		},
		/**
		 * Add polygon vertices
		 * 
		 * @name sap.riv.graphics.shape.Polygon#addVertices
		 * @function
		 * @param {Number|[[x,y]]}
		 *            x the x coordinate of one vertex, or an array of vertices
		 * @param {Number}
		 *            [y] the y coordinate of one vertex
		 * 
		 * @returns {this} this object
		 */
		addVertices : function(x, y) {
			if (TypeUtils.isArray(x)) {
				var vertices = x;
				for ( var i = 0, len = vertices.length; i < len; i++) {
					this._vertices.push([ vertices[i][0], vertices[i][1] ]);
					this._hitTestVertices.push([ vertices[i][0], vertices[i][1] ]);
				}
			} else {
				if (x !== undefined, y !== undefined) {
					this._vertices.push([ x, y ]);
					this._hitTestVertices.push([ x, y ]);
				}
			}
			return this;
		},
		/**
		 * Mark the polygon is closed. You must explicitly call this method to
		 * indicate the polygon is closed.
		 * 
		 * @name sap.riv.graphics.shape.Polygon#close
		 * @function
		 * 
		 * @returns {this} this object
		 */
		close : function() {
			if (!this._isClosed) {
				this._hitTestVertices.push([].concat(this._vertices[0]));
				this._isClosed = true;
			}
			return this;
		},
		/**
		 * Reset the polygon to empty.
		 * 
		 * @name sap.riv.graphics.shape.Polygon#reset
		 * @function
		 * 
		 * @returns {this} this object
		 */
		reset : function() {
			this._isClosed = false;
			this._vertices.splice(0, this._vertices.length);
			this._hitTestVertices.splice(0, this._hitTestVertices.length);
		},

		doDraw : function(drawingContext) {
			var vtx = this._vertices;
            if (vtx.length < 2) {
                return;
            }
            
            // Adjust vertices for crisp line optimization 
            for ( var i = 1, e, len = vtx.length; i < len; i++) {
                var start = vtx[i-1];
                var end = vtx[i];
                var result = _crispLineOptimization(start, end, this.borderWidth());
                vtx[i-1] = result.start;
                vtx[i] = result.end;
            }
            
            var dCtx = drawingContext;
            dCtx.beginPath();
            dCtx.moveTo(vtx[0][0], vtx[0][1]);
            
            for ( var i = 1, e, len = vtx.length; i < len; i++) {
                e = vtx[i];
                dCtx.lineTo(e[0], e[1]);
            }
            dCtx.closePath();
            this.fillShape(dCtx);
            this.drawBorder(dCtx);
		},

		doPointInTest : (function() {
			var isLeft = function(sp, ep, tp) {
				return ((ep[0] - sp[0]) * (tp[1] - sp[1]) - (tp[0] - sp[0]) * (ep[1] - sp[1]));
			};
			return function(point) {
				var wn = 0;
				var x = point.x, y = point.y;
				var p = [ x, y ];
				for ( var i = 0, vtx = this._hitTestVertices, elen = vtx.length - 1; i < elen; i++) {
					if (vtx[i][1] <= y) {
						if (vtx[i + 1][1] > y)
							if (isLeft(vtx[i], vtx[i + 1], p) > 0)
								++wn;
					} else {
						if (vtx[i + 1][1] <= y)
							if (isLeft(vtx[i], vtx[i + 1], p) < 0)
								--wn;
					}
				}
				return wn;
			};
		})()
	});
	return Polygon;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.layout.BasicLayout',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Represents a data structure for storing layout data on chart legend, title and
	 * the main chart graphical area. See legend and title parameterization settings example below:
	 * 
	 * <pre>
	 * chartOptions = {
	 *     legend:{
	 *         show: true|false, // true by default
	 *         position: 'right'|'top'|'bottom'|'left', // 'right' by default
	 * 	   },
	 * 	   title:{
	 * 	       main:{
	 * 		       show:true|false // false by default; Sub title visibility depends on that of main title.
	 *         },
	 *         sub:{
	 * 	           show:true|false // false by default
	 * 	       }
	 * 	   }
	 * }
	 * </pre>
	 */
	var basicLayout = function(size, initProps) {
		this._size = {
			width : size.width,
			height : size.height
		};
		this._layoutChanged = false;
		
		this._mainTitleVisible = false;
		this._subTitleVisible = false;
		
		this._showLegend = true;

		this._legendDock = "right";
		
		this._padding = [0, 0, 0, 0];
		this._legendFirst = false;
		this._maxLegendWidth = 0;
		this._maxLegendHeight = 0;
		this._preferredTitleWidth = 0;
		this._preferredTitleHeight = 0;
		this._parseOptions(initProps);
	};

	basicLayout.prototype = {
		_parseOptions : function ( options ) {
			// Each "!=" operator here just assumes client might pass a string value.
			if ( options.legend ) {
				if ( this._showLegend != options.legend.visible ) {
					this._showLegend = options.legend.visible;
					this._layoutChanged = true;
				}
				
				if ( this._legendDock != options.legend.position ) {
					this._legendDock = options.legend.position;
					this._layoutChanged = true;
				}
			}
			
			if ( options.title ) {
				if ( options.title.main ) {
					if ( this._mainTitleVisible !== options.title.main.visible ) {
						if ( options.title.main.visible === false ) {
							this._mainTitleVisible = false;
							this._subTitleVisible = false;
						} else {
							this._mainTitleVisible = true;
						}
						this._layoutChanged = true;
					}
				}
				
				if ( options.title.sub ) {
					if ( this._mainTitleVisible && this._subTitleVisible != options.title.sub.visible ) {
						this._subTitleVisible = options.title.sub.visible;
						this._layoutChanged = true;
					}
				}
			}
			
			if ( options.layout ) {
				if ( this._padding != options.layout.padding ) {
					this._padding = options.layout.padding;
					this._layoutChanged = true;
				}
				
				if ( this._legendFirst != options.layout.legendFirst ) {
					this._legendFirst = options.layout.legendFirst;
					this._layoutChanged = true;
				}
			}
		},
		
		layoutChanged : function () {
			return this._layoutChanged;
		},
		
		updateSize : function ( newSize ) {
			if ( this._size.width != newSize.width || this._size.height != newSize.height ) {
				this._size.width = newSize.width;
				this._size.height = newSize.height;
				this._layoutChanged = true;
			}
		},
		
		updateSettings : function ( settings ) {
			this._parseOptions(settings);
		},
		
		/**
		 * Returns layout data in terms of sub-component paddings.
		 * <pre>
		 * {
	     * 	main : [ x, y, w, h ],
	     * 	title : [ x, y, w, h ], //optional, if title is show
	     * 	legend : [ x, y, w, h ], //optional, if legend is show
	     *  background : [0, 0, w, h]
	     * }
	     * </pre>
		 */
		getLayoutInfo : function () {
			var returnObject = new Object();
			
			var padding = transformPadding(this._padding);
			var width = this._size.width - padding[1] - padding[3];
			var height = this._size.height - padding[0] - padding[2];
			
			var titleHeight = 0;
			if (this._mainTitleVisible) {
				returnObject.title = [];
				returnObject.title.push(padding[3], padding[0], width);
				titleHeight = this._preferredTitleHeight;
				returnObject.title.push(titleHeight);
			}
			
			if (this._showLegend) {
				var chartWidth, chartHeight, legendWidth, legendHeight, legendSpace = 0;
				if ( this._legendDock === 'left' || this._legendDock === 'right' ) {
					// left/right of legend
					chartWidth = width * 0.79;
					chartHeight = height - titleHeight;
					legendWidth = width * 0.15;// and we have 3% space
					legendHeight = height;
					legendSpace = width * 0.03;
					
					if(this._legendFirst){
						legendWidth = this._maxLegendWidth;
						chartWidth = width - legendWidth - 2 * legendSpace;
					}
				} else {
					legendWidth = width;
					legendHeight = height * 0.06;
					legendSpace = height * 0.03;
					chartWidth = width;
					chartHeight = height - legendHeight - titleHeight - 2 * legendSpace;
					
					if( this._legendFirst ) {
						legendHeight = this._maxLegendHeight;
						chartHeight = height - titleHeight - legendHeight - 2 * legendSpace;
					}
				}
				
				var legendX = 0, legendY = 0, mainX = 0, mainY = 0;
				returnObject.main = [];
				returnObject.legend = [];
				switch ( this._legendDock ) {
					case 'top':
						legendX = 0;
						legendY = titleHeight + legendSpace;
						mainX = 0;
						mainY = titleHeight + 2 * legendSpace + legendHeight;
						break;
					case 'bottom':
						legendX = 0;
						legendY = titleHeight + chartHeight + legendSpace;
						mainX = 0;
						mainY = titleHeight;
						break;
					case 'left':
						legendX = legendSpace;
						legendY = 0;
						mainX = legendSpace + legendWidth + legendSpace;
						mainY = titleHeight;
						break;
					case 'right':
					default:
						legendX = chartWidth + legendSpace;
						legendY = 0;
						mainX = 0;
						mainY = titleHeight;
						break;
				}
				returnObject.main.push(mainX + padding[3], mainY + padding[0], chartWidth, chartHeight);
				returnObject.legend.push(legendX + padding[3], legendY + padding[0], legendWidth, legendHeight);
			} else {
				var chartWidth = width;
				returnObject.main = [];
				returnObject.main.push(padding[3], titleHeight + padding[0], chartWidth, height - titleHeight);
			}
			returnObject.background = [];
			returnObject.background.push(0, 0, this._size.width, this._size.height);
			return returnObject;
		},
		
		setMaxLegendWidth : function ( value ) {
			this._maxLegendWidth = value;
		},
		
		setMaxLegendHeight : function ( value ) {
			this._maxLegendHeight = value;
		},
		
		setPreferredTitleWidth : function ( value ) {
			this._preferredTitleWidth = value;
		},
		
		setPreferredTitleHeight : function ( value ) {
			this._preferredTitleHeight = value;
		}
	};
	
	// Static function that transforms raw padding data into the format of
	// standard CSS padding attribute.
	// [10] => [10,10,10,10]
	// [2,3] => [2,3,2,3]
	// [1,30,5] => [1,30,5,30]
	var transformPadding = function( padding ){
		if( padding.length === 0 ){
			padding[0] = 0;
		}
		for ( var index = 0; index < 4; index++) {
			var value = padding[index];
			if (value == undefined) {
				if (index != 3) {
					padding[index] = padding[0];
				} else {
					padding[index] = padding[1];
				}
			}
		}
		return padding;
	};
	return basicLayout;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.FoucsCalculator',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var fCalculator = function() {
	};

	fCalculator.createFocus = function(value) {
		switch (value) {
		case 'off':
			return new fCalculator.NoFocus();
		case 'full':
			return new fCalculator.StandardFocus();
		case 'growth':
			return new fCalculator.ZoomOutFocus();
		default:
			return new fCalculator.ManualFocus();
		}
	};

	fCalculator.StandardFocus = function() {
		return this;
	};

	fCalculator.StandardFocus.prototype.calculateFocus = function(options) {
		switch (options.lineScaling) {
		case 'logarithmic':
		case 'log10':
			return this.calculateLogarithmicFocus(options.minValue,
					options.maxValue);
		default:
			return this
					.calculateLinearFocus(options.minValue, options.maxValue);
		}
	};

	fCalculator.StandardFocus.prototype.calculateLogarithmicFocus = function(
			minimum, maximum) {

		var bounds = {};

		bounds.major = this.calculateMajorUnitFromBounds(minimum, maximum);
		bounds.minor = bounds.major / 3;

		var minLog = Math.log(minimum) / Math.log(10);
		var maxLog = Math.log(maximum) / Math.log(10);

		// both bounds are positive
		if (maxLog >= 0 && minLog >= 0) {
			bounds.max = maximum + 0.05 * (maximum - minimum);
			var multiplier = Math.ceil(bounds.max / bounds.major);
			bounds.max = multiplier * bounds.major;

			bounds.min = minimum - ((maximum - minimum) / 2);
			bounds.min = bounds.major * Math.ceil(bounds.min / bounds.major);
			bounds.min = Math.max(1, bounds.min);
		} else if (maxLog <= 0 && minLog <= 0) {
			if (maxLog - minLog > 0.16667 * minLog)
				bounds.max = 1;
		}

		if (bounds.min < 1)
			bounds.min = 1 / Math.pow(10, Math.max(1,
					bounds.min.toString().length - 1));

		return bounds;
	};

	fCalculator.StandardFocus.prototype.calculateLinearFocus = function(
			minimum, maximum) {
		var bounds = {};

		// standard focus overrides the user's desired intervals
		bounds.major = this.calculateMajorUnitFromBounds(minimum, maximum);
		bounds.minor = bounds.major / 3;

		// both bounds are positive
		if (maximum >= 0 && minimum >= 0) {
			bounds.max = maximum + 0.05 * (maximum - minimum);
			var multiplier = Math.ceil(bounds.max / bounds.major);
			bounds.max = multiplier * bounds.major;

			/*
			 * X4.5 had this code, but it doesn't seem to be used. Disabling it
			 * here... if(maximum - minimum > 0.16667 * maximum) { bounds.min =
			 * 0; } else
			 */
			{
				bounds.min = minimum - ((maximum - minimum) / 2);
				multiplier = Math.max(0, Math.floor(bounds.min / bounds.major));
				bounds.min = multiplier * bounds.major;
			}
		}
		// both bounds are negative
		// both bounds are negative
		else if (maximum <= 0 && minimum <= 0) {
			bounds.min = minimum + 0.05 * (minimum - maximum);
			multiplier = Math.floor(bounds.min / bounds.major);
			bounds.min = multiplier * bounds.major;
			/*
			 * X4.5 had this code, but it doesn't seem to be used. Disabling it
			 * here... if(maximum - minimum > 0.16667 * minimum) { bounds.max =
			 * 0; } else
			 */
			{
				bounds.max = maximum - ((minimum - maximum) / 2);
				multiplier = Math.min(0, Math.ceil(bounds.max / bounds.major));
				bounds.max = multiplier * bounds.major;
			}
		} else // Max is positive and min is negative
		{
			bounds.max = maximum + 0.05 * (maximum - minimum);
			multiplier = Math.ceil(bounds.max / bounds.major);
			bounds.max = multiplier * bounds.major;

			bounds.min = minimum + 0.05 * (minimum - maximum);
			multiplier = Math.floor(bounds.min / bounds.major);
			bounds.min = multiplier * bounds.major;
		}

		return bounds;

	};

	fCalculator.DEFAULT_MIN_BOUND = 0;
	fCalculator.DEFAULT_MAX_BOUND = 5;
	/**
	 * If bounds have been set to invalid values such as NaN, this function sets
	 * them to defaults. It changes min and max values that are equal so that
	 * the bounds are a proper range. It's a last resort to any other validation
	 * that has taken place so that labels are always numbers.
	 * 
	 * @param min
	 *            the desired minimum value for the axis
	 * @param max
	 *            the desired maximum value for the axis
	 * @return an Object containing validated minimum and maximum values for an
	 *         axis
	 */
	fCalculator.validateBounds = function(min, max) {
		// if we have bad data, we have defaults so the chart displays correctly
		if (TypeUtils.isNaN(min) || TypeUtils.isNaN(max)) {
			min = fCalculator.DEFAULT_MIN_BOUND;
			max = fCalculator.DEFAULT_MAX_BOUND;
		}

		// compensate for duplicate bounds, by either changing a bound to zero,
		// or reseting to defaults
		if (min === max) {
			if (min > 0)
				min = 0;
			else if (max < 0)
				max = 0;
			// last chance, min and max both must be zero, so go to our default
			// values
			else {
				min = fCalculator.DEFAULT_MIN_BOUND;
				max = fCalculator.DEFAULT_MAX_BOUND;
			}
		}

		return {
			min : min,
			max : max
		};
	};

	fCalculator.StandardFocus.prototype.calculateMajorUnitFromBounds = function(
			minValue, maxValue) {

		var s = 0;
		var range = maxValue - minValue;

		if (maxValue > 0 && minValue < 0) {
			s = Math.log(range) / Math.log(10);
			s = Math.floor(s);
			range = range / Math.pow(10, s);
			if (1 <= range && range < 1 + (81 / 99))
				range = 0.2;
			else if (1 + (81 / 99) <= range && range < 4 + (54 / 99))
				range = 0.5;
			else if (4 + (54 / 99) <= range && range < 9 + (1 / 11))
				range = 1;
			else
				range = 2;

			return range * Math.pow(10, s);
		} else if (range < (maxValue * 0.16667)) {
			range = range / 6.3492063492063;
			s = Math.log(range) / Math.log(10);
			s = Math.floor(s);
			range = range / Math.pow(10, s);
			if (range / 5 > 1)
				range = 10;
			else if (range / 2 > 1)
				range = 5;
			else if (range > 1)
				range = 2;
			else
				range = 1;

			return range * Math.pow(10, s);
		} else {
			if (minValue < 0)
				maxValue = Math.abs(minValue);

			// scale to 1 - 10
			range = Math.log(maxValue) / Math.log(10);
			s = Math.floor(range);
			range = maxValue / Math.pow(10, s);

			if (1 <= range && range < 1.90476)
				return 0.2 * Math.pow(10, s);

			if (1.09476 <= range && range < 4.76190)
				return 0.5 * Math.pow(10, s);

			if (4.76190 <= range && range < 9.5239)
				return Math.pow(10, s);

			return 2 * Math.pow(10, s);
		}
	};

	fCalculator.NoFocus = function() {
		return this;
	};

	fCalculator.NoFocus.prototype.calculateFocus = function(options) {

	};

	fCalculator.ZoomOutFocus = function() {

	};

	fCalculator.ZoomOutFocus.prototype.calculateFocus = function(options) {

	};

	fCalculator.ManualFocus = function() {

	};

	fCalculator.ManualFocus.prototype.calculateFocus = function(options) {

	};

	return fCalculator;

});sap.riv.module(
{
  qname : 'sap.riv.vizkit.VizAppDelegate',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(FuncUtils, ThemeManager) {
	/**
	 * The abstract application delegate class. Application delegate is used to
	 * plug in your specific application logic. The object is created by
	 * VizApplication automatically
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate
	 * @constructor
	 */
	var VizAppDelegate = function() {
		this._publicMethodsRegistry = {};
		this._theme = ThemeManager.defaultTheme();
		this._application;
	};

	var vp = VizAppDelegate.prototype;

	vp._afterLaunched = function(application, launchOption) {
		this._application = application;
		this.appDidFinishLaunching(application, launchOption);
		var rootController = this.rootController();
		rootController._setApplication_(this._application);
		this._application._setRootController(rootController);
	};

	/**
	 * This method will be called after the application fully launched, the
	 * Application will pass launchOption (if any) to this method. Any
	 * application specific initialization should be put here, e.g. initialize
	 * necessary data structure.
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#appDidFinishLaunching
	 * @function
	 * @param {Object}
	 *            launchOption the launchOption which is passed in
	 *            VizApplication constructor
	 */
	vp.appDidFinishLaunching = FuncUtils.noop;

	/**
	 * Subclass <b>MUST</b> implement this method to return the root controller
	 * of the application
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#rootController
	 * @return {sap.riv.vizkit.UIController}
	 */
	vp.rootController = FuncUtils.unimplemented;

	/**
	 * This method is used to register any method specific to the current
	 * visualization implementation, and exposed to the consumer. This method is
	 * expected to be called during initialization phase, like in
	 * appDidFinishLaunching. The 'this' object of the function during invoking
	 * will be pointing to delegate object.
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#registerPublicMethod
	 * @param {String}
	 *            methodName the name of the method to be exposed
	 * @param {Function}
	 *            func the function of the method.
	 */
	vp.registerPublicMethod = function(methodName, func) {
		this._publicMethodsRegistry[methodName] = func;
	};

	vp._invokePublicMethod = function(publicMethodName, options) {
		if (this._publicMethodsRegistry.hasOwnProperty(publicMethodName)) {
			this._publicMethodsRegistry[publicMethodName].call(this, options);
		}
	};

	vp._currentTheme = function() {
		return this._theme;
	};

	vp._applyTheme = function(theme) {
		if (this._theme !== theme) {
			this.rootController().doThemeApplied(theme);
		}
	};

	vp._updateThemeSetting = function(theme, key, oldValue, newValue) {
		if (this._theme === theme) {
			this.rootController().doThemeUpdated(key, oldValue, newValue);
		}
	};
	/**
	 * Subclass should implement this method to return plain object contains all
	 * of the modifiable properties and their current value.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#getProperties
	 * 
	 * @returns {Object} property bag
	 * 
	 */
	vp.getProperties = function() {
		return {};
	};

	/**
	 * Subclass should implement this method to accept a property bag.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#updateProperties
	 * @param {Object}
	 *            propBag
	 * 
	 */
	vp.updateProperties = FuncUtils.noop;

	/**
	 * Subclass should implement this method to accept a dataset.
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#setDataset
	 * @param {Object}
	 */
	vp.setDataset = FuncUtils.noop;

	/**
	 * Subclass should implement this method to return a list of assets(only
	 * image supported) to be preload.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#getPreloadAssets
	 * 
	 * @returns {[]} the item in the array should follow below structure
	 * 
	 * <pre>
	 * [ {
	 * 	id : 'IMAGE_ID',
	 * 	url : 'IMAGE_URL'
	 * } ]
	 * </pre>
	 */
	vp.getPreloadAssets = function() {
		return [];
	};
	/**
	 * Subclass should implement this method to return a list of supported
	 * events that could be listened by visualization user.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#getSupportedEvents
	 * 
	 * @returns {[]} the list of event names
	 * 
	 */
	vp.getSupportedEvents = function() {
		return [];
	};

	vp.getSupportedMethods = function() {
		var ret = [];
		for ( var p in this._publicMethodsRegistry) {
			ret.push(p);
		}
		return ret;
	};
	return VizAppDelegate;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.DimensionAxisRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.BasicAxisRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TextRuler, TypeUtils, BasicAxisRenderer, PositionCalculator) {

	var dimensionAxisRenderer = ObjectUtils
			.derive(
					BasicAxisRenderer,
					{

						constructor : function(options) {
							this._daxr_initialize();
							return this;
						},

						_daxr_initialize : function() {

							this._maxValue = this._baxr_options.labels.length + 0.5;
							this._minValue = 0.5;
							this._num_interval = this._baxr_options.labels.length - 1;
							this._dimensionAxisFT = [];
							for ( var i = 0; i < this._baxr_options.labels.length; i++) {
								if (i < this._labels.formatString.length) {
									this._dimensionAxisFT
											.push(sap.common.globalization.NumericFormatManager
													.getFormat(this._labels.formatString[i]));
								} else {
									this._dimensionAxisFT
											.push(sap.common.globalization.NumericFormatManager
													.getFormat(this._labels.formatString[this._labels.formatString.length - 1]));
								}
							}
							this._hideOverlappingLabels = false;

						},

						_getLongestWidth : function() {
							if (!TypeUtils.isExist(this._longestWidth)
									|| this._longestWidth == 0) {
								var tu = TextRuler;

								// find the longest str
								var str = TypeUtils
										.isExist(this._dimensionAxisFT[0]) ? this._dimensionAxisFT[0]
										.display(this._baxr_options.labels[0])
										: this._baxr_options.labels[0];
								var strLength = str.toString().length;
								var formatDisplay,cLabelsLength;
								for ( var i = 1, cLabelsText = this._baxr_options.labels, len = cLabelsText.length; i < len; i++) {
									// Fix the issue [Ian 2012-3-11] if all the
									// labels are number, as the length function
									// is not exist
									// we way get the incorrect max length. so
									// we call toString function to convert
									// number to string.
									formatDisplay = TypeUtils
											.isExist(this._dimensionAxisFT[i]) ? this._dimensionAxisFT[i]
											.display(cLabelsText[i])
											: cLabelsText[i];
									cLabelsLength = formatDisplay.toString().length;
									if (strLength < cLabelsLength) {
										strLength = cLabelsText[i].toString().length;
										str = formatDisplay;
									}
									// End
								}
								this._longestWidth = tu.measureWidth(
										this._labels.font, str);
							}
							return this._longestWidth;
						},

						_createLabelsAndPosition : function() {

							var opts = this._baxr_options;
							var cLabels = this._labels.itemsValue;
							var labelpositions = this._labels.itemsPosition = [];
							var multiplier = this
									._calculatePositionMultiplier();

							for ( var i = 0, labels = opts.labels; i < labels.length; i++) {
								cLabels[i] = new this.Label();
								cLabels[i]
										.value(TypeUtils
												.isExist(this._dimensionAxisFT[i]) ? this._dimensionAxisFT[i]
												.display(labels[i])
												: labels[i]);
								cLabels[i].visible(true);

								// calculate the label position
								labelpositions[i] = PositionCalculator
										.calculateLinearPosition(i + 1,
												multiplier, this._minValue);
							}
						},

						/*
						 * return the longest width among labels
						 */
						distance : function(distance) {
							if (TypeUtils.isExist(distance)) {
								this._distance = distance;

								this._createLabelsAndPosition();
								if (this._hideOverlappingLabels) {
									// Don't remove category labels, or labels
									// that can be rotated but haven't been
									this
											._removeOverlappingLabels(this._labels.itemsPosition.length);
								}

								if (this._position == 'hb'
										|| this._position == 'ht') {
									this._axisMatrics.left = this._axisMatrics.right = 0;
								} else {
									this._axisMatrics.bottom = this._axisMatrics.top = 0;
								}

								return this;
							}
							return this._distance;
						},

						/**
						 * 
						 * @param xscale
						 *            xaxis scale
						 * @param yscale
						 *            yaxis scale
						 * @param dscale
						 *            distance scale
						 */
						zoom : function(xscale, yscale, dscale) {
							this._scaled = true;
							// reset the variable
							this._positionMultiplier = null;
							this._majorTickPositions = null;
							this._minorTickPositions = null;

							var subLayer = this.getSubLayer();
							var oldSize = subLayer.size();
							subLayer.size({
								height : oldSize.height * yscale,
								width : oldSize.width * xscale
							});

							this.distance(this._distance * dscale);
							this.draw();

						},

						setVisibleRange : function(xscale, yscale, dscale) {
							this._scaled = true;
							// reset the variable
							this._positionMultiplier = null;
							this._majorTickPositions = null;
							this._minorTickPositions = null;

							var subLayer = this.getSubLayer();
							var oldSize = this._layer.size();
							subLayer.size({
								height : oldSize.height * yscale,
								width : oldSize.width * xscale
							});

							this.distance(this._distance * dscale);
						}
					});

	return dimensionAxisRenderer;

});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.legend.LegendCanvasComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ObjUtils, TextRuler, Canvas2DSurfaceComponent, PropsMgr, ThemeManager, Circle, TextLine,
		Rectangle, Polygon) {
	/**
	 * canvas based legend component which accepts following options:
	 * 
	 * <pre>
	 * {
	 * 		show: true/false,//default true
	 * 		position: 'right'/'top'/'bottom'/'left',//default right
	 * 		verticalOffset : 0,
	 * 	horizontalOffset : 0
	 * 	font : 'bold 16px Arial',
	 * 		color : '#000000',
	 * }
	 * 
	 */
	var defaultOptions = {
		visible : true,
		position : 'right',
		verticalOffset : 0,
		horizontalOffset : 0,
		labelFont : 'bold 16px Arial',
		labelColor : '#000000',
		titleFont : 'bold 16px Arial',
		titleColor : '#000000',
		formatString : ['']
	};
	var textPhrase = "The quick brown fox jumps over the lazy dog";
	var LegendCanvasComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.legendOptions.properties.legend;

			this._parseOptions(options.legendOptions.properties);

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();
			this._content = null;
			this._maxLabelHeight = null;
			this._curmaxLabelHeight = this._maxLabelHeight;
			this._eventObservers = []; // Event observers who're interested in legend events.
			this._stateChangeable = false; // Used to determine if legend state and appearance can be changed upon state changes.
			this._initialize();
			this._hookEvents();
		},

		// here we get additional data
		_parseOptions : function(options) {
			this._titletxt = options._additional.legendTitle || "";
			this._colorList = options._additional.colorList;
			this._labels = options._additional.legendLabels;
			this._labelFont = options.legend.labelFont;
			this._labelFontColor = options.legend.labelColor;
			this._titleLabelFont = options.legend.titleFont;
			this._titleLabelFontColor = options.legend.titleColor;
			this._markerList = options._additional.legendMarkers || [];
			this._formatString =  options._additional.legendNumberFormat;
			this._legendFirst =  options.layout.legendFirst;
		},

		_initialize : function() {
			var labels = this._labels;
			this._title = this._layer.addShape(new TextLine());
			this._content = [];
			var markerList = this._markerList;
			var legendFT;

			this._maxLabelHeight = TextRuler.measureText(this._labelFont, textPhrase).height;
			for ( var i = 0; i < labels.length; i++) {
				var element = {};
				element.active = true;
				element.label = this._layer.addShape(new TextLine());
                element.colorListIndex = i;
                
                // If legendFirst property is true, this step will be skipped, the format is done by calMaxLegendSize function
                // It is critical that the format is only done once.
                if(!this._legendFirst){
                	// Nick - format label category if the formatString exists. if the label category is a string object, formatter will not work
                	legendFT = sap.common.globalization.NumericFormatManager.getFormat(this._formatString[i]);
                	this._labels[i].category = TypeUtils.isExist(legendFT) ? legendFT.display(this._labels[i].category) : this._labels[i].category;
                }
                element.measureIndex = labels[i].measureIndex;
                this._createMarkupShape(element, markerList[i]);
                this._content.push(element);
			}
		},

		_createMarkupShape : function(element, markerType) {
			switch (markerType) {
			case "circle":
				element.markup = this._layer.addShape(new Circle());
				element.checkedShape = this._layer.addShape(new Circle());
				break;
			case "diamond":
			case "triangle":
				element.markup = this._layer.addShape(new Polygon());
				element.checkedShape = this._layer.addShape(new Polygon());
				break;
			case "rect":
			default:
				element.markup = this._layer.addShape(new Rectangle());
				element.checkedShape = this._layer.addShape(new Rectangle());
				break;
			}
		},

		_refresh : function() {
			this._layer.setNeedsDisplay();
		},

		_resetShapes : function() {
			this._layer.removeShape(this._title);
			for ( var i = 0, len = this._content.length; i < len; i++) {
				this._layer.removeShape(this._content[i].label);
				this._layer.removeShape(this._content[i].markup);
				this._layer.removeShape(this._content[i].checkedShape);
			}
		},

		_update : function() {
			var options = this._options;
			var markerList = this._markerList;

			var titleWidth = TextRuler.measureWidth(this._titleLabelFont, this._titletxt);
			var labelHeight = this._maxLabelHeight;
        	var markupMarginRight = 0.5 * labelHeight;
        	var markupMarginTop = 0.2 * labelHeight;
        	var markupSize = 0.6 * labelHeight;
        	var labelSpace = 0.1 * labelHeight;
        	var padding = 0.2 * labelHeight;
        	var colorListIndex;
//        	this._title.text(this._titletxt).textAlign('l').font(this._titleLabelFont).textColor(
//            		this._titleLabelFontColor).width(titleWidth);
            if(options.position == 'right' || options.position == 'left'){
            	var titleHeight = 0, contentHeight = 0;
	        	if(TypeUtils.isExist(this._titletxt) && this._titletxt.toString() !== ''){
	        		this._title.text(this._titletxt).textAlign('l').font(this._titleLabelFont).textColor(
	                		this._titleLabelFontColor).width(titleWidth);
	        		titleHeight = this._title._height + labelSpace;
	        	}
            	contentHeight = titleHeight + (labelHeight + labelSpace)*this._content.length - labelSpace;
	        	var startX = padding, startY = padding + (this._chartHeight - contentHeight - 2*padding)/2; //[Christy | 2012/3/12]Start from Zero.
	        	startY = startY - options.verticalOffset;
	        	//Handler vertical offset overflow
//	        	if(startY < 0){
//	        		startY = 0;
//	        	}else if(startY > (this._chartHeight - contentHeight)){
//	        		startY = this._chartHeight - contentHeight;
//	        	}
	        	if(TypeUtils.isExist(this._titletxt) && this._titletxt.toString() !== ''){
	        		//[Christy/2012/3/16]Legend title. align left.
	        		this._title.topLeft([startX, startY]);
	        	}
	        	var py = titleHeight + startY;
	          
	            for (var i = 0; i < this._content.length; i++) {
	            
	                var element = this._content[i];
	                colorListIndex = i;
	                this._drawMarkup(markerList[i], element.markup, {x:startX, y:py + markupMarginTop}, this._colorList[colorListIndex]);
	                //[Christy || Add checked box shape.
	                this._drawCheckedShape(markerList[i], element.checkedShape, {x:startX, y:py + markupMarginTop}, this._colorList[colorListIndex]);
	                element.label.text(this._labels[i].category).textAlign('l').font(this._labelFont).textColor(
	                		this._labelFontColor).leftCenter([startX + markupSize + markupMarginRight, py + labelHeight/2])
	                        .width(TextRuler.measureWidth(this._labelFont, this._labels[i].category));
	                py += labelSpace + labelHeight;
	            }
            }else{
            	var contentWidth = 0, startX = padding, startY = padding;
            	for (var i = 0; i < this._content.length; i++) {
            		
            		contentWidth += TextRuler.measureWidth(this._labelFont, this._labels[i].category) + this._maxLabelHeight + 10;
            	}
            	//[Christy | 2012/3/12]Start from Zero.
            	startX = startX + (this._chartWidth - contentWidth)/2;
            	startX = startX + options.horizontalOffset;
            	
            	//[Christy | 2012/3/12]Don't show legend title when legend orientation is top/bottom.
            	this._title.text('');
//            	this._title.topLeft([startX, 0]);
//            	startX = startX + titleWidth +10;
            	var px = startX;
            	 for (var i = 0; i < this._content.length; i++) {
 	                var element = this._content[i];
 	                colorListIndex = i;
 	                var textWidth = TextRuler.measureWidth(this._labelFont, this._labels[i].category);
 	                this._drawMarkup(markerList[i], element.markup, {x:px, y:startY + markupMarginTop}, this._colorList[colorListIndex]);
 	                this._drawCheckedShape(markerList[i], element.checkedShape, {x:px, y:startY + markupMarginTop}, this._colorList[colorListIndex]);
 	                element.label.text(this._labels[i].category).textAlign('l').font(this._labelFont).textColor(
 	                		this._labelFontColor).topLeft([px + markupSize + markupMarginRight, startY])
 	                        .width(textWidth);
 	                px += markupSize + markupMarginRight + textWidth + labelSpace;
 	            }
            }
            this._refresh();
        },

		_drawMarkup : function(markerType, markerShape, point, fillColor) {
			var markerSize = this._maxLabelHeight * 0.6;
			markerShape.borderWidth(1).borderColor(fillColor);
			switch (markerType) {
			case "circle":
				markerShape.center({
					x : point.x + markerSize / 2,
					y : point.y + markerSize / 2
				}).radius(markerSize / 2);
				break;
			case "diamond":
				markerShape.reset();
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize / 2);
				markerShape.addVertices(point.x + markerSize / 2, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize / 2);
				markerShape.close();
				break;
			case "triangle":
				markerShape.reset();
				var radius = markerSize / 2;
				point.x =  point.x + markerSize / 2;
				point.y = point.y + markerSize / 2;
				markerShape.addVertices(point.x, point.y - radius);
				markerShape.addVertices(point.x + radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.addVertices(point.x - radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.close();
				break;
			case "rect":
			default:
				markerShape.topLeft([ point.x, point.y ]).width(markerSize).height(markerSize);
				break;
			}
		},
		
		_drawCheckedShape : function(markerType, markerShape, point, fillColor){
			//[Christy] Add check box.
			var markerSize = this._maxLabelHeight * 0.6 - 4;
			point.x = point.x + 2;
			point.y = point.y + 2;
			switch (markerType) {
			case "circle":
				markerShape.center({
					x : point.x + markerSize / 2,
					y : point.y + markerSize / 2
				}).radius(markerSize / 2);
				markerShape.fillingColor(fillColor);
				break;
			case "diamond":
				markerShape.reset();
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize / 2);
				markerShape.addVertices(point.x + markerSize / 2, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize / 2);
				markerShape.close();
				markerShape.fillingColor(fillColor);
				break;
			case "triangle":
				markerShape.reset();
				var radius = markerSize / 2;
				point.x =  point.x + markerSize / 2;
				point.y = point.y + markerSize / 2;
				markerShape.addVertices(point.x, point.y - radius);
				markerShape.addVertices(point.x + radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.addVertices(point.x - radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.close();
				markerShape.fillingColor(fillColor);
				break;
			case "rect":
			default:
				markerShape.topLeft([ point.x, point.y ]).width(markerSize).height(markerSize).color(fillColor);
				break;
			}
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
			this._chartHeight = newSize.height;
			this._chartWidth = newSize.width;
			this._update();
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var legendStyle = settings.legend;
           		var globalStyle = settings.global;
            		var titleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
           		this._titleLabelFont = titleStyle['font-weight'] + " " + titleStyle['font-size'] + " " + titleStyle['font-family'];
            		this._titleLabelFontColor = titleStyle['color'];
            var labelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
            this._labelFont = labelStyle['font-weight'] + " " + labelStyle['font-size'] + " " + labelStyle['font-family'];
            this._labelFontColor = labelStyle['color'];

            this._title.font(this._titleLabelFont).textColor(this._titleLabelFontColor).width(TextRuler.measureWidth(this._titleLabelFont, this._titletxt));
            
            for (var i = 0; i < this._content.length; i++) {
                this._content[i].label.font(this._labelFont).textColor(this._labelFontColor).width(TextRuler.measureWidth(this._labelFont, this._labels[i].category));
            }
			this._refresh();
		},

		updateOptions : function(legend) {
			this._parseOptions(legend.properties);
			this._resetShapes();
			this._title = null;
			this._content = null;

			this._initialize();
			this._update();
		},

		updateProperties : function(propertyBag) {
			var oldMarkerList = this._markerList;
			this._options = propertyBag.legend;
			this._parseOptions(propertyBag);
			for ( var i = 0, len = oldMarkerList.length; i < len; i++) {
				if (oldMarkerList[i] !== this._markerList[i]) {
					var element = this._content[i];
					this._layer.removeShape(element.markup);
					this._layer.removeShape(element.checkedShape);
					this._createMarkupShape(element, this._markerList[i]);
				}
			}

			this._maxLabelHeight = TextRuler.measureText(this._labelFont, textPhrase).height;
			
			var labels = this._labels;
			
			var legendFT;
        	for(var i = 0; i < labels.length; i++) {
        		legendFT = sap.common.globalization.NumericFormatManager.getFormat(this._formatString[i]);
                labels[i].category = TypeUtils.isExist(legendFT) ? legendFT.display(labels[i].category) : labels[i].category;
        	}
			this._update();
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		},
		
		calMaxLegendSize : function(options) {
			var labelFont = options.legend.labelFont;
			var maxLabelHeight = 0, maxLabelWidth = 0;
			var labelWidth = 0, labelHeight = 0, labelSize;

        	var labels = options._additional.legendLabels;
        	var labelsLength = labels.length;
        	var legendFT;
        	for(var i = 0; i < labelsLength; i++) {
        		legendFT = sap.common.globalization.NumericFormatManager.getFormat(options._additional.legendNumberFormat[i]);
                labels[i].category = TypeUtils.isExist(legendFT) ? legendFT.display(labels[i].category) : labels[i].category;
        		labelSize = TextRuler.measureText(labelFont, labels[i].category);
                labelHeight = labelSize.height;
				labelWidth = labelSize.width;
				if (labelHeight > maxLabelHeight) {
					maxLabelHeight = labelHeight;
				}
				if (labelWidth > maxLabelWidth) {
					maxLabelWidth = labelWidth;
				}
			}
			return {
				width : maxLabelWidth + maxLabelHeight + 10,
				height : maxLabelHeight
			};
		},
		
        /**
         * Attaches event observer who's interested in the legend events.
         * The event observers added here are expected to own a <code>notify</code>
         * method as a hook for being notified.
         *  
         * @param {Object} observer
         * - Interested observer
         * 
         * @author eye
         */
        addEventObserver : function ( observer ) {
        	this._eventObservers.push(observer);
        },
        
        getStateChangeable : function () {
        	return this._stateChangeable;
        },
        
        setStateChangeable : function ( changeable ) {
        	this._stateChangeable = changeable;
        },
        
		_hookEvents : function () {
        	this._layer.on([{
        		eventName : 'mouseup',
        		listener : this._dispatchEvent,
        		scope : this
        	}, {
                eventName : 'touchstart',
                listener : this._dispatchEvent,
                scope : this
            }]);
		},
		
		_dispatchEvent : function ( event ) {
        	var eventType = event.type();
        	switch ( eventType ) {
        	case 'mouseup' :
        		this._handleClick(event.targetLocalXY());
        		break;
        	case 'touchstart' :
        		this._handleClick(event.targetTouches().item(0).localXY());
        		break;
        	default:
        		break;
	        }
		},
		
		_handleClick : function ( pointCoord ) {
			if ( !this._stateChangeable ) return;
			
			var command = new Object();
			command.commandText = "ChangeSeriesVisibility";
			
			for ( var i = 0; i < this._content.length; i++ ) {
				if ( this._content[i].label.doPointInTest(pointCoord) 
        				|| this._content[i].markup.doPointInTest(pointCoord)
        				|| (this._content[i].markup.rect 
        					&& this._content[i].markup.rect.doPointInTest(pointCoord)) ) {
					command.seriesIndex = this._content[i].colorListIndex;
					if ( this._content[i].active ) {
        				this._content[i].active = false;
        				command.setVisible = false;
        				this._deactivateItem(command.seriesIndex);
        			} else {
        				this._content[i].active = true;
        				command.setVisible = true;
        				this._activateItem(command.seriesIndex);
        			}
				}
			}
			this._refresh();
			
			if ( !TypeUtils.isDefined(command.seriesIndex) ) {
				return;
			}
			
        	for ( i = 0; i < this._eventObservers.length; i++ ) {
        		this._eventObservers[i].notify(command);
        	}
		},
		
		_activateItem : function (seriesIndex) {
			var element = this._content[seriesIndex];
			element.checkedShape.visible(true);
		},
		
		_deactivateItem : function (seriesIndex) {
			var element = this._content[seriesIndex];
			element.checkedShape.visible(false);
		}
	});

	LegendCanvasComponent.getDefaultOption = function() {
		return defaultOptions;
	};
	return LegendCanvasComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PiePlotComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.MultiPieModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PieModule',
  version : '1.0.0'
}
],
function Setup(ObjUtils, LOG, UIComponent,Canvas2DSurfaceComponent, Layer,MultiPieModule,PieModule) {
	var PiePlotComponent = ObjUtils.derive(Canvas2DSurfaceComponent,
	{
		constructor : function(options) {
		 this._canvasSurface = this.getCanvasSurface();
            this._rootLayer = this._canvasSurface.getRootLayer();

            this._chart_options = options.chart;
            this._metaData = this._chart_options.metaData;
            this._dataTree = this._chart_options.dataTree;

            // the layer we actual drawing on
            this._seriesLayer = null;
            // the layer which controls the visible area and listen on event
            this._seriesMaskLayer = null;

            this._chartModule = null;

            this._init(false);

		},

        _init : function(redraw) {
            if(!redraw) {
                this._initModule();
            }
            
            this._chartModule.init();

            if(!redraw) {
                this._seriesMaskLayer = new Layer({
                    anchor : {
                        x : 0,
                        y : 0
                    }
                });
                this._seriesMaskLayer.clipToBounds(true);
                this._rootLayer.addSubLayer(this._seriesMaskLayer);
                this._seriesLayer = new Layer({
                    anchor : {
                        x : 0,
                        y : 0
                    }
                });
                this._seriesMaskLayer.addSubLayer(this._seriesLayer);
            }

            this._chartModule.bindRenderer(this._seriesLayer);

            if(!redraw) {
                this._registerEvents();
            }
        },

        _initModule : function() {
        	//[jimmy 3/7/2012] type is passed from sap.riv.html.Visualization.prototype._init
        	//it's the graphic_id user used when creating viz
            switch (this._chart_options.properties.type) {
            	case 'multipie':
            		this._chartModule = new MultiPieModule(this._chart_options);
                	break;
                case 'pie':
                default:
                	this._chartModule = new PieModule(this._chart_options);
                	break;
            }
        },

        _chart_layout : function(nsize) {
            this._chartModule.doChartLayout(nsize, this._seriesMaskLayer, this._seriesLayer);
        },

        _doDraw : function(size) {
            this._chart_layout(size);
            this._chartModule.drawSeries();
            this._rootLayer.setNeedsDisplay();
        },

        _resetEventStatusVariables : function() {
            // variables used to store mouse/touch status
            this._mouseAlreadyDown = false;
            this._mouseAlreadyMoved = false;
            // [Jimmy- 021512]we don't want mousemove too sensitive, use this
            // var to track the distance of mouse moving.
            // only when it's large than 0.5px, we think user is moving the mouse
            this._mouseMoveThreshold = 0.3;
            // [Jimmy- 021512]make sure you have to give it a value before using
            // it
            this._previousMousePosition = undefined;
            // end of variables
        },

        /**
         * [jimmy-021512]now the native event handlers are registered on layer,
         * while gestures handlers are registered on component. please note
         * touchCancel is required to handle if any other touch related events
         * are listened.
         */
        _registerEvents : function() {
            this._resetEventStatusVariables();
            this._seriesMaskLayer.on([{
                eventName : 'mousemove',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'mouseup',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'mousedown',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'mouseleave',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'touchstart',
                listener : this._touchEventHandler,
                scope : this
            }, {
                eventName : 'touchend',
                listener : this._touchEventHandler,
                scope : this
            }, {
                eventName : 'touchmove',
                listener : this._touchEventHandler,
                scope : this
            }, {
                eventName : 'touchcancel',
                listener : this._touchEventHandler,
                scope : this
            }]);
        },

        /**
         * in single chart, we directly draw shapes on series layer in the module, so actually
         * we don't need do this kind of conversion. this is only for multi chart case or other
         * special case that we create sub layers on series layer to draw chart shapes or sub charts
         * and we may not want to specify which layer to handle the event, it's up to module to determine
         * which layer to handle based on the passed in point.
         * @param mouseEvent
         *            an instance of sap.riv.graphics.MouseEvent
         */
        _convertXYForMouseEvent : function(mouseEvent) {
            // [jimmy-021512] here we'll convert coordinate from target layer to
            // the series layer
            if(this._seriesLayer == null) {
                ObjUtils.error('Series Layer should be initialized before any event handler!')
            }
            var xyOnTargetLayer = mouseEvent.targetLocalXY();
            var targetLayer = mouseEvent.targetLayer();
            var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
            return xyOnSeriesLayer;
        },
        
        /**
         * in single chart, we directly draw shapes on series layer in the module, so actually
         * we don't need do this kind of conversion. this is only for multi chart case or other
         * special case that we create sub layers on series layer to draw chart shapes or sub charts
         * and we may not want to specify which layer to handle the event, it's up to module to determine
         * which layer to handle based on the passed in point.
         * @param touch
         *            an instance of sap.riv.graphics.Touch
         */
        _convertXYForTouch : function(touch) {
            // [jimmy-021512] here we'll convert coordinate from target layer to
            // the series layer
            if(this._seriesLayer == null) {
                ObjUtils.error('Series Layer should be initialized before any event handler!')
            }
            var xyOnTargetLayer = touch.localXY();
            var targetLayer = touch.targetLayer();
            var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
            return xyOnSeriesLayer;
        },

        /**
         * @param mouseEvent
         *            an instance of sap.riv.graphics.MouseEvent
         */
        _mouseEventHandler : function(mouseEvent) {
            var eventType = mouseEvent.type();
            switch (eventType) {
                case 'mousedown':
                    this._mouseAlreadyDown = true;
                    // [jimmy-021512]set it to false so that we can have click after
                    // we do mouse move
                    this._mouseAlreadyMoved = false;
                    break;
                case 'mouseup':
                    this._mouseAlreadyDown = false;
                    if(!this._mouseAlreadyMoved) {
                        this._chartModule.clickOnPoint(this._convertXYForMouseEvent(mouseEvent));
                    }
                    this._mouseAlreadyMoved = false;
                    break;
                case 'mousemove':
                    if(this._previousMousePosition) {
                        var currentPosition = mouseEvent.targetLocalXY();
                        if(Math.abs(currentPosition.x - this._previousMousePosition.x) > this._mouseMoveThreshold || Math.abs(currentPosition.x - this._previousMousePosition.x) > this._mouseMoveThreshold) {
                            // we are actually moving
                            if(this._mouseAlreadyDown) {
                                // marquee selection
                                this._chartModule.marqueeOverPoint(this._convertXYForMouseEvent(mouseEvent));
                            } else {
                                // tooltip
                                this._chartModule.hoverOnPoint(this._convertXYForMouseEvent(mouseEvent));
                            }
                            // reset the moving tracking
                            this._previousMousePosition = undefined;
                            // we already move
                            this._mouseAlreadyMoved = true;
                        }
                    } else {
                        this._previousMousePosition = mouseEvent.targetLocalXY();
                    }
                    break;
                case 'mouseleave':
                    this._resetEventStatusVariables();
                    break;
                default:
                    break;
            }
        },

        _touchEventHandler: function(touchEvent){
        	var eventType = touchEvent.type();
        	switch (eventType){
	        	case 'touchstart':
	        		// TODO: need investigate why length not equal 1
	                var touch = touchEvent.targetTouches().item(0);
	                this._chartModule.hoverOnPoint(this._convertXYForTouch(touch));
	        		break;
	        	case 'touchmove':
	        		if (touchEvent.targetTouches().length() != 1) {
	                    return;
	                }
	                var touch = touchEvent.targetTouches().item(0);
	                this._chartModule.hoverOnPoint(this._convertXYForTouch(touch));
	        		break;
	        	case 'touchend':
	        		if (touchEvent.changedTouches().length() != 1) {
	                    return;
	                }
	                var touch = touchEvent.changedTouches().item(0);
	                this._chartModule.clickOnPoint(this._convertXYForTouch(touch));
	        		break;
	        	case 'touchcancel':
	        		//LOG.debug('about to cancel touch!')
	        		break;
	        	default:
	                break;
        	}
        },
        
        /**
         * Resize component's visual content, when the component's size changed,
         * this method will be invoked before layout sub components
         */
        doContentResize : function(osize, nsize) {
            this.callParent('doContentResize', osize, nsize);
            this._doDraw(nsize);
        },

        applyTheme : function(theme) {
        	this._chartModule.applyTheme(theme);
        },

        updateProperties : function(propBag) {
        	this._chart_options.properties = propBag;
        	this._chartModule.updateProperties(propBag);
        	this._doDraw(this.size());
        },

        updateOptions : function(options) {
            this._chart_options = options;
            this._metaData = options.metaData;
            this._dataTree = options.dataTree;

            this._chartModule.updateOptions(this._chart_options);
            this._init(true);
            this._doDraw(this.size());
        },

        /**
         * @return events which can be listened by clients
         */
        getSupportedAppEvents : function() {
            return this._chartModule.getSupportedAppEvents();
        },

		doPrint : function(drawingCtx) {

		}
	});
	return PiePlotComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.background.BackgroundComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Canvas2DSurfaceComponent, PropsMgr, Layer, ThemeManager) {
	/**
	 * It accepts following options:
	 * 
	 * <pre>
	 * {
	 * 	color : null
	 *  visible : true
	 * }
	 * by default, we don't draw any background 
	 * </pre>
	 */
	var defaultOptions = {
		color : null,
		visible : true
	};

	var BackgroundComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.backgroundOptions;

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();

			var size = this.size();
			// FIXME currently there is a bug in framework to set
			// bgcolor in
			// rootlayer, so we add a new sublayer to draw the
			// background
			this._mainLayer = new Layer({
				anchor : {
					x : 0,
					y : 0
				},
				position : {
					x : 0,
					y : 0
				},
				size : {
					w : size.width,
					h : size.height
				}
			});
			this._layer.addSubLayer(this._mainLayer);
			this._bgc_initialize();
		},

		_bgc_initialize : function() {
			this._bgc_setBgColor();
		},

		_bgc_setBgColor : function() {
			// TODO currently we only support background color, we need
			// draw something if we have more requirement
			if (this._options.visible && this._options.color) {
				this._mainLayer.backgroundColor(this._options.color);
			} else {
				this._mainLayer.backgroundColor(false);
			}
		},

		_bgc_refresh : function() {
			this._mainLayer.setNeedsDisplay();
		},

		updateProperties : function(propertyBag) {
			delete this._options;
			this._options = propertyBag.background;
			this._bgc_setBgColor();
			this._bgc_refresh();
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
			this._mainLayer.size(newSize);
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			this.updateProperties({
				background: {
					color : settings['background']
				}
			});
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		}
	});

	BackgroundComponent.getDefaultOption = function() {
		return defaultOptions;
	};
	return BackgroundComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PieComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.title.TitleCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.background.BackgroundComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.legend.LegendCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.descriptor.Descriptor',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.layout.BasicLayout',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PiePlotComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(ObjUtils,TypeUtils, LOG, UIComponent, TitleCanvasComponent, BackgroundComponent, LegendCanvasComponent, PropsMgr,
		Descriptor, BasicLayout, PiePlotComponent,ThemeManager) {
	var PieComponent = ObjUtils.derive(UIComponent,
	/**
	 * @lends sap.riv.vizkit.UIComponent
	 */
	{
		constructor : function(options) {
			this._dataTree = options.dataset.dataTree;
			this._metaData = options.dataset.metaData;
			this._pie_options = {
				selectionMode : 'single',
				allSelectable : true,
				allDeSelectable : true,
				selectedDataIndexes : [],
            			//possible value pie|donut
				pieType : 'pie',
				//possible value pie/multipie, internal property
            			type: 'pie',
				measures : [],// pass in array to override this
				
				measureDefault : {
					sectorColors : ["#113975","#e06f00","#5a92e2","#624628",
					                "#e03c2f","#ffbe7f","#96a8c3","#a9a9a9",
					                "#830b00","#344b6d","#e2ce44","#ff6657"
					               ],
					
				},
				
				tooltip : {
					text : {
						font :  undefined,
	            		color : '#000000',
	            		formatString:[''] // re-use last one
					},
				
					mainValue : {
	            		font :  undefined,
	                	color : '#000000',
	                	formatString:[''] // re-use last one
					},
					
					subValue : {
	            		font :  undefined,
	                	color : '#000000',
	                	formatString:['0.00%'] // re-use last one
					}
				},
				layout : {
					padding : [0, 0, 0, 0],
					legendFirst : true
				},
				theme : '',
				isShowPieInnerShadow : false,
				isShowPieOuterShadow : false
			};
			this._pie_options.title = ObjUtils.extend(true, {}, TitleCanvasComponent.getDefaultOption());
			this._pie_options.background = ObjUtils.extend(true, {}, BackgroundComponent.getDefaultOption());
			this._pie_options.legend = ObjUtils.extend(true, {}, LegendCanvasComponent.getDefaultOption());
			
			// default value
			var descriptor;
			if (options.pieOptions.type === 'pie') {
			    descriptor = Descriptor.getPieDescriptor();
			} else if (options.pieOptions.type === 'multipie') {
			    descriptor = Descriptor.getMultiPieDescriptor();
			}
			this._propsMgr = new PropsMgr(descriptor);
			var validatedOptions = this._propsMgr.properties(options.pieOptions);
			this._pie_options = ObjUtils.extend(true, this._pie_options, validatedOptions);
			
			//[Christy/20120423] Check theme propeties.
      		if(TypeUtils.isExist(options.pieOptions.theme) && options.pieOptions.theme !== ''){
      			this._resolveThemeAndProperties(options.pieOptions);
      		}
      		this._pie_options = ObjUtils.extend(true, this._pie_options, options.pieOptions);
      		this._propsMgr.properties(this._pie_options);
      		 
			this._attach_additional_properties();

			this._legendComponent = null;
			this._pieComponent = null;
			this._titleComponent = null;
			this._pie_layout = null;
			this._mode = null;
			this._colorList = null;
			this._initSubComponents(false);
		},

        _resolveThemeAndProperties : function(options){
        	var theme = options.theme;
        	var settings = ThemeManager.getThemeSettings(theme);
        	var globalStyle = settings.global;
        	
        	//Background 
        	options.background = options.background || {};
        	options.background.color = options.background.color || settings.background;
        	
        	//Legend Style
        	var legendStyle = settings.legend;
        	var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
        	var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
        	options.legend = options.legend || {};
        	options.legend.titleFont = options.legend.titleFont || (legendTitleStyle['font-weight'] + " " + legendTitleStyle['font-size'] + " " + legendTitleStyle['font-family']);
        	options.legend.titleColor = options.legend.titleColor || (legendTitleStyle['color']);
        	options.legend.labelFont = options.legend.labelFont || (legendLabelStyle['font-weight'] + " " + legendLabelStyle['font-size'] + " " + legendLabelStyle['font-family']);
        	options.legend.labelColor = options.legend.labelColor || (legendLabelStyle['color']);
        	
            //Title Style
        	var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
        	var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
        	options.title = options.title || {};
        	options.title.main = options.title.main || {};
        	options.title.main.font = options.title.main.font || (mainTitleStyle["font-weight"] + ' ' + mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
        	options.title.main.color = options.title.main.color || (mainTitleStyle["color"]);
        	
        	options.title.sub = options.title.sub || {};
        	options.title.sub.font = options.title.sub.font || (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"] + ' ' + subTitleStyle["font-family"]);
        	options.title.sub.color = options.title.sub.color || (subTitleStyle["color"]);
        	
			//Pie Sector
			var pieStyle = settings.pie;
			options.isShowPieInnerShadow = options.isShowPieInnerShadow || pieStyle.isShowInnerShadow;
			options.isShowPieOuterShadow = options.isShowPieOuterShadow || pieStyle.isShowOuterShadow
			
			//TODO Merge Tooltip properties and theme
			var donutStyle = pieStyle.donut;
			var measureStyle = ObjUtils.extend(true, {}, globalStyle, donutStyle.measureLabel);
			
			var tooltipStyle = pieStyle.tooltip;
			options.tooltip = options.tooltip || {};
			var dimensionStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.dimensionLabel);
			options.tooltip.text = options.tooltip.text || {};
			options.tooltip.text.font = options.tooltip.text.font || dimensionStyle['font-weight'] + " " + dimensionStyle['font-size'] + " " + dimensionStyle['font-family'];
    		options.tooltip.text.color = options.tooltip.text.color || dimensionStyle['color'];
			
			var valueStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.valueLabel);
			options.tooltip.mainValue = options.tooltip.mainValue || {};
			options.tooltip.mainValue.font = options.tooltip.mainValue.font || valueStyle['font-weight'] + " " + valueStyle['font-size'] + " " + valueStyle['font-family'];
			options.tooltip.mainValue.color = options.tooltip.mainValue.color || valueStyle['color'];
			
			var percentStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.percentLabel);
			options.tooltip.subValue = options.tooltip.subValue || {};
			options.tooltip.subValue.font = options.tooltip.subValue.font || percentStyle['font-weight'] + " " + percentStyle['font-size'] + " " + percentStyle['font-family'];
			options.tooltip.subValue.color = options.tooltip.subValue.color || percentStyle['color'];
        },
        
        _initSubComponents : function(redraw) {
            //LOG.debug("chart[" + this.id() + "]start initialize SubComponents.", "perf");
            this.autoresizeSubComponents(false);
            var size = this.size();
            if (!redraw) {
                this._pie_layout = new BasicLayout(size, this._pie_options);
            }

				if (!redraw) {
					this._backgroundComponent = new BackgroundComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						backgroundOptions : this._pie_options.background,
						id : 'backgroundComponent'
					});
					// background component is always the first component
					this.addSubComponent(this._backgroundComponent);
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._backgroundComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");

					// here we give a default size to title(or any other sub)
					// component to ensure
					// sub component has initial size to rely on
					// sap.riv.vizkit.UIComponent.Autosizing
					// for auto layout
					this._titleComponent = new TitleCanvasComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						titleOptions : this._pie_options.title,
						id : 'pieTitleComponent'
					});
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._titleComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");

					this._legendComponent = new LegendCanvasComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						legendOptions : {
							properties : this._pie_options
						},
						id : 'pieLegendComponent'
					});
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._legendComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");

					this._pieComponent = new PiePlotComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						chart : {
							metaData : this._metaData,
							dataTree : this._dataTree,
							properties : this._pie_options
						},
						id : 'piePlotComponent'
					});
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._pieComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");
				}
		},

		/**
		 * Resize component's visual content, when the component's size changed,
		 * this method will be invoked before layout sub components
		 */
		doContentResize : function(osize, nsize) {
			this.callParent('doContentResize', osize, nsize);
        	this._pie_layout.updateSize(nsize);
			this._pie_relayout();
        },
        
        /**
         * when we pass properties to the sub components, we may 
         * want to attach some special properties(calculated properties) for sub
         * components. these properties are internal and should not be returned
         * to clients
         */
        _attach_additional_properties : function(){
        	if(this._pie_options){
        		var options = this._pie_options;
        		//reset before we attach 
        		delete options._additional;
        		var _additional = {};
        		//attach colorlist
                var colorList = [];
                var legendNumberFormat = [], tooltipeTextNumberFormat=[],tooltipeMainValueNumberFormat = [],tooltipeSubValueNumberFormat = [];
                var labels = this._getEffectiveLables();
    			if (options.measures) {
    				//for single pie, we only have one measure
    				var smeasure = options.measures[0];
    				if(smeasure && smeasure.sectorColors && smeasure.sectorColors.length > 0){
    					var scolors = smeasure.sectorColors;
						for ( var i = 0, j = 0, colorLen = scolors.length, len = labels.length; i < len; i++) {
    						j = i % colorLen;
    						colorList.push(scolors[j]);
						}
    				}
    				else {
        				var scolors = options.measureDefault.sectorColors;
        				if(scolors){
    						for ( var i = 0, j = 0, colorLen = scolors.length, len = labels.length; i < len; i++) {
    							j = i % colorLen;
    							colorList.push(scolors[j]);
    						}
    					}
        			}
    			}
    			
    		 
    			var formats = options.legend.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					legendNumberFormat.push(formats[i]);
    				}else{
    					legendNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			// Tooltip dimension lable format  
     			var formats = options.tooltip.text.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					tooltipeTextNumberFormat.push(formats[i]);
    				}else{
    					tooltipeTextNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			// Tooltip dimension value format  
    			var formats = options.tooltip.mainValue.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					tooltipeMainValueNumberFormat.push(formats[i]);
    				}else{
    					tooltipeMainValueNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			
    			// Tooltip dimension percentage format  
    			var formats = options.tooltip.subValue.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					tooltipeSubValueNumberFormat.push(formats[i]);
    				}else{
    					tooltipeSubValueNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			
    			_additional.colorList = colorList;
    			_additional.legendNumberFormat = legendNumberFormat;
    			_additional.tooltipeTextNumberFormat = tooltipeTextNumberFormat;
    			_additional.tooltipeMainValueNumberFormat = tooltipeMainValueNumberFormat;
    			_additional.tooltipeSubValueNumberFormat = tooltipeSubValueNumberFormat;
 
    			//attach legend labels
    			_additional.legendLabels = labels;
    			//attach legend title
    			_additional.legendTitle = this._metaData.dimension[this._metaData.dimension.length - 1].name;
    			
    			this._pie_options._additional = _additional;
        	}
        },        
        
        _getEffectiveLables : function(){
        	var tree = this._dataTree;
        	var dimensions = this._metaData.dimension;
        	//[jyang 3/15/2012] for pie now we support up to 2 axis, for single axis
        	//we will use it to feed pie sectors. for dual axes, we will use the first(as well as measures)
        	//as multiplier and the second as feed of pie sectors
        	//only pie sectors feed need show in the legend
        	var axisNum = this._metaData.axisNum;
        	var whichAnalysisAxis = 0;
        	if(axisNum == 2){
        		whichAnalysisAxis = 1;
        	}
        	//[jyang 3/15/2012] currently we only support one dimension on the second axis. if we 
        	//support more, here we should do cartesian product on all dimensions on the second axis for sector feed
        	var pathToLegendDimension = [];
        	for(var i = 0, len = dimensions.length; i < len; i++){
        		var dt = dimensions[i];
        		if(dt.analysisAxisIndex === whichAnalysisAxis){
        			//we only support one, so we break here
        			break;
        		}else{
        			pathToLegendDimension.push(0);
        		}
        	}
        	var categories = tree.getSubMemberLabels(pathToLegendDimension);
        	var labels = [], category, value;
        	var length = categories.length;
        	for(var i = 0; i < length; i++){
        		category = categories[i];
                labels.push({
    				category : category
        		});
        		 
        	}
        	return labels;
        },
        
        _pie_processLayoutOfComponent : function(component, layarr) {
			if (!layarr) {
			    //log component which won't be layout.
			    //LOG.debug("chart["+this.id()+"]"+"subComponent["+component.getCanvasSurface().getRootLayer().id()+"]skipped.", "perf");
				component.detachFromSuperComponent();
			} else {
			    LOG.debug("chartComponent["+this.id()+"]"+"subComponent["+component.getCanvasSurface().getRootLayer().id()+"]initialized.", "perf");
				if (!component.superComponent()) {
					// has been detached, re-attach
					this.addSubComponent(component);
				}
				component.position({
					x : layarr[0],
					y : layarr[1],
				});
				component.size({
					width : layarr[2],
					height : layarr[3],
				});
			}
		},

		_pie_relayout : function(force) {
			if (this._pie_layout.layoutChanged() || force) {
				if (this._pie_options.layout.legendFirst) {
					var legendSize = this._legendComponent.calMaxLegendSize(this._pie_options);
					this._pie_layout.setMaxLegendWidth(legendSize.width);
					this._pie_layout.setMaxLegendHeight(legendSize.height);
				}
				
				var titleSize = this._titleComponent.getPreferredSize(this._pie_layout._size, 
						this._pie_options.title);
				
				this._pie_layout.setPreferredTitleWidth(titleSize.width);
				this._pie_layout.setPreferredTitleHeight(titleSize.height);
				
				var layoutinfo = this._pie_layout.getLayoutInfo();
	        	//Ian [2012-4-10] fix the bug:ADAPT01629959, when the chart's width or height is less than 0, we should do nothing.
				//Nick [2012-4-19] move the following code from doContentResize function here.
	        	if(layoutinfo.main[2] <=0 || layoutinfo.main[3] <=0){
	        		return;
	        	}
	        	//End
				if ( layoutinfo.title ) {
					this._titleComponent.setPreferredSize({
						width : layoutinfo.title[2],
						height : layoutinfo.title[3]
					});
				}
				this._pie_processLayoutOfComponent(this._pieComponent, layoutinfo.main);
				this._pie_processLayoutOfComponent(this._titleComponent, layoutinfo.title);
				this._pie_processLayoutOfComponent(this._legendComponent, layoutinfo.legend);
				this._pie_processLayoutOfComponent(this._backgroundComponent, layoutinfo.background);
			}
		},
        
        applyTheme : function(theme) {
        	var options = this._pie_options;
        	this._setThemes(options, theme);
        	this.updateProperties(options);
//            this._backgroundComponent.applyTheme(theme);
//            this._titleComponent.applyTheme(theme);
//            this._legendComponent.applyTheme(theme);
//            this._pieComponent.applyTheme(theme);
        },
        
        _setThemes : function(options, theme){
        	var settings = ThemeManager.getThemeSettings(theme);
        	var globalStyle = settings.global;
        	
        	//Background 
        	options.background.color = settings.background;
        	
        	//Legend Style
        	var legendStyle = settings.legend;
        	var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
        	var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
        	options.legend.titleFont = (legendTitleStyle['font-weight'] + " " + legendTitleStyle['font-size'] + " " + legendTitleStyle['font-family']);
        	options.legend.titleColor = (legendTitleStyle['color']);
        	options.legend.labelFont = (legendLabelStyle['font-weight'] + " " + legendLabelStyle['font-size'] + " " + legendLabelStyle['font-family']);
        	options.legend.labelColor = (legendLabelStyle['color']);
        	
            //Title Style
        	var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
        	var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
        	options.title.main.font = (mainTitleStyle["font-weight"] + ' ' + mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
        	options.title.main.color = (mainTitleStyle["color"]);
        	
        	options.title.sub.font = (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"] + ' ' + subTitleStyle["font-family"]);
        	options.title.sub.color = (subTitleStyle["color"]);
        	
			//Pie Sector
			var pieStyle = settings.pie;
			options.isShowPieInnerShadow = pieStyle.isShowInnerShadow;
			options.isShowPieOuterShadow = pieStyle.isShowOuterShadow
			
			//TODO Merge Tooltip properties and theme
			var donutStyle = pieStyle.donut;
			var measureStyle = ObjUtils.extend(true, {}, globalStyle, donutStyle.measureLabel);
			
			var tooltipStyle = pieStyle.tooltip;
			var dimensionStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.dimensionLabel);
			options.tooltip.text.font = dimensionStyle['font-weight'] + " " + dimensionStyle['font-size'] + " " + dimensionStyle['font-family'];
    		options.tooltip.text.color = dimensionStyle['color'];
			
			var valueStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.valueLabel);
			options.tooltip.mainValue.font = valueStyle['font-weight'] + " " + valueStyle['font-size'] + " " + valueStyle['font-family'];
			options.tooltip.mainValue.color = valueStyle['color'];
			
			var percentStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.percentLabel);
			options.tooltip.subValue.font = percentStyle['font-weight'] + " " + percentStyle['font-size'] + " " + percentStyle['font-family'];
			options.tooltip.subValue.color = percentStyle['color'];
        },
        
        updateProperties : function(propBag) {
			var validatedOptions = this._propsMgr.properties(propBag);
			this._pie_options = ObjUtils.extend(true, this._pie_options, validatedOptions);
			this._attach_additional_properties();
			this._pie_layout.updateSettings(this._pie_options);

			this._pie_relayout(false);
			// sub component update properties
			this._backgroundComponent.updateProperties(this._pie_options);
			this._pieComponent.updateProperties(this._pie_options);
			this._titleComponent.updateProperties(this._pie_options);
			this._legendComponent.updateProperties(this._pie_options);
		},

		getProperties : function() {
			return this._propsMgr.properties();
		},

		setDataset : function(dataset) {
			this._dataTree = dataset.dataTree;
			this._metaData = dataset.metaData;
			this._initSubComponents(true);
			// re_attach additional properties
			this._attach_additional_properties();
			this._pie_relayout(false);
			this._pieComponent.updateOptions({
				mode : this._mode,
				metaData : this._metaData,
				dataTree : this._dataTree,
				properties : this._pie_options
			});

            this._legendComponent.updateOptions({
                title : this._metaData.dimension[0],
                labels : this._dataTree.getSubMembersAt(),
                properties : this._pie_options
            });
			if(this._pie_options.layout.legendFirst==true){
                this._pie_relayout();
			}
        },
        
        /**
         * @return events which can be listened by clients
         */
        getSupportedAppEvents : function(){
        	return this._pieComponent.getSupportedAppEvents();
        },

		doPrint : function(drawingCtx) {

		}
	});
	return PieComponent;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.UIController',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
}
],
function Setup(FuncUtils, UIComponent) {
	/**
	 * The base class of Controller in VizKit MVC framework
	 * 
	 * @name sap.riv.vizkit.UIController
	 * @constructor
	 * @param {Object}
	 *            options any arguments you want to pass in when initialize your
	 *            concrete subclass of controller
	 */
	var controller = function(options) {
		this._defaultWidth = 300;
		this._defaultHeight = 150;
		this._app;
		this._uiComp;
	};

	var cp = controller.prototype;

	/**
	 * Return the root component of the hierarchy that this controller manages
	 * 
	 * @name sap.riv.vizkit.UIController#rootUIComponent
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	cp.rootUIComponent = function() {
		if (!this._uiComp) {
			this._uiComp = this.initUIComponent(this._defaultWidth, this._defaultHeight);
			this._uiComp.on({
				eventName : 'beforeShow',
				listener : this._handleBeforeShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'beforeHide',
				listener : this._handleBeforeHide,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterShow',
				listener : this._handleAfterShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterHide',
				listener : this._handleAfterHide,
				scope : this
			});
			this.afterUIComponentLoaded();
		}
		return this._uiComp;
	};

	cp._handleBeforeHide = function(hide) {
		this.beforeUIComponentDisappear();
	};

	cp._handleBeforeShow = function(hide) {
		this.beforeUIComponentAppear();
	};

	cp._handleAfterHide = function(hide) {
		this.afterUIComponentDisappear();
	};

	cp._handleAfterShow = function(hide) {
		this.afterUIComponentAppear();
	};

	cp._setApplication_ = function(application) {
		this._app = application;
	};

	/**
	 * Get the application instance
	 * 
	 * @name sap.riv.vizkit.UIController#getApplication
	 * @function
	 * @returns {sap.riv.vizkit.VizApplication}
	 */
	cp.getApplication = function() {
		return this._app;
	};
	/**
	 * Fire the event supported by application which is declared in
	 * {@link sap.riv.vizkit.VizAppDelegate#getSupportedEvents}
	 * 
	 * @name sap.riv.vizkit.UIController#fireAppEvent
	 * @function
	 */
	cp.fireAppEvent = function(event, arguments) {
		this._app._fireEvent(event, arguments);
	};

	/**
	 * Subclass should override this method to initialize its own UIComponent
	 * hierarchy and return the root UIComponent. The default implementation
	 * creates an empty UIComponent
	 * 
	 * @name sap.riv.vizkit.UIController#initUIComponent
	 * @function
	 * @param {Number}
	 *            initWidth the initial width of the root component
	 * @param {Number}
	 *            initHeight the initial height of the root component
	 * 
	 */
	cp.initUIComponent = function(initWidth, initHeight) {
		return new UIComponent({
			size : {
				w : initWidth,
				h : initHeight
			}
		});
	};

	/**
	 * This method will be called after the root UIComponent initialized
	 * 
	 * @name sap.riv.vizkit.UIController#afterUIComponentLoaded
	 * @function
	 */
	cp.afterUIComponentLoaded = FuncUtils.noop;

	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#beforeUIComponentAppear
	 * @function
	 */
	cp.beforeUIComponentAppear = FuncUtils.noop;

	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#afterUIComponentAppear
	 * @function
	 */
	cp.afterUIComponentAppear = FuncUtils.noop;
	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#beforeUIComponentDisappear
	 * @function
	 */
	cp.beforeUIComponentDisappear = FuncUtils.noop;
	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#afterUIComponentDisappear
	 * @function
	 */
	cp.afterUIComponentDisappear = FuncUtils.noop;

	/**
	 * This method will be called when user apply a new theme, and if and only
	 * if the controller is the root controller.
	 * 
	 * @name sap.riv.vizkit.UIController#doThemeApplied
	 * @function
	 * @param {String}
	 *            old the name of the old theme
	 * @param {String}
	 *            new the name of the new theme
	 */
	cp.doThemeApplied = FuncUtils.noop;

	/**
	 * This method will be called when user update the theme setting and if and
	 * only if the controller is the root controller.
	 * 
	 * @name sap.riv.vizkit.UIController#doThemeUpdated
	 * @function
	 * @param {String}
	 *            key the key of the updated property
	 * @param {Object}
	 *            oldValue the old value
	 * @param {Object}
	 *            newValue the new value
	 */
	cp.doThemeUpdated = FuncUtils.noop;
	return controller;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.gridLine.GridLine',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
}
],
function Setup(TypeUtils, PropsMgr, ThemeManager, Math, Line) {
	var defaultOptions = {
		showMajor : false,
		majorColor : '#c9c9c9',
		majorThickness : '1',

		showMinor : false,
		minorColor : '#c9c9c9',
		minorThickness : '1',

		showSub : false,
		subColor : '#c9c9c9',
	};

	/**
	 * 
	 */
	var gridLine = function() {

		this._xAxis = null;
		this._yAxis = null;
		this._xAxisLayer = null;
		this._yAxisLayer = null;
		this._seriesMaskLayer = null;

		this._majorGridLineShape = [];
		this._minorGridLineShape = [];
		this._subGridLineShape = [];

	};

	gridLine.prototype.setXAxis = function(xAxis) {
		this._xAxis = xAxis;
	};

	gridLine.prototype.setXAxisLayer = function(xAxisLayer) {
		this._xAxisLayer = xAxisLayer;
	};

	gridLine.prototype.setYAxis = function(yAxis) {
		this._yAxis = yAxis;
	};

	gridLine.prototype.setYAxisLayer = function(yAxisLayer) {
		this._yAxisLayer = yAxisLayer;
	};

	gridLine.prototype.setYAxisOptions = function(yAxisOptions) {
		this._yAxis_options = yAxisOptions;
	};

	gridLine.prototype.setXAxisOptions = function(xAxisOptions) {
		this._xAxis_options = xAxisOptions;
	};

	gridLine.prototype.setSeriesMaskLayer = function(seriesMaskLayer) {
		this._seriesMaskLayer = seriesMaskLayer;
	};

	gridLine.prototype.setSeriesLayer = function(seriesLayer) {
		this._seriesLayer = seriesLayer;
	};

	gridLine.prototype.getXAxis = function() {
		if (TypeUtils.isExist(this._xAxis)) {
			return this._xAxis;
		}
		return null;
	};

	gridLine.prototype.getYAxis = function() {
		if (TypeUtils.isExist(this._yAxis)) {
			return this._yAxis;
		}
		return null;
	};

	/**
	 * Draw grid line
	 */
	gridLine.prototype.drawGridLine = function() {
		// add major grid line place holder if it is not exist
		if (!TypeUtils.isExist(this._majorGridLineShape[0])) {
			this._majorGridLineShape[0] = this._seriesLayer
					.addShape(new Line());
		}
		;
		this._drawMajorGridLine();

		// add minor grid line place holder if it is not exist
		if (!TypeUtils.isExist(this._minorGridLineShape[0])) {
			this._minorGridLineShape[0] = this._seriesLayer
					.addShape(new Line());
		}
		;
		this._drawMinorGridLine();

		// add sub grid line place holder if it is not exist
		if (!TypeUtils.isExist(this._subGridLineShape[0])) {
			this._subGridLineShape[0] = this._seriesLayer.addShape(new Line());
		}
		this._drawSubGridLine();
	};

	/**
	 * Draw major grid line
	 */
	gridLine.prototype._drawMajorGridLine = function() {
		this.resetMajorGridLineShape();

		if (this._xAxis_options.showMajor) {
			var xAxis = this._xAxis;
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var layer = this._seriesLayer;
			// there is a little offset between seriesMaskLayer and axislayer.
			// it is necessary to get the offset
			// and correct it when the grid line is drawn.
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 1, len = xAxisMajorTicks.length; i < len; i++) {
				// When the properties are updated, the bar shapes are not
				// removed from the layer, but the grid line shapes are removed.
				// On the other hand, the grid line shapes must be on the top of
				// bar shapes. So, this._majorGridLineShape[0] is used as
				// a placeholder to make sure all the grid line shapes are on
				// the top of bar shapes.
				this._majorGridLineShape[i] = layer.insertShapeAfter(
						new Line(), this._majorGridLineShape[0]);
				this._majorGridLineShape[i].visible(true).color(
						this._xAxis_options.majorColor).width(
						this._xAxis_options.majorThickness).from({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xaxis
		if (this._yAxis_options.showMajor) {
			var yAxis = this._yAxis;
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var layer = this._seriesLayer;
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 0, len = yAxisMajorTicks.length; i < len; i++) {
				this._majorGridLineShape[i+1] = layer.insertShapeAfter(
						new Line(), this._majorGridLineShape[0]);
				this._majorGridLineShape[i+1].visible(true).color(
						this._yAxis_options.majorColor).width(
						this._yAxis_options.majorThickness).from({
					x : 0,
					y : yAxisMajorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMajorTicks[i] + layerOffSet
				});
			}
		}
	};

	/**
	 * Draw minor grid line.
	 */
	gridLine.prototype._drawMinorGridLine = function() {
		this.resetMinorGridLineShape();

		// The minor grid line is only shown when both of showMajor and
		// showMinor are true
		if (this._xAxis_options.showMajor && this._xAxis_options.showMinor) {
			var xAxis = this._xAxis;
			var xAxisMinorTicks = xAxis.getMinorTicks();
			var layer = this._seriesLayer;
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 0, len = xAxisMinorTicks.length; i < len; i++) {
				// When the properties are updated, the bar shapes are not
				// removed from the layer, but the grid line shapes are removed.
				// On the other hand, the grid line shapes must be on the top of
				// bar shapes. So, this._minorGridLineShape[0] is used as
				// a placeholder to make sure all the grid line shapes are on
				// the top of bar shapes.
				this._minorGridLineShape[i + 1] = layer.insertShapeAfter(
						new Line(), this._minorGridLineShape[0]);
				this._minorGridLineShape[i + 1].visible(true).color(
						this._xAxis_options.minorColor).width(
						this._xAxis_options.minorThickness).from({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xAxis
		if (this._yAxis_options.showMajor && this._yAxis_options.showMinor) {
			var yAxis = this._yAxis;
			var yAxisMinorTicks = yAxis.getMinorTicks();
			var layer = this._seriesLayer;
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 0, len = yAxisMinorTicks.length; i < len; i++) {
				this._minorGridLineShape[i + 1] = layer.insertShapeAfter(
						new Line(), this._minorGridLineShape[0]);
				this._minorGridLineShape[i + 1].visible(true).color(
						this._yAxis_options.minorColor).width(
						this._yAxis_options.majorThickness).from({
					x : 0,
					y : yAxisMinorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMinorTicks[i] + layerOffSet
				});
			}
		}

	};

	/**
	 * Draw sub grid line -- always be hidden for now
	 */
	gridLine.prototype._drawSubGridLine = function() {
		this.resetSubGridLineShape();

		// When both of showMajor and showSub are true, the showSub will be
		// ignored.
		if (!this._xAxis_options.showMajor && this._xAxis_options.showSub) {
			var xAxisMajorTicks = this._xAxis.getMajorTicks();
			var halfTickInterval = this._xAxis.getTickInterval() / 2;

			for ( var i = 1; i < xAxisMajorTicks.length; i++) {
				// When the properties are updated, the bar shapes are not
				// removed from the layer, but the grid line shapes are removed.
				// On the other hand, the grid line shapes must be on the top of
				// bar shapes. So, this._subGridLineShape[0] is used as
				// a placeholder to make sure all the grid line shapes are on
				// the top of bar shapes.
				this._subGridLineShape[i] = this._seriesLayer.insertShapeAfter(
						new Line(), this._subGridLineShape[0]);
				this._subGridLineShape[i].width('1').color(
						this._xAxis_options.subColor).from({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getLastTickOffset()
				});
			}
		}

		// the same as xAxis
		if (!this._yAxis_options.showMajor && this._yAxis_options.showSub) {
			var yAxisMajorTicks = this._yAxis.getMajorTicks();
			var halfTickInterval = this._yAxis.getTickInterval() / 2;

			for ( var i = 0; i < yAxisMajorTicks.length; i++) {
				this._subGridLineShape[i + 1] = this._seriesLayer
						.insertShapeAfter(new Line(), this._subGridLineShape[0]);
				this._subGridLineShape[i + 1].width('1').color(
						this._yAxis_options.subColor).from({
					x : 0,
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				});
			}
		}
	};

	/**
	 * Update properties and will re-draw all grid line
	 * 
	 * @param propsBag
	 */
	gridLine.prototype.parseProperties = function(propsBag) {
		this._propsMgr = new PropsMgr(defaultOptions);
		this._xAxis_options = this._propsMgr
				.properties(propsBag.properties.xAxis[0].gridLine);
		this._yAxis_options = this._propsMgr
				.properties(propsBag.properties.yAxis[0].gridLine);

	};

	/**
	 * Apply the theme properties to grid line properties, which includes color,
	 * thickness for both of axis.
	 * 
	 * @param theme
	 */
	gridLine.prototype.applyTheme = function(theme) {
		var settings = ThemeManager.getThemeSettings(theme);

		this._xAxis_options.majorColor = settings.axis.xAxisMajorGridLine.color;
		this._xAxis_options.majorThickness = settings.axis.xAxisMajorGridLine.thickness;
		this._xAxis_options.minorColor = settings.axis.xAxisMinorGridLine.color;
		this._xAxis_options.minorThickness = settings.axis.xAxisMinorGridLine.thickness;
		this._xAxis_options.subColor = settings.axis.xAxisSubGridLine.color;

		this._yAxis_options.majorColor = settings.axis.yAxisMajorGridLine.color;
		this._yAxis_options.majorThickness = settings.axis.yAxisMajorGridLine.thickness;
		this._yAxis_options.minorColor = settings.axis.yAxisMinorGridLine.color;
		this._yAxis_options.minorThickness = settings.axis.yAxisMinorGridLine.thickness;
		this._yAxis_options.subColor = settings.axis.yAxisSubGridLine.color;

		if (this._xAxis_options.showMajor) {
			for ( var i = 1, len = this._majorGridLineShape.length; i < len; i++) {
				this._majorGridLineShape[i].color(
						this._xAxis_options.majorColor).width(
						this._xAxis_options.majorThickness);
			}
			;
		}

		if (this._yAxis_options.showMajor) {
			for ( var i = 1, len = this._majorGridLineShape.length; i < len; i++) {
				this._majorGridLineShape[i].color(
						this._yAxis_options.majorColor).width(
						this._yAxis_options.majorThickness);
			}
			;
		}

		if (this._xAxis_options.showMinor) {
			for ( var i = 1, len = this._minorGridLineShape.length; i < len; i++) {
				this._minorGridLineShape[i].color(
						this._xAxis_options.minorColor).width(
						this._xAxis_options.minorThickness);
			}
			;
		}

		if (this._yAxis_options.showMinor) {
			for ( var i = 1, len = this._minorGridLineShape.length; i < len; i++) {
				this._minorGridLineShape[i].color(
						this._yAxis_options.minorColor).width(
						this._yAxis_options.minorThickness);
			}
			;
		}

		if (this._xAxis_options.showSub) {
			for ( var i = 1, len = this._subGridLineShape.length; i < len; i++) {
				this._subGridLineShape[i].color(this._xAxis_options.subColor)
						.width("1");
			}
			;
		}

		if (this._yAxis_options.showSub) {
			for ( var i = 1, len = this._subGridLineShape.length; i < len; i++) {
				this._subGridLineShape[i].color(this._yAxis_options.subColor)
						.width("1");
			}
			;
		}
	};

	/**
	 * Reset all sub grid line shapes except the first one -
	 * this._subGridLineShape[0](place holder)
	 */
	gridLine.prototype.resetSubGridLineShape = function() {
		for ( var i = 1, len = this._subGridLineShape.length; i < len; i++) {
			this._seriesLayer.removeShape(this._subGridLineShape[i]);
		}
	};

	/**
	 * Reset all major grid line shapes except the first one -
	 * this._majorGridLineShape[0](place holder)
	 */
	gridLine.prototype.resetMajorGridLineShape = function() {
		for ( var i = 1; i < this._majorGridLineShape.length; i++) {
			this._seriesLayer.removeShape(this._majorGridLineShape[i]);
		}
	};

	/**
	 * Reset all minor grid line shapes except the first one -
	 * this._minorGridLineShape[0](place holder)
	 */
	gridLine.prototype.resetMinorGridLineShape = function() {
		for ( var i = 1; i < this._minorGridLineShape.length; i++) {
			this._seriesLayer.removeShape(this._minorGridLineShape[i]);
		}
	};

	gridLine.prototype.gestureUpdate = function() {

		if (this._xAxis_options.showMajor) {
			var xAxis = this._xAxis;
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 1, len = xAxisMajorTicks.length; i < len; i++) {
				this._majorGridLineShape[i].from({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xaxis
		if (this._yAxis_options.showMajor) {
			var yAxis = this._yAxis;
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 1, len = yAxisMajorTicks.length; i < len; i++) {
				this._majorGridLineShape[i].from({
					x : 0,
					y : yAxisMajorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMajorTicks[i] + layerOffSet
				});
			}
		}

		if (this._xAxis_options.showMajor && this._xAxis_options.showMinor) {
			var xAxis = this._xAxis;
			var xAxisMinorTicks = xAxis.getMinorTicks();
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 0, len = xAxisMinorTicks.length; i < len; i++) {
				this._minorGridLineShape[i + 1].from({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xAxis
		if (this._yAxis_options.showMajor && this._yAxis_options.showMinor) {
			var yAxis = this._yAxis;
			var yAxisMinorTicks = yAxis.getMinorTicks();

			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 0, len = yAxisMinorTicks.length; i < len; i++) {
				this._minorGridLineShape[i + 1].from({
					x : 0,
					y : yAxisMinorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMinorTicks[i] + layerOffSet
				});
			}
		}

		// When both of showMajor and showSub are true, the showSub will be
		// ignored.
		if (!this._xAxis_options.showMajor && this._xAxis_options.showSub) {
			var xAxisMajorTicks = this._xAxis.getMajorTicks();
			var halfTickInterval = this._xAxis.getTickInterval() / 2;

			for ( var i = 1; i < xAxisMajorTicks.length; i++) {
				this._subGridLineShape[i].from({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getLastTickOffset()
				});
			}
		}

		// the same as xAxis
		if (!this._yAxis_options.showMajor && this._yAxis_options.showSub) {
			var yAxisMajorTicks = this._yAxis.getMajorTicks();
			var halfTickInterval = this._yAxis.getTickInterval() / 2;

			for ( var i = 0; i < yAxisMajorTicks.length; i++) {
				this._subGridLineShape[i + 1].from({
					x : 0,
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				});
			}
		}
	};
	return gridLine;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Event class
	 * 
	 * @name sap.riv.vizkit.Event
	 * @constructor
	 */
	var Event = function(type, target, canBubbling) {
		this._type = type;
		this._target = this._currentTarget = target;
		this._canBubbling = canBubbling !== undefined ? canBubbling : true;
		this._timestamp = +new Date;
	};

	var Ep = Event.prototype;

	Ep._setCurrentTarget_ = function(currentTarget) {
		this._currentTarget = currentTarget;
	};

	/**
	 * Get the type of the event
	 * 
	 * @name sap.riv.vizkit.Event#type
	 * @function
	 * @returns {String}
	 */
	Ep.type = function() {
		return this._type;
	};

	/**
	 * Get the timestamp of the event
	 * 
	 * @name sap.riv.vizkit.Event#timestamp
	 * @function
	 * @returns {Integer}
	 */
	Ep.timestamp = function() {
		return this._timestamp;
	};

	/**
	 * Get the target component the event is originated from
	 * 
	 * @name sap.riv.vizkit.Event#target
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	Ep.target = function() {
		return this._target;
	};

	/**
	 * Get the current target component the event is currently going through it
	 * can be different with the target component
	 * 
	 * @name sap.riv.vizkit.Event#currentTarget
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	Ep.currentTarget = function() {
		return this._currentTarget;
	};

	/**
	 * Whether the event is in the bubbling phase
	 * 
	 * @name sap.riv.vizkit.Event#isInBubbling
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.isInBubbling = function() {
		return this._target.id() != this._currentTarget.id();
	};
	/**
	 * Whether the event should be bubbled
	 * 
	 * @name sap.riv.vizkit.Event#shouldBubble
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.shouldBubble = function() {
		return this._canBubbling;
	};
	/**
	 * Stop the event propagation in the bubbling phase
	 * 
	 * @name sap.riv.vizkit.Event#stopPropagation
	 * @function
	 * 
	 */
	Ep.stopPropagation = function() {
		this._canBubbling = false;
	};
	return Event;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * The mask used to specify gesture detector's state
	 * 
	 * @name sap.riv.vizkit.GestureDetector.TransitionState
	 * @class
	 */
	var ts = {
		/**
		 * Possible State. Gesture Detector is ready to detect gesture
		 * 
		 * @field
		 * 
		 */
		Possible : 0,
		/**
		 * Began State. Gesture Detector is ready to detect continuous gesture
		 * 
		 * @field
		 * 
		 */
		Began : 1,
		/**
		 * Began State. Gesture Detector is continuous to detect continuous
		 * gesture
		 * 
		 * @field
		 * 
		 */
		Changed : 2,
		/**
		 * Recognized State. Discrete Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Recognized : 3,// Recognized == Ended
		/**
		 * Ended State. Continuous Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Ended : 3,
		/**
		 * Ended State. Continuous Gesture is stop to detected
		 * 
		 * @field
		 * 
		 */
		Cancelled : 4,
		/**
		 * Ended State. Detector fails to detect in current touch sequence
		 * 
		 * @field
		 * 
		 */
		Failed : 5
	};

	/**
	 * The base abstract gesture detector class
	 * 
	 * @name sap.riv.vizkit.GestureDetector
	 * @constructor
	 */
	var GestureDetector = function() {
		this._grOwnerComp;
		this._grEnabled = true;
		this._grTouchTotal = 0;
		this._grTouchTracker = {};
		this._grState = ts.Possible;
		this._grActions = [];
		this._grCancelTouches = true;
	};
	var grp = GestureDetector.prototype;

	grp._setOwnerComp_ = function(ownerComp) {
		this._grOwnerComp = ownerComp;
	};
	/**
	 * Get the attached UI component
	 * 
	 * @name sap.riv.vizkit.GestureDetector#attachedComponent
	 * @function
	 * @returns {sap,riv.vizkit.UIComponent}
	 */
	grp.attachedComponent = function() {
		return this._grOwnerComp;
	};

	/**
	 * Add a gesture action function which will get triggered when gesture
	 * detected.
	 * 
	 * @name sap.riv.vizkit.GestureDetector#addGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, function to be called when gesture detected.
	 * @returns {Boolean}
	 */
	grp.addGestureAction = function(actionFn) {
		var added = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				added = true;
				break;
			}
		}
		if (!added) {
			this._grActions.push(actionFn);
		}
		return !added;
	};

	/**
	 * Remove a previously added gesture action
	 * 
	 * @name sap.riv.vizkit.GestureDetector#removeGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, the function to be removed.
	 * @returns {Boolean}
	 */
	grp.removeGestureAction = function(actionFn) {
		var found = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				found = true;
				this._grActions.splice(i, 1);
				break;
			}
		}
		return found;
	};

	/**
	 * Return the current global location of the gesture, the location is
	 * calculated as the center of the current touches. Caution: This function
	 * only return meaningful point value IF and ONLY IF the current state of
	 * this gesture detector is in Recognizing state, a.k.a Began, Cancelled,
	 * Ended, Recognized, otherwise undefined will return.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfGesture = function() {
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var count = 0;
			var ttracker = this._grTouchTracker, xy;
			var x = y = 0;
			for ( var tId in ttracker) {
				xy = ttracker[tId].globalXY;
				x += xy.x;
				y += xy.y;
				count++;
			}
			if (count) {
				return {
					x : x / count,
					y : y / count
				};
			}
		} else {
			return;
		}
	};

	/**
	 * Return a list of identifier of touches currently involved in the gesture
	 * detection, Caution: This function only return meaningful array of touches
	 * IF and ONLY IF the current state of this gesture detector is in
	 * Recognizing state, a.k.a Began, Cancelled, Ended, Recognized, otherwise
	 * empty array will return.
	 * 
	 * @function
	 * @returns {Array}
	 */
	grp.involvedTouchePoints = function() {
		var ret = [];
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var ttracker = this._grTouchTracker;
			for ( var tId in ttracker) {
				ret.push(tId);
			}
		}
		return ret;
	};

	/**
	 * Return the current global location of all the current touches, the
	 * location is calculated as the center of the touches currently contacting
	 * with the screen.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfTouchPoints = function() {
		var count = 0;
		var ttracker = this._grTouchTracker, xy;
		var x = y = 0;
		for ( var tId in ttracker) {
			xy = ttracker[tId].globalXY;
			x += xy.x;
			y += xy.y;
			count++;
		}
		if (count) {
			return {
				x : x / count,
				y : y / count
			};
		}
	};

	/**
	 * Return the number of touches currently contacting with the screen
	 * 
	 * @function
	 * @returns {Number}
	 */
	grp.totalTouches = function() {
		return this._grTouchTotal;
	};

	/**
	 * Get or set whether canceling previous touches when a gesture detected.
	 * Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.cancelTouches = function(cancel) {
		if (cancel !== undefined) {
			this._grCancelTouches = cancel;
			return this;
		} else {
			return this._grCancelTouches;
		}
	};
	/**
	 * Get or set the enable status of the gesture detector. If the gesture
	 * detector is in detecting some continuous gesture it will immediately
	 * transit to cancelled state. Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.enable = function(enable) {
		if (enable !== undefined) {
			this._grEnabled = enable;
			if (!enable) {
				if (this._grState === ts.Began || this._grState === ts.Cancelled) {
					this.state(ts.Cancelled);
				} else {
					this.state(ts.Failed);
				}
			}
		} else {
			return this._grEnabled;
		}
	};

	grp.touchBegin = function(touchStartEvent) {
		if (this._grEnabled) {
			var newTouches = touchStartEvent.changedTouches;
			var ttracker = this._grTouchTracker;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			for ( var i = 0, t, len = newTouches.length; i < len; i++) {
				t = newTouches.item(i);
				ttracker[t.identifier] = {
					globalXY : ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					}),
					stopped : false
				};
				this._grTouchTotal++;
			}
			this.doTouchBegin(touchStartEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#touchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.touchMove = function(touchMoveEvent) {
		if (this._grEnabled) {
			var movedTouches = touchMoveEvent.changedTouches;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			var ttracker = this._grTouchTracker;
			for ( var i = 0, t, len = movedTouches.length; i < len; i++) {
				t = movedTouches.item(i);
				if (ttracker[t.identifier]) {
					ttracker[t.identifier].globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
				}
			}
			this.doTouchMove(touchMoveEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#touchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.touchEnd = function(touchEndEvent) {
		if (this._grEnabled) {
			var endedTouches = touchEndEvent.changedTouches;
			var ttracker = this._grTouchTracker;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			for ( var i = 0, t,tId, track, len = endedTouches.length; i < len; i++) {
				t = endedTouches.item(i);
				tId = t.identifier;
				track = ttracker[tId];
				if (track) {
					track.globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
					track.stopped = true;
					this._grTouchTotal--;
				}
			}
			this.doTouchEnd(touchEndEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#touchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.touchCancel = function(touchCancelEvent) {
		if (this._grEnabled) {
			var cancelledTouches = touchCancelEvent.changedTouches;
			var ttracker = this._grTouchTracker;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			for ( var i = 0, t,tId, track, len = cancelledTouches.length; i < len; i++) {
				t = cancelledTouches.item(i);
				tId = t.identifier;
				track = ttracker[tId];
				if (track) {
					track.globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
					track.stopped = true;
					this._grTouchTotal--;
				}
			}
			this.doTouchCancel(touchCancelEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in start phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchBegin
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchStartEvent
	 */
	grp.doTouchBegin = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.doTouchMove = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.doTouchEnd = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.doTouchCancel = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to reset the internal state, before
	 * start to do next around recognition.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#reset
	 * @function
	 */
	grp.reset = function() {
		this._grState = ts.Possible;
		this._grTouchTotal = 0;
		this._grTouchTracker = {};
	};
	/**
	 * Gesture Detector uses this method to set or get the current state.
	 * Subclass should set correct state at correct time, usually in overriding
	 * touchBegin/touchMove/touchEnd/touchCancel method.
	 * <P>
	 * <b>This method is not meant to be overridden</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#state
	 * @function
	 * @param {sap.riv.vizkit.GestureDetector.TransitionState}
	 *            transState
	 */
	grp.state = function(transState) {
		return this._grState;
	};

	grp._setState_ = function(transState) {
		switch (transState) {
		case ts.Possible:
			break;
		case ts.Began:
			this._grState = ts.Began;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Changed:
			if (this._grState === ts.Began) {
				this._grState = ts.Changed;
			}
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Cancelled:
			this._grState = ts.Cancelled;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			this.reset();
			break;
		case ts.Failed:
			this._grState = ts.Failed;
			this.reset();
			break;
		case ts.Ended:
		case ts.Recognized:
			this._grState = transState;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			this.reset();
			break;
		}
	};

	GestureDetector.TransitionState = ts;
	return GestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.TapGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};

	var _startNewTapSequence = function(tapDetector, event) {
		tapDetector._sequenceStarted = true;
		tapDetector._currentNumberOfTaps = 0;
		tapDetector._firstStartXY = tapDetector.globalLocOfTouchPoints();
	};

	// Defines the maximum distance from current tap to where
	// the first tap
	// starts
	var _maxDistance = 50;
	// Defines the maximum and minimum time for each tap
	var _maxTapTime = 150;
	var _minTapTime = 20;
	// Defines the maximum time gap
	// between the time the previous tap ends and the time the
	// next one starts
	var _maxTapGap = 150;

	/**
	 * This class defines detector for detecting Tapping gesture. Tapping
	 * gesture is detected when required number of fingers tap the screen for
	 * required number of times.
	 * 
	 * @name sap.riv.vizkit.TapGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */

	var TapGestureDetector = ObjUtils
			.derive(
					GestureDetector,
					{
						constructor : function(touchesRequired, tapsRequired) {
							this._touchesRequired = (typeof touchesRequired === 'number' && touchesRequired > 0 && touchesRequired < 6) ? touchesRequired
									: 1;
							this._tapsRequired = (typeof tapsRequired === 'number' && tapsRequired > 0) ? tapsRequired
									: 1;

							this._currentNumberOfTaps = 0;
							this._firstStartXY = undefined;
							this._sequenceStarted = false;
							this._currentStartWhen = 0;
						},

						doTouchBegin : function(touchStartEvent) {
							if (this.state() === ts.Possible) {
								var currentNumOfTouches = this.totalTouches();

								if (currentNumOfTouches === this._touchesRequired) {
									var currentTimeStamp = touchStartEvent.timeStamp;

									// Beginning of the first
									// tap in a tap
									// sequence
									if (this._currentNumberOfTaps == 0) {
										// Record the
										// information of first
										// tap
										// for later comparison
										_startNewTapSequence(this, touchStartEvent);
									}
									// Beginning of a tap (other
									// than the first
									// one) in a tap sequence
									else {
										if (this._currentNumberOfTaps < this._tapsRequired) {
											var distance = _distance(this._firstStartXY, this.globalLocOfTouchPoints());
											var preStartWhen = this._currentStartWhen;

											// If the tap breaks
											// a tap sequence,
											// start a new
											// sequence with it
											if (distance > _maxDistance
													|| (currentTimeStamp - preStartWhen) > (_maxTapTime + _maxTapGap)) {
												_startNewTapSequence(this, touchStartEvent);
											}
										}
									}

									this._currentStartWhen = currentTimeStamp;
								} else { // Fails if touch
									// number doesn't
									// match
									this._setState_(ts.Failed);
								}
							}
						},

						doTouchEnd : function(touchEndEvent) {
							if (this.state() === ts.Possible && this._sequenceStarted) {
								// Fails if the touch ends too
								// far away from
								// where it starts
								if (_distance(this._firstStartXY, this.globalLocOfTouchPoints()) > _maxDistance) {
									this._setState_(ts.Failed);
									return;
								}
								// Fails if the tap is too short
								// or too long
								var tapTime = touchEndEvent.timeStamp - this._currentStartWhen;
								if (tapTime > _maxTapTime || tapTime < _minTapTime) {
									this._setState_(ts.Failed);
									return;
								}
								if (++this._currentNumberOfTaps === this._tapsRequired) {
									this._setState_(ts.Recognized);
								}
							}
						},

						doTouchCancel : function(touchCancelEvent) {
							if (this.state() === ts.Possible) {
								this._setState_(ts.Failed);
							}
						},

						reset : function() {
							this.callParent('reset');
							this._currentNumberOfTaps = 0;
							this._sequenceStarted = false;
							this._firstStartXY = undefined;
							this._firstStartWhen = 0;
							this._currentStartWhen = 0;
						}
					});
	return TapGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.ChartModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.gridLine.GridLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
}
],
function Setup(ObjUtils, FunctionUtils, TypeUtils, LOG, GridLine, Observable,
		Rect) {
	var chartModule = ObjUtils.derive(Observable, {
		constructor : function(options) {
			this._chart_options = ObjUtils.extend(true, {},
					options);
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;

			this._xaxes = null;
			this._yaxes = null;
			this._data = null;

			this._defaultSelectionArmed = true;

			this._scrollBar = [];
			this._seriesLayer = null;
			this.addEvents(this.getSupportedAppEvents());
			this._gridLine = new GridLine();
		},

		init : function() {
			this._buildData();
			this.initSeries();
			this.initAxes();
			this.bindSeriesWithAxes();
			this.initScrollBar();
			this.initGridLineProperties();
		},

		_buildData : function() {

			this._data = [];
			var dimensionList = this._dataTree.getSubMembersAt();
			for ( var i = 0, iLen = this._metaData.measureMembers.length; i < iLen; i++) {
				var subData = [];
				var measure = this._metaData.measureMembers[i];
				for ( var j = 0, jLen = dimensionList.length; j < jLen; j++) {
					var d = [ dimensionList[j] ];
					var value = this._dataTree.getMeasuresAt(d)[measure].sum.result;
					subData.push({
						value : (TypeUtils.isNumber(value)) ? value : 'NaN',
						dimensionItemIndex : this._dataTree
								.getMeasuresAt(d)[measure].sum.tags.dimensionItemIndex,
						measureIndex : this._dataTree
								.getMeasuresAt(d)[measure].sum.tags.measureIndex
						});
				}
				this._data.push(subData);
			}
		},

		updateProperties : function(propBag) {
			var options = {};
			options.properties = propBag;
			this._chart_options = ObjUtils.extend(true, {},
					options);
		},

		updateOptions : function(options) {
			this._chart_options = ObjUtils.extend(true, {},
					options);
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;
			this._hasDrawn = false;
		},

		/*
		 * mandatory functions, should be implemented by sub
		 * classes
		 */

		initAxes : FunctionUtils.unsupported,

		initSeries : FunctionUtils.unsupported,

		initScrollBar : FunctionUtils.noop,

		bindSeriesWithAxes : FunctionUtils.unsupported,

		drawSeries : FunctionUtils.unsupported,

		doChartLayout : FunctionUtils.unsupported,

		bindRenderer : FunctionUtils.unsupported,
		initGridLineProperties : FunctionUtils.unsupported,

		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : FunctionUtils.unsupported,

		/* optional functions */

		marqueeOverPoint : FunctionUtils.noop,

		hoverOnPoint : FunctionUtils.noop,

		clickOnPoint : FunctionUtils.noop,

		onblur : FunctionUtils.noop,

		drawViewPort : FunctionUtils.noop,

		/**
		 * only move the series layer
		 */
		position : FunctionUtils.noop,

		scale : FunctionUtils.noop,

		panMove : FunctionUtils.noop,

		pinchingResize : FunctionUtils.noop,

		backUp : FunctionUtils.noop,

		restore : FunctionUtils.noop,
		
		getPlotArea : FunctionUtils.noop,

		/**
		 * move the series layer
		 */
		position : function(xoffset, yoffset) {
			this._seriesLayer.position({
				x : xoffset,
				y : yoffset
			});
		},

		scrollBar : function() {
			var scrollBarRenderer = function() {
				this.SCROLLBARSIZE = 6;
				this._layer = null;
				this._scrollBarRenderer = null;
			};

			scrollBarRenderer.prototype.init = function(
					seriesMasklayer, seriesLayer, direction) {
				this._seriesMasklayer = seriesMasklayer;
				this._seriesLayer = seriesLayer;

				if (this._scrollBarRenderer) {
					this._seriesMasklayer
							.removeShape(this._scrollBarRenderer);
				}

				this._scrollBarRenderer = this._seriesMasklayer
						.addShape(new Rect());
				this._direction = direction;
				var size = this._seriesMasklayer.size();
				var position = this._seriesMasklayer.position();

				if (!direction || direction == 'vertical') {
					this._scrollBarRenderer.width(
							this.SCROLLBARSIZE).height(
							size.height).topLeft(
							[ size.width - this.SCROLLBARSIZE,
									0 ]).cornerRadius(6)
							.visible(true).borderWidth(1);
				} else {
					this._scrollBarRenderer.width(size.width)
							.height(this.SCROLLBARSIZE)
							.topLeft([ 0, 0 ]).cornerRadius(6)
							.visible(true).borderWidth(1);
				}
				this.hidden();
			};

			scrollBarRenderer.prototype.highLight = function() {
				this._scrollBarRenderer.visible(true).color(
						'rgba(51,51,51, 0.6)').borderColor(
						'rgba(255,255,255, 0.15)');
			};

			scrollBarRenderer.prototype.unHighLight = function() {
				this._scrollBarRenderer.visible(true).color(
						'rgba(51,51,51, 0.3)').borderColor(
						'rgba(255,255,255, 0.07)');
			};

			scrollBarRenderer.prototype.hidden = function() {
				this._scrollBarRenderer.visible(false);
			};

			scrollBarRenderer.prototype.update = function() {
				var seriesMasklayer = this._seriesMasklayer
						.size();
				var seriesSize = this._seriesLayer.size();
				var seriesPos = this._seriesLayer.position();

				if (!this._direction
						|| this._direction === 'vertical') {
					var yposition;
					var size;
					if (seriesPos.y <= 0) {
						size = seriesMasklayer.height
								* seriesMasklayer.height
								/ seriesSize.height;
						yposition = Math.abs(seriesPos.y)
								* seriesMasklayer.height
								/ seriesSize.height;
					} else {
						size = (seriesMasklayer.height - seriesPos.y)
								* seriesMasklayer.height
								/ seriesSize.height;
						yposition = -seriesPos.y
								* seriesMasklayer.height
								/ seriesSize.height;
					}
					this._scrollBarRenderer.height(size);
					this._scrollBarRenderer.topLeft([
							seriesMasklayer.width
									- this.SCROLLBARSIZE,
							yposition ]);
				} else {
					var xposition;
					var size;
					if (seriesPos.x <= 0) {
						size = seriesMasklayer.width
								* seriesMasklayer.width
								/ seriesSize.width;
						xposition = Math.abs(seriesPos.x)
								* seriesMasklayer.width
								/ seriesSize.width;
					} else {

					}
					this._scrollBarRenderer.width(size);
					this._scrollBarRenderer.topLeft([
							xposition, 0 ])
				}
			},
			
			scrollBarRenderer.prototype.remove = function(){
				if (this._scrollBarRenderer) {
					this._seriesMasklayer
							.removeShape(this._scrollBarRenderer);
				}
			}
			return new scrollBarRenderer();
		}
	});
	return chartModule;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PieController',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIController',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PieComponent',
  version : '1.0.0'
}
],
function Setup(ObjUtils,FunctionUtils, UIController, PieComponent) {
	var Controller = ObjUtils.derive(UIController, {
		constructor : function(options) {
			this._dataset = options.dataset;
			this._pieComponent = undefined;
			this._option = options.option;
		},

		/**
		 * Subclass should overide this method to initialize custom UIComponent
		 * hierarchy and return the root UIComponent. The default implementation
		 * creates an empty UIComponent
		 */
		initUIComponent : function(width, height) {
			this._pieComponent = new PieComponent({
				id : 'rootComponent',
				dataset : this._dataset,
				pieOptions : this._option,
				size : {
					w : width,
					h : height
				}
			});
			return this._pieComponent;
		},

		doThemeApplied : function(theme) {
			this._pieComponent.applyTheme(theme);
		},

		updateProperties : function(propBag) {
			this._pieComponent.updateProperties(propBag);
		},

		getProperties : function() {
			return this._pieComponent.getProperties();
		},

		/**
		 * This method will be called after the managed UIComponent initialized
		 */
		afterUIComponentLoaded : FunctionUtils.noop,

		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentAppear : FunctionUtils.noop,

		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentAppear : function() {
			var appEvent = this._pieComponent.getSupportedAppEvents();
        	for(var i= appEvent.length; i--;){
        		this._pieComponent._pieComponent._chartModule.on({
        			 eventName: appEvent[i],
                     listener: this._fireInternalAppEvent,
                     scope: this
        		});
        	}
		},
		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentDisappear : FunctionUtils.noop,
		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentDisappear : FunctionUtils.noop,
		
		setDataset : function(dataset) {
			this._dataset = dataset;
			this._pieComponent.setDataset(dataset);
		},
		
		_fireInternalAppEvent : function(evt) {
		    this.fireAppEvent(evt.name, evt);
		}
	});
	return Controller;
});sap.riv.module(
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
},
function Setup() {
    var id = 0;
    var nextId = function() {
        return (id++).toString();
    };
    
	/**
	 * @name sap.riv.viz.AbstractVisualization
	 * @constructor
	 */
	var AbstractVisualization = function(holderElement, properties, dataset) {
		this._viz = null;
		this._id = nextId();
	};

	AbstractVisualization.prototype = 
	/**
	 * @lends sap.riv.viz.AbstractVisualization.prototype
	 */
	{
	    /**
		 * Get unique id of current visualization instance
		 * @name sap.riv.viz.AbstractVisualization#id
		 * @function
		 * 
		 * @returns{id|String}
		*/
	    id : function(){
            return this._id;
        },
        
		/**
		 * Get and set the size of the visualization
		 * @name sap.riv.viz.AbstractVisualization#size
		 * @function
		 * @param {Object}
		 *            size undefined or new size of the application. {width:##,
		 *            height:##}
		 * @returns {this|Object} when set the size the return is this object,
		 *          when get the size the return will be the size
		 * 
		 */
		'size' : function(sizeObj) {
			if (sizeObj) {
				if (this._viz) {
					this._viz.size(sizeObj);
					return this;
				}
			} else {
				if (this._viz) {
					return this._viz.size();
				}
			}
		},

		/**
		 * set a dataset to the viz
		 * @name sap.riv.viz.AbstractVisualization#setDataset
		 * @function
		 * @param {Object}
		 *            dataset dataset instance used by this visualization. see
		 *            sap.riv.viz.shared.dataConverter.* for all supported
		 *            datasets
		 * @returns {this}
		 */
		'setDataset' : function(dataset) {
			if (this._viz) {
				this._viz.setDataset(dataset);
				return this;
			}
		},

		/**
		 * apply a theme to the viz
		 * @name sap.riv.viz.AbstractVisualization#applyTheme
		 * @function
		 * @param theme
		 *            theme name, see theme doc for current supported themes
		 * @returns {this}
		 */
		'applyTheme' : function(theme) {
			if (this._viz) {
				this._viz.applyTheme(theme);
				return this;
			}
		},

		/**
		 * update or get properties of the viz
		 * 
		 * @name sap.riv.viz.AbstractVisualization#properties
		 * @function
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details. empty parameter means get current properties
		 * @returns {this|Object}
		 */
		'properties' : function(properties){
			if(properties){
				if (this._viz) {
					this._viz.properties(properties);
					return this;
				}
			}else{
				if (this._viz) {
					return this._viz.properties(properties);
				}
			}		
		},
		
		//[jy 4/15/2012]to be removed
		'updateProperties' : function(properties) {
			if (this._viz) {
				this._viz.properties(properties);
				return this;
			}
			
		},

		/**
		 * register a new event listener to the viz
		 * 
		 * @name sap.riv.viz.AbstractVisualization#addListener
		 * @function
		 * @param event
		 *            event name supported by this viz
		 * @param listener
		 *            event handler
		 * @returns {this}
		 */
		'addListener' : function(event, listener) {
			if (this._viz) {
				this._viz.addListener(event, listener);
				return this;
			}
		},

		/**
		 * remove a registered event listener from the viz
		 * 
		 * @name sap.riv.viz.AbstractVisualization#removeListener
		 * @function
		 * @param event
		 *            event name supported by this viz
		 * @param listener
		 *            event handler
		 * @returns {this}
		 */
		'removeListener' : function(event, listener) {
			if (this._viz) {
				this._viz.removeListener(event, listener);
				return this;
			}
		},
		
		/**
		 * get event names supported by this viz
		 * @name sap.riv.viz.AbstractVisualization#getSupportedEvents
		 * @function
		 * @returns {Array} event names supported by this viz
		 */
		'getSupportedEvents' : function(){
			if(this._viz){
				//[jy 4/15/2012]change the api in VizApplication to getSupportedEvents?
				return this._viz.getSupportedEvent();
			}
		}
	};
	return AbstractVisualization;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.dataConverter.BaseDataset',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FuncUtils) {
	var BaseDataset = function() {
	};

	BaseDataset.prototype.exportTree = FuncUtils.noop;
	return BaseDataset;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.ImageManager',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils, LinkedHashMap, FuncUtils) {
	/**
	 * The image object
	 * 
	 * @name sap.riv.vizkit.Image
	 * @constructor
	 */
	var img = function(htmlImageElement) {
		this._imgEl = htmlImageElement;
	};

	/**
	 * Return the underlying htmlImageElement
	 * 
	 * @name sap.riv.vizkit.Image#getBitmap
	 * @function
	 * @returns {HtmlImageElement}
	 */
	img.prototype.getBitmap = function() {
		return this._imgEl;
	};

	/**
	 * Get or set the visual width of the image
	 * 
	 * @name sap.riv.vizkit.Image#width
	 * @param {undefined|Number}
	 *            width the new width of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the width
	 */
	img.prototype.width = function(width) {
		if (width !== undefined) {
			this._imgEl.width = width;
			return this;
		}
		return this._imgEl.width;
	};

	/**
	 * Get or set the visual height of the image
	 * 
	 * @name sap.riv.vizkit.Image#height
	 * @param {undefined|Number}
	 *            height the new height of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the height
	 */
	img.prototype.height = function(height) {
		if (height !== undefined) {
			this._imgEl.height = height;
			return this;
		}
		return this._imgEl.height;
	};

	/**
	 * Get the intrinsic height of the image
	 * 
	 * @name sap.riv.vizkit.Image#intrinsicHeight
	 * @returns {Number}
	 */
	img.prototype.intrinsicHeight = function() {
		return this._imgEl.naturalHeight;
	};

	/**
	 * Get the intrinsic width of the image
	 * 
	 * @name sap.riv.vizkit.Image#intrinsicWidth
	 * @returns {Number}
	 */
	img.prototype.intrinsicWidth = function() {
		return this._imgEl.naturalWidth;
	};

	/**
	 * Get the url of the image
	 * 
	 * @name sap.riv.vizkit.Image#url
	 * @returns {String} the url of the image
	 */
	img.prototype.url = function() {
		return this._imgEl.src;
	};

	var _imageCache = new LinkedHashMap();
	var _id2src = new LinkedHashMap();
	var _src2ids = {};

	/**
	 * This class defines global shared image manager used for loading external
	 * image. The loading process is asynchronously. The loaded images are
	 * indentified by src urls internally, and can shared within the all viz
	 * application. You must assign an id when loading an image. You can
	 * retrieve the loaded image by id only. the same image can be assigned
	 * multiple ids.
	 * 
	 * @name sap.riv.vizkit.ImageManager
	 * @class
	 */
	var ImageManager = {
		/**
		 * Load an image designated by URL. The loading is asynchronized, the
		 * image will be available when the onComplete is called
		 * 
		 * @param {String}
		 *            id the caller-provided Id of the image to be loaded and
		 *            retrieved later.
		 * @param {String}
		 *            url the url of the image to be loaded
		 * @param {Function}
		 *            [onComplete], the on complete callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImage : function(id, url, onComplete) {
			if (id && url) {
				onComplete = onComplete || FuncUtils.noop;
				if (_id2src.has(id)) {
					if (_imageCache.get(_id2src.get(url))) {
						onComplete(true);
					}
				}
				var imgEl = new Image();
				imgEl.onabort = imgEl.onerror = function() {
					onComplete(false, {
						id : id,
						url : url
					});
				};
				imgEl.onload = ObjUtils.proxy(function() {
					var src = imgEl.src;
					if (!_imageCache.has(src)) {
						var imgObj = new img(imgEl);
						_id2src.add(id, src);
						_src2ids[src] = {
							ids : {
								id : id
							},
							length : 1
						};
						_imageCache.add(src, imgObj);
					} else {
						_id2src.add(id, imgEl.src);
						_src2ids[src].ids[id] = id;
						_src2ids[src].length++;
					}
					onComplete(true, {
						id : id,
						url : url
					});
				}, this);
				imgEl.src = url;
			}
		},
		/**
		 * Load an array of images concurrently. The loading is asynchronized,
		 * the images will be available when the onComplete is called
		 * 
		 * @param {Object[]}
		 *            urls the array of the image url to be loaded. The urls
		 *            should follow the format:
		 * 
		 * <pre>
		 * [ {
		 * 	id : 'IMAGE_ID',
		 * 	url : 'IMAGE_URL'
		 * } ]
		 * </pre>
		 * 
		 * @param {Function}
		 *            [onComplete] the on-complete function callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImages : function(urls, onProgress, onComplete) {
			onProgress = onProgress || FuncUtils.noop;
			onComplete = onComplete || FuncUtils.noop;
			var total = urls.length;
			if (total == 0) {
				onComplete(true);
			} else {
				var count = 0;
				var _stepFunction = function(isSuccessful, imgInfo) {
					count++;
					if (count < total) {
						onProgress(count / total, isSuccessful, imgInfo);
					} else {
						onComplete(true, imgInfo);
					}
				};
				for ( var i = 0, len = urls.length; i < len; i++) {
					ImageManager.loadImage(urls[i].id, urls[i].url, _stepFunction);
				}
			}
		},

		/**
		 * Check if the image has been loaded
		 * 
		 * @param {String}
		 *            id the id of the image to be checked
		 * @returns {Boolean}
		 */
		hasImage : function(id) {
			return _id2src.has(id);
		},

		/**
		 * Get the loaded image by its id, the caller has to ensure the image is
		 * loaded
		 * 
		 * @param {String}
		 *            id the id of the image to get
		 * @returns {sap.riv.vizkit.Image}
		 */
		getImage : function(id) {
			if (_id2src.has(id)) {
				return _imageCache.get(_id2src.get(id));
			}
		},

		/**
		 * Remove the loaded image from internal cache
		 * 
		 * @param {String}
		 *            id the id of the image
		 */
		disposeImage : function(id) {
			if (_id2src.has(id)) {
				var src = _id2src.remove(id);
				delete _src2ids[src].ids[id];
				_src2ids[src].length--;
				if (_src2ids[src].length === 0) {
					delete _src2ids[src];
					_imageCache.remove(src);
				}
			}
		}
	};
	return ImageManager;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.TouchEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
}
],
function Setup(FuncUtils, ObjectUtils, Event) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * Touch class
	 * 
	 * @name sap.riv.vizkit.Touch
	 * @constructor
	 */
	var Touch = function(identifier, target, localXY, pageXY) {
		this._id = identifier;
		this._target = target;
		this._localXY = localXY;
		this._pageXY = pageXY;
	};
	var tp = Touch.prototype;
	/**
	 * Get the identifier of the touch
	 * 
	 * @name sap.riv.vizkit.Touch#identifier
	 * @function
	 * @returns {Number}
	 */
	tp.identifier = function() {
		return this._id;
	};

	/**
	 * Get the target component of the touch
	 * 
	 * @name sap.riv.vizkit.Touch#target
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	tp.target = function() {
		return this._target;
	};

	/**
	 * Get the local XY of the touch in touch's target component's coordinate
	 * system
	 * 
	 * @name sap.riv.vizkit.Touch#localXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.localXY = function() {
		return {
			x : this._localXY.x,
			y : this._localXY.y
		};
	};

	/**
	 * Get the page XY of the touch in document's coordinate system
	 * 
	 * @name sap.riv.vizkit.Touch#pageXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.pageXY = function() {
		return {
			x : this._pageXY.x,
			y : this._pageXY.y
		};
	};
	/**
	 * Touch List class
	 * 
	 * @name sap.riv.vizkit.TouchList
	 * @constructor
	 */
	var TouchList = function(tArray, tMap) {
		this.tA = tArray, this.tM = tMap;
	};

	var tlp = TouchList.prototype;
	/**
	 * Return the length of the list
	 * 
	 * @name sap.riv.vizkit.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.riv.vizkit.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.riv.vizkit.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.riv.vizkit.TouchEvent
	 * @class
	 * @augments sap.riv.vizkit.Event
	 */
	var TouchEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.riv.vizkit.TouchEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, touches, targetTouches, changedTouches) {
			this._relatedTarget = undefined;
			this._touches = touches;
			this._targetTouches = targetTouches;
			this._changedTouches = changedTouches;
		},

		/**
		 * Get the all touches on the screen.
		 * 
		 * @name sap.riv.vizkit.TouchEvent#touches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		touches : function() {
			return this._touches;
		},
		/**
		 * Get the touches initiated from the same target
		 * 
		 * @name sap.riv.vizkit.TouchEvent#targetTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		targetTouches : function() {
			return this._targetTouches;
		},
		/**
		 * Get the touches lead to the event
		 * 
		 * @name sap.riv.vizkit.TouchEvent#changedTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		changedTouches : function() {
			return this._changedTouches;
		}
	});
	var _buildTouchListFromTouchList = function(touchlist) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchlist.length; i < len; i++) {
			targetComp = _findTargetComp(touchlist.item(i));
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchlist.item(i), targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _buildTouchListFromTouchArray = function(touchArray) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchArray.length; i < len; i++) {
			targetComp = _findTargetComp(touchArray[i]);
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchArray[i], targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _findTargetComp = function(touch) {
		var cnode = $(touch.target);
		while (cnode.length && !cnode.data('selfComp')) {
			cnode = cnode.parent();
		}
		return cnode.data('selfComp');
	};

	var _buildTouch = function(touch, targetComp) {
		var targetCompPagePosition = targetComp.pagePosition();
		var localXY = {
			x : touch.pageX - targetCompPagePosition.x,
			y : touch.pageY - targetCompPagePosition.y
		};
		// binding to UIComponent instead of Element
		return new Touch(touch.identifier, targetComp, localXY, {
			x : touch.pageX,
			y : touch.pageY
		});
	};
	TouchEvent.buildFrom3TouchArray = function(type, target, touches, changedTouches, targetTouches, canBubbling) {
		var _touches = _buildTouchListFromTouchArray(touches);
		var _targetTouches = _buildTouchListFromTouchArray(targetTouches);
		var _changedTouches = _buildTouchListFromTouchArray(changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	TouchEvent.buildFromDomTouchEvent = function(type, target, domTouchEvent, canBubbling) {
		var _touches = _buildTouchListFromTouchList(domTouchEvent.touches);
		var _targetTouches = _buildTouchListFromTouchList(domTouchEvent.targetTouches);
		var _changedTouches = _buildTouchListFromTouchList(domTouchEvent.changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	return TouchEvent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.BarRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ColorUtils, Math, BaseRenderer, Rectangle, Paths,
		ObjectUtils, Animator, ThemeManager) {
	var barRenderer = ObjectUtils.derive(BaseRenderer, {
		/**
		 * 
		 * @param layer
		 * @returns {___anonymous198_591}
		 */
		constructor : function(layer, options) {
			this._fillToZero = true;

			this._barStyle = {
				isShowGradient : false,
				isShowInnerBorder : false,
				isShowOutBorder : false,
				isShowShadow : false
			};

			this._seriesPoints = [];
			this._seriesBackUpPoints = [];
			this._seriesColor = [];
			this._parseOptions(options);

			// the tooltip decorative renderer, it should be
			// added to layer before all the shape;
			this._tpDecorativeRenderer = layer
					.addShape(new Rectangle());
		},

		/**
		 * 
		 * @param options
		 *            parse bar renderer options
		 */
		_parseOptions : function(options) {
			this._barStyle.isShowGradient = options.isShowGradient;
			this._barStyle.isShowInnerBorder = options.isShowInnerBorder;
			this._barStyle.isShowOutBorder = options.isShowOutBorder;
			this._barStyle.isShowShadow = options.isShowShadow;
		},

		/**
		 * only draw the first series group of series groups in
		 * bar renderer
		 */
		draw : function() {
			this._resetShapes();
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			this._seriesShapes = [];
			this._seriesColor = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesColor
						.push(seriesList[i]._seriesColor);
				this._seriesShapes[i] = this
						._initSeries(seriesList[i]._data.length);
			}

			this._update();
		},

		/**
		 * redraw the bar renderer, only draw the first series
		 * group of series groups in bar renderer.
		 */
		redraw : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}
			this._seriesColor = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesColor
						.push(seriesList[i]._seriesColor);
			}
			this._update();
			this.refresh();
		},

		_update : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;
			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var yAxis = seriesList[0].getYAxis();
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var tickInterval = yAxis.getTickInterval();

			var markSize = seriesList[0]._barMarkerSize;
			markSize = this._calculateMarkSzie(
					seriesList.length, tickInterval, markSize);

			// draw seriesList
			this._seriesPoints = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesPoints.push(this
						._calculateSeriesPoints(i, len,
								seriesList[i], yAxisMajorTicks,
								markSize));
				this._drawSeries(this._seriesShapes[i],
						this._seriesPoints[i], seriesList[i]);
			}

			this._doAnimation();

		},
		/**
		 * 
		 * @param sCount
		 *            series count
		 * @param tickInterval
		 *            tick interval in yAxis
		 * @param defaultMarkSize
		 *            default mark size of bar renderer
		 * 
		 * @return actual mark size
		 */
		_calculateMarkSzie : function(sCount, tickInterval,
				defaultMarkSize) {
			var markerSize;
			if (sCount == 1) {
				// Single Bar Series
				markerSize = 2 * tickInterval / 3;
			} else {
				// Multi Bar Series
				// markerSize = tickInterval / sCount;
				markerSize = Math.round(tickInterval
						/ (1 + sCount + (sCount - 1) / 8));
			}
			if (TypeUtils.isDefined(defaultMarkSize) && (markerSize > defaultMarkSize))
				markerSize = defaultMarkSize;

			return markerSize;
		},

		/**
		 * 
		 * @param sIndex
		 *            series index
		 * @param series
		 *            count
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * @param yAxisMajorTicks
		 *            major ticks of yAxis
		 * @Param markSize
		 *            series bar size
		 * 
		 * @return bar point positions Array[{x1,y1, x2,
		 *         y2}....]
		 * 
		 * calculation: points[i] y1 = (sIndex - (sCount/2 )) *
		 * markSize + yAxisMajorTicks[i] if(this._fillToZero){
		 * point.x1 = zeroTick; }else{ point.x1 = baseTick; } y2 =
		 * y1 + markSize x2 = series.getXAxis().u2p(data[i])
		 */
		_calculateSeriesPoints : function(sIndex, sCount,
				series, yAxisMajorTicks, markSize) {
			var data = series.getData();
			var xAxis = series.getXAxis();
			var baseTick = 0;
			var zeroTick = xAxis.u2p(0);
			var points = [];
			var offset = Math.round(markSize / 8);

			for ( var i = 0, len = data.length; i < len; i++) {
				var point = {};

				/*
				 * point.y1 = yAxisMajorTicks[i] - (markSize*sCount + offset(sCount-1))/2 + (markSize+offset)*sIndex;
				 */
				point.y1 = yAxisMajorTicks[i]  - ((sCount - 2*sIndex) * (markSize + offset) - offset)/2;

				if (this._fillToZero) {
					point.x1 = zeroTick;
				} else {
					point.x1 = baseTick;
				}

				point.y2 = point.y1 + markSize;
				point.x2 = xAxis.u2p(data[i].value);

				points.push(point);
			}
			return points;
		},

		_initSeries : function(pointNum) {
			var rects = [];

			for ( var i = pointNum; i--;) {
				rects[i] = this._addBarShape();
			}
			return rects;
		},

		/**
		 * 
		 * @param seriesShape
		 *            series shape array
		 * @param points
		 *            series points
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * @param drawedPArray
		 *            point array what we want to draw
		 * 
		 * @return shape Array
		 * 
		 * if drawnPArray is defined, we will only draw the
		 * point which is should drawn else draw all the shapes
		 */
		_drawSeries : function(seriesShape, points, series,
				drawnPArray) {
			var data = series.getData();
			var color = series._seriesColor;
			var point;

			for ( var i = points.length; i--;) {
				point = points[i];
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
						seriesShape[i].measureIndex = data[i].measureIndex;
						this._drawBarShape(seriesShape[i],
								point, color);
					}
				} else {
					seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
					seriesShape[i].measureIndex = data[i].measureIndex;
					this._drawBarShape(seriesShape[i], point,
							color);
				}
			}
		},

		/**
		 * 
		 * @param portView
		 */
		_doAnimation : function(portView) {
			var animator = Animator;
			var self = this;

			if (!portView) {
				animator
						.animate({
							values : [ {
								type : 'FLOAT',
								from : 0.0,
								to : 1
							} ],
							duration : 800,
							onStep : function(values) {
								var seriesPoints = self._seriesPoints;
								var seriesShapes = self._seriesShapes;
								for ( var i = 0, len = seriesShapes.length; i < len; i++) {
									var series = seriesShapes[i];
									for ( var j = 0, length = series.length; j < length; j++) {
										var point = seriesPoints[i][j];
										self._updateBarShapeDuringAnimation(seriesShapes[i][j], point, self._seriesColor[i], values[0]);
									}
								}
								//highlight selected bars
								for ( var hi = 0, highlights = self._highlights, hlen = highlights.length; hi < hlen; hi++) {
										self.highlight(highlights[hi]);
								}
								self.getLayer().setNeedsDisplay();
							},
							onComplete : function(){
								var seriesPoints = self._seriesPoints;
								var seriesShapes = self._seriesShapes;
								for ( var i = 0, len = seriesShapes.length; i < len; i++) {
									var series = seriesShapes[i];
									for ( var j = 0, length = series.length; j < length; j++) {
										if (seriesShapes[i][j]) {
											var point = seriesPoints[i][j];
											self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
										}
									}
								}
								//highlight selected bars
								for ( var hi = 0, highlights = self._highlights, hlen = highlights.length; hi < hlen; hi++) {
										self.highlight(highlights[hi]);
								}
								self.getLayer().setNeedsDisplay();
							}
						});

			} else {
				var seriesPoints = self._seriesPoints;
				var seriesShapes = self._seriesShapes;
				for ( var i = 0, len = seriesShapes.length; i < len; i++) {
					var series = seriesShapes[i];
					for ( var j = 0, length = series.length; j < length; j++) {
						if (seriesShapes[i][j]) {
							var point = seriesPoints[i][j];
							self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
						}
					}
				}
				for ( var hi = 0, highlights = self._highlights, hlen = highlights.length; hi < hlen; hi++) {
					self.highlight(highlights[hi]);
				}
				self.getLayer().setNeedsDisplay();
			}
		},

		_resetShapes : function() {
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				for ( var j = 0, seriesShapes = this._seriesShapes[i], jlen = seriesShapes.length; j < jlen; j++) {
					this._removeBarShape(seriesShapes[j]);
				}
			}
			this._seriesShapes = [];
		},

		/**
		 * first we reset all shapes to the normal state, and
		 * then highlight any shapes under the passed in point.
		 * 
		 * @override sap.riv.viz.shared.series.BaseRenderer.highlightOnPoint
		 * @deprecated
		 */
		highlightOnPoint : function(point) {
			// for bar chart, we only have one datacontext on
			// each point
			var dataContextOnPoint = null;
			// do point-in-test through all shapes
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				// we should have seriesList since we have
				// something in seriesShapesArray
				var series = this.getSeriesGroups()[0]
						.getSeriesList()[i];
				for ( var j = 0, seriesShapes = this._seriesShapes[i], jlen = seriesShapes.length; j < jlen; j++) {
					var shape = seriesShapes[j];

					// [jimmy 021612]now we only change color
					// for highlight, reset anything else here
					// if we add more effect for highlight
					shape.rect.color(series._seriesColor);
					if (shape.rect.pointIn(point)) {
						// we find a shape, just highlight it
						shape.rect
								.color(ColorUtils
										.adjust_brightness(
												series._seriesColor,
												50));
						// this._doHighlight(i, j);
						dataContextOnPoint = {
							"measureIndex" : shape.measureIndex,
							"dimensionItemIndex" : shape.dimensionItemIndex,
							"series" : series
						};
					}
				}
			}
			// [jimmy TODO]optimize point, we don't need do
			// refresh if no shape is under point
			// and no shape needs update (previous selected)
			this.refresh();
			return dataContextOnPoint;
		},

		/**
		 * Highlights a bar with given locator as a clue to find
		 * the bar shape. This function cannot handle concurrent
		 * bars highlighting, i.e., only "single highlighting"
		 * is supported. :)
		 * 
		 * @param {Object}
		 *            locator - Specifier or path for finding a
		 *            shape
		 * @returns {Object} dataContext - Contextual data when
		 *          highlighting
		 * @eye
		 */
		highlight : function(locator) {
			if (!locator)
				return;

			var series, dataContext;
			var seriesGroup = this.getSeriesGroups()[0];

			if (TypeUtils.isDefined(locator.measureIndex)) {
				series = seriesGroup.getSeriesList()[locator.measureIndex];
				// var targetShape =
				// this._seriesShapes[locator.measureIndex][locator.dimensionItemIndex];

				this._doHighlight(locator.measureIndex,
						locator.dimensionItemIndex);
				// this._doHighlight(series._seriesColor,
				// targetShape);
				dataContext = {
					"measureIndex" : locator.measureIndex,
					"dimensionItemIndex" : locator.dimensionItemIndex,
					"series" : series
				};
			}

			if (TypeUtils.isDefined(locator.x)) {
				var clickedShape = this.getShape(locator);
				if (clickedShape
						&& clickedShape.measureIndex != null) {
					series = seriesGroup.getSeriesList()[clickedShape.measureIndex];
					this._doHighlight(
							clickedShape.measureIndex,
							clickedShape.dimensionItemIndex);
					// this._doHighlight(series._seriesColor,
					// this._seriesShapes[clickedShape.measureIndex][clickedShape.dimensionItemIndex]);
					dataContext = {
						"measureIndex" : clickedShape.measureIndex,
						"dimensionItemIndex" : clickedShape.dimensionItemIndex,
						"series" : series
					};
				}
			}

			this.refresh();
			return dataContext;
		},

		/**
		 * Simply restores a bar's color.
		 * 
		 * @param {Object}
		 *            locator - Specifier or finder for a bar
		 *            shape
		 */
		restore : function(locator) {
			if (!locator)
				return;

			// Only restores bar's color by its index.
			if (TypeUtils.isDefined(locator.measureIndex)) {
				this._doRestoreHighlight();
				this.refresh();
			}
		},

		/**
		 * Tests if a specified bar shape exists, if true return
		 * necessary information and vice versa.
		 * 
		 * @param {Object}
		 *            locator - Specifier or path for finding a
		 *            shape
		 * @returns {Object} bar shape data
		 */
		getShape : function(locator) {
			if (!locator)
				return;

			var returnObject = {
				"measureIndex" : null,
				"dimensionItemIndex" : null,
				"shape" : null
			};

			if (TypeUtils.isDefined(locator.measureIndex)) {
				return this._seriesShapes[locator.measureIndex][locator.dimensionItemIndex];
			}

			if (TypeUtils.isDefined(locator.x)) {
				for ( var i = 0, rows = this._seriesShapes.length; i < rows; i++) {
					for ( var j = 0, shapeCount = this._seriesShapes[i].length; j < shapeCount; j++) {
						if (this._seriesShapes[i][j].rect
								.pointIn(locator)) {
							returnObject.measureIndex = i;
							returnObject.dimensionItemIndex = j;
							returnObject.shape = this._seriesShapes[i][j];
							return returnObject;
						}
					}
				}
			}
		},

		/**
		 * Quick test for the existence of a bar shape.
		 * 
		 * @param seriesIndex -
		 *            Series index
		 * @param shapeIndex -
		 *            Shape index
		 * @returns {Object} - If bar shape exists, return it or
		 *          vice versa.
		 */
		shapeExists : function(seriesIndex, shapeIndex) {
			return this._seriesShapes[seriesIndex] 
					? this._seriesShapes[seriesIndex][shapeIndex] : undefined;
		},

		_doHighlight : function(selectedMeasureIndex,
				selectedDimensionIndex) {
			var seriesShapes = this._seriesShapes;
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					if(shape){
						shape.rect.compositionMode({
							alpha : 0.5
						});
						shape.outerBorder.compositionMode({
							alpha : 0.5
						});
						shape.innerBorder.compositionMode({
							alpha : 0.5
						});
					}
				}
			}
			var selectedShape = seriesShapes[selectedMeasureIndex]? seriesShapes[selectedMeasureIndex][selectedDimensionIndex]: null;
			if(selectedShape){
				selectedShape.rect.compositionMode({
					alpha : 1
				});
				selectedShape.outerBorder.compositionMode({
					alpha : 1
				});
				selectedShape.innerBorder.compositionMode({
					alpha : 1
				});
			}
		},

		_doRestoreHighlight : function() {
			var seriesShapes = this._seriesShapes;
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					shape.rect.compositionMode({
						alpha : 1
					});
					shape.outerBorder.compositionMode({
						alpha : 1
					});
					shape.innerBorder.compositionMode({
						alpha : 1
					});
				}
			}
		},

		/**
		 * @param viewPort
		 *            the size should to been drawn
		 * 
		 * if viewPort is defined, we only draw the shape in the
		 * this view, and remove other shape which we do not
		 * want to draw else draw all the shapes
		 */
		drawViewPort : function(scale, viewPort) {
			var offset = this.getLayer().position();

			this._seriesBackUpPoints = ObjectUtils.extend(true,
					[], this._seriesPoints);

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var yAxis = seriesList[0].getYAxis();
			var yAxisMajorTicks = yAxis.getMajorTicks();
			//Ian [2012-4-18] Fix the bug, when there is only one dimension in bar chart, the second major ticks in undefind. 
			var tickInterval = yAxis.getTickInterval();
			//End
			
			var markSize;
			// var markSize = seriesList[0]._zommBarMarkerSize *
			// scale;//[Christy] Bar size is not limited.
			// if(markSize < seriesList[0]._barMarkerSize){
			// markSize = seriesList[0]._barMarkerSize;
			// }
			seriesList[0]._zommBarMarkerSize = markSize = this
					._calculateMarkSzie(seriesList.length,
							tickInterval);

			var layer = this.getLayer();
			this._seriesPoints = [];
			if (viewPort) {
				// draw serieses
				var pointArray = [];
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var seriesPoints = this._seriesPoints[i] = this
							._calculateSeriesPoints(i, len,
									seriesList[i],
									yAxisMajorTicks, markSize);
					for ( var j = 0; j < seriesPoints.length; j++) {

						if (seriesPoints[j].y2 + offset.y < 0
								|| seriesPoints[j].y1
										+ offset.y >= viewPort.height) {
							if (seriesShapes[j]) {
								this
										._removeBarShape(seriesShapes[j]);
							}
							seriesShapes[j] = null;
						} else {
							pointArray[j] = 1;
							if (!seriesShapes[j]) {
								seriesShapes[j] = this
										._addBarShape();
							}
						}
					}

					this._drawSeries(seriesShapes,
							seriesPoints, seriesList[i],
							pointArray);
					pointArray = [];
				}
				this._doAnimation(true);
			} else {
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var seriesPoints = this._seriesPoints[i] = this
							._calculateSeriesPoints(i, len,
									seriesList[i],
									yAxisMajorTicks, markSize);
					for ( var j = 0; j < seriesPoints.length; j++) {
						if (!seriesShapes[j]) {
							seriesShapes[j] = this
									._addBarShape();
						}
					}
					this._drawSeries(seriesShapes,
							seriesPoints, seriesList[i]);
				}
				this._doAnimation(true);
			}

			this.refresh();
		},

		_addBarShape : function() {
			var layer = this.getLayer();
			return {
				'rect' : layer.addShape(new Rectangle()),
				'outerBorder' : layer.addShape(new Paths()),
				'innerBorder' : layer.addShape(new Paths())
			};
		},

		_removeBarShape : function(shape) {
			var layer = this.getLayer();
			layer.removeShape(shape.rect);
			layer.removeShape(shape.outerBorder);
			layer.removeShape(shape.innerBorder);
		},

		_drawBarShape : function(seriesShape, point, basicColor) {
			var barHeight = Math.abs(point.y2 - point.y1);
			var isShowOutBorder = this._barStyle.isShowOutBorder, isShowInnerBorder = this._barStyle.isShowInnerBorder;
			if (barHeight < 8) {
				// Remove Out Border
				isShowOutBorder = false;
			}
			if (barHeight < 5) {
				// Remove Inner Border
				isShowInnerBorder = false;
			}

			var color = ColorUtils
					.getColorSeriesForBar(basicColor);

			// draw rectangle
			seriesShape.rect.color(basicColor);

			if (point.x1 > point.x2) {
				seriesShape.rect
						.topRight([ point.x1, point.y1 ]);
			} else {
				seriesShape.rect
						.topLeft([ point.x1, point.y1 ]);
			}
			// draw inner border
			//Ian [2012-04-11] To fix the bug VISUAL-561, we should reset the inner and outer border because it may keep the last value
			seriesShape.innerBorder.reset();
			seriesShape.outerBorder.reset();
			//End
			
			seriesShape.innerBorder.borderWidth(1).borderColor(
					color[0]).visible(isShowInnerBorder);
			// draw outer border
			seriesShape.outerBorder.borderWidth(1).borderColor(
					color[3]).visible(isShowOutBorder);
		},

		_updateBarShapeDuringAnimation : function(seriesShape, point,
				basicColor, factor){
			var width = Math.abs(point.x1 - point.x2) * factor;
			var height = Math.abs(point.y2 - point.y1);
			if ((width.toString() === 'NaN')
					|| (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height).shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 0,
				color : 'rgba(0,0,0,0.5)'
			});

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.x1 > point.x2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : 0,
							y : point.y1
						},
						s : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : 0,
							y : point.y1
						},
						e : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}
		},
		
		_updateBarShape : function(seriesShape, point,
				basicColor, factor) {
			var width = Math.abs(point.x1 - point.x2) * factor;
			var height = Math.abs(point.y2 - point.y1);
			if ((width.toString() === 'NaN')
					|| (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height);
			
			// draw rectangle
			if (this._barStyle.isShowShadow) {
				seriesShape.rect.shadow({
					offsetX : 1,
					offsetY : 2,
					blur : 2,
					color : 'rgba(0,0,0,0.5)'
				});
			} else {
				seriesShape.rect.shadow({
					offsetX : 0,
					offsetY : 0,
					blur : 0,
					color : 'rgba(0,0,0,0.5)'
				});
			}

			var color = ColorUtils
					.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.x1 > point.x2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : 0,
							y : point.y1
						},
						s : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : 0,
							y : point.y1
						},
						e : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}

			var offset = 0;
			seriesShape.outerBorder.reset();
			if (seriesShape.outerBorder.visible()) {
				this._drawBorderPath(seriesShape.outerBorder,
						point, width, offset);
				offset = offset + 1;
			}
			seriesShape.innerBorder.reset();
			if (seriesShape.innerBorder.visible()) {
				this._drawBorderPath(seriesShape.innerBorder,
						point, width, offset);
			}
		},

		_drawBorderPath : function(shape, point, distance,
				offset) {
			var barWidth = Math.abs(point.x1 - point.x2);
			if (barWidth < 2)
				return;
			if (point.x1 > point.x2) {
				shape.moveTo(point.x1, point.y1 + offset)
						.lineTo(point.x1 - distance + offset,
								point.y1 + offset);
				if (barWidth < 3) {
					shape.moveTo(point.x1 - distance + offset,
							point.y2 - offset);
				} else {
					shape.lineTo(point.x1 - distance + offset,
							point.y2 - offset);
				}
				shape.lineTo(point.x1, point.y2 - offset);
			} else {
				shape.moveTo(point.x1, point.y1 + offset)
						.lineTo(point.x1 + distance - offset,
								point.y1 + offset);
				if (barWidth < 3) {
					shape.moveTo(point.x1 + distance - offset,
							point.y2 - offset);
				} else {
					shape.lineTo(point.x1 + distance - offset,
							point.y2 - offset);
				}
				shape.lineTo(point.x1, point.y2 - offset);
			}
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var barStyle = settings.bar;
			this._barStyle.isShowGradient = barStyle.isShowGradient;
			this._barStyle.isShowInnerBorder = barStyle.isShowInnerBorder;
			this._barStyle.isShowOutBorder = barStyle.isShowOutBorder;
			this._barStyle.isShowShadow = barStyle.isShowShadow;
			this.redraw();
		},

		updateProperties : function(propBag) {
			this._parseOptions(propBag);
		},

		hoverOnPoint : function(point) {
			var dataCtxOnpoint = {};

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;
			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var yAxis = seriesList[0].getYAxis();
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var halfTickInterval = yAxis.getTickInterval() / 2;

			var start = 0, end = yAxisMajorTicks.length - 1;
			var found = false;
			var dimensionItemIndex;
			while (!found && start < end) {
				dimensionItemIndex = Math
						.round((start + end) / 2);
				var xPoint = yAxisMajorTicks[dimensionItemIndex]
						- point.y;
				if (Math.abs(xPoint) <= halfTickInterval)
					found = true;
				else if (xPoint >= 0) {
					start = dimensionItemIndex + 1;
				} else {
					end = dimensionItemIndex - 1;
				}
			}
			if (!found)
				dimensionItemIndex = start;
			
			if (this._dataCtxOnPoint
					&& this._dataCtxOnPoint.dimensionItemIndex === dimensionItemIndex) {
				return this._dataCtxOnPoint;
			}
			dataCtxOnpoint['dimensionItemIndex'] = dimensionItemIndex;

			this._tpDecorativeRenderer
					.visible(true)
					.width(this.getLayer().size().width)
					.height(halfTickInterval * 2)
					.color('rgba(133,133,133, 0.4)')
					.topLeft(
							[
									0,
									Math
											.round(yAxisMajorTicks[dimensionItemIndex]
													- halfTickInterval) ]);
			this.refresh();

			this._dataCtxOnPoint = null;
			this._dataCtxOnPoint = dataCtxOnpoint;

			return dataCtxOnpoint;
		},

		onblur : function(point) {
			this._dataCtxOnPoint = null;
			this._tpDecorativeRenderer.visible(false);
			// refresh the chart to remove the decorative
			// renderer
			this.refresh();

		}
	});

	return barRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.LineRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math, BaseRenderer, Series, ObjectUtils, Animator, ThemeManager, Line, Polygon, Circle, Paths) {
	var lineRenderer = ObjectUtils.derive(BaseRenderer, {
		constructor : function(layer, options) {
			this._seriesPoints = [];
			this._isShowMarkerShadow = false;
			this._isShowLineShadow = false;

			// the tooltip decorative renderer, it should be
			// added to layer before all the shape;
			this._tpDecorativeRenderer = layer.addShape(new Line());
			this._tpDecorativePathRenderers = [];
			this._parseOptions(options);
		},

		/**
		 * @param options
		 */
		_parseOptions : function(options) {
			this._isShowLineShadow = options.isShowLineShadow;
			this._isShowMarkerShadow = options.isShowMarkerShadow;
		},

		/**
		 * 1. create the marker points 2. draw the marker
		 */
		draw : function() {
			this._resetShape();
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				return;
			}

			// draw series
			for ( var i = 0, len = series.length; i < len; i++) {
				this._seriesShapes[i] = this._initSeries(series[i]._data.length, series[i]);
			}
			this._update();
			// register event
			this._regEvent();

		},

		_update : function() {
			var seriesGroups = this.getSeriesGroups();
			var series = seriesGroups[0].getSeriesList();

			var xAxis = series[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();

			// create series points
			this._seriesPoints = [];
			for ( var i = 0, len = series.length; i < len; i++) {
				this._seriesPoints.push(this._calculateSeriesPoints(series[i], xAxisMajorTicks));
			}

			// draw series
			for ( var i = 0, len = series.length; i < len; i++) {
				this._drawSeries(this._seriesShapes[i], this._seriesPoints[i], series[i]);
			}

			this._doAnimation();
		},

		/**
		 * redraw line renderer. 1. clear the shapes 2. reset
		 * the series points 3. call draw function
		 */
		redraw : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				return;
			}

			var i, seriesNum = series.length, isRedraw = false;
			for (i = 0; i < seriesNum; i++) {
				if (!(this._seriesShapes[i].marker[0] instanceof this
						._getMarkerObject(series[i]._markerSymbol))) {
					isRedraw = true;
					break;
				}
			}

			if (isRedraw) {
				this._resetShape();
				this._seriesPoints = [];
				this.draw();
			} else {
				this._update();
				this.refresh();
			}
		},

		_getMarkerObject : function(markerSymbol) {
			var shapeObj;
			switch (markerSymbol) {
			case Series.TRIANGLEMARKER:
			case Series.DIAMONDMARKER:
				shapeObj = Polygon;
				break;
			case Series.CIRCLEMARKER:
			default:
				shapeObj = Circle;
				break;
			}
			return shapeObj;
		},

		/**
		 * 
		 * @param series
		 * @param xAxisMajorTicks
		 * @returns {Array} return the center position of every
		 *          mark
		 */
		_calculateSeriesPoints : function(series, xAxisMajorTicks) {
			var data = series.getData();
			var yAxis = series.getYAxis();

			var points = [];

			for ( var i = 0, len = data.length; i < len; i++) {

				var point = {};
				point.x = xAxisMajorTicks[i];
				point.y = yAxis.u2p(data[i].value);
				points.push(point);

			}
			return points;
		},

		_initSeries : function(pointNum, series) {
			var layer = this.getLayer();
			var lineShapes = {
				line : [],
				marker : []
			};
			var markerSymbol = series._markerSymbol;
			for ( var i = 0; i < pointNum; i++) {
				lineShapes.line[i] = layer.addShape(new Line());
			}
			for ( var i = 0; i < pointNum; i++) {
				switch (markerSymbol) {
				case Series.TRIANGLEMARKER:
				case Series.DIAMONDMARKER:
					lineShapes.marker[i] = layer.addShape(new Polygon());
					break;
				case Series.CIRCLEMARKER:
				default:
					lineShapes.marker[i] = layer.addShape(new Circle());
					break;
				}
			}
			return lineShapes;
		},

		_drawSeries : function(shape, points, series, drawnPArray) {
			var markerSymbol = series._markerSymbol;

			for ( var i = 0, len = points.length; i < len; i++) {
				if ((TypeUtils.isExist(drawnPArray)) && (drawnPArray[i] !== 1))
					break;
				
				if ( !series.isVisible() ) {
					if ( shape.marker[i].rect ) {
						shape.marker[i].rect.visible(false);
					} else {
						shape.marker[i].visible(false);
					}
					shape.line[i].visible(false);
				}
				
				// Marker Shadow
				if (this._isShowMarkerShadow) {
					shape.marker[i].shadow({
						offsetX : 1,
						offsetY : 2,
						blur : 2,
						color : 'rgba(0,0,0,0.5)'
					});
				} else {
					shape.marker[i].shadow({
						offsetX : 0,
						offsetY : 0,
						blur : 0,
						color : 'rgba(0,0,0,0.5)'
					});
				}
				// Line Shadow
				if (this._isShowLineShadow) {
					shape.line[i].shadow({
						offsetX : 0,
						offsetY : 2,
						blur : 3,
						color : 'rgba(0,0,0,0.5)'
					});
				} else {
					shape.line[i].shadow({
						offsetX : 0,
						offsetY : 0,
						blur : 0,
						color : 'rgba(0,0,0,0.5)'
					});
				}
			}

			switch (markerSymbol) {
			case Series.CIRCLEMARKER: {
				this._drawCircleMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			case Series.TRIANGLEMARKER: {
				this._drawTriangleMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			case Series.DIAMONDMARKER: {
				this._drawDiamondMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			case Series.PENTAGONMARKER: {
				this._drawPentagonMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			default: {
				this._drawCircleMarkAndLine(shape, points, series, drawnPArray);
				break;
			}
			}
		},

		/**
		 * 
		 * @param viewPort
		 * 
		 * we only do animation on loading chart now. Every
		 * time, we calculate the marker number we should draw.
		 * we will set the property visible to true to show it,
		 * including marker and line shape. Line shape start
		 * from index of 1.
		 */
		_doAnimation : function(viewPort) {

			var self = this;
			if (!viewPort) {
				var highlights = self._highlights;
				var series = self.getSeriesGroups()[0].getSeriesList();
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doUnHighlight(highlights[hi]);
				}
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doHighlight(highlights[hi], series[highlights[hi].measureIndex]);
				}

				Animator.animate({
					values : [ {
						type : 'FLOAT',
						from : 0.0,
						to : 1
					} ],
					duration : 800,
					onStep : function(values) {
						var seriesPoints = self._seriesPoints;
						var shapes = self._seriesShapes;
						var index = 0;

						var length = self.getLayer().size().width * values[0];
						for ( var i = 0, len = seriesPoints[0].length; i < len; i++) {
							if (seriesPoints[0][i].x >= length) {
								index = i;
								break;
							}
						}

						index++;

						for ( var i = 0; i < shapes.length; i++) {
							var lineShape = shapes[i].line;
							var markers = shapes[i].marker;
							for ( var j = 0; j < index; j++) {
								if (markers[j]) {
									markers[j].visible(true);
								}
								if (j > 0 && lineShape[j]) {
									lineShape[j].visible(true);
								}
							}
						}
						
						var highlights = self._highlights;
						for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
							highlights[hi].crossShape.visible(true);
							highlights[hi].borderShape.visible(true);
						}
						
						self.getLayer().setNeedsDisplay();
					},
					/**
					 * As the performance issue, in IPAD, we may do not have the resource the complement all the animation,
					 * but we should assure that all the line show in the chart area.
					 */
					onComplete: function(){
						var shapes = self._seriesShapes;
						for ( var i = 0, len = shapes.length; i < len; i++) {
							var markers = shapes[i].marker;
							var lines = shapes[i].line;
							for ( var j = 0, jlen = markers.length; j < jlen; j++) {
								if (markers[j]) {
									markers[j].visible(true);
								}
								if (j > 0 && lines[j]) {
									lines[j].visible(true);
								}
							}
						}
					}
				});
			} else {
				var shapes = self._seriesShapes;
				var series = self.getSeriesGroups()[0].getSeriesList();

				var highlights = self._highlights;
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doUnHighlight(highlights[hi]);
				}
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doHighlight(highlights[hi], series[highlights[hi].measureIndex]);
				}

				for ( var i = 0, len = shapes.length; i < len; i++) {
					var markers = shapes[i].marker;
					var lines = shapes[i].line;
					for ( var j = 0, jlen = markers.length; j < jlen; j++) {
						if (markers[j]) {
							markers[j].visible(true);
						}
						if (j > 0 && lines[j]) {
							lines[j].visible(true);
						}
					}
				}
				var highlights = self._highlights;
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					highlights[hi].crossShape.visible(true);
					highlights[hi].borderShape.visible(true);
				}
				self.refresh();
			}
		},

		_drawCircleMarkAndLine : function(lineShapes, points, series, drawnPArray) {
			if ( !series.isVisible() ) return;
			
			var lineMarkerSize = series._lineMarkerSize;
			var lineSize = series._lineSize;
			var color = series._seriesColor;
			var lineColor = series._lineColor;

			for ( var i = 0, len = points.length; i < len; i++) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						// draw circle marker
						lineShapes.marker[i].fillingColor(color).center({
							x : points[i].x,
							y : points[i].y
						}).radius(lineMarkerSize / 2).visible(false);

						if (i != 0) {
							lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
								x : points[i - 1].x,
								y : points[i - 1].y
							}).to({
								x : points[i].x,
								y : points[i].y
							});
						}
					}
				} else {
					// draw circle marker
					lineShapes.marker[i].fillingColor(color).center({
						x : points[i].x,
						y : points[i].y
					}).radius(lineMarkerSize / 2).visible(false);

					if (i != 0) {
						lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
							x : points[i - 1].x,
							y : points[i - 1].y
						}).to({
							x : points[i].x,
							y : points[i].y
						});
					}
				}
			}
		},

		_drawTriangleMarkAndLine : function(lineShapes, points, series, drawnPArray) {
			if ( !series.isVisible() ) return;
			
			var lineMarkerSize = series._lineMarkerSize;
			var lineSize = series._lineSize;
			var color = series._seriesColor;
			var lineColor = series._lineColor;

			for ( var i = 0, len = points.length; i < len; i++) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						// draw circle marker
						var plgn = lineShapes.marker[i].visible(false);
						plgn.reset();
						plgn.fillingColor(color);
						this._drawTriangleVertices(plgn, points[i], lineMarkerSize);
						plgn.close();

						if (i != 0) {
							lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
								x : points[i - 1].x,
								y : points[i - 1].y
							}).to({
								x : points[i].x,
								y : points[i].y
							});
						}
					}
				} else {
					// draw circle marker
					var plgn = lineShapes.marker[i].visible(false);
					plgn.reset();
					plgn.fillingColor(color);
					this._drawTriangleVertices(plgn, points[i], lineMarkerSize);
					plgn.close();

					if (i != 0) {
						lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
							x : points[i - 1].x,
							y : points[i - 1].y
						}).to({
							x : points[i].x,
							y : points[i].y
						});
					}
				}

			}

		},

		_drawDiamondMarkAndLine : function(lineShapes, points, series, drawnPArray) {
			if ( !series.isVisible() ) return;
			
			var lineMarkerSize = series._lineMarkerSize;
			var lineSize = series._lineSize;
			var color = series._seriesColor;
			var lineColor = series._lineColor;

			for ( var i = 0, len = points.length; i < len; i++) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						// draw circle marker
						var plgn = lineShapes.marker[i].visible(false);
						plgn.reset();
						plgn.fillingColor(color);
						this._drawDiamondVertices(plgn, points[i], lineMarkerSize);
						plgn.close();

						if (i != 0) {
							lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
								x : points[i - 1].x,
								y : points[i - 1].y
							}).to({
								x : points[i].x,
								y : points[i].y
							});
						}
					}
				} else {
					// draw circle marker
					var plgn = lineShapes.marker[i].visible(false);
					plgn.reset();
					plgn.fillingColor(color);
					this._drawDiamondVertices(plgn, points[i], lineMarkerSize);
					plgn.close();

					if (i != 0) {
						lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
							x : points[i - 1].x,
							y : points[i - 1].y
						}).to({
							x : points[i].x,
							y : points[i].y
						});
					}
				}
			}
		},

		_drawPentagonMarkAndLine : function(points, series) {
			if ( !series.isVisible() ) return;
		},

		/**
		 * remove all the shape created
		 */
		_resetShape : function() {
			var layer = this.getLayer();
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				// remove the marker renderer
				for ( var markers = this._seriesShapes[i].marker, j = markers.length; j--;) {
					layer.removeShape(markers[j]);
				}

				// remove the line renderer
				for ( var lines = this._seriesShapes[i].line, j = lines.length; j--;) {
					layer.removeShape(lines[j]);
				}
			}
			this._seriesShapes = [];
		},

		/**
		 * register event on line renderer
		 */
		_regEvent : function() {

		},

		/** @overrides sap.riv.viz.shared.series.BaseRenderer.highlight */
		highlight : function() {
			if (this._seriesShapes.length === 0)
				return;
			var series = this.getSeriesGroups()[0].getSeriesList();

			if (this._layerPrioritization) {
				// For default selection, we should put the
				// highlighted line at the top layer and reinit
				// the shape
				var highlights = this._highlights;
				if (highlights.length > 0) {
					var firstSeriesIndex = highlights[0]['measureIndex'];
					if (TypeUtils.isExist(firstSeriesIndex) && firstSeriesIndex <= (series.length - 1)) {
						// Here is for the click event, all the
						// shape have been created,
						// we can change the shape's order to
						// put the series at the top position
						if (this._seriesShapes.length > 0) {
							// remove the shapes at current
							// layer, then reinit it and put
							// them at the top position
							var shapes = this._seriesShapes[firstSeriesIndex];
							var layer = this.getLayer();
							for ( var i = 0; i < shapes.marker.length; i++) {
								layer.removeShape(shapes.marker[i]);
								layer.removeShape(shapes.line[i]);
							}

							// remove the shapes
							this._seriesShapes[firstSeriesIndex] = this._initSeries(
									series[firstSeriesIndex]._data.length, series[firstSeriesIndex]);

							var points = [];
							var xAxis = series[0].getXAxis();
							var xAxisMajorTicks = xAxis.getMajorTicks();

							// create series points
							points = this._calculateSeriesPoints(series[firstSeriesIndex],
									xAxisMajorTicks);

							this._drawSeries(this._seriesShapes[firstSeriesIndex], points, series[firstSeriesIndex]);
							
							//show series points
							var markers = this._seriesShapes[firstSeriesIndex].marker;
							var lines = this._seriesShapes[firstSeriesIndex].line;
							for ( var i = 0, len = markers.length; i < len; i++) {
								markers[i].visible(true);
								lines[i].visible(true);
							}
							
							if(this._dataCtxOnPoint){
								//remove highlight shape
								for ( var i = 0, pathRenderers = this._tpDecorativePathRenderers, len = pathRenderers.length; i < len; i++) {
									layer.removeShape(pathRenderers[i]);
								}
								this._tpDecorativePathRenderers = [];
								//add new highlight shape
								var dimensionItemIndex = this._dataCtxOnPoint.dimensionItemIndex;
								var s, shape;
								for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
									s = series[i];
									shape = this._drawBorderShape(s._markerSymbol, i, dimensionItemIndex,
											1.5 * s._lineMarkerSize, s._seriesColor);
									shape.visible(true);
									this._tpDecorativePathRenderers[i] = shape;
								}
							}
						}
					}
				}
			}

			for ( var i = 0; i < this._highlights.length; i++) {
				this._doHighlight(this._highlights[i], series[this._highlights[i].measureIndex]);
				this._highlights[i].crossShape.visible(true);
				this._highlights[i].borderShape.visible(true);
			}
			this.refresh();
		},

		_doHighlight : function(highlightItem, series) {
			var measureIndex = highlightItem.measureIndex;
			var dimensionItemIndex = highlightItem.dimensionItemIndex;

			var borderSize = 1.7 * series._lineMarkerSize;
			var seriesColor = series._seriesColor;

			if(!TypeUtils.isExist(this._seriesShapes[measureIndex].marker[dimensionItemIndex]))
				return;
			
			var borderShape = this._drawBorderShape(series._markerSymbol, measureIndex,
					dimensionItemIndex, borderSize, seriesColor);
			highlightItem.borderShape = borderShape;

			var crossShape = this._drawCrossShape(measureIndex, dimensionItemIndex, borderSize,
					borderShape, seriesColor);
			highlightItem.crossShape = crossShape;
		},

		_doUnHighlight : function(highlightItem) {
			var layer = this.getLayer();
			layer.removeShape(highlightItem.borderShape);
			layer.removeShape(highlightItem.crossShape);
		},

		removeHighlights : function() {
			for ( var i = 0, len = this._highlights.length; i < len; i++) {
				this._doUnHighlight(this._highlights[i]);
			}
			this._highlights.splice(0, this._highlights.length);
			this.refresh();
		},

		/**
		 * 
		 * @param scale
		 *            the scale degree in xaxis direction
		 * @param viewPort
		 *            the size should to been drawn
		 * 
		 * if viewPort is defined, we only draw the shape in the
		 * this view, and remove other shape which we do not
		 * want to draw else draw all the shapes
		 */
		drawViewPort : function(scale, viewPort) {

			var offset = this.getLayer().position();

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var tickInterval = xAxis.getTickInterval();
			var layer = this.getLayer();
			this._seriesPoints = [];

			if (viewPort) {
				var pointArray = [];
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesMarkerShapes = this._seriesShapes[i].marker;
					var seriesLineShapes = this._seriesShapes[i].line;

					var seriesPoints = this._calculateSeriesPoints(seriesList[i], xAxisMajorTicks);
					this._seriesPoints.push(seriesPoints);

					for ( var j = 0; j < seriesPoints.length; j++) {
						// Fix the issue, in Line chart, when
						// you zoom in/out the chart, we also
						// should show the line at the right
						// side of the last mark
						if (seriesPoints[j].x + offset.x < 0
								|| seriesPoints[j].x + offset.x > viewPort.width + tickInterval) {
							if (seriesMarkerShapes[j] && seriesLineShapes[j]) {
								layer.removeShape(seriesMarkerShapes[j]);
								layer.removeShape(seriesLineShapes[j]);
							}
							seriesMarkerShapes[j] = null;
							seriesLineShapes[j] = null;
						} else {
							pointArray[j] = 1;
							// we should keep that the marker is
							// added after line
							if (!seriesMarkerShapes[j] && !seriesLineShapes[j]) {
								seriesLineShapes[j] = layer.addShape(new Line());

								switch (seriesList[i]._markerSymbol) {
								case Series.CIRCLEMARKER: {
									seriesMarkerShapes[j] = layer.addShape(new Circle());
									break;
								}

								default: {
									seriesMarkerShapes[j] = layer.addShape(new Polygon());
									break;
								}
								}
							}
						}
					}

					this._drawSeries(this._seriesShapes[i], seriesPoints, seriesList[i], pointArray);
				}

				this._doAnimation(true);
			} else {
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesMarkerShapes = this._seriesShapes[i].marker;
					var seriesLineShapes = this._seriesShapes[i].line;
					var seriesPoints = this._calculateSeriesPoints(seriesList[i], xAxisMajorTicks);
					this._seriesPoints.push(seriesPoints);
					// Here is special code for line render. As
					// in line render, we should keep all the
					// mark and line above the bar side. so we
					// should
					// remove the shape and add the shape again.
					for ( var j = 0, jlen = seriesPoints.length; j < jlen; j++) {
						if (seriesMarkerShapes[j]) {
							layer.removeShape(seriesMarkerShapes[j]);
						}
						if (seriesLineShapes[j]) {
							layer.removeShape(seriesLineShapes[j]);
						}

						seriesLineShapes[j] = null;
						seriesMarkerShapes[j] = null;
					}

					for ( var j = 0; j < seriesPoints.length; j++) {
						if (!seriesLineShapes[j])
							seriesLineShapes[j] = layer.addShape(new Line());
					}

					for ( var j = 0; j < seriesPoints.length; j++) {
						if (!seriesMarkerShapes[j]) {
							switch (seriesList[i]._markerSymbol) {
							case Series.CIRCLEMARKER: {
								seriesMarkerShapes[j] = layer.addShape(new Circle());
								break;
							}
							default: {
								seriesMarkerShapes[j] = layer.addShape(new Polygon());
								break;
							}
							}

						}
					}

					this._drawSeries(this._seriesShapes[i], seriesPoints, seriesList[i]);
				}
				this._doAnimation(true);
			}
			this.refresh();
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var lineStyle = settings.line;

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				return;
			}

			for ( var i = 0, len = series.length; i < len; i++) {
				series[i]._lineMarkerSize = lineStyle.marker.size;
				series[i]._lineSize = lineStyle.line.size;
			}
			this._isShowLineShadow = lineStyle.line.isShowShadow;
			this._isShowMarkerShadow = lineStyle.marker.isShowShadow;

			this._update();
			this.refresh();
		},

		updateProperties : function(propBag) {
			this._parseOptions(propBag);
		},

		hoverOnPoint : function(point, isShowLine) {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				alert('rew');
				return;
			}

			var xAxis = series[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var halfTickInterval = xAxis.getTickInterval() / 2;

			var start = 0, end = xAxisMajorTicks.length - 1;
			var found = false;
			var dimensionItemIndex;
			while (!found && start < end) {
				dimensionItemIndex = Math.round((start + end) / 2);
				var xPoint = xAxisMajorTicks[dimensionItemIndex] - point.x;
				if (Math.abs(xPoint) <= halfTickInterval)
					found = true;
				else if (xPoint <= 0) {
					start = dimensionItemIndex + 1;
				} else {
					end = dimensionItemIndex - 1;
				}
			}
			if (!found)
				dimensionItemIndex = start;

			if (isShowLine) {
				this._tpDecorativeRenderer.width(2).visible(true).color('rgb(0,0,0)').from({
					x : point.x,
					// [Ian 2012-3-28]Fix the issue, the
					// back ground line is not align
					// with the aixs
					y : series[0].getYAxis().getLastTickOffset()
				}).to({
					x : point.x,
					y : this.getLayer().size().height
				}).shadow({
					offsetX : 0,
					offsetY : 0,
					blur : 5,
					color : 'rgba(80,80,80,1)'
				});

				this.refresh();
			}

			// If the dimension item index do not change, we can
			// do not refresh the chart.
			if (this._dataCtxOnPoint && this._dataCtxOnPoint.dimensionItemIndex === dimensionItemIndex) {
				return this._dataCtxOnPoint;
			}

			// In Line chart, we should highlight the marker. So
			// we should insert the path renderer before the
			// marker in order to
			// highlight the marker
			var layer = this.getLayer();
			var pathRenderers = this._tpDecorativePathRenderers;
			for ( var i = 0, len = pathRenderers.length; i < len; i++) {
				// remove the path render those are exist, and
				// we must to remove the path shape and can not
				// reuse it, because if the chart area is
				// very small, and the path renderer is behind
				// of all the marker renderer, it will be
				// overridden.
				layer.removeShape(pathRenderers[i]);
			}
			this._tpDecorativePathRenderers = [];

			// show highlighted shape
			var highlights = this._highlights;
			for ( var j = 0, hLen = highlights.length; j < hLen; j++) {
				var highlightedItem = highlights[j];
				highlightedItem.borderShape.visible(true);
				highlightedItem.crossShape.visible(true);
			}

			// readd the path renderers, and we should add them
			// before every marker
			var s, shape;
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				if(this._seriesShapes[i].line.length > 0 || this._seriesShapes[i].marker.length > 0){
					s = series[i];
					shape = this._drawBorderShape(s._markerSymbol, i, dimensionItemIndex,
							1.5 * s._lineMarkerSize, s._seriesColor);
					shape.visible(true);
					this._tpDecorativePathRenderers[i] = shape;
	
					// hide highlighted shape
					var highlights = this._highlights;
					for ( var j = 0, hLen = highlights.length; j < hLen; j++) {
						var highlightedItem = highlights[j];
						if (highlightedItem.measureIndex == i
								&& highlightedItem.dimensionItemIndex == dimensionItemIndex) {
							// Highlight and selected the same
							// shape, hide selected effect
							highlightedItem.borderShape.visible(false);
							highlightedItem.crossShape.visible(false);
						}
					}
				}
			}

			var dataCtxOnpoint = {};
			dataCtxOnpoint['dimensionItemIndex'] = dimensionItemIndex;

			this._dataCtxOnPoint = null;
			this._dataCtxOnPoint = dataCtxOnpoint;

			return dataCtxOnpoint;
		},

		onblur : function(point) {
			if(this._dataCtxOnPoint){
				var dimensionItemIndex = this._dataCtxOnPoint.dimensionItemIndex;
				if (this._isShowMarkerShadow) {
					for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
						this._seriesShapes[i].marker[dimensionItemIndex].shadow({
							offsetX : 1,
							offsetY : 2,
							blur : 2,
							color : 'rgba(0,0,0,0.5)'
						});
					}
				}
			}

			var highlights = this._highlights, highlightedItem;
			for ( var i = 0, hLen = highlights.length; i < hLen; i++) {
				highlightedItem = highlights[i];
				highlightedItem.borderShape.visible(true);
				highlightedItem.crossShape.visible(true);

				this._seriesShapes[highlightedItem.measureIndex].marker[highlightedItem.dimensionItemIndex]
						.shadow({
							offsetX : 0,
							offsetY : 0,
							blur : 0,
							color : 'rgba(0,0,0,0.5)'
						});
			}

			this._dataCtxOnPoint = null;
			// as we can reuse the decorative renderer, we only
			// make it invisible
			this._tpDecorativeRenderer.visible(false);

			// we can not reuse the decorative path renderers,
			// so we should remove them and readd them agian
			// when we need them.
			var layer = this.getLayer();
			for ( var i = 0, pathRenderers = this._tpDecorativePathRenderers, len = pathRenderers.length; i < len; i++) {
				// remove the path render those are exist, and
				// we must to remove the path shape and can not
				// reuse it, because if the chart area is
				// very small, and the path renderer is behind
				// of all the marker renderer, it will be
				// overridden.
				layer.removeShape(pathRenderers[i]);
			}
			this._tpDecorativePathRenderers = [];

			this.refresh();
		},

		/*
		 * Add border to shape while highlight and selected.
		 */
		_drawBorderShape : function(markerSymbol, measureIndex, dimensionItemIndex, withBorderSize,
				fillingColor) {
			var borderShape = null;
			var baseShape = this._seriesShapes[measureIndex].marker[dimensionItemIndex];
			var layer = this.getLayer();

			// initial shape
			switch (markerSymbol) {
			case Series.CIRCLEMARKER: {
				borderShape = layer.insertShapeBefore(new Circle(), baseShape);
				break;
			}
			default: {
				borderShape = layer.insertShapeBefore(new Polygon(), baseShape);
				break;
			}
			}

			// Add shape style
			borderShape.fillingColor('white').borderWidth(1).borderColor(fillingColor).visible(false);

			// draw shape
			var points = {
				x : this._seriesPoints[measureIndex][dimensionItemIndex].x,
				y : this._seriesPoints[measureIndex][dimensionItemIndex].y
			};
			switch (markerSymbol) {
			case Series.CIRCLEMARKER: {
				this._drawHighlightedCircleMark(borderShape, points, withBorderSize);
				break;
			}

			case Series.TRIANGLEMARKER: {
				this._drawHighlightedTriangleMark(borderShape, points, withBorderSize);
				break;
			}

			case Series.DIAMONDMARKER: {
				this._drawHighlightedDiamondMarkAndLine(borderShape, points, withBorderSize);
				break;
			}

			default: {
				this._drawHighlightedCircleMark(borderShape, points, withBorderSize);
				break;
			}
			}

			// Remove highlighted marker's shadow
			baseShape.shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 0,
				color : 'rgba(0,0,0,0.5)'
			});

			return borderShape;
		},

		/*
		 * Draw Cross Label to selected item
		 */
		_drawCrossShape : function(measureIndex, dimensionItemIndex, borderSize, borderShape,
				fillingColor) {
			var points = {
				x : this._seriesPoints[measureIndex][dimensionItemIndex].x,
				y : this._seriesPoints[measureIndex][dimensionItemIndex].y
			};
			var crossLen = borderSize / 2 + 2;
			var crossShape = this.getLayer().insertShapeAfter(new Paths(), borderShape);
			crossShape.reset();
			crossShape.moveTo(points.x, points.y - crossLen);
			crossShape.lineTo(points.x, points.y + crossLen);
			crossShape.moveTo(points.x - crossLen, points.y);
			crossShape.lineTo(points.x + crossLen, points.y);
			crossShape.borderWidth(1).borderColor(fillingColor).visible(false);
			return crossShape;
		},

		_drawHighlightedCircleMark : function(shape, point, withBorderSize) {
			shape.center({
				x : point.x,
				y : point.y
			}).radius(withBorderSize / 2);
		},

		_drawHighlightedTriangleMark : function(shape, point, withBorderSize) {
			shape.reset();
			this._drawTriangleVertices(shape, point, withBorderSize);
			shape.close();
		},

		_drawHighlightedDiamondMarkAndLine : function(shape, point, withBorderSize) {
			shape.reset();
			this._drawDiamondVertices(shape, point, withBorderSize);
			shape.close();
		},

		_drawTriangleVertices : function(shape, point, size) {
			var radius = size / 2;
			shape.addVertices(point.x, point.y - radius);
			shape.addVertices(point.x + radius * Math.sqrt(3) / 2, point.y + radius / 2);
			shape.addVertices(point.x - radius * Math.sqrt(3) / 2, point.y + radius / 2);
		},

		_drawDiamondVertices : function(shape, point, size) {
			shape.addVertices(point.x, point.y - size / 2);
			shape.addVertices(point.x + size / 2, point.y);
			shape.addVertices(point.x, point.y + size / 2);
			shape.addVertices(point.x - size / 2, point.y);
		}
	});

	return lineRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TextRuler, Paths, TextLine, Line, Circle, Rect, Polygon, TypeUtils) {
	var TooltipRenderer = function(options, layer) {
		this._layer = layer;

		this._display = {
			singleMeasure : {
				text : {
					font : 'bold 10px Arial',
					color : "#c2c2c2"
				},
				value : {
					font : 'bold 14px Arial',
					color : "#ffffff"
				},
				padding : {
					vertical : 9,
					horizontal : 10
				}
			},
			multipleMeasure : {
				text : {
					font : 'bold 10px Arial',
					color : "#c2c2c2"
				},
				value : {
					font : 'bold 12px Arial',
					color : "#ffffff"
				},
				padding : {
					vertical : 8,
					horizontal : 10,
					inline : 6,
					markerGap : 7,
					defaultSpace : 8
				}
			},
			valueFormat : [],
			textFormat : null,
			maxDimensionLabelWidth : 150,
			maxMeasureLabelWidth : 80
		};

		this._finalWidth = {
			dimension : undefined,
			measure : undefined,
			value : undefined
		};

		this._shapeLayout = {
			padding : 3,
			radius : 4,
			markerWidth : 12,
			markerHeight : 8,
			borderWidth : 2
		};

		this._shapes = {
			tooltip : null,
			dimensionLabel : null,
			separateLine : null,
			measureLabels : [],
			measureMarks : [],
			valueLabels : []
		};

		this._currentValue = {
			dimensionIndex : undefined,
			offset : undefined
		}

		this._parseOptions(options);
	};

	TooltipRenderer.prototype._parseOptions = function(options) {
		this._dataTree = options.dataTree;
		this._metaData = options.metaData;
		this._options = options.properties;

		this._borderColor = "#cdcdcd";
		this._fill = "rgba(0,0,0,0.8)";
		
		var tooltipOptions = this._options.tooltip;
		if (tooltipOptions.text.color != null) {
		    this._display.singleMeasure.text.color = tooltipOptions.text.color;
		    this._display.multipleMeasure.text.color = tooltipOptions.text.color;
		}
		if (tooltipOptions.text.font != null) {
            this._display.singleMeasure.text.font = tooltipOptions.text.font;
            this._display.multipleMeasure.text.font = tooltipOptions.text.font;
        }
        if (tooltipOptions.mainValue.color != null) {
            this._display.singleMeasure.value.color = tooltipOptions.mainValue.color;
            this._display.multipleMeasure.value.color = tooltipOptions.mainValue.color;
        }
        if (tooltipOptions.mainValue.font != null) {
            this._display.singleMeasure.value.font = tooltipOptions.mainValue.font;
            this._display.multipleMeasure.value.font = tooltipOptions.mainValue.font;
        }

        this._display.textFormat = tooltipOptions.text.formatString;
        var lastFormat = null;
        for (var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
            if (TypeUtils.isExist(tooltipOptions.mainValue.formatString[i])) {
                lastFormat = this._display.valueFormat[i] = tooltipOptions.mainValue.formatString[i];
            } else {
                this._display.valueFormat[i] = lastFormat;
            }
        }
        
        this._size = this.getShapeSize();
        this._markerPos = this._getMarkerPos();
	};

	TooltipRenderer.prototype.drawShape = function(offset) {
		if (offset === this._currentValue.offset) {
			return;
		} else {
			this._currentValue.offset = offset;
		}

		var xStart = this._shapeLayout.padding, yStart = this._shapeLayout.padding, radius = this._shapeLayout.radius, markerWidth = this._shapeLayout.markerWidth, markerHeight = this._shapeLayout.markerHeight;

		var width = this._size.width, height = this._size.height;
		if (this._markerPos == 'left') {
			xStart += markerHeight;
		}
		if (this._markerPos == 'top') {
			yStart += markerHeight;
		}

		if (this._shapes.tooltip === null) {
			this._shapes.tooltip = this._layer.addShape(new Paths());
		} else {
			this._shapes.tooltip = this._layer.replaceShape(this._shapes.tooltip, new Paths());
		}
		var tooltipShape = this._shapes.tooltip;

		// start point at the left top corner
		tooltipShape.moveTo(xStart, yStart + radius);
		if (this._markerPos == 'left') {
			tooltipShape.lineTo(xStart, yStart + height / 2 - offset - markerWidth / 2);
			tooltipShape.lineTo(xStart - markerHeight, yStart + height / 2 - offset);
			tooltipShape.lineTo(xStart, yStart + height / 2 - offset + markerWidth / 2);
		}
		tooltipShape.lineTo(xStart, yStart + height - radius);
		tooltipShape.arc({
			x : xStart + radius,
			y : yStart + height - radius
		}, radius, Math.PI, Math.PI / 2, false);

		// bottom border
		if (this._markerPos == 'bottom') {
			tooltipShape.lineTo(xStart + width / 2 + offset - markerWidth / 2, yStart + height);
			tooltipShape.lineTo(xStart + width / 2 + offset, yStart + height + markerHeight);
			tooltipShape.lineTo(xStart + width / 2 + offset + markerWidth / 2, yStart + height);
		}
		tooltipShape.lineTo(xStart + width - radius, yStart + height);
		tooltipShape.arc({
			x : xStart + width - radius,
			y : yStart + height - radius
		}, radius, Math.PI / 2, 0, false);

		// right border
		if (this._markerPos == 'right') {
			tooltipShape.lineTo(xStart + width, yStart + height / 2 - offset + markerWidth / 2);
			tooltipShape.lineTo(xStart + width + markerHeight, yStart + height / 2 - offset);
			tooltipShape.lineTo(xStart + width, yStart + height / 2 - offset - markerWidth / 2);
		}
		tooltipShape.lineTo(xStart + width, yStart + radius);
		tooltipShape.arc({
			x : xStart + width - radius,
			y : yStart + radius
		}, radius, 0, 3 * Math.PI / 2, false);

		// top border
		if (this._markerPos == 'top') {
			tooltipShape.lineTo(xStart + width / 2 + offset + markerWidth / 2, yStart);
			tooltipShape.lineTo(xStart + width / 2 + offset, yStart - markerHeight);
			tooltipShape.lineTo(xStart + width / 2 + offset - markerWidth / 2, yStart);
		}
		tooltipShape.lineTo(xStart + radius, yStart);
		tooltipShape.arc({
			x : xStart + radius,
			y : yStart + radius
		}, radius, 3 * Math.PI / 2, Math.PI, false);
		tooltipShape.fillingColor({
			t : 'css',
			v : 'rgba(0,0,0,0.8)'
		}).borderWidth(this._shapeLayout.borderWidth).borderColor(this._borderColor).shadow({
			offsetX : 1,
			offsetY : 1,
			blur : 5,
			color : 'rgba(0,0,0,0.75)'
		});
	};

	TooltipRenderer.prototype.drawContent = function(index) {
		if (index === this._currentValue.dimensionIndex) {
			return;
		} else {
			this._currentValue.dimensionIndex = index;
		}

		var dimensionLabels = this._dataTree.getSubMemberLabels();
		var measureLabels = this._metaData.measureMembers;
		var xStart = this._shapeLayout.padding;
		var yStart = this._shapeLayout.padding;
		if (this._markerPos === 'left') {
			xStart += this._shapeLayout.markerHeight;
		}
		if (this._markerPos === 'top') {
			yStart += this._shapeLayout.markerHeight;
		}

		var display;
		var textFormat = sap.common.globalization.NumericFormatManager.getFormat(this._display.textFormat);
		var _self = this;
		if (measureLabels.length == 1) {
			// single measure
			display = this._display.singleMeasure;

			if (this._shapes.dimensionLabel === null) {
				this._shapes.dimensionLabel = this._layer.addShape(new TextLine());
			} else {
				this._shapes.dimensionLabel = this._layer.replaceShape(this._shapes.dimensionLabel, new TextLine());
			}

			if (this._shapes.valueLabels.length === 0) {
				this._shapes.valueLabels[0] = this._layer.addShape(new TextLine());
			} else {
				this._shapes.valueLabels[0] = this._layer.replaceShape(this._shapes.valueLabels[0], new TextLine());
			}
            
            var text = TypeUtils.isExist(textFormat) ? textFormat.display(dimensionLabels[index]) : dimensionLabels[index];
			var dimensionWidth = TextRuler.measureText(display.text.font, text).width;
			this._shapes.dimensionLabel.text(text).font(display.text.font).textColor(
					display.text.color).width(
					this._finalWidth.dimension > dimensionWidth ? dimensionWidth : this._finalWidth.dimension).visible(
					true);
			var value = this._dataTree.getMeasuresAt([ index ])[measureLabels[0]].sum.result;
			var valueFormatter = sap.common.globalization.NumericFormatManager.getFormat(this._display.valueFormat[0]);
			value = TypeUtils.isExist(valueFormatter) ? valueFormatter.display(value) : value;
			var valueWidth = TextRuler.measureText(display.value.font, value).width;
			this._shapes.valueLabels[0].text(value).font(display.value.font).textColor(display.value.color).width(
					this._finalWidth.value > valueWidth ? valueWidth : this._finalWidth.value).visible(true);

			var dimensionLabelBottom;
			if (this._markerPos === 'left') {
				this._shapes.dimensionLabel.topLeft([ xStart + display.padding.horizontal,
						yStart + display.padding.vertical ]);
				dimensionLabelBottom = this._shapes.dimensionLabel.bottomLeft().y;
				this._shapes.valueLabels[0].topLeft([ xStart + display.padding.horizontal,
						dimensionLabelBottom + display.padding.vertical ]);
			} else if (this._markerPos === 'top' || this._markerPos === 'bottom') {
				var centerX = xStart + this._size.width / 2;
				this._shapes.dimensionLabel.topCenter([ centerX, yStart + display.padding.vertical ]);
				dimensionLabelBottom = this._shapes.dimensionLabel.bottomLeft().y;
				this._shapes.valueLabels[0].topCenter([ centerX, dimensionLabelBottom + display.padding.vertical ]);
			}

		} else {
			// multiple measure
			display = this._display.multipleMeasure;
			var centerX = xStart + this._size.width / 2;

			if (this._shapes.dimensionLabel != null) {
				this._layer.removeShape(this._shapes.dimensionLabel);
			}
			
            var text = TypeUtils.isExist(textFormat) ? textFormat.display(dimensionLabels[index]) : dimensionLabels[index];
			var dimensionWidth = TextRuler.measureText(display.text.font, text).width;
			this._shapes.dimensionLabel = this._layer.addShape(new TextLine()).text(text).font(
					display.text.font).textColor(display.text.color).width(
					this._finalWidth.dimension > dimensionWidth ? dimensionWidth : this._finalWidth.dimension).visible(
					true).topCenter([ centerX, yStart + display.padding.vertical ]);

			var yOffset = this._shapes.dimensionLabel.bottomLeft().y + display.padding.vertical;
			var xRight = xStart + this._size.width - display.padding.horizontal;
			var xLeft = xStart + display.padding.horizontal;

			this._shapes.separateLine = this._layer.addShape(new Line()).from({
				x : xLeft,
				y : yOffset
			}).to({
				x : xRight,
				y : yOffset
			}).width(1).color({
				t : 'lg',
				s : {
					x : xLeft,
					y : yOffset
				},
				e : {
					x : xRight,
					y : yOffset
				},
				st : [ {
					o : 0,
					v : "#202020"
				}, {
					o : 0.5,
					v : "#ffffff"
				}, {
					o : 1,
					v : "#202020"
				} ]
			}).visible(true);

			yOffset += display.padding.vertical;
			var measureOptions = this._options._additional;
			for ( var i = 0, len = measureLabels.length; i < len; i++) {

				if (this._shapes.valueLabels[i] != undefined) {
					this._layer.removeShape(this._shapes.valueLabels[i]);
				}
				var value = this._dataTree.getMeasuresAt([ index ])[measureLabels[i]].sum.result;
				var valueFormatter = sap.common.globalization.NumericFormatManager.getFormat(this._display.valueFormat[i]);
				value = TypeUtils.isExist(valueFormatter) ? valueFormatter.display(value) : value;
				var valueSize = TextRuler.measureText(display.value.font, value);
				this._shapes.valueLabels[i] = this._layer.addShape(new TextLine()).text(value).font(display.value.font)
						.textColor(display.value.color).width(valueSize.width).visible(true).rightCenter(
								[ xRight, yOffset + valueSize.height / 2 ]);

				var labelSize = TextRuler.measureText(display.text.font, measureLabels[i]);
				if (this._shapes.measureMarks[i] == undefined) {
					// add measure marks once, no need change
					this._shapes.measureMarks[i] = _drawMarkup(measureOptions.legendMarkers[i], {
						x : xLeft,
						y : yOffset + valueSize.height / 2 - labelSize.height / 2
					}, measureOptions.colorList[i], labelSize.height);
				}

				var measureTextX = xLeft + labelSize.height + display.padding.markerGap;
				var measureWidth = labelSize.width > this._finalWidth.measure ? this._finalWidth.measure
						: labelSize.width;
				if (this._shapes.measureLabels[i] == undefined) {
					// add measure labels once, no need change
					this._shapes.measureLabels[i] = this._layer.addShape(new TextLine()).text(measureLabels[i]).font(
							display.text.font).textColor(display.text.color).width(measureWidth).visible(true)
							.leftCenter([ measureTextX, yOffset + valueSize.height / 2 ]);
					;
				}

				yOffset += valueSize.height + display.padding.inline;

			}

		}

		function _drawMarkup(markerType, point, fillColor, size) {
			var markerShape = null;
			var markerSize = size;
			switch (markerType) {
			case "circle":
				markerShape = _self._layer.addShape(new Circle()).fillingColor(fillColor).center({
					x : point.x + markerSize / 2,
					y : point.y + markerSize / 2
				}).radius(markerSize / 2);
				break;
			case "diamond":
				markerShape = _self._layer.addShape(new Polygon());
				markerShape.fillingColor(fillColor);
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize / 2);
				markerShape.addVertices(point.x + markerSize / 2, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize / 2);
				markerShape.close();
				break;
			case "triangle":
				markerShape = _self._layer.addShape(new Polygon());
				markerShape.fillingColor(fillColor);
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize);
				markerShape.close();
				break;
			case "rect":
			default:
				markerShape = _self._layer.addShape(new Rect());
				markerShape.topLeft([ point.x, point.y ]).width(markerSize).height(markerSize).color(fillColor);
				break;
			}
			return markerShape;
		}
	};

	TooltipRenderer.prototype.getSize = function() {
		var width = this._size.width + this._shapeLayout.padding * 2;
		var height = this._size.height + this._shapeLayout.padding * 2;
		if (this._markerPos === 'bottom' || this._markerPos === 'top') {
			height += this._shapeLayout.markerHeight;
		} else if (this._markerPos === 'left' || this._markerPos === 'right') {
			width += this._shapeLayout.markerHeight;
		}
		return {
			width : width,
			height : height
		}
	};

	TooltipRenderer.prototype.getShapeSize = function() {
		var width = 0, height = 0;
		var dimensionLabels = this._dataTree.getSubMemberLabels();
		var measureLabels = this._metaData.measureMembers;

		var maxDimensionWidth = 0, maxDimensionHeight = 0, maxMeasureWidth = 0, maxMeasureHeight = 0, maxValueWidth = 0, maxValueHeight = 0;
		var display = measureLabels.length > 1 ? this._display.multipleMeasure : this._display.singleMeasure;
		var textFormat = sap.common.globalization.NumericFormatManager.getFormat(this._display.textFormat);

		var _self = this;
		var getMeasurePartWidth = function() {
			var max = maxMeasureWidth > _self._display.maxMeasureLabelWidth ? _self._display.maxMeasureLabelWidth
					: maxMeasureWidth;
			_self._finalWidth.measure = max;
			return maxMeasureHeight + display.padding.markerGap + display.padding.defaultSpace + max + maxValueWidth;
		};

		// get max size for all text and value
		for ( var i = 0, ilen = measureLabels.length; i < ilen; i++) {
			var labelSize = TextRuler.measureText(display.text.font, measureLabels[i]);
			maxMeasureWidth = labelSize.width > maxMeasureWidth ? labelSize.width : maxMeasureWidth;
			maxMeasureHeight = labelSize.height > maxMeasureHeight ? labelSize.height : maxMeasureHeight;

			for ( var j = 0, jlen = dimensionLabels.length; j < jlen; j++) {
				if (i == 0) {
                    var text = TypeUtils.isExist(textFormat) ? textFormat.display(dimensionLabels[j]) : dimensionLabels[j];
					var labelSize = TextRuler.measureText(display.text.font, text);
					maxDimensionWidth = labelSize.width > maxDimensionWidth ? labelSize.width : maxDimensionWidth;
					maxDimensionHeight = labelSize.height > maxDimensionHeight ? labelSize.height : maxDimensionHeight;
				}

				if(this._dataTree.getMeasuresAt([ j ])){
					var value = this._dataTree.getMeasuresAt([ j ])[measureLabels[i]].sum.result;
					var valueFormatter = sap.common.globalization.NumericFormatManager.getFormat(this._display.valueFormat[i]);
					value = TypeUtils.isExist(valueFormatter) ? valueFormatter.display(value) : value;
					var valueSize = TextRuler.measureText(display.value.font, value);
					maxValueWidth = valueSize.width > maxValueWidth ? valueSize.width : maxValueWidth;
					maxValueHeight = valueSize.height > maxValueHeight ? valueSize.height : maxValueHeight;
				}
			}
		}

		if (measureLabels.length == 1) {
			if (maxValueWidth < maxDimensionWidth && this._display.maxDimensionLabelWidth > maxDimensionWidth) {
				width = maxDimensionWidth + display.padding.horizontal * 2;
				this._finalWidth.dimension = maxDimensionWidth;
			} else {
				width = maxValueWidth + display.padding.horizontal * 2;
				this._finalWidth.dimension = maxValueWidth;
			}
			height = maxValueHeight + maxDimensionHeight + display.padding.vertical * 3;
			this._finalWidth.value = maxValueWidth;
		} else {
			var measurePartWidth = getMeasurePartWidth();
			var dimensionPartWidth = maxDimensionWidth > this._display.maxDimensionLabelWidth ? this._display.maxDimensionLabelWidth
					: maxDimensionWidth;
			width = (measurePartWidth > dimensionPartWidth ? measurePartWidth : dimensionPartWidth) + 2
					* display.padding.horizontal;
			height = maxDimensionHeight + display.padding.vertical * 4 + measureLabels.length * maxValueHeight
					+ (measureLabels.length - 1) * display.padding.inline;
			this._finalWidth.dimension = (measurePartWidth > dimensionPartWidth ? measurePartWidth : dimensionPartWidth);
			this._finalWidth.value = maxValueWidth;
		}

		return {
			width : width,
			height : height
		}
	};

	TooltipRenderer.prototype.reset = function(options) {
		if (this._shapes.tooltip != null) {
			this._layer.removeShape(this._shapes.tooltip);
		}
		if (this._shapes.dimensionLabel != null) {
			this._layer.removeShape(this._shapes.dimensionLabel);
		}
		if (this._shapes.separateLine != null) {
			this._layer.removeShape(this._shapes.separateLine);
		}
		for ( var i = 0, len = this._shapes.measureLabels.length; i < len; i++) {
			this._layer.removeShape(this._shapes.measureLabels[i]);
		}
		for ( var i = 0, len = this._shapes.measureMarks.length; i < len; i++) {
			this._layer.removeShape(this._shapes.measureMarks[i]);
		}
		for ( var i = 0, len = this._shapes.valueLabels.length; i < len; i++) {
			this._layer.removeShape(this._shapes.valueLabels[i]);
		}

		this._dataTree = options.dataTree;
		this._metaData = options.metaData;

		this._finalWidth = {
			dimension : undefined,
			measure : undefined,
			value : undefined
		};

		this._shapes = {
			tooltip : null,
			dimensionLabel : null,
			separateLine : null,
			measureLabels : [],
			measureMarks : [],
			valueLabels : []
		};

		this._currentValue = {
			dimensionIndex : undefined,
			offset : undefined
		}

		this._parseOptions(options);
	};

	TooltipRenderer.prototype._getMarkerPos = function() {
		switch (this._options.type) {
		case 'bar':
			return 'left';
		case 'combination':
			return 'bottom';
		default:
			return;
		}
	};
	
	TooltipRenderer.prototype.getMarkerHeight = function() {
	    // include border
        return this._shapeLayout.markerHeight + this._shapeLayout.borderWidth;
    };
	
	return TooltipRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipRenderer',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Canvas2DSurfaceComponent, PropsMgr, Layer, TextRuler, TooltipRenderer) {
	
	/**
	 * Represents a <code>Canvas2DSurfaceComponent</code> object been used to
	 * draw chart tooltip.
	 */
	var TooltipComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.tooltip;

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();

			this._initialize();
		},

		_initialize : function() {
			this._renderer = new TooltipRenderer(this._options, this._layer);
		},

		getSize : function() {
			return this._renderer.getSize();
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
		},

		draw : function(index, offset) {
			// make sure draw tooltip shape before content
			this._renderer.drawShape(offset);
			this._renderer.drawContent(index);
			this._layer.setNeedsDisplay();
		},

		reset : function(options) {
			this._renderer.reset(options);
		},
		
		getMarkerHeight : function() {
		    return this._renderer.getMarkerHeight();
		}

	});
	return TooltipComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.LinearAxisRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.BasicAxisRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.FoucsCalculator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, Math, TextRuler, TypeUtils, BasicAxisRenderer,
		FoucsCalculator, PositionCalculator) {
	var linearAxisRenderer = ObjectUtils
			.derive(
					BasicAxisRenderer,
					{

						constructor : function(options) {
							this._laxr_initialize();
							return this;
						},

						/**
						 * Init the Linear Axis Renderer
						 */
						_laxr_initialize : function() {

							var opts = this._baxr_options;

							this._labels.itemsValue = [];

							var fCalculator = FoucsCalculator;

							var fcl = fCalculator.createFocus('full');

							var bounds = fCalculator.validateBounds(
									opts.minValue, opts.maxValue);

							this._minValue = bounds.min;
							this._maxValue = bounds.max;

							// The value precision
							this.VALUE_LABEL_PRECISION = 10000000;

							var focus = fcl.calculateFocus({
								lineScaling : this._lineScaling,
								minValue : this._minValue,
								maxValue : this._maxValue
							});

							this._minValue = parseFloat(focus.min.toFixed(8));
							this._maxValue = parseFloat(focus.max.toFixed(8));
							this._majorInterval = focus.major;
							this._minorInterval = parseFloat(focus.minor.toFixed(8));

							this._hideOverlappingLabels = true;

							this._valueAxisFT = sap.common.globalization.NumericFormatManager
									.getFormat(this._labels.formatString[0]);
							this._FTminValue = TypeUtils
									.isExist(this._valueAxisFT) ? this._valueAxisFT
									.display(this._minValue)
									: this._minValue;
							this._FTmaxValue = TypeUtils
									.isExist(this._valueAxisFT) ? this._valueAxisFT
									.display(this._maxValue)
									: this._maxValue;
						},

						/**
						 * 
						 * @param distance
						 *            the length of axis
						 * @returns if distance is undefined, return the
						 *          distance.
						 */
						distance : function(distance) {
							if (TypeUtils.isExist(distance)) {
								this._distance = distance;

								this._createLabelsAndPosition();

								if (!this._isLabelHorizontal()) {
									this._direction = 'vertical';
								}

								if (this._hideOverlappingLabels) {
									// Don't remove category labels, or labels
									// that can be rotated but haven't been
									this
											._removeOverlappingLabels(this._labels.itemsPosition.length);
								}

								var tu = TextRuler;

								if (this._position == 'hb'
										|| this._position == 'ht') {
									if (this._direction == 'horizontal') {
										this._axisMatrics.left = tu
												.measureWidth(
														this._labels.font,
														this._labels.itemsValue[0]
																.value()) / 2;
										this._axisMatrics.right = tu
												.measureWidth(
														this._labels.font,
														this._labels.itemsValue[this._labels.itemsValue.length - 1]
																.value()) / 2;
									} else {
										this._axisMatrics.left = this._axisMatrics.right = tu
												.measureHeight(
														this._labels.font,
														this._FTmaxValue) / 2;
									}

								} else {
									this._axisMatrics.bottom = this._axisMatrics.top = tu
											.measureHeight(this._labels.font,
													this._FTmaxValue) / 2;
								}

								return this;
							}
							return this._distance;
						},

						/**
						 * Draws the labels at given intervals
						 * 
						 * @param positionMultiplier
						 *            converts from a value based on the min and
						 *            max bounds to a position in pixels
						 */
						_createLabelsAndPosition : function() {
							if (!this._labels.show) {
								return;
							}

							var majorInterval = this._majorInterval;
							var minorInterval = this._minorInterval;

							var positionMultiplier = this
									._calculatePositionMultiplier(false);

							var positionDelta = 0.0;
							if (this._hideOverlappingLabels) {
								positionDelta = 0.5;
							}

							var numLabels = 0;
							var labelPositions = this._labels.itemsPosition = [];
							this._labels.itemsValue = [];
							var value = this._minValue;
							var position = this._calculatePositionFromValue(
									value, positionMultiplier);
							var i = 0;
							// Fix the bug:VISUAL-935 [Ian 2012-3-4] we should
							// keep the precision when float calculation in
							// javascript
							while ((Math.round(value
									* this.VALUE_LABEL_PRECISION) / this.VALUE_LABEL_PRECISION) < (Math
									.round(this._maxValue
											* this.VALUE_LABEL_PRECISION) / this.VALUE_LABEL_PRECISION)) {
								var label = new this.Label();
								var FTvalue = TypeUtils
										.isExist(this._valueAxisFT) ? this._valueAxisFT
										.display(value)
										: value;
								label.visible(true);
								label.value(FTvalue);
								// Keep the position as a percentage of distance
								// because our multiplier isn't correct yet
								labelPositions.push((position) || 0);
								this._labels.itemsValue.push(label);
								var nextInt = this._calculateNextValidInterval(
										position, positionMultiplier, value,
										majorInterval, positionDelta);
								position = nextInt.position;
								if (value >= nextInt.value)
									break; // make sure we don't get an infinte
								// loop
								value = nextInt.value;
								i++;
							}

							// Always draw the max value
							position = this._calculatePositionFromValue(
									this._maxValue, positionMultiplier);
							label = new this.Label();
							label.visible(true);
							label
									.value(TypeUtils.isExist(this._valueAxisFT) ? this._valueAxisFT
											.display(value)
											: value);
							labelPositions.push((position) || 0); // Keep the
							// position
							// as a
							// percentage
							this._labels.itemsValue.push(label);
						},

						/**
						 * Calculates the next position in an interval that
						 * differs visually from the previous position. Large
						 * ranges with small intervals can cause many values to
						 * occupy the same pixel position. We want to avoid
						 * iterating through large numbers of undrawable
						 * positions.
						 * 
						 * @param lastPos
						 *            the last position that was drawn
						 * @param posMultiplier
						 *            the multiplier to pass to a
						 *            PositionCalculator
						 * @param lastValue
						 *            the last value that was drawn
						 * @param interval
						 *            the interval by which values are
						 *            incremented
						 * @param posDelta
						 *            the minimum amount by which the position
						 *            must change
						 * 
						 * @return the next position in the interval that should
						 *         be drawn and the value it represents.
						 */
						_calculateNextValidInterval : function(lastPos,
								posMultiplier, lastValue, interval, posDelta) {
							if (!TypeUtils.isExist(posDelta)) {
								posDelta = 0.5;
							}

							// Fix the isssue: As the float precision issue, we
							// should control the precision of the value
							var nextValue = this._add(lastValue, interval);
							var position = this._calculatePositionFromValue(
									nextValue, posMultiplier);

							if (Math.abs(position - lastPos) < posDelta) {
								var minNextValue;

								minNextValue = this
										._calculateValueFromPosition(position
												+ posDelta, posMultiplier);

								var numIntervals = Math
										.ceil((minNextValue - nextValue)
												/ interval);
								nextValue += numIntervals * interval;
								position = this._calculatePositionFromValue(
										nextValue, posMultiplier);
							}

							return {
								position : position,
								value : nextValue
							};
						},

						/**
						 * Returns sum of arg1 and arg2.
						 * 
						 * As in javascript, we may get a result
						 * 0.600000000000001 from 0.4 and 0.2. So we should
						 * control the float precision
						 */
						_add : function(arg1, arg2) {
							var r1, r2, m;
							try {
								r1 = arg1.toString().split(".")[1].length;
							} catch (e) {
								r1 = 0;
							}
							try {
								r2 = arg2.toString().split(".")[1].length;
							} catch (e) {
								r2 = 0;
							}
							m = Math.pow(10, Math.max(r1, r2));
							return (arg1 * m + arg2 * m) / m;
						},

						/**
						 * Returns the position of a particular value.
						 * 
						 * @param value
						 *            the value from which to determine the line
						 *            position
						 * @param positionMultiplier
						 *            the multiplier to pass to a
						 *            PositionCalculator
						 * @return the position calculated
						 */
						_calculatePositionFromValue : function(value,
								positionMultiplier) {
							var position = 0;

							if (this._lineScaling == "linear")
								position = PositionCalculator
										.calculateLinearPosition(value,
												positionMultiplier,
												this._minValue);
							else
								position = PositionCalculator
										.calculateLogarithmicPosition(value,
												positionMultiplier,
												this._minValue);

							return position;
						},

						/**
						 * Returns the value of a particular position.
						 * 
						 * @param position
						 *            the line position from which to determine
						 *            the value
						 * @param positionMultiplier
						 *            the multiplier to pass to a
						 *            PositionCalculator
						 * @return the value calculated
						 */
						_calculateValueFromPosition : function(position,
								positionMultiplier) {

							var value = 0;
							if (this._lineScaling == "linear")
								value = PositionCalculator
										.calculateLinearValue(position,
												positionMultiplier,
												this._minValue);
							else
								value = PositionCalculator
										.calculateLogarithmicValue(position,
												positionMultiplier,
												this._minValue);

							return value;
						},

						/**
						 * 
						 * Returns the longest width among all the labels. In
						 * value axis, the longest width is either the min
						 * value's width or the max value's width
						 */
						_getLongestWidth : function() {
							if (!TypeUtils.isExist(this._longestWidth)
									|| this._longestWidth == 0) {
								var tu = TextRuler;

								if (this._FTminValue.toString().length > this._FTmaxValue
										.toString().length) {
									this._longestWidth = tu
											.measureWidth(this._labels.font,
													this._FTminValue);
								} else {
									this._longestWidth = tu
											.measureWidth(this._labels.font,
													this._FTmaxValue);
								}
							}
							return this._longestWidth;
						},

						/**
						 * Loops through the labels and removes some so that
						 * there is no overlap. Leaves a small amount of spacing
						 * between labels. Never removes the first or last
						 * label.
						 */
						_removeOverlappingLabels : function(numUsed) {
							var tu = TextRuler;

							if (numUsed < 3)
								return;

							/*
							 * _________ or a e i abcd| b f j efgh| c g k ijkl|
							 * d h m mnop|
							 */
							/*
							 * if the graphic is the similar with the below
							 * picture, we should calculate the total width or
							 * height is whether can fulfill all the labels
							 */

							var res = (this._position == 'hb' || this._position == 'ht')
									&& this._direction == 'vertical';
							res = res
									| (this._position == 'vl' || this._position == 'vr');

							if (res && this._lineScaling == 'linear') {

								var labelHeight = tu
										.measureHeight(this._labels.font);
								var labelTotalSpace = this._distance;
								var maxLabelsCount = Math.floor(labelTotalSpace
										/ labelHeight);

								this._hideOverlappingLabelsByBestInterval(
										numUsed, maxLabelsCount);
								this._removeLastTwoOverlappedLabel(numUsed);

							} else {
								/*
								 * if the lineScaling is Logarithmic
								 */
								var lastVisbleID = numUsed - 1;
								for ( var i = numUsed - 2; i >= 1; i--) {

									var currentLabel = this._labels.itemsValue[i];

									if (0 == currentLabel.value()) {
										continue;
									}

									// if the label overlaps with the last label
									// that stayed visible
									// or the label overlaps with the origin
									// label

									// to be implemented:

									/*
									 * var lastVisibleID:int = numUsed - 1;
									 * for(var i:int = numUsed - 2; i >= 1; i--) {
									 * var currentLabel:UITextField =
									 * this._labels[i];
									 * 
									 * //always show zero! if(currentLabel.text ==
									 * "0") { continue; }
									 * 
									 * //if the label overlaps with the last
									 * label that stayed visible //or the label
									 * overlaps with the origin label
									 * if(this.invertScale) {
									 * if(this._labels[lastVisibleID].textHeight >
									 * (currentLabel.y -
									 * this._labels[lastVisibleID].y) ||
									 * this._labels[0].y - currentLabel.y <
									 * currentLabel.textHeight) {
									 * currentLabel.visible = false; } else
									 * lastVisibleID = i; } else {
									 * if(currentLabel.textHeight >
									 * (this._labels[lastVisibleID].y -
									 * currentLabel.y) || currentLabel.y -
									 * this._labels[0].y <
									 * this._labels[0].textHeight) {
									 * currentLabel.visible = false; } else
									 * lastVisibleID = i; } }
									 */
								}

							}
						},

						/**
						 * When the user set Manual Scale & Size of Division in
						 * property sheet, some times the overlap happens on the
						 * last two labels. For example: minimun=0, maximum=10,
						 * Size of Division=9.8. The following code is to avoid
						 * the overlap.
						 */
						_removeLastTwoOverlappedLabel : function(numUsed) {
							// to be implements, now focus is the stardand, if
							// the focus is the ManualFocus, please based on the
							// following code to
							// implement our feature;
							/*
							 * if(this.focus is ManualFocus) { var
							 * lastLabel1:FormattedUITextField =
							 * this._labels[numUsed-1]; var
							 * lastLabel2:FormattedUITextField; for(var i:int =
							 * numUsed-2;i>0;i--) { if(this._labels[i].visible) {
							 * lastLabel2 = this._labels[i]; break; } }
							 * 
							 * if(lastLabel2 == null) return;
							 * 
							 * if(this.orientation == "horizontal") {
							 * if(lastLabel1.textHeight>Math.abs(lastLabel2.y -
							 * lastLabel1.y)) lastLabel2.visible = false; } else {
							 * if(lastLabel1.textHeight>Math.abs(lastLabel1.x -
							 * lastLabel2.x)) lastLabel2.visible = false; } }
							 */
						},

						/**
						 * Hide some labels to avoid overlapping.
						 * 
						 * For example:The original labels:
						 * [0,1,2,3,4,5,6,7,8,9], numUsed = 10, maxLabels = 5.
						 * 
						 * The result is: interval = 2, displayed
						 * labels:[0,3,6,9].
						 */
						_hideOverlappingLabelsByBestInterval : function(
								numUsed, maxLabelsCount) {

							if (maxLabelsCount >= numUsed) {
								return;
							}

							// Calculate the best interval to display these
							// labels
							var interval = 0;
							for (; interval <= numUsed - 2; interval++) {
								if ((0 == (numUsed - 1) % (interval + 1))
										&& ((numUsed - 1) / (interval + 1) <= maxLabelsCount)) {
									break;
								}
							}

							for ( var i = numUsed - 2; i >= 1; i--) {
								var currentLabel = this._labels.itemsValue[i];
								if (i % (interval + 1) != 0) {
									currentLabel.visible(false);
								}
							}
						}

					});

	return linearAxisRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.tooltip.BaseTooltip',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipComponent',
  version : '1.0.0'
}
],
function Setup(TypeUtils, TooltipComponent) {
    /**
     * Default options for drawing chart titles. See usage example below:
     * 
     * <pre>
     * {
     *  main : {
     *      text : 'This is the main title',
     *      font : 'bold 16px Arial',
     *      color : '#000000',
     *      horizontalAlign : 'center',
     *      show : false
     *  },
     *  sub : {
     *      text : 'This is the sub title',
     *      font : 'normal 14px Arial',
     *      color : '#000000',
     *      horizontalAlign : 'center',
     *      show : false
     *  }
     * }
     * </pre>
     * 
     * Note that the font size here represents a preferred size, it will be
     * automatically adjusted if the container can't contain such big font.
     */
    var defaultOptions = {
        enable : false,
        customization : null,
        mainValue : {
            color : undefined,
            font : undefined,
            formatString : ['']
        },
        // only for Pie Chart
        subValue : {
            color : undefined,
            font : undefined,
            formatString : ['']
        },
        text : {
            color : undefined,
            font : undefined,
            formatString : ''
        }
    };
    
	var BaseTooltip = function(options) {
		this._init(options);
	};

	var baseTooltipPro = BaseTooltip.prototype;

	baseTooltipPro._init = function(options) {
		this._parent = options.parent;
		this._options = options;
		this._component = new TooltipComponent({
			enable : true,
			hidden : true,
			anchor : {
				x : 0,
				y : 0
			},
			position : {
				x : 0,
				y : 0
			},
			size : {
				w : 0,
				h : 0
			},
			tooltip : {
				metaData : options.metaData,
				dataTree : options.dataTree,
				properties : options.properties
			},
			id : 'tooltipComponent'
		});

		this._parent.addSubComponent(this._component);

		this._size = this._getSize();

		this._component.size(this._size);
	};

	baseTooltipPro.getZone = function() {
		return {
			top : 0,
			left : 0,
			bottom : this._parent.size().height,
			right : this._parent.size().width
		};
	};

	baseTooltipPro.getPlotArea = function() {
		return this._parent._chartComponent.getPlotArea();
	};

	/**
	 * Show tooltip with giving event information
	 */
	baseTooltipPro.show = function(evt) {
		if (!this._options.properties.tooltip.enable) {
	        return;
	    }

		var isShow = false;
		var dimensionIndex = evt.data[0].dimensionItemIndex;
		var measureLabels = this._options.metaData.measureMembers;
		for ( var i = 0, len = measureLabels.length; i < len; i++) {
			var value = this._options.dataTree.getMeasuresAt([ dimensionIndex ]);
			if(TypeUtils.isDefined(value) && TypeUtils.isDefined(value[measureLabels[i]].sum.result) && value[measureLabels[i]].sum.result != 'NaN'){
				isShow = true;
				break;
			}
		}
		var dimensionLabels = this._options.dataTree.getSubMemberLabels();
		if(TypeUtils.isUndefined(dimensionLabels[dimensionIndex])){
			isShow = false;
		}
		if(!isShow) {
			this.hide();
			return; 
		}
	    
		var zone = this.getZone();
		var area = this.getPlotArea();
		var markerHeight = this._component.getMarkerHeight();
		var size = this._size;
		var point = evt.data[0].point;
		var x, y, offset = 0;
		switch (this._options.properties.type) {
		case 'bar':
			x = zone.right > (area.right + size.width - markerHeight) ? area.right - markerHeight : (zone.right - size.width);
			if (zone.top > point.y - size.height / 2) {
				y = zone.top;
				offset = zone.top - (point.y - size.height / 2);
			} else if (zone.bottom < point.y + size.height / 2) {
				y = zone.bottom - size.height;
				offset = zone.bottom - (point.y + size.height / 2);
			} else {
				y = point.y - size.height / 2;
			}
			break;
		case 'combination':
			y = zone.top < (area.top - size.height + markerHeight) ? (area.top - size.height + markerHeight) : zone.top;
			if (zone.left > point.x - size.width / 2) {
				x = zone.left;
				offset = point.x - size.width / 2 - zone.left
			} else if (zone.right < point.x + size.width / 2) {
				x = zone.right - size.width;
				offset = point.x + size.width / 2 - zone.right;
			} else {
				x = point.x - size.width / 2;
			}
			break;
		default:
			break;
		}
		this._component.position({
			x : x,
			y : y
		});
		this._draw(evt.data[0].dimensionItemIndex, offset);
		this._component.markShow();
	};

	/**
	 * Hide tooltip
	 */
	baseTooltipPro.hide = function(evt) {
	    if (!this._options.properties.tooltip.enable) {
            return;
        }
		this._component.markHide();
	};

	/**
	 * Reset exist tooltip status
	 */
	baseTooltipPro.reset = function(options) {
		this._options = options;
		this._component.reset(options);
		this._size = this._getSize();

		this._component.size(this._size);
	};

	baseTooltipPro._getSize = function() {
		return this._component.getSize();
	};

	baseTooltipPro._draw = function(dimensionIndex, offset) {
		return this._component.draw(dimensionIndex, offset);
	};
	
	baseTooltipPro.getCustomization = function() {
	    return this._options.properties.tooltip.customization;
	}
	
	BaseTooltip.getDefaultOption = function() {
	    return defaultOptions;
	};
	return BaseTooltip;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.DataTree',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils) {
	/**
	 * Tree structured data for storing hierarchical aggregated data which
	 * typically comes from OLAP query, you should never create the instance
	 * manually, parsing from json or querying a cube from DataTable instead.
	 * 
	 * @name sap.riv.vizkit.DataTree
	 * @constructor
	 */
	var DataTree = function(groupRoot, stats) {
		this._gr = groupRoot;
		this._stats = stats;
	};
	/**
	 * Instantiate a data tree from its JSON representation. Below is a
	 * recursive definition of a DATANODE of a data tree structure.
	 * 
	 * <pre>
	 * {
	 * 	  &quot;member&quot; : &quot;MEMBER_NAME&quot;,
	 * 	  &quot;measureValues&quot; : {
	 * 	     &quot;MEASURE_Name&quot; : {
	 * 									   &quot;AGGREGATE_TYPE&quot; : {
	 * 																	    &quot;result&quot; : &quot;&quot;,
	 * 																		&quot;tags&quot; : {}
	 * 									  								},
	 * 									   &quot;AGGREGATE_TYPE&quot; : {
	 * 															  			&quot;result&quot; : &quot;&quot;,
	 * 														      			&quot;tags&quot; : {}
	 * 														   			},
	 *                                        ....
	 *                                    },
	 *                     					 ...
	 * 				      				}
	 *    &quot;subNodes&quot; : [
	 *    				DATANODE,
	 *    				...
	 *    			   ]
	 * }
	 * </pre>
	 * 
	 * @function
	 * @name sap.riv.vizkit.DataTree#dataTreeFromJSON
	 * @param json
	 *            the JSON string representation of a
	 *            {@link sap.riv.vizkit.DataTree}.
	 * @returns {sap.riv.vizkit.DataTree}
	 */
	DataTree.dataTreeFromJSON = function(json) {
		var data = JSON.parse(json);
		var stats = [];
		var rootNode = {
			member : 'root',
			subNodes : {},
			subMembers : [],
			subMemberLabels : [],
			leafMemberCount : 0,
			result : {}
		};
		var pStack = [ {
			rNode : rootNode,
			cNode : data,
			traversed : false,
			cIdx : 0
		} ];
		while (pStack.length) {
			var cStackFrame = pStack[pStack.length - 1];
			var cNode = cStackFrame.cNode;
			var rNode = cStackFrame.rNode;
			if (!cStackFrame.traversed) {
				rNode.member = cNode.member;
				for ( var measureName in cNode.measureValues) {
					rNode.result[measureName] = ObjUtils.extend({}, cNode.measureValues[measureName]);
				}
				cStackFrame.traversed = true;
				// update the statistics
				stats[pStack.length - 1] = stats[pStack.length - 1] || {
					longest : cNode.member,
					shortest : cNode.member,
					allMembers : []
				};
				stats[pStack.length - 1].allMembers.push(cNode.member);
				if (stats[pStack.length - 1].longest.length < cNode.member.length) {
					stats[pStack.length - 1].longest = cNode.member;
				}
				if (stats[pStack.length - 1].shortest.length > cNode.member.length) {
					stats[pStack.length - 1].shortest = cNode.member;
				}
			}
			if (cNode.subNodes.length > cStackFrame.cIdx) {
				// down the tree
				rNode.subMembers.push(cNode.subNodes[cStackFrame.cIdx].member);
				rNode.subMemberLabels.push(cNode.subNodes[cStackFrame.cIdx].label);
				var rSubNode = {
					member : '',
					subNodes : {},
					subMembers : [],
					subMemberLabels : [],
					leafMemberCount : 0,
					result : {}
				};
				rNode.subNodes[cNode.subNodes[cStackFrame.cIdx].member] = rSubNode;
				pStack.push({
					rNode : rSubNode,
					cNode : cNode.subNodes[cStackFrame.cIdx],
					traversed : false,
					cIdx : 0
				});
				cStackFrame.cIdx++;
			} else {
				if (cNode.subNodes.length == 0) {
					pStack.pop();
					if (pStack.length) {
						pStack[pStack.length - 1].rNode.leafMemberCount++;
					}
				} else {
					pStack.pop();
					if (pStack.length) {
						pStack[pStack.length - 1].rNode.leafMemberCount += rNode.leafMemberCount;
					}
				}
			}
		}
		stats.shift();// remove the unnecessary root node
		return new DataTree(rootNode, stats);
	};

	var dtp = DataTree.prototype;

	/**
	 * Encode a data tree instance into a JSON representation. It can be used to
	 * recreate the instance later on.
	 * 
	 * @function
	 * @name sap.riv.vizkit.DataTree#dataTreeToJSON
	 * @param dataTree
	 * @returns {String} JSON string
	 */
	dtp.dataTreeToJSON = function() {
		var output = {
			member : '',
			measureValues : {},
			subNodes : []
		};
		var pStack = [ {
			rNode : output,
			cNode : this._gr,
			traversed : false,
			cIdx : 0
		} ];
		while (pStack.length) {
			var cStackFrame = pStack[pStack.length - 1];
			var cNode = cStackFrame.cNode;
			var rNode = cStackFrame.rNode;
			if (!cStackFrame.traversed) {
				rNode.member = cNode.member;
				for ( var measureName in cNode.result) {
					rNode.measureValues[measureName] = ObjUtils.extend({}, cNode.result[measureName]);
				}
				cStackFrame.traversed = true;
			}
			if (cNode.subMembers.length > cStackFrame.cIdx) {
				// down the tree
				var rSubNode = {
					member : '',
					measureValues : {},
					subNodes : []
				};
				rNode.subNodes.push(rSubNode);
				pStack.push({
					rNode : rSubNode,
					cNode : cNode.subNodes[cNode.subMembers[cStackFrame.cIdx]],
					traversed : false,
					cIdx : 0
				});
				cStackFrame.cIdx++;
			} else {
				pStack.pop();
			}
		}
		return JSON.stringify(output);
	};

	/**
	 * Get the tree depth
	 * 
	 * @name sap.riv.vizkit.DataTree#getGroupDepth
	 * @function
	 * @returns {Integer} the depth of the aggregated data
	 */
	dtp.getGroupDepth = function() {
		return this._stats.length;
	};

	/**
	 * Get the given statistics of the given level. Typically contains an array
	 * of all members in the current level(Dimension), the longest and shortest
	 * member.
	 * 
	 * @name sap.riv.vizkit.DataTree#getLevelStatistics
	 * @function
	 * @param groupLevel
	 * 
	 * @returns {Object}
	 */
	dtp.getLevelStatistics = function(groupLevel) {
		return this._stats[groupLevel];
	};

	/**
	 * 
	 * Get the members of a node by given member path. The memberPath should be
	 * an array of member from root level to its parent level.
	 * 
	 * @name sap.riv.vizkit.DataTree#getSubMembersAt
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Array} array of members under the given member path
	 */
	dtp.getSubMembersAt = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
				if (!subNode) {
					return undefined;
				}
			}
		}
		return subNode.subMembers;
	};

	/**
	 * Gets the member labels. Works exactly the same way as the
	 * getSubMembersAt() function does. Suggestion is the path parameter should
	 * only contain indexes which are integers. It's probably a workaround
	 * solution and might be replaced later.
	 * 
	 * @name sap.riv.vizkit.DataTree#getSubMemberLabels
	 * @function
	 * @param {Array}
	 *            [path] The path depicting the where the members locate.
	 * @returns {Array} Array of labels of target members\
	 * @author I069394
	 */
	dtp.getSubMemberLabels = function(path) {
		var node = this._gr;
		if (path !== undefined) {
			for ( var i = 0, len = path.length; i < len; i++) {
				node = node.subNodes[path[i]];
				if (!node) {
					return undefined;
				}
			}
		}
		return node.subMemberLabels;
	};

	/**
	 * Get the measures of a node by given member path. The memberPath should be
	 * an array of member from root level to its parent level.
	 * 
	 * @name sap.riv.vizkit.DataTree#getMeasuresAt
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Object} plain object contains all measures of the node
	 */
	dtp.getMeasuresAt = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
				if (!subNode) {
					return undefined;
				}
			}
		}
		return subNode.result;
	};
	/**
	 * Get the count of the leaf node of a node by given member path. The
	 * memberPath should be an array of member from root level to its parent
	 * level.
	 * 
	 * @name sap.riv.vizkit.DataTree#getLeafMemberCount
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Number}
	 */
	dtp.getLeafMemberCount = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
			}
		}
		return subNode.leafMemberCount;
	};

	dtp.getContriRows = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
			}
		}
		return subNode.contriRows ? subNode.contriRows.concat() : undefined;
	};
	/**
	 * Set a tag to a measure of a node, the tag can carry some semantic meaning
	 * of the measure, like whether it's a singular.
	 * 
	 * @name sap.riv.vizkit.DataTree#setMeasureTagsAt
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Number}
	 */
	dtp.setMeasureTagsAt = function(memberPath, measure, aggrType, tags) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
			}
		}
		for ( var colId in subNode.result) {
			if (colId === measure) {
				if (subNode.result[colId].hasOwnProperty(aggrType)) {
					subNode.result[colId][aggrType].tags = tags;
				}
			}
		}
	};
	return DataTree;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.ColumnBarRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BarRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ColorUtils, BarRenderer, Math, ObjectUtils, Animator) {

	var columnBarRenderer = ObjectUtils.derive(BarRenderer, {
		constructor : function(layer, options) {},

		/**
		 * only draw the first series group of series groups in
		 * bar renderer
		 */
		draw : function() {
			this._resetShapes();
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length === 0) return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length === 0) return;
			
			this._seriesColor = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesColor.push(seriesList[i]._seriesColor);
				this._seriesShapes[i] = this._initSeries(seriesList[i]._data.length);
			}
			this._update();

			// register event
			this._regEvent();
		},

		_update : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0) return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) return;

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var tickInterval = xAxis.getTickInterval();

			var markSize = seriesList[0]._barMarkerSize;
			markSize = this._calculateMarkSzie(seriesList.length, tickInterval, markSize);

			// draw seriesList
			this._seriesPoints = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesPoints.push(this._calculateSeriesPoints(i, len, seriesList[i],
						xAxisMajorTicks, markSize));
				this._drawSeries(this._seriesShapes[i], this._seriesPoints[i], seriesList[i]);
			}

			this._doAnimation();
		},

		/**
		 * 
		 * @param points
		 *            series points
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * 
		 * @return shape Array
		 */
		_drawSeries : function(seriesShape, points, series, drawnPArray) {
			// [Ian TODO]change to a function instead of private variable
			var data = series.getData();
			var color = series._seriesColor;

			for ( var i = points.length; i--;) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						var point = points[i];
						seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
						seriesShape[i].measureIndex = data[i].measureIndex;
						//Fix the bug [2012-04-18] VISUAL-1412, if the series is not visible, we should make the chart rect, outerBorder and innerBorder invisible 
						if ( !series.isVisible() ) {
							seriesShape[i].rect.visible(false);
							seriesShape[i].outerBorder.visible(false);
							seriesShape[i].innerBorder.visible(false);
						}
						//End
						this._drawBarShape(seriesShape[i], point, color);
					}
				} else {
					var point = points[i];
					seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
					seriesShape[i].measureIndex = data[i].measureIndex;
					//Fix the bug [2012-04-18] VISUAL-1412, if the series is not visible, we should make the chart rect, outerBorder and innerBorder invisible 
					if ( !series.isVisible() ) {
						seriesShape[i].rect.visible(false);
						seriesShape[i].outerBorder.visible(false);
						seriesShape[i].innerBorder.visible(false);
					}
					//End
					this._drawBarShape(seriesShape[i], point, color);
				}
			}
		},

		/**
		 * @param viewPort
		 *            if viewPort exist, it means that the
		 *            animation is not in pinch interaction. so
		 *            we should renderer the column bar in
		 *            vertical direction if not, now we do not
		 *            support animation.
		 */
		_doAnimation : function(viewPort) {
			var animator = Animator;
			var self = this;

			if (!viewPort) {
				animator.animate({
					values : [ {
						type : 'FLOAT',
						from : 0.0,
						to : 1
					} ],
					duration : 800,
					onStep : function(values) {
						var seriesPoints = self._seriesPoints;
						var seriesShapes = self._seriesShapes;
						for ( var i = 0, len = seriesShapes.length; i < len; i++) {
							for ( var j = 0; j < seriesShapes[i].length; j++) {
								var point = seriesPoints[i][j];
								self._updateBarShapeDuringAnimation(seriesShapes[i][j], point, self._seriesColor[i], values[0]);
							}
						}
						//Highlight selected shape
						if(self._highlights && self._highlights.length > 0){
							self.highlight();
						}
						self.refresh();
					},
					onComplete : function(){
						var seriesPoints = self._seriesPoints;
						var seriesShapes = self._seriesShapes;
						for ( var i = 0, len = seriesShapes.length; i < len; i++) {
							for ( var j = 0; j < seriesShapes[i].length; j++) {
								if (seriesShapes[i][j]) {
									var point = seriesPoints[i][j];
									self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
								}

							}
						}
						//Highlight selected shape
						if(self._highlights && self._highlights.length > 0){
							self.highlight();
						}
						self.refresh();
					}
				});
			} else {
				var seriesPoints = self._seriesPoints;
				var seriesShapes = self._seriesShapes;
				for ( var i = 0, len = seriesShapes.length; i < len; i++) {
					for ( var j = 0; j < seriesShapes[i].length; j++) {
						if (seriesShapes[i][j]) {
							var point = seriesPoints[i][j];
							self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
						}

					}
				}
				
				//Ian 2012-4-18 In order to keep the highlights, do highlight after update all the shapes
				// [Ian 2012-3-28] To check whether
				// the shape is in highlight status,
				// now we do not do other operation,
				// we only change the color of
				// highlighted shape.
				//Christy 2012-4-18 ColumnBarRender's highlight function is differect from barRender. Highlight all shape at one time.
				if(self._highlights && self._highlights.length > 0){
					self.highlight();
				}
				
				self.refresh();
			}
		},

		/**
		 * 
		 * @param sIndex
		 *            series index
		 * @param series
		 *            count
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * @param xAxisMajorTicks
		 *            major ticks of xAxis
		 * @Param markSize
		 *            series bar size
		 * 
		 * @return bar point positions Array[{x1,y1, x2,
		 *         y2}....]
		 * 
		 * calculation: points[i] x1 = ( - (sCount/2 ) + sIndex) *
		 * markSize + xAxisMajorTicks[i] y1 =
		 * series.getYAxis().u2p(data[i]) x2 = x1 + markSize
		 * if(this._fillToZero){ point.y2 = zeroTick; }else{
		 * point.y2 = baseTick; }
		 */
		_calculateSeriesPoints : function(sIndex, sCount, series, xAxisMajorTicks, markSize) {
			var data = series.getData();
			var yAxis = series.getYAxis();
			var baseTick = yAxis.getMajorTicks()[0];
			var zeroTick = yAxis.u2p(0);
			var points = [];
			var offset = Math.round(markSize / 8);

			for ( var i = 0, len = data.length; i < len; i++) {
				var point = {};

				//Similar with BarRender
				point.x1 = xAxisMajorTicks[i]  - ((sCount - 2*sIndex) * (markSize + offset) - offset)/2;

				if (this._fillToZero) {
					point.y2 = zeroTick;
					if ( baseTick < zeroTick ) {
						point.y2 = baseTick;
					}
				} else {
					point.y2 = baseTick;
				}

				point.y1 = yAxis.u2p(data[i].value);
				point.x2 = point.x1 + markSize;

				points.push(point);
			}
			return points;
		},

		_regEvent : function() {

		},

		_drawBarShape : function(seriesShape, point, basicColor) {
			if ( !seriesShape.rect.visible() ) return;
			var barWidth = Math.abs(point.x1 - point.x2);
			var isShowOutBorder = this._barStyle.isShowOutBorder, isShowInnerBorder = this._barStyle.isShowInnerBorder;
			if (barWidth < 8) {
				// Remove Out Border
				isShowOutBorder = false;
			}
			if (barWidth < 5) {
				// Remove Inner Border
				isShowInnerBorder = false;
			}

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			// draw rectangle
			seriesShape.rect.color(basicColor);
			if (point.y1 > point.y2) {
				seriesShape.rect.topRight([ point.x2, point.y2 ]);
			} else {
				seriesShape.rect.bottomRight([ point.x2, point.y2 ]);
			}

			//Ian [2012-04-11] To fix the bug VISUAL-561, we should reset the inner and outer border because it may keep the last value
			seriesShape.innerBorder.reset();
			seriesShape.outerBorder.reset();
			//End
			
			// draw inner border
			seriesShape.innerBorder.borderWidth(1).borderColor(color[0]).visible(isShowInnerBorder);
			// draw outer border
			seriesShape.outerBorder.borderWidth(1).borderColor(color[3]).visible(isShowOutBorder);
		},

		_updateBarShapeDuringAnimation : function(seriesShape, point, basicColor, factor) {
			var width = Math.abs(point.x1 - point.x2);
			var height = Math.abs(point.y2 - point.y1) * factor;
			if ((width.toString() === 'NaN') || (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height).shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 0,
				color : 'rgba(0,0,0,0.5)'
			});

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.y1 > point.y2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : point.x1,
							y : 0
						},
						s : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : point.x1,
							y : 0
						},
						e : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}
		},
		
		_updateBarShape : function(seriesShape, point, basicColor, factor) {
			var width = Math.abs(point.x1 - point.x2);
			var height = Math.abs(point.y2 - point.y1) * factor;
			if ((width.toString() === 'NaN') || (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height);
			
			if (this._barStyle.isShowShadow) {
				seriesShape.rect.shadow({
					offsetX : 2,
					offsetY : 1,
					blur : 2,
					color : 'rgba(0,0,0,0.5)'
				});
			} else {
				seriesShape.rect.shadow({
					offsetX : 0,
					offsetY : 0,
					blur : 0,
					color : 'rgba(0,0,0,0.5)'
				});
			}

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.y1 > point.y2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : point.x1,
							y : 0
						},
						s : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : point.x1,
							y : 0
						},
						e : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}

			var offset = 0;
			seriesShape.outerBorder.reset();
			if (this._barStyle.isShowOutBorder) {
				this._drawBorderPath(seriesShape.outerBorder, point, height, offset);
				offset = offset + 1;
			}
			seriesShape.innerBorder.reset();
			if (this._barStyle.isShowInnerBorder) {
				this._drawBorderPath(seriesShape.innerBorder, point, height, offset);
			}
		},

		_drawBorderPath : function(shape, point, distance, offset) {
			var barHeight = Math.abs(point.y2 - point.y1);
			if (barHeight < 2)
				return;
			if (point.y1 > point.y2) {
				shape.moveTo(point.x2 - offset, point.y2).lineTo(point.x2 - offset,
						point.y2 + distance - offset);
				if (barHeight < 3) {
					shape.moveTo(point.x1 + offset, point.y2 + distance - offset);
				} else {
					shape.lineTo(point.x1 + offset, point.y2 + distance - offset);
				}
				shape.lineTo(point.x1 + offset, point.y2);
			} else {
				shape.moveTo(point.x2 - offset, point.y2).lineTo(point.x2 - offset,
						point.y2 - distance + offset);
				if (barHeight < 3) {
					shape.moveTo(point.x1 + offset, point.y2 - distance + offset);
				} else {
					shape.lineTo(point.x1 + offset, point.y2 - distance + offset);
				}
				shape.lineTo(point.x1 + offset, point.y2);
			}
		},

		/** @overrides sap.riv.viz.shared.series.BaseRenderer.highlight */
		highlight : function() {
			var seriesShapes = this._seriesShapes;
			if (seriesShapes.length === 0)
				return;

			// Adjust all shape color alpha to 0.5
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					if(shape){
						shape.rect.compositionMode({
							alpha : 0.5
						});
						shape.outerBorder.compositionMode({
							alpha : 0.5
						});
						shape.innerBorder.compositionMode({
							alpha : 0.5
						});
					}
				}
			}

			// Highlight selected shape
			var highlights = this._highlights, selectedShape;
			for ( var i = 0, len = highlights.length; i < len; i++) {
				selectedShape =  seriesShapes[highlights[i].measureIndex] ? seriesShapes[highlights[i].measureIndex][highlights[i].dimensionItemIndex]: null;
				if(selectedShape){
					selectedShape.rect.compositionMode({
						alpha : 1
					});
					selectedShape.outerBorder.compositionMode({
						alpha : 1
					});
					selectedShape.innerBorder.compositionMode({
						alpha : 1
					});
				}
			}
			this.refresh();
		},

		removeHighlights : function() {
			this._highlights.splice(0, this._highlights.length);
			var seriesShapes = this._seriesShapes;
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					shape.rect.compositionMode({
						alpha : 1
					});
					shape.outerBorder.compositionMode({
						alpha : 1
					});
					shape.innerBorder.compositionMode({
						alpha : 1
					});
				}
			}
			this.refresh();
		},

		/**
		 * @param scale
		 *            the scale in xaxis drrection
		 * @param viewPort
		 *            the size should to been drawn
		 * 
		 * if the viewPort is defined, we only draw the shape in
		 * the this view, remove other shape those we do not
		 * want to draw
		 */
		drawViewPort : function(scale, viewPort) {
			var offset = this.getLayer().position();

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length === 0) {
				return;
			}

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length === 0) {
				return;
			}

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var tickInterval = xAxis.getTickInterval();

			var markerSize;
			// var markerSize = seriesList[0]._zoomBarMarkerSize
			// * scale; //[Christy] Bar size is not limited.
			// if(markerSize < seriesList[0]._barMarkerSize){
			// markerSize = seriesList[0]._barMarkerSize;
			// }

			seriesList[0]._zoomBarMarkerSize = markerSize = this._calculateMarkSzie(seriesList.length,
					tickInterval);

			this._seriesPoints = [];
			if (viewPort) {
				var pointArray = [];
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var seriesPoints = this._seriesPoints[i] = this._calculateSeriesPoints(i, len,
							seriesList[i], xAxisMajorTicks, markerSize);

					for ( var j = 0; j < seriesPoints.length; j++) {
						if (seriesPoints[j].x2 + offset.x < 0
								|| seriesPoints[j].x1 + offset.x > viewPort.width) {
							if (seriesShapes[j]) {
								this._removeBarShape(seriesShapes[j]);
							}
							seriesShapes[j] = null;
						} else {
							pointArray[j] = 1;
							if (!seriesShapes[j]) {
								seriesShapes[j] = this._addBarShape();
							}
						}
					}
					this._drawSeries(seriesShapes, seriesPoints, seriesList[i], pointArray);

					pointArray = [];
				}
				this._doAnimation(true);
			} else {
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var sereisPoints = this._seriesPoints[i] = this._calculateSeriesPoints(i, len,
							seriesList[i], xAxisMajorTicks, markerSize);
					for ( var j = 0; j < sereisPoints.length; j++) {
						if (!seriesShapes[j]) {
							seriesShapes[j] = this._addBarShape();
						}
					}
					this._drawSeries(seriesShapes, sereisPoints, seriesList[i]);
				}
				this._doAnimation(true);
			}
			this.refresh();
		},

		hoverOnPoint : function(point) {

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();

			if (seriesList.length == 0) {
				return;
			}

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var halfTickInterval = xAxis.getTickInterval() / 2;

			var start = 0, end = xAxisMajorTicks.length - 1;
			var found = false;
			var dimensionItemIndex;
			while (!found && start < end) {
				dimensionItemIndex = Math.round((start + end) / 2);
				var xPoint = xAxisMajorTicks[dimensionItemIndex] - point.x;
				if (Math.abs(xPoint) <= halfTickInterval)
					found = true;
				else if (xPoint <= 0) {
					start = dimensionItemIndex + 1;
				} else {
					end = dimensionItemIndex - 1;
				}
			}
			if (!found)
				dimensionItemIndex = start;

			if (this._dataCtxOnPoint && this._dataCtxOnPoint.dimensionItemIndex === dimensionItemIndex) {
				return this._dataCtxOnPoint;
			}

			var dataCtxOnpoint = {};
			dataCtxOnpoint['dimensionItemIndex'] = dimensionItemIndex;

			this._tpDecorativeRenderer.visible(true).width(halfTickInterval * 2).height(
					this.getLayer().size().height - seriesList[0].getYAxis().getLastTickOffset())
					.color('rgba(133,133,133, 0.4)').topLeft(
							[ Math.round(xAxisMajorTicks[dimensionItemIndex] - halfTickInterval),
									seriesList[0].getYAxis().getLastTickOffset() ]);
			this.refresh();

			this._dataCtxOnPoint = null;
			this._dataCtxOnPoint = dataCtxOnpoint;

			return dataCtxOnpoint;
		},
	});
	return columnBarRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.SeriesHighlighter',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup ( funcUtils ) {
	var equals = function (obj, other) {
		var prop = null;
		for ( prop in obj ) {
			if ( typeof other[prop] === 'undefined' ) return false;
		}
		
		for ( prop in obj ) {
			if ( obj[prop] ) {
				switch ( typeof obj[prop] ) {
				case 'object':
					if ( !obj[prop].equals(other[prop]) ) return false;
					break;
				case 'function':
					if ( typeof other[prop] === 'undefined' ||
							( prop !== 'equals' && obj[prop].toString() !== other[prop].toString()) ) {
						return false;
					}
					break;
				default:
					if ( obj[prop] !== other[prop] ) return false;
				}
			} else {
				if ( other[prop] ) return false;
			}
		}
		
		for ( prop in obj ) {
			if ( typeof obj[prop] === 'undefined' ) return false;
		}
		
		return true;
	};
	
	var removeArrayItem = function ( array, from, to ) {
		var rest = array.slice((to || from) + 1 || array.length);
		array.length = from < 0 ? array.length + from : from;
		return array.push.apply(array, rest);
	};
	
	/**
	 * Represents an ordered list structure.
	 * 
	 * @returns {sap.riv.viz.shared.series.ArrayList}
	 * @author eye
	 */
	var ArrayList = function () {
		var elementData;
		
		if ( arguments.length === 0 ) {
			elementData = [];
		} else if ( arguments.length > 0 && typeof arguments[0] !== 'number' ) {
			elementData = arguments[0].toArray();
		} else {
			elementData = [];
			elementData.length = arguments[0];
		}
		
		function Iterator( array ) {
			var index = 0;
		
			this.hasNext = function () {
				return index < array.length;
			};
			this.next = function () {
				return array[index++];
			};
			
			this.remove = function () {
				array.splice(index, 1);
			};
			
			this.getIndex = function () {
				return index;
			};
		}
		
		this.add = function ( elem ) {
			elementData.push(elem);
		};
		
		this.addAll = function ( from, array ) {
			if ( typeof from !== 'number' ) return;
			
			if ( from < 0 || from > elementData.length ) return;
			var iterator = new Iterator(array);
			while ( iterator.hasNext() ) {
				elementData.push(iterator.next());
			}
		};
		
		this.insert = function ( index, elem ) {
			elementData.splice(index, 0, elem);
		};
		
		this.indexOf = function ( elem ) {
			for ( var i = 0; i < elementData.length; i++ ) {
				if ( equals(elementData[i], elem) ) {
					return i;
				}
			}
			return -1;
		};
		
		this.get = function ( index ) {
			return elementData[index];
		};
		
		this.size = function () {
			return elementData.length;
		};
		
		this.exchange = function ( first, last ) {
			var temp = elementData[first];
			elementData[first] = elementData[last];
			elementData[last] = temp;
		};
		
		this.contains = function ( item ) {
			for ( var i = 0; i < elementData.length; i++ ) {
				if ( equals(elementData[i], item) ) {
					return true;
				}
			}
			return false;
		};
		
		this.deleteItem = function ( item ) {
			var index = this.indexOf(item);
			if ( index !== -1 ) {
				removeArrayItem(elementData, index);
			}
		};
		
		this.remove = function ( from, to ) {
			removeArrayItem(elementData, from, to);
		};
		
		this.removeAll = function () {
			elementData.splice(0, elementData.length);
		};
		
		this.toArray = function () {
			return elementData.slice(0);
		};
		
		this.iterator = function () {
			return new Iterator(elementData);
		};
	};
	
	/**
	 * Represents a double-ended queue.
	 * @param capacityRestricted
	 * - Whether the queue's capacity can be expanded.
	 * @returns {sap.riv.viz.shared.series.Deque}
	 * @author eye
	 */
	var Deque = function ( capacityRestricted ) {
		var elementData = new ArrayList();
		var maxCapacity = Number.MAX_VALUE;
		var capacity = 16; // Default capacity
		
		this.setCapacity = function ( quantity ) {
			capacity = quantity;
		};
		
		this.offerFirst = function ( item ) {
			if ( this.remainingCapacity() < 1 ) {
				this.removeLast();
			} 
			elementData.insert(0, item);
		};
		
		this.offerLast = function ( item ) {
			if ( this.remainingCapacity() < 1 ) {
				this.removeFirst();
			}
			elementData.add(item);
		};
		
		this.removeFirst = function () {
			elementData.remove(0);
		};
		
		this.removeLast = function () {
			elementData.remove(elementData.size() - 1);
		};
		
		this.pollFirst = function () {
			var firstElem = this.peekFirst();
			elementData.remove(0);
			return firstElem;
		};
		
		this.pollLast = function () {
			var lastElement = this.peekLast();
			elementData.remove(elementData.size() - 1);
			return lastElement;
		};
		
		this.peekFirst = function () {
			if ( elementData.size() > 0 ) {
				return elementData.get(0);
			} else {
				return null;
			}
		};
		
		this.peekLast = function () {
			if ( elementData.size() > 0 ) {
				return elementData.get(elementData.size() - 1);
			} else {
				return null;
			}
		};
		
		this.size = function () {
			return elementData.size();
		};
		
		this.iterator = function () {
			return elementData.iterator();
		};
		
		this.toArrayList = function () {
			return elementData;
		};
		
		this.toArray = function () {
			return elementData.toArray();
		};
		
		this.remainingCapacity = function () {
			if ( capacityRestricted ) {
				return ( capacity - elementData.size() );
			} else {
				return ( maxCapacity - elementData.size() );
			}
		};
	};
	
	/**
	 * Represents a highlight agent for various chart components. The highlight agent
	 * employs the builder design pattern, who collects data step by step and executes
	 * the highlight action on demand on the premise of completion of data settings
	 * and data integrity.
	 * 
	 * @param {Array} graphicsRenderers
	 * - List of graphics renderers who's capable of doing graphical works.
	 * 
	 * @param {Number} thresholdValue
	 * - Maximal value of highlight quantities
	 * 
	 * @param {Boolean} layerPrioritization
	 * - If layer is meant to be prioritized, typically by moving its visual layer. 
	 * 
	 * @returns {sap.riv.viz.shared.series.SeriesHighlighter}
	 * 
	 * @author eye
	 */
	var SeriesHighlighter = function ( graphicsRenderers, threshold, layerPrioritization ) {
		var 
			// Stores references of graphicsRenderers whether they're working or not.
			rendererList = new ArrayList(),
			// Saves current candidates for highlight. 
			candidates = new Deque(true),
			// Saves translated context paths which renderer can understand.
			targets = [],
			// Stores ordered list of series data which represents 
			// current existing and active series entries.
			seriesTuple = new ArrayList(),
			// References actual graphical shapes descriptions.
			// Quantities of the shapes MUST be identical with
			// that of series tuple, but orders of them may vary.
			shapesList = new ArrayList(),
			// Generated data during highlight.
			products = [],
			//disable series index
			disabledSeriesIndex;
		
		candidates.setCapacity(threshold);
		rendererList.addAll(0, graphicsRenderers);
		
		/**
		 * Reloads essential data for operations.
		 */
		this.reload = function () {
			seriesTuple.removeAll();
			shapesList.removeAll();
			
			var iter = rendererList.iterator(), rendererItem;
			while ( iter.hasNext() ) {
				rendererItem = iter.next();
				for ( var i = 0, len = rendererItem.getSeriesGroups()[0].getSeriesList().length; 
						i < len; i++ ) {
					seriesTuple.add(rendererItem.getSeriesGroups()[0].getSeriesList()[i]);
				}
				
				for ( i = 0, len = rendererItem.getSeriesShapes().length; i < len; i++ ) {
					if ( rendererItem.getSeriesShapes()[i].constructor == Array ) {
						shapesList.add(rendererItem.getSeriesShapes()[i]);
					}
					if ( rendererItem.getSeriesShapes()[i].constructor == Object ) {
						shapesList.add(rendererItem.getSeriesShapes()[i].marker);
					}
				}
			}
		};
		this.reload();
		
		/**
		 * Sets target paths for highlight.
		 * 
		 * @param {Array} argument[0]
		 * - Target paths
		 */
		this.setTargets = function () {
			if ( !arguments[0] || arguments[0].constructor !== Array ) return;
			
			for ( var i = 0, len = arguments[0].length; i < len; i++ ) {
				candidates.offerLast(arguments[0][i]);
				products.push(arguments[0][i]);
			}
			
			targets = translatePaths(candidates.toArray());
		};
		
		/**
		 * Tests if the given point coordinate happens to be
		 * located in one of the shapes and returns the path
		 * of the shape if so.
		 * 
		 * @param {Object} pointCoord
		 * - Given point coordinate
		 * 
		 * @returns {Object} path
		 * - Context path which contains the point
		 */
		this.hits = function ( pointCoord ) {
			var iterator = shapesList.iterator(), seriesShapes, seriesNo, path = {};
			while ( iterator.hasNext() ) {
				seriesShapes = iterator.next();
				seriesNo = iterator.getIndex() - 1;
				for ( var i = 0, len = seriesShapes.length; i < len; i++ ) {
					if ( (seriesShapes[i].rect 
							&& seriesShapes[i].rect.doPointInTest(pointCoord))
							|| (seriesShapes[i].doPointInTest 
							&& seriesShapes[i].doPointInTest(pointCoord) ) ) {
						path.measureIndex = seriesNo;
						path.dimensionItemIndex = i;
					}
				}
			}
			return path;
		};
		
		// Converts chart scoped context path(s) to renderer scoped path(s).
		// If no input provided, the function will be returning an empty
		// array. Note that this function is deliberately designed as private
		// which is impossible to be invoked at an outer scope.
		function translatePaths() {
			if ( arguments[0].constructor != Array ) funcUtils.error("Unsupported argument type.");
			var input = new ArrayList(), output = [];
			input.addAll(0, arguments[0]);
			
			var iterator = rendererList.iterator(), 
				seriesIndexMap = [],
				chartSeriesIndex = 0,
				renderer,
				rendererId;
			while ( iterator.hasNext() ) {
				renderer = iterator.next();
				rendererId = iterator.getIndex() - 1;
				
				for ( var i = 0, len = renderer.getSeriesGroups()[0]
						.getSeriesList().length; i < len; i++, chartSeriesIndex++ ) {
					seriesIndexMap.push({
						rendererNo : rendererId,
						chartSeriesNo : chartSeriesIndex,
						rendererSeriesNo : i
					});
				}
			}
			
			iterator = input.iterator();
			var inputItem, outputItem;
			while ( iterator.hasNext() ) {
				inputItem = iterator.next();
				outputItem = new Object();
				outputItem.measureIndex = inputItem.measureIndex;
				outputItem.dimensionItemIndex = inputItem.dimensionItemIndex;
				
				for ( i = 0, len = seriesIndexMap.length; i < len; i++ ) {
					if ( seriesIndexMap[i].chartSeriesNo 
							=== outputItem.measureIndex ) {
						outputItem.rendererNo = seriesIndexMap[i].rendererNo;
						outputItem.rendererSeriesNo = 
							seriesIndexMap[i].rendererSeriesNo;
						output.push(outputItem);
					}
				}
			}
			return output;
		}
		
		/**
		 * Removes the given path if it's enrolled.
		 * 
		 * @param {Object} path
		 * - Given path to test against
		 */
		this.remove = function ( path ) {
			candidates.toArrayList().deleteItem(path);
		};
		
		/**
		 * Removes all set paths.
		 */
		this.erase = function () {
			candidates.toArrayList().removeAll();
			targets.splice(0, targets.length);
		};
		
		/**
		 * Removes everything been changed before
		 * and makes the agent brand new.
		 */
		this.reset = function () {
			seriesTuple.removeAll();
			shapesList.removeAll();
			disabledSeriesIndex = null;
		};
		
		this.ready = function () {
			return shapesList.size();
		};
		
		/**
		 * Returns if the given path has already been
		 * enrolled for highlight.
		 * 
		 * @param path 
		 * - The given path
		 * 
		 * @returns true 
		 * - If the given path has been enrolled and vice versa
		 */
		this.isEnrolled = function ( path ) {
			return candidates.toArrayList().contains(path);
		};
		
		/**
		 * Executes everything.
		 * The method has two working modes. The first is just
		 * inject highlight targets into right renderer(s), and
		 * the other is do the highlight job by itself. This is
		 * determined by judging the <code>manually</code> flag.
		 * 
		 * @param {Boolean} manually
		 * - If the highlight agent will be doing the highlight
		 * directly or only setting highlight targets.
		 * 
		 * @returns {Array} products
		 * - Generated data upon highlights
		 */
		this.run = function ( manually ) {
			targets = translatePaths(candidates.toArray());
			
			for ( var iter = rendererList.iterator(); iter.hasNext(); ) {
				iter.next().removeHighlights();
			}
			
			// Get responsible renderer IDs.
			var targetRendererIDs = [];
			for ( var i = 0, len = targets.length; i < len; i++ ) {
				targetRendererIDs.push(targets[i].rendererNo);
			}
			
			// Merge repetitive renderer numbers.
			for ( i = 0, len = targetRendererIDs.length; i < len; i++ ) {
				if ( (i < targetRendererIDs.length - 1) 
						&& targetRendererIDs[i] === targetRendererIDs[i + 1] ) {
					removeArrayItem(targetRendererIDs, i, i + 1);
				}
			}
			
			var finalTargets = [], targetItem;
			for ( i = 0; i < targetRendererIDs.length; i++ ) {
				targetItem = new Object();
				targetItem.rendererNo = targetRendererIDs[i];
				targetItem.highlights = [];
				for ( var j = 0, len = targets.length; j < len; j++ ) {
					if ( targets[j].rendererNo === targetRendererIDs[i] ) {
						targetItem.highlights.push({
							measureIndex : targets[j].rendererSeriesNo,
							dimensionItemIndex : targets[j].dimensionItemIndex
						});
					}
				}
				finalTargets.push(targetItem);
			}
			
			for ( i = 0; i < targets.length; i++ ) {
				if ( !seriesTuple.get(targets[i].measureIndex).isVisible() ) {
					finalTargets.splice(i, 1);
				}
			}
			
			// Notifies renderer(s) who's responsible of handling
			// highlight request(s).
			for ( i = 0; i < finalTargets.length; i++ ) {
				rendererList.get(finalTargets[i].rendererNo).setHighlights(
						finalTargets[i].highlights, layerPrioritization);
				if ( manually ) {
					rendererList.get(finalTargets[i].rendererNo).highlight();
				}
			}
			
			return products;
		};
	};
	
	return SeriesHighlighter;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.Axis',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.DimensionAxisRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.LinearAxisRenderer',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TypeUtils, DimensionAxisRenderer,
		LinearAxisRenderer) {

	/**
	 * Axis layout step: 1. getPreferredWidth of yAxis. 2. update the distance
	 * property of xAxis 3. get preferredHeight of xAxis 4. get prefereredWidth
	 * of xAxis 5. update the distance property of yAxis 5. get preferredHeight
	 * of yAxis
	 * 
	 */

	/**
	 * options: { mode: 'numeric', 'dimension' required labels: labels, required
	 * in dimension axis minValue: min value of line axis, required in linear
	 * axis maxValue: max value of line axis, required in linear axis lineColor:
	 * line color, default value is black lineThickness: lint thickness, default
	 * value 1 showMajorTicks : show or hidden major ticks, default value is
	 * false showMinorTicks: show or hidden minor ticks, default value is false }
	 */
	var axis = function(options) {

		this._sax_options = ObjectUtils.extend(true, {}, options);
		this._sax_initialize(this._sax_options);

		return this;
	};

	// static variables
	axis.LINEAR = 'numeric';
	axis.DIMENSION = 'dimension';

	/*
	 * 
	 */
	axis.prototype._sax_initialize = function(options) {
		this._sax_mode = options.mode;
		switch (this._sax_mode) {
		case axis.DIMENSION:
			this._sax_renderer = new DimensionAxisRenderer(
					options);
			break;
		case axis.LINEAR:
		default:
			this._sax_renderer = new LinearAxisRenderer(
					options);
			break;
		}
	};

	/**
	 * @layer sap.riv.graphics.Layer
	 */
	axis.prototype.setLayer = function(layer) {
		this._sax_renderer.setLayer(layer);
	};

	axis.prototype.draw = function() {
		this._sax_renderer.draw();
	};

	/**
	 * @reutrn object {width, height}
	 */
	axis.prototype.getPreferredSize = function() {
		return this._sax_renderer.getPreferredSize();
	};

	axis.prototype.getPreferredWidth = function() {
		return this._sax_renderer.getPreferredWidth();
	};

	axis.prototype.getPreferredHeight = function() {
		return this._sax_renderer.getPreferredHeight();
	};

	/**
	 * @properties Object
	 */
	axis.prototype.updateProperties = function(properties) {
		var needReset = false;

		if (properties && properties.distance
				&& properties.distance !== this._sax_renderer.distance()) {
			needReset = true;
		}

		if (needReset) {
			this._sax_renderer.reset();
		}

		if (properties && properties.distance) {
			this._sax_renderer.distance(properties.distance);
		}

		return this;
	};

	/**
	 * @unitObj, value or number in Dimension axis, the unitObj is number, 0, 1,
	 *           2, 3 in value axis, the unitObj is value, 0, 10, 20
	 */
	axis.prototype.u2p = function(unitObj) {
		return this._sax_renderer.u2p(unitObj);
	};

	axis.prototype.p2u = function(pointObj) {
		return this._sax_renderer.p2u(pointObj);
	};

	axis.prototype.position = function(xoffset, yoffset) {
		this._sax_renderer.position(xoffset, yoffset);
	};

	axis.prototype.zoom = function(xscale, yscale, dscale) {
		this._sax_renderer.zoom(xscale, yscale, dscale);
	};

	axis.prototype.setVisibleRange = function(xscale, yscale, dscale) {
		this._sax_renderer.setVisibleRange(xscale, yscale, dscale);
	};
	/*
	 * @return Array, the positions of major ticks
	 */
	axis.prototype.getMajorTicks = function() {
		return this._sax_renderer.getMajorTicks();
	};

	/*
	 * @return Array, the positions of minor ticks
	 */
	axis.prototype.getMinorTicks = function() {
		return this._sax_renderer.getMinorTicks();
	};

	axis.prototype.getAxisWidth = function() {
		return this._sax_renderer.getAxisWidth();
	};

	axis.prototype.getTickInterval = function() {
		return this._sax_renderer.getTickInterval();
	};

	axis.prototype.getFirstTickOffset = function() {
		return this._sax_renderer.getFirstTickOffset();
	};

	axis.prototype.getLastTickOffset = function() {
		return this._sax_renderer.getLastTickOffset();
	};

	axis.prototype.getLineThickness = function() {
		return this._sax_renderer.getLineThickness();
	};

	axis.prototype.getMajorTickWidth = function() {
		return this._sax_renderer.getMajorTickWidth();
	};
	axis.prototype.applyTheme = function(theme) {
		return this._sax_renderer.applyTheme(theme);
	};

	return axis;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.BarModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.Axis',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BarRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.ChartModule',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, FunctionUtils, LOG, UADetector,
		GestureDetector, Animator, Axis, SeriesGroup, Series, BarRenderer,
		ChartModule) {
	var defaultOptions = {
			xAxis :{
				showMajor : true,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			},
			yAxis :{
				showMajor : false,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			}
	};
	
	var BarModule = ObjUtils.derive(ChartModule, {
		events : [ 'selectData', 'showTooltip', 'hideTooltip' ],
		constructor : function(options) {
			this._seriesGroup = null;
			this._barRenderer = null;
			this._hasDrawn = false;
			this._hasBacked = false;
			this._valueAxisRange = null;
			this._selections = [];
		},
		initAxes : function() {
			this._xaxes = [];
			var xaxesOption = this._chart_options.properties.xAxis;
			for ( var i = 0, len = xaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(xaxesOption[i].showTitle) && xaxesOption[i].showTitle
						&& !TypeUtils.isExist(xaxesOption[i].title) ) {
					xaxesOption[i].title = "X" + (i + 1);
				}
				
				// FIX ISSUE: if there are two axis and more
				// than one series,
				// but it only use the one series. so according
				// to the
				// valueAxisRange
				// to judge whether the axis is to been used.
				// when it is not to
				// been used, set the min and max 0
				var option = {
					mode : Axis.LINEAR,
					position : i == 0 ? 'hb' : 'ht',
					maxValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].max
							: 0,
					minValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].min
							: 0
				}
				var x = new Axis(ObjUtils.extend(true, option,
						xaxesOption[i]));
				this._xaxes.push(x);
			}

			this._yaxes = [];
			var yaxesOption = this._chart_options.properties.yAxis;
			var labels = this._dataTree.getSubMemberLabels();
			if(labels.length < 1){
				labels = [];
				labels.push('1');
			}
			for ( var i = 0, len = yaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(yaxesOption[i].showTitle) && yaxesOption[i].showTitle
						&& !TypeUtils.isExist(yaxesOption[i].title) ) {
					yaxesOption[i].title = "Y" + (i + 1);
				}
				
				var option = {
					mode : Axis.DIMENSION,
					position : 'vl',
					labels : labels
				}
				var y = new Axis(ObjUtils.extend(true, option,
						yaxesOption[i]));
				this._yaxes.push(y);
			}
		},
		
		initGridLineProperties : function() {
			this._xAxis_gridLine_option = ObjUtils.extend(true, defaultOptions.xAxis,
							this._chart_options.properties.xAxis[0].gridLine);
			this._yAxis_gridLine_option = ObjUtils.extend(true, defaultOptions.yAxis,
							this._chart_options.properties.yAxis[0].gridLine);
			this._gridLine.setXAxisOptions(this._xAxis_gridLine_option);
			this._gridLine.setYAxisOptions(this._yAxis_gridLine_option);
			// Nick - if users have some wrong settings, we do not throw any error, but the behavior is unexpected.
			// be consistent with showMajorticks
			//this.gridLinePropertiesCheck();
		},
		
		gridLinePropertiesCheck : function() {
			// Nick - if users have some wrong settings for the grid line, an error is thrown out
			if((!this._xAxis_gridLine_option.showMajor && this._xAxis_gridLine_option.showSub) || this._yAxis_gridLine_option.showMajor || this._yAxis_gridLine_option.showMinor){
				FunctionUtils.error("Wrong settings for grid line of bar chart");
			}
		},
		
		initSeries : function() {
			this._valueAxisRange = [];
			var barOptions = this._chart_options.properties.bar;
			var seriesOption = this._chart_options.properties.measures;
			var measureMembers = this._metaData.measureMembers;
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			this._seriesGroup = new SeriesGroup();

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = ObjUtils.extend(true, {}, barOptions, seriesOption[i]);
				o.fillColor = TypeUtils.isExist(o.fillColor) ? o.fillColor
						: defaultColor[i % defaultColor.length];
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if (o.visible) {
					var s = new Series(o);
					s.setName(measureMembers[i]);
					s.setData(this._data[i]);
					s.setVisible(o.visible);
					this._seriesGroup.addSeries(s);

					var valueAxis = o.valueAxis || 0;
					this._updateValueAxisRange(s.getDataRange(), valueAxis);
				}

			}
		},

		/**
		 * in bar chart, the scroll bar is in the right side of
		 * the chart and there is only one scroll bar.
		 */
		initScrollBar : function() {
			//Fix the bug:[Ian] if you update the chart, the scroll bar will show as we do not remove the first scrollBar
			if(this._scrollBar.length > 0){
				for(var i=0; i<this._scrollBar.length; i++){
					this._scrollBar[i].remove();
				}
			}
			
			// init scroll bar layer
			this._scrollBar = [];
			this._scrollBar[0] = this.scrollBar();

		},

		updateValueAxisRange : function() {
			this._valueAxisRange = [];
			var seriesOption = this._chart_options.properties.measures;
			var seriesList = this._seriesGroup.getSeriesList();
			var series;
			var validCount = 0;
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				var o = seriesOption[i] || {};
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if ( o.visible ) {
					var valueAxis = o.valueAxis || 0;
					series = seriesList[validCount];
					this._updateValueAxisRange(series.getDataRange(), valueAxis);
					validCount++;
				}
			}
		},

		_updateValueAxisRange : function(range, valueAxis) {
			if (this._valueAxisRange[valueAxis] == undefined) {
				this._valueAxisRange[valueAxis] = {
					max : Number.NEGATIVE_INFINITY,
					min : Number.POSITIVE_INFINITY
				};
			}

			if (range.max > this._valueAxisRange[valueAxis].max) {
				this._valueAxisRange[valueAxis].max = range.max;
			}
			if (range.min < this._valueAxisRange[valueAxis].min) {
				this._valueAxisRange[valueAxis].min = range.min;
			}
		},

		bindSeriesWithAxes : function() {
			var seriesOption = this._chart_options.properties.measures;
			var seriesArray = this._seriesGroup.getSeriesList();
			var validCount = 0;

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = seriesOption[i] || {};
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if (o.visible) {
					var valueAxis = o.valueAxis || 0;
					seriesArray[validCount].setXAxis(this._xaxes[valueAxis]);
					seriesArray[validCount].setYAxis(this._yaxes[0]);
					validCount++;
				}
			}
		},
		
		bindRenderer : function(layer) {
			if (this._barRenderer == null) {
				this._barRenderer = new BarRenderer(layer,
						this._chart_options.properties.bar);
			} else {
				this._barRenderer.resetSeriesGroup();
			}
			this._barRenderer.addSeriesGroup(this._seriesGroup);
		},
		
		drawSeries : function() {
			if (!this._hasDrawn) {
				this._barRenderer.draw();
				this._hasDrawn = true;
			} else {
				this._barRenderer.redraw();
			}

			if (this._defaultSelectionArmed) {
				// If default selection is armed, let it go.
				var defaultSelections = this._chart_options.properties.selectability.defaultSelectedItems;
				if (defaultSelections
						&& defaultSelections.length > 0) {
					this.doSelect(defaultSelections);
				}
				// Default selection won't get performed more
				// than twice.
				this._defaultSelectionArmed = false;
			} else {
				this.doSelect(this._selections);
			}
		},

		/**
		 * To align the yaxis and xaxis, we should adjust the
		 * position of axis to an integer position. so we do
		 * following adjustment. 1. set the ceiled y position
		 * and floored x position of yaxis[0] 2. set the floor x
		 * position and rounded y position of xaxis[0] 3. set
		 * the ceiled y position and floored x position of
		 * xaxis[1] if it exists 4. set the floored y position
		 * and floored x position of _seriesMaskLayer
		 */
		doChartLayout : function(nsize, yaxisLayers,
				xaxisLayers, seriesMaskLayer, seriesLayer) {
			this._seriesLayer = seriesLayer;

			var xTop = {
				width : 0,
				height : 0
			};
			var xBottom = {
				width : 0,
				height : 0
			};
			var yLeft = {
				width : 0,
				height : 0
			};
			var yRight = {
				width : 0,
				height : 0
			};

			// TODO: currently only left yaxis
			yLeft.width += this._yaxes[0].getPreferredWidth();
			var tempXaxisLength = (nsize.width - yLeft.width) * 0.95;

			this._xaxes[0].updateProperties({
				distance : tempXaxisLength
			});
			xBottom.width += this._xaxes[0].getPreferredWidth();
			xBottom.height += this._xaxes[0]
					.getPreferredHeight();

			// TODO: currently only primary(at bottom) and
			// secondary(at top)
			// xaxis
			if (this._xaxes.length == 2) {
				this._xaxes[1].updateProperties({
					distance : tempXaxisLength
				});
				xTop.width += this._xaxes[1].getPreferredWidth();
				xTop.height += this._xaxes[1].getPreferredHeight();
			}

			var topPadding = xTop.height > 0 ? xTop.height : nsize.height * 0.1;

			var tempYaxisLength = (nsize.height - xBottom.height - topPadding) * 0.95;
			this._yaxes[0].updateProperties({
				distance : tempYaxisLength
			});
			yLeft.height += this._yaxes[0].getPreferredHeight();

			yaxisLayers[0].size({
				width : yLeft.width,
				height : yLeft.height
			});
			yaxisLayers[0].position({
				x : 0,
				y : Math.ceil(topPadding)
			})

			xaxisLayers[0].size({
				width : xBottom.width,
				height : xBottom.height
			});
			// we set y position of xaxis layer according to the
			// y position of yaxis and the height of yaxis.
			// if the sum value of them is between 0 ~ 0.5, we
			// should floor the value of y position of yaxis.
			// if the value is between 0.5 ~ 1, we should ceil
			// the value of y position of yaxis
			xaxisLayers[0]
					.position({
						x : Math.floor(yLeft.width
										- this._xaxes[0].getFirstTickOffset()
										- this._yaxes[0].getLineThickness() / 2),
						y : Math.round(topPadding
								+ yLeft.height
								- this._xaxes[0].getMajorTickWidth() / 2)
					});

			if (xTop.height > 0) {
				// Top X axis is enabled
				xaxisLayers[1].size({
					width : xTop.width,
					height : xTop.height
				});
				xaxisLayers[1].position({
					x : Math.floor(yLeft.width
							- this._xaxes[1].getFirstTickOffset()
							- this._yaxes[0].getLineThickness() / 2),
					y : Math.ceil(this._xaxes[1].getMajorTickWidth() / 2)
				});
			}

			seriesMaskLayer.size({
				width : tempXaxisLength,
				height : tempYaxisLength
			});

			seriesMaskLayer.position({
				x : Math.floor(this._yaxes[0].getAxisWidth()),
				y : Math.ceil(topPadding)
			});

			seriesLayer.size(seriesMaskLayer.size());
			seriesLayer.position({
				x : 0,
				y : 0
			});

			this._scrollBar[0].init(seriesMaskLayer,
					seriesLayer, 'vertical');

			if (!this._hasBacked) {
				// update visible range
				this._updateVisibleRange();
			} else {
				this.restore();
			}
			
			this._rightBound = xaxisLayers[0].position().x + this._xaxes[0].getLastTickOffset();
		},

		/**
		 * scale the series layer according to the user's
		 * visible range option if the start or end is invalid,
		 * it will draw whole dimension
		 */
		_updateVisibleRange : function() {
			var visibleRangeOption = this._chart_options.properties.visibleRange;

			var visibleRangeStart = visibleRangeOption.start;
			var visibleRangeEnd = visibleRangeOption.end;
			if (visibleRangeStart < 0
					|| visibleRangeEnd < 0
					|| visibleRangeStart > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeEnd > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeStart > visibleRangeEnd) {
				visibleRangeStart = 0;
				visibleRangeEnd = this._dataTree.getSubMemberLabels().length - 1;
			}

			if (visibleRangeStart === 0
					&& visibleRangeEnd === this._dataTree.getSubMemberLabels().length - 1)
				return;

			var range = visibleRangeEnd - visibleRangeStart + 1;
			var scale = this._dataTree.getSubMemberLabels().length / range;
			this._yaxes[0].setVisibleRange(1, scale, scale);

			var interval = this._yaxes[0].getTickInterval();
			this._yaxes[0].position(0, -interval * visibleRangeStart);

			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width,
				height : curSize.height * scale
			});
			this.position(0, -interval * visibleRangeStart);

			// [Ian]Check whether it is in IPad, now we only
			// show the scroll bar in IPad, do not show it in
			// browser and another device.
			if (UADetector.os() === 'iPad') {
				this._scrollBar[0].update();
				this._scrollBar[0].unHighLight();
			}
		},

		updateProperties : function(propBag) {
			this.callParent('updateProperties', propBag);

			var seriesOption = this._chart_options.properties.measures;
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			var barOptions = this._chart_options.properties.bar;
			var barSeriesProperties = [];

			if (TypeUtils.isExist(barOptions)) {
				this._barRenderer.updateProperties(barOptions);
			}

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {},barOptions, seriesOption[i]);
				opts.fillColor = TypeUtils.isExist(opts.fillColor) 
									? opts.fillColor
									: defaultColor[i % defaultColor.length];
				
				barSeriesProperties.push(opts);
			}
			
			this._seriesGroup.updateProperties(barSeriesProperties);

			if ( !this._hasDrawn ) {
				this.initSeries();
				this._barRenderer.resetSeriesGroup();
				this._barRenderer.addSeriesGroup(this._seriesGroup);
			}
		},

		/**
		 * @return events 'selectData': {measureIndex,
		 *         dimensionItemIndex}
		 * @return events 'showTooltip': {measureIndex,
		 *         dimensionItemIndex, points }
		 * @override sap.riv.viz.xychart.ChartModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData', 'showTooltip', 'hideTooltip' ];
		},

		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		clickOnPoint : function(point) {
			if (this._barRenderer == null) {
				FunctionUtils.error('No renderer to handle event!');
			}

			var dataCtxOnPoint = this.doSelect(point);
			if (dataCtxOnPoint) {
				this.fireEvent('selectData', {
					name : 'selectData',
					data : [ {
						dimensionAxisIndex : 0, // reserved for multiple charts
						dimensionIndex : 0, // reserved for multiple charts
						dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
						measureIndex : dataCtxOnPoint.measureIndex,
						dimensionLabel : null, 
						measureValue : null
					} ]
				});
			}
		},
		
		/**
		 * Selects/highlights bar(s) by instruments or programmatically.
		 * 
		 * @param {Object} target
		 * - Specifier for a bar target, which could be a mouse point, 
		 * touch point or a bar path, i.e., dimension-measure pair(s).
		 * @returns {Object} dataContext 
		 * - Contextual data when bar(s) are selected successfully
		 * 
		 * (This method is obsolete and will be deprecated soon.)
		 * @author eye
		 */
		doSelect : function(target) {
			if (!target)
				return;

			// Represents a mouse click, touch or programmatic
			// selection.
			var selection = {
				"measureIndex" : null,
				"dimensionItemIndex" : null
			};

			var selectionOptions = this._chart_options.properties.selectability;
			var series, dataContext;

			if ( selectionOptions.mode === 'single' ) {
				if ( this._selections.length > 1 ) {
					// Erases multiple selections
					this._selections.splice(0, this._selections.length);
				}

				// No bar is selected, so it's safe to highlight
				// a bar straightforwardly.
				if ( this._selections.length === 0 ) {
					// Select by precise indexes.
					// The code snippet here simply implies that
					// it's executed for default selection,
					// programmatic selection is not well
					// supported so we limit its functionalities.
					if ( target[0] && TypeUtils.isDefined(target[0].measureIndex) ) {
						if ( !this._barRenderer.shapeExists(target[0].measureIndex,
								target[0].dimensionItemIndex) ) {
							return;
						}
						this._barRenderer.highlight(target[0]);
						selection.measureIndex = target[0].measureIndex;
						selection.dimensionItemIndex = target[0].dimensionItemIndex;
						this._selections.push(selection);
						var rendererHighlights = this._barRenderer.getHighlights();
						if ( rendererHighlights && rendererHighlights.length !== 0 ) {
							rendererHighlights.splice(0, rendererHighlights.length);
						}
						rendererHighlights.push(selection);
						return dataContext;
					}

					if ( TypeUtils.isDefined(target.x) ) { // Mouse click point exists.
						dataContext = this._barRenderer.highlight(target);
						if ( dataContext != null ) {
							selection.measureIndex = dataContext.measureIndex;
							selection.dimensionItemIndex = dataContext.dimensionItemIndex;
							var rendererHighlights = this._barRenderer.getHighlights();
							if ( rendererHighlights && rendererHighlights.length !== 0 ) {
								rendererHighlights.splice(0, rendererHighlights.length);
							}
							rendererHighlights.push(selection);
							this._selections.push(selection);
						}
						return dataContext;
					}
				}

				// Indicates one of the bars has been selected.
				// So if the deSelectable is set true,
				// clicking on blank area or the selected bar
				// itself DO restore its initial color,
				// otherwise only clicking on another bar will
				// take effect in restoring the selected
				// bar's color.
				if ( this._selections.length === 1 ) {
					var lastSelection = this._selections[0];

					// Test if mouse point has been located on
					// one of the bars.
					var shapeSelection = this._barRenderer.getShape(target);

					if ( selectionOptions.deSelectable ) {
						if ( shapeSelection && shapeSelection.measureIndex != null ) {
							// Hits one of the bars.
							// Just restore the selected bar's color regardless of
							// if it's currently clicked.
							this._barRenderer.restore(lastSelection);
							this._selections.splice(0, 1);

							if ( shapeSelection.measureIndex !== lastSelection.measureIndex
									|| shapeSelection.dimensionItemIndex !== lastSelection.dimensionItemIndex ) {
								// If mouse click was located on
								// another shape, select it.
								selection.measureIndex = shapeSelection.measureIndex;
								selection.dimensionItemIndex = shapeSelection.dimensionItemIndex;
								dataContext = this._barRenderer.highlight(selection);
								this._barRenderer.highlight(selection);
								this._selections.push(selection);
								var rendererHighlights = this._barRenderer.getHighlights();
								if ( rendererHighlights && rendererHighlights.length !== 0 ) {
									rendererHighlights.splice(0, rendererHighlights.length);
								}
								rendererHighlights.push(selection);
							}
						} else {
							if ( TypeUtils.isDefined(target.x) ) { // It's a click on blank area.
								this._barRenderer.restore(lastSelection);
								this._selections.splice(0, 1);
							} else { // It's a component/data/property update, no mouse click detected.
								if ( this._barRenderer.shapeExists(this._selections[0].measureIndex,
											this._selections[0].dimensionItemIndex) ) {
									this._barRenderer.highlight(this._selections[0]);
								}
							}
						}
					} else {
						shapeSelection = this._barRenderer.getShape(target);
						if ( shapeSelection && shapeSelection.measureIndex != null) {
							if (shapeSelection.measureIndex === lastSelection.measureIndex
									&& shapeSelection.dimensionItemIndex === lastSelection.dimensionItemIndex ) {
								return; // Not deSelectable, so ignore it.
							} else {
								// Clicked on another bar so restore the prior
								// and highlight the newly created one.
								this._barRenderer.restore(lastSelection);
								this._selections.splice(0, 1);
								selection.measureIndex = shapeSelection.measureIndex;
								selection.dimensionItemIndex = shapeSelection.dimensionItemIndex;
								dataContext = this._barRenderer.highlight(selection);
								this._selections.push(selection);
								var rendererHighlights = this._barRenderer.getHighlights();
								if ( rendererHighlights && rendererHighlights.length !== 0 ) {
									rendererHighlights.splice(0, rendererHighlights.length);
								}
								rendererHighlights.push(selection);
							}
						} else {
							if ( this._barRenderer.shapeExists(this._selections[0].measureIndex,
										this._selections[0].dimensionItemIndex) ) {
								this._barRenderer.highlight(this._selections[0]);
							}
						}
					}
				}
				return dataContext;
			} else if ( selectionOptions.mode === 'multiple' ) {
				return; // Not supported yet
			} else {
				return; // For malicious values
			}
		},

		/**
		 * As the rangeInXY function only return the x y offset
		 * base on the init status. so the move function is also
		 * based on the init status, we can only pan the bar
		 * chart in vertical direction
		 * 
		 * Begin: store some original value into variable
		 * 
		 * Change: move the yaxis layer and series layer
		 * 
		 * Ended: at the end time, we should support damping
		 * effect. so calculate the distance by h = v* v/(2*g)
		 * and use bezierCurveTiming to render the chart
		 */
		panMove : (function() {
			var ySpeed;
			var panStartTime;
			var yaxisLayerSize;
			var yaxisSubLayerSize;
			var yaxisSubLayerPosition;
			var origSeriesPos;
			var panMove;

			return function(panGestureDetector) {

				var comp = panGestureDetector.attachedComponent();
				var range = panGestureDetector.rangeInXY();

				if (panGestureDetector.state() === GestureDetector.TransitionState.Began) {
					origSeriesPos = comp._seriesLayer.position();
					yaxisSubLayerSize = comp._yaxes[0]._sax_renderer._subLayer.size();
					yaxisSubLayerPosition = comp._yaxes[0]._sax_renderer._subLayer.position();
					yaxisLayerSize = comp._yaxes[0]._sax_renderer._layer.size();

					panStartTime = new Date().getTime();

					// when start to pan, if the chart is in
					// inital statue, we will do not show the
					// scrollbar
					if (yaxisSubLayerSize.height > yaxisLayerSize.height) {
						comp._chartModule._scrollBar[0].highLight();
					}

					panMove = false;
				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Changed) {
					//Ian [2012-04-10] if the gesture is recongizer as a long press, we obly show tooltip 
					//and do not pan the chart
					if(panGestureDetector.attachedComponent().islongPressGesture === true ){
						//Currently, we only disable it. It is a short solution
						/*var globalXY = panGestureDetector.globalLocOfGesture();
						var plotXY = comp.convertPointFromGlobal(globalXY);
						var targetLayer = comp._rootLayer;
						var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
						comp._chartModule.hoverOnPoint(point);
						*/
						return;
					}
					//End
					
					panMove = true;

					/*
					if ((origSeriesPos.y + range.y) >= 0
							|| (origSeriesPos.y
									+ range.y
									+ comp._yaxes[0]._sax_renderer._subLayer
											.size().height <= comp._yaxes[0]._sax_renderer._layer
									.size().height)) {
						return;
					}*/
					//Fix the bug[Ian 2012-4-19], when the chart is in the boundary, it is hard to move. 
					var yOffset = 0;

					if((origSeriesPos.y + range.y) > 0){
						yOffset = - origSeriesPos.y;
					}else if (origSeriesPos.y + range.y
									+ comp._seriesLayer.size().height <= comp._seriesMaskLayer
									.size().height){
						yOffset = comp._seriesMaskLayer.size().height - origSeriesPos.y - comp._seriesLayer.size().height ;
					}else{
						yOffset = range.y;
					}
					//End
					
					// move the series layer
					comp._chartModule.position(origSeriesPos.x, origSeriesPos.y + yOffset);
					comp._chartModule._scrollBar[0].update();

					// move yaxis
					var yaxis = comp._yaxes;
					for ( var i = yaxis.length; i--;) {
						yaxis[i].position(0, origSeriesPos.y + yOffset);
					}
					ySpeed = panGestureDetector.velocityInXY().y;
					panStartTime = new Date().getTime();

				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Ended) {
					if ((origSeriesPos.y + range.y) >= 0
							|| (origSeriesPos.y
									+ range.y
									+ comp._yaxes[0]._sax_renderer._subLayer
											.size().height <= comp._yaxes[0]._sax_renderer._layer
									.size().height)) {
						// if the chart is in zoom status, we
						// should show the scrollbar and
						// unhighlight it.
						if (yaxisSubLayerSize.height > yaxisLayerSize.height) {
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
						}
						panMove = false;
						return;
					}

					if (panMove) {
						// [Ian 2012-2-21] Fix the bug
						// VISUAL-1186, we should comfirm that
						// do the inertia effect only when the
						// ySpeed is large than 0
						if (ySpeed == 0) {
							panMove = false;
							// if you touch the chart and pan
							// the chart at start time and do
							// not pan the chart at later, you
							// should unhighlight the chart
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
							return;
						}
						// End
						
						var panAcceleration = (ySpeed - 0) / (new Date().getTime() - panStartTime);
						var self = comp;
						var curPos = self._seriesLayer.position();

						// as the distance is so small, we
						// enlarge it 10 times
						var s = ySpeed * ySpeed / (2 * panAcceleration) * 10;
						Animator.animate({
							values : [ {
								type : 'FLOAT',
								from : 0.0,
								to : s
							} ],
							duration : 600,
							easing : 'EaseOut',
							onStep : function(values) {
								if ((curPos.y + values[0]) > 0
										|| curPos.y
												+ values[0]
												+ self._yaxes[0]._sax_renderer._subLayer
														.size().height <= self._yaxes[0]._sax_renderer._layer
														.size().height)
									return;
								self._seriesLayer.position({
									x : curPos.x,
									y : curPos.y + values[0]
								}); 
								self._yaxes[0].position(0, curPos.y	+ values[0]);
								self._chartModule._scrollBar[0].update();
								self._rootLayer.setNeedsDisplay();
							},
							onComplete : function() {
								var pos = comp._yaxes[0]._sax_renderer._subLayer.position().y;
								var overZeroHeight = comp._yaxes[0]._sax_renderer._subLayer.size().height + pos;
								if (pos > 0) {
									Animator.animate({
										values : [ {
											type : 'FLOAT',
											from : pos,
											to : 0
										} ],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : 0,
												y : values[0]
											});
											self._yaxes[0].position(0, values[0]);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else if (overZeroHeight < yaxisLayerSize.height) {
									Animator.animate({
										values : [ {
											type : 'FLOAT',
											from : pos,
											to : (yaxisLayerSize.height - overZeroHeight + pos)
										} ],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : 0,
												y : values[0]
											});
											self._yaxes[0].position(0, values[0]);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else {
									self._chartModule._scrollBar[0].unHighLight();
								}
							}
						});

						panMove = false;
					} else {
						// if you touch the chart and do not pan
						// the chart, you should unhighlight the
						// chart
						comp._chartModule._scrollBar[0].unHighLight();
						comp._rootLayer.setNeedsDisplay();
					}
				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Cancelled) {

				}
			};
		})(),

		/**
		 * @param xscale,
		 *            scale size in xasix direction
		 * @param yscale,
		 *            scale size in yaxis direction
		 * @param viewPort,
		 *            visiable view size
		 * 
		 * if viewPort is exist, we only draw the visiable size
		 */
		scale : function(xscale, yscale, viewPort) {
			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width * xscale,
				height : curSize.height * yscale
			});

			this._barRenderer.drawViewPort(yscale, viewPort);

		},

		/**
		 * when user pinch the chart, we scale the chart
		 * according to the closest bar index to gesture. To
		 * avoid scale to quick, we compute the squre value of
		 * scale.
		 * 
		 * the max scale size: we set the max size is that one
		 * single domension in visible area.
		 * 
		 * the min scale size: we all the min size is that all
		 * the dimension in visible area. when user zoom in the
		 * chart and the chart's size is less than visible size,
		 * then zoom out the size to fulfill visible area.
		 * 
		 * Begin: store the values.
		 * 
		 * Chnaged: only draw the shapes in visible area to
		 * imporve the performance.
		 * 
		 * End: draw all the shapes
		 * 
		 * Cancle: To be implemented
		 */
		pinchingResize : (function() {
			var seriesLayerOldSize;
			var seriesLayerPosition;
			var seriesMaskLayerSize;
			var point;
			var pinchStartTime;
			var majorTicks;
			var closeMark;
			var seriesCount;
			var measureCount;
			var interval;
			var oriScale;
			return function(recognizer) {
				var comp = recognizer.attachedComponent();
				var tscale = recognizer.scale();
				// As the touch event is so sensitive, so we
				// should round the scale value
				// tscale = Math.sqrt(tscale);
				tscale = Math.round(tscale * 100) / 100;

				if (recognizer.state() === GestureDetector.TransitionState.Began) {

					seriesLayerOldSize = comp._seriesLayer.size(); // series layer's size
					seriesLayerPosition = comp._seriesLayer.position(); // series layer's position
					seriesMaskLayerSize = comp._seriesMaskLayer.size();
					point = recognizer.globalLocOfGesture();
					point.y = point.y - comp._seriesMaskLayer.position().y;
					// TODO: find the closed mark Tick
					pinchStartTime = new Date().getTime();

					majorTicks = comp._yaxes[0].getMajorTicks();
					interval = comp._yaxes[0].getTickInterval();
					var halfInterval = interval / 2;
					closeMark = -1;

					// find the close the mark index, if we can
					// find it. set he closeMark to the half
					// value of major size
					for ( var i = 0, len = majorTicks.length; i < len; i++) {
						if (Math.abs(majorTicks[i] - point.y + seriesLayerPosition.y) 
								<= halfInterval) {
							closeMark = i;
							break;
						}
					}
					if (closeMark === -1) {
						closeMark = Math.floor(majorTicks.length / 2);
					}

					seriesCount = comp._metaData.measureMembers.length > 20 ? 20
							: comp._metaData.measureMembers.length;
					measureCount = comp._dataTree.getSubMemberLabels().length;

					// when start to pinch, we should show
					// scroll bar
					comp._chartModule._scrollBar[0].highLight();
					comp._rootLayer.setNeedsDisplay();
					oriScale = tscale;
					
					//Fix the bug, [Ian 2012-04-26] VISUAL-1571 
					//[Bar] pinch without losing long touch cause line data marker and mouse over line show improperly.
					//if the first gesture is long press, clear it when pinch start.
					if(comp.islongPressGesture === true ){
						comp.islongPressGesture = false;
						comp._chartModule.onblur();
					}
					
				} else if (recognizer.state() == GestureDetector.TransitionState.Changed) {
					/**
					 * when touch move, in order to not draw shape
					 * too often, we calculate the size very 30 ms
					 */
					var scale = 0;
					scale = Math.round((tscale / oriScale) * 100) / 100;

					// Fix the bug, if the gesture is not move,
					// we should do not large the chart.
					if (tscale === oriScale) {
						return;
					}

					oriScale = tscale;
					
					var stime = new Date().getTime();
					//To do not draw chart too frequence, we can do pinch action every 0.005 second
					if ((stime - pinchStartTime) > 5) {
						pinchStartTime = stime;

						// To do not enlarge the size unlimited,
						// set the largest size is 4 times of
						// the background series size
						if (scale >= 1 && interval * scale >= seriesMaskLayerSize.height) {
							return;
						}

						// To do not curtail the size unlimited,
						// set the least size
						if (scale < 1 && interval * scale 
								<= seriesMaskLayerSize.height / (2 * measureCount)) {
							return;
						}

						interval *= scale;

						var yaxis = comp._yaxes;
						for ( var i = yaxis.length; i--;) {
							yaxis[i].zoom(1, scale, scale);
						}

						var offset = {
							x : 0,
							y : 0
						}
						var newMajorTicks = comp._yaxes[0].getMajorTicks();
						if (scale >= 1) {
							offset.y = majorTicks[closeMark]
									- newMajorTicks[closeMark]
									+ seriesLayerPosition.y;
						} else {
							offset.y = seriesLayerPosition.y
									- (newMajorTicks[closeMark] - majorTicks[closeMark]);
						}

						seriesLayerOldSize.height = seriesLayerOldSize.height * scale;
						comp._chartModule.position(offset.x, offset.y);

						comp._chartModule.scale(1, scale, seriesMaskLayerSize);
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._gridLine.gestureUpdate();
						yaxis[0].position(0, offset.y);
						comp._rootLayer.setNeedsDisplay();
					}
				} 
				else if ( recognizer.state() == GestureDetector.TransitionState.Ended || recognizer.state() == GestureDetector.TransitionState.Cancelled ) {
					// redraw all the shapes
					comp._chartModule.scale(1, 1);
					comp._chartModule._scrollBar[0].update();
					comp._chartModule._scrollBar[0].unHighLight();
					comp._rootLayer.setNeedsDisplay();

					var size = comp._seriesLayer.size();
					if (size.height <= seriesMaskLayerSize.height) {
						var nscale = seriesMaskLayerSize.height/ size.height;

						var yaxis = comp._yaxes;
						for ( var i = yaxis.length; i--;) {
							yaxis[i].zoom(1, nscale, nscale);
							yaxis[i].position(0, 0);
						}

						comp._chartModule.scale(1, nscale);
						comp._seriesLayer.position({
							x : 0,
							y : 0
						});
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._scrollBar[0].hidden();
						comp._chartModule._gridLine.gestureUpdate();
						comp._rootLayer.setNeedsDisplay();
						
					}
				}
			};
		})(),

		/**
		 * @param recognizer
		 * 
		 * if the gesture is reconginzer as a long press gesture, we will show tooltip.
		 * and set the variable islongPressGesture true.
		 * 
		 */
		longPressHandler:(function() {
			return function(recognizer){
				var comp = recognizer.attachedComponent();
				if (recognizer.state() === GestureDetector.TransitionState.Began) {
					comp.islongPressGesture = true;
					//get the global xy, to convert the point to series layer, we should do two thing.
					//1. convert the global point to plot component point.
					//2. convert the component point to series layer point.
					var globalXY = recognizer.globalLocOfGesture();
					var plotXY = comp.convertPointFromGlobal(globalXY);
					var targetLayer = comp._rootLayer;
					var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
					
					//do interaction when point hit.
					comp._chartModule.hoverOnPoint(point);
				}
			};
		})(),
		
		/**
		 * @param recognizer
		 * 
		 * Tap gesture on chart component
		 */
		tapHandler: function(recognizer){
			var comp = recognizer.attachedComponent();
			if (recognizer.state() === GestureDetector.TransitionState.Ended) {
				//get the global xy, to convert the point to series layer, we should do two thing.
				//1. convert the global point to plot component point.
				//2. convert the component point to series layer point.
				var globalXY = recognizer.globalLocOfGesture();
				var plotXY = comp.convertPointFromGlobal(globalXY);
				var targetLayer = comp._rootLayer;
				var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
				//do interaction when tap
				comp._chartModule.clickOnPoint(point);
			}
		},
		
		backUp : function() {
			this._hasBacked = true;
			this._backedYScale = this._yaxes[0]._sax_renderer._subLayer
					.size().height / this._yaxes[0]._sax_renderer._layer.size().height;
			this._backedYPoint = this._yaxes[0]._sax_renderer._subLayer.position().y;
		},

		restore : function() {
			if (this._hasBacked
					&& TypeUtils.isExist(this._backedYScale)
					&& TypeUtils.isExist(this._backedYPoint)) {
				
				//Fix the bug: [Ian] even though the chart is in its original size, the scroll bar is still show because we consider the 1 as an scale
				if(this._backedYScale <= 1.00000000001){
					return;
				}
				
				this._yaxes[0].setVisibleRange(1, this._backedYScale, this._backedYScale);
				this._yaxes[0].position(0, this._backedYPoint);

				var curSize = this._seriesLayer.size();
				this._seriesLayer.size({
					width : curSize.width,
					height : curSize.height * this._backedYScale
				});
				this.position(0, this._backedYPoint);

				// [Ian]Check whether it is in IPad, now we only
				// show the scroll bar in IPad, do not show it
				// in browser and another device.
				if (UADetector.os() === 'iPad') {
					this._scrollBar[0].update();
					this._scrollBar[0].unHighLight();
				}

				this._backedYScale = null;
				this._backedYPoint = null;
				this._hasBacked = false;
			}
		},

		applyTheme : function(theme) {
			this._barRenderer.applyTheme(theme);
		},

		hoverOnPoint : function(point) {
			// If do not exist the bar renderer, ignore the
			// hover event
			if (!this._barRenderer) {
				return;
			}

			var dataCtxOnPoint = this._barRenderer
					.hoverOnPoint(point);
			if (dataCtxOnPoint) {
				this.fireEvent('showTooltip', {
					name : 'showTooltip',
					data : [ {
						dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
						point : point
					} ]
				});
			}
		},

		onblur : function(point) {
			this._barRenderer.onblur(point);
			// fire hide tooltip event
			this.fireEvent('hideTooltip', {
				name : 'hideTooltip',
				data : [ {} ]
			});
		},
		
		getPlotArea : function() {
		    return {
		        top : 0,
		        left : 0,
		        bottom : 0,
		        right : this._rightBound
		    };
		}

	});
	return BarModule;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.PinchGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	/**
	 * This class defines detector for detecting Pinching gesture.
	 * 
	 * @name sap.riv.vizkit.PinchGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */
	var PinchGestureDetector = ObjUtils.derive(GestureDetector, {
		constructor : function() {
			this._origDistance = 1;
			this._currDistance = 1;
			this._startWhen = 0;
			this._stopWhen = 0;
		},

		_distance : function() {
			var points = [];
			for ( var tId in this._grTouchTracker) {
				points.push(this._grTouchTracker[tId].globalXY);
			}
			var dx = points[1].x - points[0].x;
			var dy = points[1].y - points[0].y;
			return Math.sqrt(dx * dx + dy * dy);
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();

			if (this.state() === ts.Possible) {
				if (currentNumOfTouches === 2) {
					var twoTouchDistance = this._distance();
					if (twoTouchDistance > 35) {
						this._origDistance = this._currDistance = twoTouchDistance;
						this._startWhen = this._stopWhen = touchStartEvent.timeStamp;
					} else {
						this._setState_(ts.Failed);
						return;
					}
				}
				// If more than 2 touches began, regard it as a failure
				else if (currentNumOfTouches > 2) {
					this._setState_(ts.Failed);
					return;
				}
				// If only one touch began, we can wait for another one to come.
			} else if ((this.state() === ts.Began || this.state() === ts.Changed)) {
				this._stopWhen = touchStartEvent.timeStamp;
				this._currDistance = this._distance();

				this._setState_(ts.Cancelled);
				return;
			}
		},

		doTouchMove : function(touchMoveEvent) {
			switch (this.state()) {
			case ts.Possible:
				if (this.totalTouches() === 2) {
					this._stopWhen = touchMoveEvent.timeStamp;
					this._currDistance = this._distance();

					var scale = this.scale();
					if (scale > 1.1 || scale < 0.9) {
						this._setState_(ts.Began);
					}
				}
				break;
			case ts.Began:
				if (Math.abs(this._origDistance - this._distance()) > 10) {
					this._stopWhen = touchMoveEvent.timeStamp;
					this._currDistance = this._distance();
					this._setState_(ts.Changed);
				}
				break;
			case ts.Changed:
				this._currDistance = this._distance();
				this._stopWhen = touchMoveEvent.timeStamp;
				this._setState_(ts.Changed);
				break;
			}
		},

		doTouchEnd : function(touchEndEvent) {
			if ((this.state() === ts.Began || this.state() === ts.Changed) && this.totalTouches() === 0) {
				this._stopWhen = touchEndEvent.timeStamp;
				this._currDistance = this._distance();
				this._setState_(ts.Ended);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._stopWhen = touchCancelEvent.timeStamp;
				this._currDistance = this._distance();
				this._setState_(ts.Cancelled);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},
		/**
		 * The current scale of the pinching gesture
		 * 
		 * 
		 * @name sap.riv.vizkit.PinchGestureDetector#scale
		 * @function
		 * @return {Number}
		 */
		scale : function() {
			return this._currDistance / this._origDistance;
		},
		/**
		 * The current velocity of the pinching gesture
		 * 
		 * 
		 * @name sap.riv.vizkit.PinchGestureDetector#velocity
		 * @function
		 * @return {Number}
		 */
		velocity : function() {
			var duration = this._startWhen - this._stopWhen;
			if (duration) {
				return Math.abs((this._currDistance - this._origDistance)) * 1000 / duration;
			} else {
				return 0;
			}
		},
		reset : function() {
			this.callParent('reset');

			this._origDistance = 1;
			this._currDistance = 1;
			this._startWhen = 0;
			this._stopWhen = 0;
		}
	});
	return PinchGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.CombinationModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.Axis',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.ColumnBarRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.LineRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesHighlighter',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.ChartModule',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, FunctionUtils, LOG, UADetector, GestureDetector, Animator,
		Axis, SeriesGroup, Series, ColumnBarRenderer, LineRenderer, SeriesHighlighter, ChartModule) {
	var defaultOptions = {
			xAxis :{
				showMajor : false,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			},
			yAxis :{
				showMajor : true,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			}
	};
	
	var CombinationModule = ObjUtils.derive(ChartModule, {
		events : [ 'selectData', 'showTooltip', 'hideTooltip' ],

		constructor : function(options) {
			this._valueAxisRange = [];
			this._barSeriesGroup = null;
			this._lineSeriesGroup = null;
			this._columnBarRenderer = null;
			this._hasDrawn = false;
			this._hasBacked = false;
			this._tooltipEnabled = options.properties.tooltip.enable;
		},

		initGridLineProperties : function() {
			this._xAxis_gridLine_option = ObjUtils
					.extend(
							true,
							defaultOptions.xAxis,
							this._chart_options.properties.xAxis[0].gridLine);
			this._yAxis_gridLine_option = ObjUtils
					.extend(
							true,
							defaultOptions.yAxis,
							this._chart_options.properties.yAxis[0].gridLine);

			this._gridLine.setXAxisOptions(this._xAxis_gridLine_option);
			this._gridLine.setYAxisOptions(this._yAxis_gridLine_option);
			// Nick - if users have some wrong settings, we do not throw any error, but the behavior is unexpected.
			// be consistent with showMajorticks
			//this.gridLinePropertiesCheck();
		},
		
		gridLinePropertiesCheck : function() {
			// Nick - if users have some wrong settings for the grid line, an error is thrown out
			if((!this._yAxis_gridLine_option.showMajor && this._yAxis_gridLine_option.showSub) || this._xAxis_gridLine_option.showMajor || this._xAxis_gridLine_option.showMinor){
				FunctionUtils.error("Wrong settings for grid line of combination chart");
			}
			
		},

		initAxes : function() {
			this._initXAxes();
			this._initYAxes();
		},

		_initXAxes : function() {
			this._xaxes = [];
			var xaxesOption = this._chart_options.properties.xAxis;
			var labels = this._dataTree.getSubMemberLabels();
			if(labels.length < 1){
				labels = [];
				labels.push('1');
			}
			for ( var i = 0, len = xaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(xaxesOption[i].showTitle) && xaxesOption[i].showTitle
						&& !TypeUtils.isExist(xaxesOption[i].title) ) {
					xaxesOption[i].title = "X" + (i + 1);
				}
				
				var option = {
					mode : Axis.DIMENSION,
					position : 'hb',
					labels : labels
				}
				var x = new Axis(ObjUtils.extend(true, option, xaxesOption[i]));
				this._xaxes.push(x);
			}
		},

		_initYAxes : function() {
			this._yaxes = [];
			var yaxesOption = this._chart_options.properties.yAxis;
			for ( var i = 0, len = yaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(yaxesOption[i].showTitle) && yaxesOption[i].showTitle
						&& !TypeUtils.isExist(yaxesOption[i].title) ) {
					yaxesOption[i].title = "Y" + (i + 1);
				}
				
				// FIX ISSUE: if there are two axis and more
				// than one series, but it only use the one
				// series. so according to the valueAxisRange
				// to judge whether the axis is to been used.
				// when it is not to been used, set the min 0,
				// max 0
				var option = {
					mode : Axis.LINEAR,
					position : i === 0 ? 'vl' : 'vr',
					maxValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].max
							: 0,
					minValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].min
							: 0
				}
				var y = new Axis(ObjUtils.extend(true, option, yaxesOption[i]));
				this._yaxes.push(y);
			}
		},

		initSeries : function() {
			this._valueAxisRange = [];
			var seriesOption = this._chart_options.properties.measures;
			var measureMembers = this._metaData.measureMembers;
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			var barOptions = this._chart_options.properties.bar;
			var lineOptions = this._chart_options.properties.line;
			this._barSeriesGroup = new SeriesGroup();
			this._lineSeriesGroup = new SeriesGroup();

			for ( var i = 0, len = measureMembers.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {},
						barOptions, lineOptions,
						seriesOption[i]);
				opts.fillColor = TypeUtils
						.isExist(opts.fillColor) ? opts.fillColor
						: defaultColor[i % defaultColor.length];
				opts.lineColor = TypeUtils
						.isExist(opts.lineColor) ? opts.lineColor
						: defaultColor[i % defaultColor.length];

				var s = new Series(opts);
				s.setName(measureMembers[i]);
				s.setData(this._data[i]);
				if (this._chart_options.properties.measure.type === 'bar' || opts.type === 'bar') {
					this._barSeriesGroup.addSeries(s);
				} else {
					this._lineSeriesGroup.addSeries(s);
				}

				var valueAxis = opts.valueAxis || 0;
				this._updateValueAxisRange(s.getDataRange(), valueAxis);
			}
		},

		/**
		 * in bar chart, the scroll bar is in the right side of
		 * the chart and there is only one scroll bar.
		 */
		initScrollBar : function() {
			//Fix the bug:[Ian] if you update the chart, the scroll bar will show as we do not remove the first scrollBar
			if(this._scrollBar.length > 0){
				for(var i=0; i<this._scrollBar.length; i++){
					this._scrollBar[i].remove();
				}
			}
			
			// init scroll bar layer
			this._scrollBar = [];
			this._scrollBar[0] = this.scrollBar();

		},

		updateValueAxisRange : function() {
			this._valueAxisRange = [];
			var seriesOption = this._chart_options.properties.measures;
			var measureOption =  this._chart_options.properties.measure;
			var barSeriesIndex = 0, lineSeriesIndex = 0;
			var barSeries = this._barSeriesGroup.getSeriesList();
			var lineSeries = this._lineSeriesGroup.getSeriesList();
			
			var series;
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = seriesOption[i] || {};
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if (o.visible) {
					var valueAxis = o.valueAxis || 0;
					if (o.type === 'bar' || measureOption.type == 'bar') {
						series = barSeries[barSeriesIndex];
						barSeriesIndex++;
					} else {
						series = lineSeries[lineSeriesIndex];
						lineSeriesIndex++;
					}
					this._updateValueAxisRange(series.getDataRange(), valueAxis);
				}
			}
		},
		
		_updateValueAxisRange : function(range, valueAxis) {
			if (this._valueAxisRange[valueAxis] === undefined) {
				this._valueAxisRange[valueAxis] = {
					max : Number.NEGATIVE_INFINITY,
					min : Number.POSITIVE_INFINITY
				};
			}

			if (range.max > this._valueAxisRange[valueAxis].max) {
				this._valueAxisRange[valueAxis].max = range.max;
			}
			if (range.min < this._valueAxisRange[valueAxis].min) {
				this._valueAxisRange[valueAxis].min = range.min;
			}
		},

		bindSeriesWithAxes : function() {
			var seriesOption = this._chart_options.properties.measures;

			var barSeriesIndex = 0, lineSeriesIndex = 0;
			var barSeries = this._barSeriesGroup.getSeriesList();
			var lineSeries = this._lineSeriesGroup.getSeriesList();
			
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++ ) {
				var o = seriesOption[i] || {};

				var valueAxis = o.valueAxis || 0;
				if ( this._chart_options.properties.measure.type === 'bar' || o.type === 'bar') {
					barSeries[barSeriesIndex].setXAxis(this._xaxes[0]);
					barSeries[barSeriesIndex].setYAxis(this._yaxes[valueAxis]);
					barSeriesIndex++;
				} else {
					lineSeries[lineSeriesIndex].setXAxis(this._xaxes[0]);
					lineSeries[lineSeriesIndex].setYAxis(this._yaxes[valueAxis]);
					lineSeriesIndex++;
				}
			}
		},

		bindRenderer : function(layer) {
			if (this._columnBarRenderer == null
					&& this._lineRenderer == null) {
				this._columnBarRenderer = new ColumnBarRenderer(layer,
						this._chart_options.properties.bar);
				this._lineRenderer = new LineRenderer(layer,
						this._chart_options.properties.line);
			} else {
				this._columnBarRenderer.resetSeriesGroup();
				this._lineRenderer.resetSeriesGroup();
			}
			
			this._columnBarRenderer.addSeriesGroup(this._barSeriesGroup);
			this._lineRenderer.addSeriesGroup(this._lineSeriesGroup);
		},

		drawSeries : function() {
			// =====================================================================
			// Selection specifics 
			var selectionOptions = this._chart_options.properties.selectability;
			var maxSelections = 0;
			if ( selectionOptions.mode === 'single' ) {
				maxSelections = 1;
			}
			if ( selectionOptions.mode === 'multiple' ) {
				maxSelections = 1000;
			}
			
			if ( !this._highlighter ) {
				if ( this._defaultSelectionArmed ) {
					this._highlighter = new SeriesHighlighter(
						[ this._columnBarRenderer, this._lineRenderer ],
						maxSelections, true);
					if ( selectionOptions.mode !== 'none'
							&& selectionOptions.defaultSelectedItems.length !== 0 
							&& TypeUtils.isDefined(selectionOptions.defaultSelectedItems[0].measureIndex) ) {
						this._highlighter.setTargets(selectionOptions.defaultSelectedItems);
						this._highlighter.run();
					}
					this._defaultSelectionArmed = false;
				}
			} else {
				this._highlighter.run();
			}
			// =====================================================================
			
			if (!this._hasDrawn) {
				this._columnBarRenderer.draw();
				this._lineRenderer.draw();
				this._hasDrawn = true;
			} else {
				this._columnBarRenderer.redraw();
				this._lineRenderer.redraw();
			}
			this._highlighter.reload();
		},

		/**
		 * To align the yaxis and xaxis, we should adjust the
		 * position of axis to an integer position. so we do
		 * following adjustment. 1. set the ceiled y position
		 * and floored x position of yaxis[0] 2. set the floored
		 * x position and rounded y position of xaxis[0] 3. set
		 * the floored y position and rounded x position of
		 * xaxis[1] if it exists 4. set the floored y position
		 * and floored x position of seriesMaskLayer
		 */
		doChartLayout : function(nsize, yaxisLayers,
				xaxisLayers, seriesMaskLayer, seriesLayer) {
			this._seriesLayer = seriesLayer;

			var xTop = {
				width : 0,
				height : 0
			};
			var xBottom = {
				width : 0,
				height : 0
			};
			var yLeft = {
				width : 0,
				height : 0
			};
			var yRight = {
				width : 0,
				height : 0
			};

			// TODO: currently only left yaxis
			yLeft.width += this._yaxes[0].getPreferredWidth();
			if (this._yaxes.length === 2) {
				yRight.width += this._yaxes[1].getPreferredWidth();
			}
			var tempXaxisLength = (nsize.width - yLeft.width - yRight.width) * 0.95;

			this._xaxes[0].updateProperties({
				distance : tempXaxisLength
			});
			
			xBottom.width += this._xaxes[0].getPreferredWidth();
			xBottom.height += this._xaxes[0].getPreferredHeight();

			var topPadding = xTop.height > 0 ? xTop.height : nsize.height * 0.1;

			var tempYaxisLength = (nsize.height - xBottom.height - topPadding) * 0.95;
			this._yaxes[0].updateProperties({
				distance : tempYaxisLength
			});
			yLeft.height += this._yaxes[0].getPreferredHeight();

			// TODO: currently only primary(at left) and
			// secondary(at right) yaxis
			if (this._yaxes.length === 2) {
				this._yaxes[1].updateProperties({
					distance : tempYaxisLength
				});
				yRight.height += this._yaxes[1].getPreferredHeight();
			}

			yaxisLayers[0].size({
				width : yLeft.width,
				height : yLeft.height
			});
			yaxisLayers[0].position({
				x : 0,
				y : Math.ceil(topPadding)
			})

			xaxisLayers[0].size({
				width : xBottom.width,
				height : xBottom.height
			});

			xaxisLayers[0].position({
				x : Math.floor(this._yaxes[0].getAxisWidth()),
				y : Math.ceil(topPadding)
						+ Math.round(this._yaxes[0]
								.getFirstTickOffset())// Math.floor(yLeft.height
			// -
			// this._yaxes[0].getLastTickOffset())
			});

			if (yRight.height > 0) {
				// Top X axis is enabled
				yaxisLayers[1].size({
					width : yRight.width,
					height : yRight.height
				});
				yaxisLayers[1].position({
					x : Math.floor(this._yaxes[0].getAxisWidth()
							+ xBottom.width
							- this._yaxes[1].getMajorTickWidth() / 2),
					y : Math.ceil(topPadding)
				});
			}

			seriesMaskLayer.size({
				width : tempXaxisLength,
				height : tempYaxisLength + this._yaxes[0].getLastTickOffset()
			});
			seriesMaskLayer.position({
				x : Math.floor(this._yaxes[0].getAxisWidth()),
				y : Math.floor(xTop.height > 0 ? this._xaxes[1].getAxisWidth() : topPadding)
			});

			seriesLayer.size(seriesMaskLayer.size());
			seriesLayer.position({
				x : 0,
				y : 0
			});

			this._scrollBar[0].init(seriesMaskLayer, seriesLayer, 'horizontal');

			if (!this._hasBacked) {
				this._updateVisibleRange();
			} else {
				this.restore();
			}
			
			this._topBound = topPadding + this._yaxes[0].getLastTickOffset();
		},

		/**
		 * scale the series layer according to the user's
		 * visible range option if the start or end is invalid,
		 * it will draw whole dimension
		 */
		_updateVisibleRange : function() {
			var visibleRangeOption = this._chart_options.properties.visibleRange;

			var visibleRangeStart = visibleRangeOption.start;
			var visibleRangeEnd = visibleRangeOption.end;
			if ( visibleRangeStart < 0
					|| visibleRangeEnd < 0
					|| visibleRangeStart > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeEnd > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeStart > visibleRangeEnd ) {
				visibleRangeStart = 0;
				visibleRangeEnd = this._dataTree.getSubMemberLabels().length - 1;
			}

			if ( visibleRangeStart === 0
					&& visibleRangeEnd === this._dataTree.getSubMemberLabels().length - 1 )
				return;

			var range = visibleRangeEnd - visibleRangeStart + 1;
			var scale = this._dataTree.getSubMemberLabels().length / range;
			this._xaxes[0].setVisibleRange(scale, 1, scale);

			var interval = this._xaxes[0].getTickInterval();
			this._xaxes[0].position(-interval * visibleRangeStart, 0);

			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width * scale,
				height : curSize.height
			});
			this.position(-interval * visibleRangeStart, 0);
			if (UADetector.os() === 'iPad') {
				this._scrollBar[0].update();
				this._scrollBar[0].unHighLight();
			}

		},

		updateProperties : function(propBag) {
			this.callParent('updateProperties', propBag);

			var seriesOption = this._chart_options.properties.measures;
			var measureOption =  this._chart_options.properties.measure;
			var barSeriesProperties = [], lineSeriesProperties = [];
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			var barOptions = this._chart_options.properties.bar;
			var lineOptions = this._chart_options.properties.line;
			this._tooltipEnabled = this._chart_options.properties.tooltip.enable;

			if (TypeUtils.isExist(barOptions)) {
				this._columnBarRenderer.updateProperties(barOptions);
			}
			if (TypeUtils.isExist(lineOptions)) {
				this._lineRenderer.updateProperties(lineOptions);
			}

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {},
						barOptions, lineOptions,
						seriesOption[i]);
				opts.fillColor = TypeUtils
						.isExist(opts.fillColor) ? opts.fillColor
						: defaultColor[i % defaultColor.length];
				opts.lineColor = TypeUtils
						.isExist(opts.lineColor) ? opts.lineColor
						: defaultColor[i % defaultColor.length];
				if (opts.type === 'bar' || measureOption.type === 'bar') {
					barSeriesProperties.push(opts);
				} else {
					lineSeriesProperties.push(opts);
				}
			}

			this._barSeriesGroup.updateProperties(barSeriesProperties);
			this._lineSeriesGroup.updateProperties(lineSeriesProperties);
			
			// Resets renderer series groups and all previous selections
			// will be removed for now.
			if ( !this._hasDrawn ) {
				this.initSeries();
				this._columnBarRenderer.resetSeriesGroup();
				this._lineRenderer.resetSeriesGroup();
				this._columnBarRenderer.addSeriesGroup(this._barSeriesGroup);
				this._lineRenderer.addSeriesGroup(this._lineSeriesGroup);
			}
		},

		applyTheme : function(theme) {
			if (this._columnBarRenderer) {
				this._columnBarRenderer.applyTheme(theme);
			}
			if (this._lineRenderer) {
				this._lineRenderer.applyTheme(theme);
			}
		},
		/**
		 * @override sap.riv.viz.xychart.ChartModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData', 'showTooltip', 'hideTooltip' ];
		},

		clickOnPoint : function ( coord ) {
			var dataContext = this.select(coord);
			if ( TypeUtils.isDefined(dataContext)  && dataContext.length > 0 ) {
				var dataContextItem = dataContext[dataContext.length - 1];
				this.fireEvent("selectData", {
					"name" : "selectData",
					"data" : [{
						dimensionAxisIndex : 0,
						dimensionAxisIndex : 0,
						dimensionIndex : 0,
						dimensionItemIndex : dataContextItem.dimensionItemIndex,
						measureIndex : dataContextItem.measureIndex,
						dimensionLabel : null,
						measureValue : null
					}]
				});
			}
		},
		
		/**
		 * Selects chart element(s) by user action or program commands.
		 * 
		 * @param target 
		 * - Target for locating chart element(s). If it's an object,
		 * then it's a point coordinate and an array of paths otherwise.
		 * 
		 * @returns {Object} dataContext
		 * - Contextual data generated while selection(s)
		 * 
		 * @author eye
		 */
		select : function ( target ) {
			if ( !target ) return;
			
			var selectionOptions = this._chart_options.properties.selectability;
			if ( selectionOptions.mode === 'none' ) return;
			
			if ( !this._highlighter.ready() ) {
				this._highlighter.reload();
			}
			
			if ( target instanceof Array ) {
				this._highlighter.setTargets(target);
				this._highlighter.run();
				return;
			}
			
			if ( TypeUtils.isDefined(target.x) ) {
				var path = this._highlighter.hits(target);
				if ( TypeUtils.isDefined(path.measureIndex) ) {
					if ( this._highlighter.isEnrolled(path) 
							&& selectionOptions.deSelectable ) {
						this._highlighter.remove(path);
					} else {
						this._highlighter.setTargets([path]);
					}
				} else {
					if ( selectionOptions.deSelectable ) {
						this._highlighter.erase();
					}
				}
				
				// Since only single selection is supported right now,
				// only the last element of data context items will be
				// returned. Well, actually, there can be multiple values
				// here.
				return this._highlighter.run(true);
			}
		},
		
		/**
		 * As the rangeInXY function only return the x y offset
		 * base on the init status. so the move function is also
		 * based on the init status, we can only pan the bar
		 * chart in horizontal direction
		 * 
		 * Begin: store some original value into variable
		 * 
		 * Change: move the xaxis layer and series layer in
		 * horizontal direction
		 * 
		 * Ended: at the end time, we should support damping
		 * effect. so calculate the distance by h = v* v/(2*g)
		 * and use bezierCurveTiming to render the chart
		 */
		panMove : (function() {
			var ySpeed;
			var panStartTime;
			var xaxisLayerSize;
			var xaxisSubLayerSize;
			var xaxisSubLayerPosition;
			var origSeriesPos;
			var panMove;

			return function ( panGestureDetector ) {
				var comp = panGestureDetector.attachedComponent();
				var range = panGestureDetector.rangeInXY();

				if ( panGestureDetector.state() === GestureDetector.TransitionState.Began ) {
					origSeriesPos = comp._seriesLayer.position();
					xaxisSubLayerSize = comp._xaxes[0]._sax_renderer._subLayer.size();
					xaxisSubLayerPosition = comp._xaxes[0]._sax_renderer._subLayer.position();
					xaxisLayerSize = comp._xaxes[0]._sax_renderer._layer.size();

					panStartTime = new Date().getTime();

					// when start to pan, if the chart is in
					// inital statue, we will do not show the
					// scrollbar
					if ( xaxisSubLayerSize.width > xaxisLayerSize.width ) {
						comp._chartModule._scrollBar[0].highLight();
					}

					panMove = false;
				} else if ( panGestureDetector.state() 
						=== GestureDetector.TransitionState.Changed ) {
					//Ian [2012-04-10] if the gesture is recongizer as a long press, we obly show tooltip 
					//and do not pan the chart
					if(panGestureDetector.attachedComponent().islongPressGesture === true ){
						/*var globalXY = panGestureDetector.globalLocOfGesture();
						var plotXY = comp.convertPointFromGlobal(globalXY);
						var targetLayer = comp._rootLayer;
						var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
						comp._chartModule.hoverOnPoint(point);
						*/
						return;
					}
					//End
					
					panMove = true;
					
					/*
					if ((origSeriesPos.x + range.x) >= 0
							|| (origSeriesPos.x + range.x
									+ comp._seriesLayer.size().width <= comp._seriesMaskLayer
									.size().width)) {
						return;
					}*/
					//Fix the bug[Ian 2012-4-19], when the chart is in the boundary, it is hard to move. 
					var xOffset = 0;

					if((origSeriesPos.x + range.x) > 0){
						xOffset = - origSeriesPos.x;
					}else if (origSeriesPos.x + range.x
									+ comp._seriesLayer.size().width <= comp._seriesMaskLayer
									.size().width){
						xOffset = comp._seriesMaskLayer.size().width - origSeriesPos.x - comp._seriesLayer.size().width ;
					}else{
						xOffset = range.x;
					}
					//End
					
					// move the series layer
					comp._chartModule.position(origSeriesPos.x + xOffset, origSeriesPos.y);
					comp._chartModule._scrollBar[0].update();

					// move yaxis
					var xaxis = comp._xaxes;
					for ( var i = xaxis.length; i--;) {
						xaxis[i].position(origSeriesPos.x + xOffset, 0);
					}
					ySpeed = panGestureDetector.velocityInXY().x;
					panStartTime = new Date().getTime();

				} else if ( panGestureDetector.state() === GestureDetector.TransitionState.Ended ) {
					if ((origSeriesPos.x + range.x) >= 0
							|| (origSeriesPos.x
									+ range.x
									+ comp._seriesLayer.size().width <= comp._seriesMaskLayer
									.size().width)) {
						// if the chart is in zoom status, we
						// should show the scrollbar and
						// unhighlight it.
						if (xaxisSubLayerSize.width > xaxisLayerSize.width) {
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
						}
						panMove = false;
						return;
					}

					if ( panMove ) {
						// [Ian 2012-2-21] Fix the bug, we
						// should comfirm that do the inertia
						// effect only when the ySpeed is large
						// than 0
						if ( ySpeed === 0 ) {
							panMove = false;
							// if you touch the chart and pan
							// the chart at start time and do
							// not pan the chart at later, you
							// should unhighlight the chart
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
							return;
						}
						// End

						var panAcceleration = (ySpeed - 0) / (new Date().getTime() - panStartTime);
						var self = comp;
						var curPos = self._seriesLayer.position();

						// as the distance is so small, we
						// enlarge it 10 times
						var s = ySpeed * ySpeed / (2 * panAcceleration) * 10;
						Animator.animate({
							values : [{
								type : 'FLOAT',
								from : 0.0,
								to : s
							}],
							duration : 600,
							easing : 'EaseOut',
							onStep : function ( values ) {
								if ( (curPos.x + values[0]) > 0
											|| curPos.x + values[0] + self._seriesLayer.size().width 
												<= self._seriesMaskLayer.size().width) {
										return;
									}
								self._seriesLayer.position({ x : curPos.x + values[0], y : 0 });
								self._xaxes[0].position(curPos.x + values[0], 0);
								self._chartModule._scrollBar[0].update();
								self._rootLayer.setNeedsDisplay();
							},
							onComplete : function() {
								var pos = comp._seriesLayer.position().x;
								var overZeroWidth = comp._seriesLayer.size().width + pos;
								if (pos > 0) {
									Animator.animate({
										values : [{
											type : 'FLOAT',
											from : pos,
											to : 0
										}],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : values[0],
												y : 0
											});
											self._xaxes[0].position(values[0], 0);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else if ( overZeroWidth < xaxisLayerSize.width ) {
									Animator.animate({
										values : [{
											type : 'FLOAT',
											from : pos,
											to : (xaxisLayerSize.width - overZeroWidth + pos)
										}],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : values[0],
												y : 0
											});
											self._xaxes[0].position(values[0], 0);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else {
									self._chartModule._scrollBar[0].unHighLight();
								}
							}
						});
						panMove = false;
					} else {
						// if you touch the chart and do not pan
						// the chart, you should unhighlight the
						// chart
						comp._chartModule._scrollBar[0].unHighLight();
						comp._rootLayer.setNeedsDisplay();
					}
				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Cancelled) {

				}
			};
		})(),

		/**
		 * when user pinch the chart, we scale the chart
		 * according to the closest bar index to gesture. To
		 * avoid scale to quick, we compute the squre value of
		 * scale.
		 * 
		 * the max scale size: we set the max size is that one
		 * single domension in visible area.
		 * 
		 * the min scale size: we all the min size is that all
		 * the dimension in visible area. when user zoom in the
		 * chart and the chart's size is less than visible size,
		 * then zoom out the size to fulfill visible area.
		 * 
		 * Begin: store the values.
		 * 
		 * Chnaged: only draw the shapes in visible area to
		 * imporve the performance.
		 * 
		 * End: draw all the shapes
		 * 
		 * Cancle: To be implemented
		 */
		pinchingResize : (function() {
			var seriesLayerOldSize;
			var seriesLayerPosition;
			var seriesMaskLayerSize;
			var point;
			var pinchStartTime;
			var majorTicks;
			var closeMark;
			var seriesCount;
			var measureCount;
			var interval;
			var oriScale;
			return function(recognizer) {
				var comp = recognizer.attachedComponent();
				var tscale = recognizer.scale();
				// As the touch event is so sensitive, so we
				// should round the scale value
				// tscale = Math.sqrt(tscale);
				tscale = Math.round(tscale * 100) / 100;

				if (recognizer.state() === GestureDetector.TransitionState.Began) {

					seriesLayerOldSize = comp._seriesLayer.size(); // series
					// layer's size
					seriesLayerPosition = comp._seriesLayer.position(); // series
					// layer's position
					seriesMaskLayerSize = comp._seriesMaskLayer.size();
					point = recognizer.globalLocOfGesture();
					point.x = point.x - comp._seriesMaskLayer.position().x;
					// TODO: find the closed mark Tick
					pinchStartTime = new Date().getTime();

					majorTicks = comp._xaxes[0].getMajorTicks();
					interval = comp._xaxes[0].getTickInterval();
					var halfInterval = interval / 2;
					closeMark = -1;

					// find the close the mark index, if we can
					// find it. set he closeMark to the half
					// value of major size
					for ( var i = 0, len = majorTicks.length; i < len; i++) {
						if (Math.abs(majorTicks[i] - point.x
								+ seriesLayerPosition.x) <= halfInterval) {
							closeMark = i;
							break;
						}
					}
					if (closeMark === -1) {
						closeMark = Math.floor(majorTicks.length / 2);
					}

					seriesCount = comp._metaData.measureMembers.length > 20 ? 20
							: comp._metaData.measureMembers.length;
					measureCount = comp._dataTree.getSubMemberLabels().length;

					// when start to pinch, we should show
					// scroll bar
					comp._chartModule._scrollBar[0].highLight();
					comp._rootLayer.setNeedsDisplay();
					oriScale = tscale;
					
					//Fix the bug, [Ian 2012-04-26] VISUAL-1571 
					//[combination] pinch without losing long touch cause line data marker and mouse over line show improperly.
					//if the first gesture is long press, clear it when pinch start.
					if(comp.islongPressGesture === true ){
						comp.islongPressGesture = false;
						comp._chartModule.onblur();
					}
				}
				/**
				 * when touch move, in order to not draw shape
				 * too often, we calculate the size very 30 ms
				 */
				else if (recognizer.state() == GestureDetector.TransitionState.Changed) {
					var scale = 0;
					scale = Math.round((tscale / oriScale) * 100) / 100;

					// Fix the bug, if the gesture is not move,
					// we should do not large the chart.
					if (tscale === oriScale) {
						return;
					}

					oriScale = tscale;

					var stime = new Date().getTime();

					//To do not draw chart too frequence, we can do pinch action every 0.005 second
					if ((stime - pinchStartTime) > 5) {
						pinchStartTime = stime;

						// To do not enlarge the size unlimited,
						// set the largest size is 4 times of
						// the background series size
						if (scale >= 1 && interval * scale >= seriesMaskLayerSize.width) {
							return;
						}

						// To do not curtail the size unlimited,
						// set the least size
						if (scale < 1 && interval * scale <= seriesMaskLayerSize.width
										/ (2 * measureCount)) {
							return;
						}

						interval *= scale;

						var xaxis = comp._xaxes;
						for ( var i = xaxis.length; i--;) {
							xaxis[i].zoom(scale, 1, scale);
						}

						var offset = {
							x : 0,
							y : 0
						}
						var newMajorTicks = comp._xaxes[0]
								.getMajorTicks();
						if (scale >= 1) {
							offset.x = majorTicks[closeMark]
									- newMajorTicks[closeMark]
									+ seriesLayerPosition.x;
						} else {
							offset.x = seriesLayerPosition.x
									- (newMajorTicks[closeMark] - majorTicks[closeMark]);
						}

						seriesLayerOldSize.width = seriesLayerOldSize.width * scale;
						comp._chartModule.position(offset.x, offset.y);

						comp._chartModule.scale(scale, 1, seriesMaskLayerSize);
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._gridLine.gestureUpdate();
						xaxis[0].position(offset.x, 0);
						comp._rootLayer.setNeedsDisplay();
					}
				}
				/**
				 * redraw all the shapes when pinch end or cancel
				 */
				else if (recognizer.state() == GestureDetector.TransitionState.Ended || recognizer.state() == GestureDetector.TransitionState.Cancelled) {
					comp._chartModule.scale(1, 1);
					comp._chartModule._scrollBar[0].update();
					comp._chartModule._scrollBar[0].unHighLight();
					comp._rootLayer.setNeedsDisplay();

					var size = comp._seriesLayer.size();
					if (size.width <= seriesMaskLayerSize.width) {
						var nscale = seriesMaskLayerSize.width / size.width;

						var xaxis = comp._xaxes;
						for ( var i = xaxis.length; i--;) {
							xaxis[i].zoom(nscale, 1, nscale);
							xaxis[i].position(0, 0);
						}

						comp._chartModule.scale(nscale, 1);
						comp._seriesLayer.position({
							x : 0,
							y : 0
						});
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._scrollBar[0].hidden();
						comp._chartModule._gridLine.gestureUpdate();
						comp._rootLayer.setNeedsDisplay();
						
					}
					
					comp._chartModule._highlighter.reload();
				}
			};
		})(),

		/**
		 * @param recognizer
		 * 
		 * if the gesture is reconginzer as a long press
		 * gesture, we will show tooltip. and set the variable
		 * islongPressGesture true.
		 * 
		 */
		longPressHandler : (function() {
			return function(recognizer) {
				var comp = recognizer.attachedComponent();
				if (recognizer.state() === GestureDetector.TransitionState.Began) {
					comp.islongPressGesture = true;
					// get the global xy, to convert the point
					// to series layer, we should do two thing.
					// 1. convert the global point to plot
					// component point.
					// 2. convert the component point to series
					// layer point.
					var globalXY = recognizer
							.globalLocOfGesture();
					var plotXY = comp
							.convertPointFromGlobal(globalXY);
					var targetLayer = comp._rootLayer;
					var point = comp._seriesLayer
							.convertPointFromLayer(plotXY,
									targetLayer);

					//do interaction when point hit.
					comp._chartModule.hoverOnPoint(point);
				}
			};
		})(),
		
		/**
		 * @param recognizer
		 * 
		 * Tap gesture on chart component
		 */
		tapHandler: function(recognizer){
			var comp = recognizer.attachedComponent();
			if (recognizer.state() === GestureDetector.TransitionState.Ended) {
				//get the global xy, to convert the point to series layer, we should do two thing.
				//1. convert the global point to plot component point.
				//2. convert the component point to series layer point.
				var globalXY = recognizer.globalLocOfGesture();
				var plotXY = comp.convertPointFromGlobal(globalXY);
				var targetLayer = comp._rootLayer;
				var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
				//do interaction when tap
				comp._chartModule.clickOnPoint(point);
			}
		},
		
		/**
		 * @param xscale,
		 *            scale size in xasix direction
		 * @param yscale,
		 *            scale size in yaxis direction
		 * @param viewPort,
		 *            visiable view size
		 * 
		 * if viewPort is exist, we only draw the visiable size
		 */
		scale : function(xscale, yscale, viewPort) {
			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width * xscale,
				height : curSize.height * yscale
			});

			this._columnBarRenderer.drawViewPort(xscale,
					viewPort);
			this._lineRenderer.drawViewPort(xscale, viewPort);
		},

		backUp : function() {
			this._hasBacked = true;
			this._backedXScale = this._xaxes[0]._sax_renderer._subLayer.size().width
					/ this._xaxes[0]._sax_renderer._layer.size().width;
			this._backedXPoint = this._xaxes[0]._sax_renderer._subLayer.position().x;
		},

		restore : function() {
			if (this._hasBacked
					&& TypeUtils.isExist(this._backedXScale)
					&& TypeUtils.isExist(this._backedXPoint)) {

				//Fix the bug: [Ian] even though the chart is in its original size, the scroll bar is still show because we consider the 1 as an scale
				if(this._backedXScale <= 1.00000000001){
					return;
				}
				
				this._xaxes[0].setVisibleRange(this._backedXScale, 1, this._backedXScale);
				this._xaxes[0].position(this._backedXPoint, 0);

				var curSize = this._seriesLayer.size();
				this._seriesLayer.size({
					width : curSize.width * this._backedXScale,
					height : curSize.height
				});
				this.position(this._backedXPoint, 0);

				// [Ian]Check whether it is in IPad, now we only
				// show the scroll bar in IPad, do not show it
				// in browser and another device.
				if (UADetector.os() === 'iPad') {
					this._scrollBar[0].update();
					this._scrollBar[0].unHighLight();
				}

				this._backedXScale = null;
				this._backedXPoint = null;
				this._hasBacked = false;
			}

		},

		hoverOnPoint : function(point) {
			// If do not exist the bar renderer, ignore the
			// hover event
			if (!this._columnBarRenderer && !this._lineRenderer) {
				return;
			}

			// In combination chart, if there is column bar, we
			// will do not show the line behind the chart, only
			// show the grey backgournd
			if (this._barSeriesGroup.getSeriesList().length > 0
					&& this._lineSeriesGroup.getSeriesList().length > 0) {
				var dataCtxOnPoint = this._columnBarRenderer.hoverOnPoint(point);
				this._lineRenderer.hoverOnPoint(point, false);
				if (dataCtxOnPoint) {
					this.fireEvent('showTooltip', {
						name : 'showTooltip',
						data : [ {
							dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
							point : point
						} ]
					});
				}
			}
			// if only line chart, we will show the background
			// line
			else if (this._lineSeriesGroup.getSeriesList().length > 0) {
				var dataCtxOnPoint = this._lineRenderer
						.hoverOnPoint(point, this._tooltipEnabled);
				if (dataCtxOnPoint) {
					this.fireEvent('showTooltip', {
						name : 'showTooltip',
						data : [ {
							dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
							point : point
						} ]
					});
				}
			}
			// if only column bar chart
			else {
				var dataCtxOnPoint = this._columnBarRenderer.hoverOnPoint(point);
				if (dataCtxOnPoint) {
					this.fireEvent('showTooltip', {
						name : 'showTooltip',
						data : [ {
							dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
							point : point
						} ]
					});
				}
			}
		},

		onblur : function(point) {
			if (this._barSeriesGroup.getSeriesList().length > 0) {
				this._columnBarRenderer.onblur(point);
				this._lineRenderer.onblur(point);
			} else {
				this._lineRenderer.onblur(point);
			}

			this.fireEvent('hideTooltip', {
				name : 'hideTooltip',
				data : [ {} ]
			});
		},
		
		getPlotArea : function() {
            return {
                top : this._topBound,
                left : 0,
                bottom : 0,
                right : 0
            };
        }
	});
	return CombinationModule;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.LongPressGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};
	/**
	 * This class defines detector for detecting long press gesture. Long press
	 * gesture is detected when required number of fingers touch the screen for
	 * a specified period and the touches don't move beyond the allowable
	 * movement distance.
	 * 
	 * @name sap.riv.vizkit.LongPressGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */
	var LongPressGestureDetector = ObjUtils.derive(GestureDetector, {

		constructor : function(touchesRequired) {
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._minimumPressDuration = 500;
			this._allowableMovement = 10;

			this._distanceFromStart = 0;
			this._startXY = undefined;
		},

		/**
		 * The minimum press duration before a long press gesture can be
		 * detected. The duration is in milliseconds. The default duration is
		 * 500 milliseconds.
		 * 
		 * @function
		 * @returns {Number|this}
		 */
		minimumPressDuration : function(duration) {
			if (duration !== undefined) {
				this._minimumPressDuration = duration;
			} else {
				return this._minimumPressDuration;
			}
		},

		/**
		 * The allowable distance the touches can move for a long press gesture
		 * to be detected. The duration is in pixels. The default distance is 10
		 * pixels.
		 * 
		 * @function
		 * @returns {Number|this}
		 */
		allowableMovement : function(distance) {
			if (distance !== undefined) {
				this._allowableMovement = distance;
			} else {
				return this._allowableMovement;
			}
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();
			if (currentNumOfTouches === this._touchesRequired && this.state() === ts.Possible) {
				this._startXY = this.globalLocOfTouchPoints();
				clearTimeout(this._timeoutId);
				this._timeoutId = setTimeout(ObjUtils.proxy(
						function() {
							if (this._startXY && this.state() === ts.Possible
									&& this.totalTouches() === this._touchesRequired) {
								this._setState_(ts.Began);
							}
						}, this), this._minimumPressDuration);
			} else if (currentNumOfTouches > this._touchesRequired) {
				if (this.state() === ts.Began || this.state() === ts.Changed) {
					this._setState_(ts.Cancelled);
				} else if (this.state() === ts.Possible) {
					this._setState_(ts.Failed);
				}
			}
		},

		doTouchMove : function(touchMoveEvent) {
			switch (this.state()) {
			case ts.Possible:
				if (this._startXY) {
					this._distanceFromStart = _distance(this._startXY, this.globalLocOfTouchPoints());
					if (this._distanceFromStart > this._allowableMovement)
						this._setState_(ts.Failed);
				}
				break;
			case ts.Began:
			case ts.Changed:
				if (_distance(this._startXY, this.globalLocOfTouchPoints()) <= this._allowableMovement) {
					this._setState_(ts.Changed);
				} else
					this._setState_(ts.Cancelled);
				break;
			}
		},

		doTouchEnd : function(touchEndEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._setState_(ts.Ended);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._setState_(ts.Cancelled);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},

		reset : function() {
			this.callParent('reset');
			this._startXY = undefined;
			this._distanceFromStart = 0;
		}
	});

	return LongPressGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.PanGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};
	/**
	 * This class defines detector for detecting Panning gesture. Panning
	 * gesture is detected when required number of fingers touch the screen and
	 * move a reasonable distance.
	 * 
	 * @name sap.riv.vizkit.PanGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */
	var PanGestureDetector = ObjUtils.derive(GestureDetector, {
		constructor : function(touchesRequired) {
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();
			if (currentNumOfTouches === this._touchesRequired && this.state() === ts.Possible) {
				this._startWhen = this._stopWhen = touchStartEvent.timeStamp;
				this._startXY = this._lastXY = this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Began);
			} else if (currentNumOfTouches > this._touchesRequired) {
				if (this.state() === ts.Began || this.state() === ts.Changed) {
					this._stopWhen = touchStartEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this._setState_(ts.Cancelled);
				} else {
					this._setState_(ts.Failed);
				}
			}
		},
		doTouchMove : function(touchMoveEvent) {
			switch (this.state()) {
			case ts.Began:
				if (_distance(this._startXY, this.globalLocOfTouchPoints()) > 10) {
					this._startWhen = this._stopWhen;
					this._stopWhen = touchMoveEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this._setState_(ts.Changed);
				}
				break;
			case ts.Changed:
				this._startWhen = this._stopWhen;
				this._stopWhen = touchMoveEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Changed);
				break;
			}
		},
		doTouchEnd : function(touchEndEvent) {
			if ((this.state() === ts.Began || this.state() === ts.Changed) && this.totalTouches() === 0) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchEndEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Ended);
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchCancelEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Cancelled);
			}
		},

		/**
		 * The current moving range in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.vizkit.PanGestureDetector#rangeInXY
		 * @function
		 * @return {POINT}
		 */
		rangeInXY : function() {
			return {
				x : this._currentXY.x - this._startXY.x,
				y : this._currentXY.y - this._startXY.y
			};
		},

		/**
		 * The current moving velocity in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.vizkit.PanGestureDetector#velocityInXY
		 * @function
		 * @return {POINT}
		 */
		velocityInXY : function() {
			var duration = this._stopWhen - this._startWhen;
			if (duration) {
				return {
					x : (this._currentXY.x - this._lastXY.x) / duration,
					y : (this._currentXY.y - this._lastXY.y) / duration
				};
			} else {
				return 0;
			}
		},
		reset : function() {
			this.callParent('reset');
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		}
	});
	return PanGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.XYChartPlotComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.PinchGestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.PanGestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.LongPressGestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.gridLine.GridLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.BarModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.CombinationModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.TapGestureDetector',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, FunctionUtils, LOG, Canvas2DSurfaceComponent, Layer, UADetector,
		PinchGestureDetector, PanGestureDetector, LongPressGestureDetector, GridLine, BarModule, CombinationModule, TapGestureDetector) {
	var PlotComponent = ObjUtils.derive(Canvas2DSurfaceComponent,
	{
		constructor : function(options) {
			this._canvasSurface = this.getCanvasSurface();
			this._rootLayer = this._canvasSurface.getRootLayer();

			this._chart_options = ObjUtils.extend(true, {}, options.chart);
			this._metaData = this._chart_options.metaData;
			this._dataTree = this._chart_options.dataTree;

			this._xaxes = [];
			this._yaxes = [];
			this._gridLine = null;

			this._xaxisLayers = [];
			this._yaxisLayers = [];
			this._gridLineLayer = null;
			// the layer we actual drawing on
			this._seriesLayer = null;
			// the layer which controls the visible area and
			// listen on event
			this._seriesMaskLayer = null;

			this._chartModule = null;

			this._init(false);
		},

		_init : function(redraw) {
			if (!redraw) {
				this._initModule();
			}

			this._chartModule.init();

			if (!redraw) {
				this._seriesMaskLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._seriesMaskLayer.clipToBounds(true);
				this._rootLayer.addSubLayer(this._seriesMaskLayer);
				this._seriesLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._seriesMaskLayer.addSubLayer(this._seriesLayer);

			}
			this._initAxesLayer();
			this._chartModule.bindRenderer(this._seriesLayer);
			this._gridLine = this._chartModule._gridLine;
			this._initGridLine();

			if (!redraw) {
				this._registerEvents();
			}
		},

		_initGridLine : function() {
			this._gridLine.setXAxisLayer(this._xaxisLayers);
			this._gridLine.setYAxisLayer(this._yaxisLayers);
			this._gridLine.setSeriesMaskLayer(this._seriesMaskLayer);
			this._gridLine.setSeriesLayer(this._seriesLayer);

			this._gridLine.setXAxis(this._xaxes[0]);
			this._gridLine.setYAxis(this._yaxes[0]);

		},

		_initAxesLayer : function() {
			this._initXAxesLayer();
			this._initYAxesLayer();
		},

		_initXAxesLayer : function() {
			this._xaxes = [];

			for ( var i = 0, len = this._xaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._xaxisLayers[i]);
			}
			this._xaxisLayers = [];

			this._xaxes = this._chartModule._xaxes;
			for ( var i = 0, len = this._xaxes.length; i < len; i++) {
				var xaxisLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._xaxes[i].setLayer(xaxisLayer);
				this._xaxisLayers.push(xaxisLayer);
				this._rootLayer.addSubLayer(xaxisLayer);
			}
		},

		_initYAxesLayer : function() {
			this._yaxes = [];
			for ( var i = 0, len = this._yaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._yaxisLayers[i]);
			}
			this._yaxisLayers = [];

			this._yaxes = this._chartModule._yaxes;
			for ( var i = 0, len = this._yaxes.length; i < len; i++) {
				var yaxisLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._yaxes[i].setLayer(yaxisLayer);
				this._yaxisLayers.push(yaxisLayer);
				this._rootLayer.addSubLayer(yaxisLayer);
			}
		},

		_initModule : function() {
			switch (this._chart_options.properties.type) {
			case 'bar':
				this._chartModule = new BarModule(this._chart_options);
				break;
			case 'combination':
				this._chartModule = new CombinationModule(this._chart_options);
				break;
			}
		},

		_chart_layout : function(nsize) {
			this._chartModule.doChartLayout(nsize, this._yaxisLayers, this._xaxisLayers, this._seriesMaskLayer,
					this._seriesLayer);
		},

		_doDraw : function(size) {
			// Fix the bug: visual-1050 [Ian 2012- 2- 31] check
			// whether the axis
			// is defined, if not, we will draw nothing exclude
			// Legend
			if (this._xaxes.length === 0 || this._yaxes.length === 0)
				return;
			// End

			this._chart_layout(size);
			this._gridLine.drawGridLine();
			this._chartModule.drawSeries();
			for ( var i = 0, len = this._xaxes.length; i < len; i++) {
				this._xaxes[i].draw();
			}

			for ( var i = 0, len = this._yaxes.length; i < len; i++) {
				this._yaxes[i].draw();
			}
			this._rootLayer.setNeedsDisplay();
		},

		_resetEventStatusVariables : function() {
			// variables used to store mouse/touch status
			this._mouseAlreadyDown = false;
			this._mouseAlreadyMoved = false;
			// [Jimmy- 021512]we don't want mousemove too
			// sensitive, use this
			// var to track the distance of mouse moving.
			// only when it's large than 1px, we think user is
			// moving the mouse
			this._mouseMoveThreshold = 1;
			// [Jimmy- 021512]make sure you have to give it a
			// value before using
			// it
			this._previousMousePosition = undefined;
			// end of variables
		},

		/**
		 * [jimmy-021512]now the native event handlers are registered on layer,
		 * while gestures handlers are registered on component. please note
		 * touchCancel is required to handle if any other touch related events
		 * are listened.
		 */
		_registerEvents : function() {
			this._resetEventStatusVariables();
			this._seriesMaskLayer.on([ {
				eventName : 'mousemove',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'mouseup',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'mousedown',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'mouseleave',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'touchstart',
				listener : this._touchEventHandler,
				scope : this
			}, {
				eventName : 'touchend',
				listener : this._touchEventHandler,
				scope : this
			}, {
				eventName : 'touchmove',
				listener : this._touchEventHandler,
				scope : this
			}, {
				eventName : 'touchcancel',
				listener : this._touchEventHandler,
				scope : this
			} ]);

			// add Pinch Gesture event on XYChart
			var oPinchGestureDetector = this._oPinchGestureDetector = new PinchGestureDetector();
			oPinchGestureDetector.addGestureAction(this._pinchingResize);
			oPinchGestureDetector.enable(true);
			this.addGestureDetector(oPinchGestureDetector);

			// add pan Gesture event on XYChart
			var oPanGestureDetector = this._oPanGestureDetector = new PanGestureDetector(1);
			oPanGestureDetector.cancelTouches(false).addGestureAction(this._panMove);
			oPanGestureDetector.enable(true);
			this.addGestureDetector(oPanGestureDetector);
			
			var oLongPressGestureDetector = this._oLongPressGestureDetector =  new LongPressGestureDetector();
			oLongPressGestureDetector.addGestureAction(this._longPressHandler);
			oLongPressGestureDetector.enable(true);
			oLongPressGestureDetector.minimumPressDuration(500);
			this.addGestureDetector(oLongPressGestureDetector);
			
			var oTapGestureDetector = this._oTapGestureDetector = new TapGestureDetector();
			oTapGestureDetector.addGestureAction(this._tapHandler);
			oTapGestureDetector.enable(true);
			this.addGestureDetector(oTapGestureDetector);
		},

		/**
		 * in single chart, we directly draw shapes on series layer in the
		 * module, so actually we don't need do this kind of conversion. this is
		 * only for multi chart case or other special case that we create sub
		 * layers on series layer to draw chart shapes or sub charts and we may
		 * not want to specify which layer to handle the event, it's up to
		 * module to determine which layer to handle based on the passed in
		 * point.
		 * 
		 * @param mouseEvent
		 *            an instance of sap.riv.graphics.MouseEvent
		 */
		_convertXYForMouseEvent : function(mouseEvent) {
			// [jimmy-021512] here we'll convert coordinate from
			// target layer to
			// the series layer
			if (this._seriesLayer == null) {
				ObjUtils.error('Series Layer should be initialized before any event handler!')
			}
			var xyOnTargetLayer = mouseEvent.targetLocalXY();
			var targetLayer = mouseEvent.targetLayer();
			var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
			return xyOnSeriesLayer;
		},

		/**
		 * in single chart, we directly draw shapes on series layer in the
		 * module, so actually we don't need do this kind of conversion. this is
		 * only for multi chart case or other special case that we create sub
		 * layers on series layer to draw chart shapes or sub charts and we may
		 * not want to specify which layer to handle the event, it's up to
		 * module to determine which layer to handle based on the passed in
		 * point.
		 * 
		 * @param touch
		 *            an instance of sap.riv.graphics.Touch
		 */
		_convertXYForTouch : function(touch) {
			// [jimmy-021512] here we'll convert coordinate from
			// target layer to
			// the series layer
			if (this._seriesLayer == null) {
				TypeUtils.error('Series Layer should be initialized before any event handler!')
			}
			var xyOnTargetLayer = touch.localXY();
			var targetLayer = touch.targetLayer();
			var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
			return xyOnSeriesLayer;
		},

		/**
		 * @param mouseEvent
		 *            an instance of sap.riv.graphics.MouseEvent
		 */
		_mouseEventHandler : function(mouseEvent) {
			var eventType = mouseEvent.type();
			switch (eventType) {
			case 'mousedown':
				this._mouseAlreadyDown = true;
				// [jimmy-011512]set it to false so that we can
				// have click after
				// we do mouse move
				this._mouseAlreadyMoved = false;
				break;
			case 'mouseup':
				this._mouseAlreadyDown = false;
				if (!this._mouseAlreadyMoved) {
					this._chartModule.clickOnPoint(this._convertXYForMouseEvent(mouseEvent));
				}
				this._mouseAlreadyMoved = false;
				break;
			case 'mousemove':
				if (this._previousMousePosition) {
					var currentPosition = mouseEvent.targetLocalXY();
					if (Math.abs(currentPosition.x - this._previousMousePosition.x) > this._mouseMoveThreshold
							|| Math.abs(currentPosition.y - this._previousMousePosition.y) > this._mouseMoveThreshold) {
						// we are actually moving
						if (this._mouseAlreadyDown) {
							// marquee selection
							this._chartModule.marqueeOverPoint(mouseEvent.targetLocalXY());
						} else {
							// show tooltip
							this._chartModule.hoverOnPoint(this._convertXYForMouseEvent(mouseEvent));
						}
						// reset the moving tracking
						this._previousMousePosition = undefined;
						// we already move
						this._mouseAlreadyMoved = true;
					}
				} else {
					this._previousMousePosition = mouseEvent.targetLocalXY();
				}
				break;
			case 'mouseleave':
				// LOG.debug('about to leave layer!');
				this._chartModule.onblur(this._convertXYForMouseEvent(mouseEvent));
				this._resetEventStatusVariables();
				break;
			default:
				break;
			}
		},

		_touchEventHandler : function(touchEvent) {
			var eventType = touchEvent.type();
			switch (eventType) {
			case 'touchstart':
				break;
			case 'touchmove':
				break;
			case 'touchend':
				if(this.islongPressGesture){
					this.islongPressGesture = false;
					this._chartModule.onblur();
				}
				break;
			case 'touchcancel':
				if(this.islongPressGesture){
					this.islongPressGesture = false;
					this._chartModule.onblur();
				}
				break;
			default:
				break;
			}
		},

		/**
		 * when touch begin: set the initial value when touch move: we redraw
		 * the yaxis and redraw part of shape which are in viewPort, when touch
		 * end and cancel: redraw the all shapes in series layer
		 * 
		 * @returns function
		 */
		_pinchingResize : function(recognizer) {
			recognizer.attachedComponent()._chartModule.pinchingResize(recognizer);
		},

		_panMove : function(panGestureDetector) {
			panGestureDetector.attachedComponent()._chartModule.panMove(panGestureDetector);
		},

		/**
		 * 
		 */
		_longPressHandler : function(recognizer){
			recognizer.attachedComponent()._chartModule.longPressHandler(recognizer);
		},
		
		_tapHandler : function(recognizer){
			recognizer.attachedComponent()._chartModule.tapHandler(recognizer);
		},
		/**
		 * Resize component's visual content, when the component's size changed,
		 * this method will be invoked before layout sub components
		 */
		doContentResize : function(osize, nsize) {
			this.callParent('doContentResize', osize, nsize);
			this._doDraw(nsize);
		},

		applyTheme : function(theme) {
			this._chartModule.applyTheme(theme);
			for ( var i = 0, len = this._xaxes.length; i < len; i++) {
				this._xaxes[i].applyTheme(theme);
			}

			for ( var i = 0, len = this._yaxes.length; i < len; i++) {
				this._yaxes[i].applyTheme(theme);
			}
			this._gridLine.applyTheme(theme);
		},

		updateProperties : function(propBag) {
			this._chart_options.properties = propBag;
			this._chartModule.updateProperties(propBag);
			// var resetAxis = false;
			// var xAxisOptions =
			// this._chart_options.properties.xAxis;
			// if(this._xaxes.length != xAxisOptions.length){
			// this._chartModule.initXAxes();
			// this._initXAxesLayer();
			// resetAxis = true;
			// }
			// var yAxisOptions =
			// this._chart_options.properties.yAxis;
			// if(this._yaxes.length != yAxisOptions.length){
			// this._chartModule.updateValueAxisRange();
			// this._chartModule.initYAxes();
			// this._initYAxesLayer();
			// resetAxis = true;
			// }
			// if(resetAxis){
			// this._chartModule.bindSeriesWithAxes();
			// }else{
			// for(var i = 0, len = this._xaxes.length; i < len;
			// i++) {
			// this._xaxes[i].updateProperties(this._chart_options.properties.xAxis[i]);
			// this._xaxes[i].draw();
			// }
			// for(var i = 0, len = this._yaxes.length; i < len;
			// i++) {
			// this._yaxes[i].updateProperties(this._chart_options.properties.yAxis[i]);
			// this._yaxes[i].draw();
			// }
			// }
			// [Ian 2012-2-19] Currently, we only back up the
			// scene in IPad and
			// restore it in IPad
			if (UADetector.os() === 'iPad') {
				this._chartModule.backUp();
			}

			// Reset Axis
			this._chartModule.updateValueAxisRange();
			this._chartModule.initAxes();
			this._initAxesLayer();
			this._chartModule.bindSeriesWithAxes();
			this._chartModule.initGridLineProperties();
			this._initGridLine();
			
			this._doDraw(this.size());
		},

		updateOptions : function(options) {
			this._chart_options = options;
			this._metaData = options.metaData;
			this._dataTree = options.dataTree;

			this._xaxes = [];
			this._yaxes = [];

			for ( var i = 0, len = this._xaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._xaxisLayers[i]);
			}

			for ( var i = 0, len = this._yaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._yaxisLayers[i]);
			}

			this._xaxisLayers = [];
			this._yaxisLayers = [];

			this._chartModule.updateOptions(this._chart_options);
			this._init(true);
			this._doDraw(this.size());
		},

		/**
		 * Receives chart component command and execute it.
		 * 
		 * @param {Object} args - command value
		 */
		receiveCommand : function ( args ) {
        	switch ( args.commandText ) {
        	case "ChangeSeriesVisibility":
        		if ( TypeUtils.isDefined(
        				this._chart_options.properties.measure.visibilityChangeable) 
        				&& this._chart_options.properties.measure.visibilityChangeable 
        				&& TypeUtils.isDefined(this._chart_options.properties.measures[args.seriesIndex])) {
        			this._chart_options.properties.measures[args.seriesIndex].visible = args.setVisible;
        			this._chartModule._hasDrawn = false;
        			this.updateProperties(this._chart_options.properties);
        		}
        		break;
        	default:
        		return;
        	}
        },
		
		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : function() {
			return this._chartModule.getSupportedAppEvents();
		},

		doPrint : function(drawingCtx) {

		},
		
		getPlotArea : function() {
		    var pos = this.position();
		    var area = this._chartModule.getPlotArea();
		    return {
		        top : area.top + pos.y,
		        left : area.left + pos.x,
		        bottom : area.bottom + pos.y,
		        right : area.right + pos.x
            };
		}
	});
	return PlotComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.XYChartComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.title.TitleCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.background.BackgroundComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.legend.LegendCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.BaseTooltip',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.descriptor.Descriptor',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.layout.BasicLayout',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.XYChartPlotComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, LOG, UIComponent, TitleCanvasComponent, BackgroundComponent, LegendCanvasComponent,
		BaseTooltip, PropsMgr, Descriptor, BasicLayout, ThemeManager, Series, XYChartPlotComponent, LOG) {
	var XYChartComponent = ObjUtils.derive(UIComponent, {
		constructor : function(options) {
			this._dataTree = options.dataset.dataTree;
			this._metaData = options.dataset.metaData;
			this._xychart_options = {
				layout : {
					padding : [ 0, 0, 0, 0 ],
					legendFirst : true
				},
				type : 'bar',
				measure : { visibilityChangeable : false },
				measures : [],
				//Ian [2012-4-18] Fix the bug, if user do not pass chart option, the xAxis's size is zero so that it can not draw chart.
				//So to use an empty object means that we at least have one axis.
				xAxis : [{}],
				yAxis : [{}],
				//End
				selectability : {
					"mode" : "single",
					"deSelectable" : true,
					"defaultSelectedItems" : []
				},
				bar : {
					barMarkerSize : Series.DEFAULTBARMARKERSIZE,
					isShowGradient : false,
					isShowInnerBorder : false,
					isShowOutBorder : false,
					isShowShadow : false
				},
				line : {
					lineThickness : Series.DEFAULTLINESIZE,
					lineMarkerSize : Series.DEFAULTLINEMARKERSIZE,
					isShowMarkerShadow : false,
					isShowLineShadow : false
				},
				measureDefault : {
					colors : [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f",
							"#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]
				},
				visibleRange : {
					start : 0,
					end : Number.POSITIVE_INFINITY
				},
				theme : ''
			};
			this._xychart_options.title = ObjUtils.extend(true, {}, TitleCanvasComponent
					.getDefaultOption());
			this._xychart_options.background = ObjUtils.extend(true, {}, BackgroundComponent
					.getDefaultOption());
			this._xychart_options.legend = ObjUtils.extend(true, {}, LegendCanvasComponent
					.getDefaultOption());
		    this._xychart_options.tooltip = ObjUtils.extend(true, {}, BaseTooltip
                    .getDefaultOption());
			
			// default value
			var descriptor;
			if (options.xyChartOptions.type === 'bar') {
			    descriptor = Descriptor.getBarDescriptor();
			} else if (options.xyChartOptions.type === 'combination') {
			    if (options.xyChartOptions.measure.type === 'line') {
			        descriptor = Descriptor.getLineDescriptor();
			    } else if (options.xyChartOptions.measure.type === 'bar') {
			        descriptor = Descriptor.getColumnDescriptor();
			    } else if (options.xyChartOptions.measure.type === 'combination') {
			        descriptor = Descriptor.getCombinationDescriptor();
			    }
			}

			this._propsMgr = new PropsMgr(descriptor);
			var validatedOptions = this._propsMgr.properties(options.xyChartOptions);
			this._xychart_options = ObjUtils.extend(true, this._xychart_options, validatedOptions);
			
			// TODO[Christy/20120423] Check theme propeties.
			if (TypeUtils.isExist(options.xyChartOptions.theme) && options.xyChartOptions.theme !== '') {
				var theme = options.xyChartOptions.theme;
				this._resolveThemeAndProperties(options.xyChartOptions, theme);
			}
			this._xychart_options = ObjUtils.extend(true, this._xychart_options, options.xyChartOptions);
			this._propsMgr.properties(this._xychart_options);
			
			this._attach_additional_properties();

			this._legendComponent = null;
			this._chartComponent = null;
			this._titleComponent = null;
			this._xychart_layout = null;

			this._colorList = null;
			this._initSubComponents(false);

		},

		_resolveThemeAndProperties : function(options, theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var globalStyle = settings.global;

			// Background
			options.background = options.background || {};
			options.background.color = options.background.color || settings.background;

			// Legend Style
			var legendStyle = settings.legend;
			var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
			var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
			options.legend = options.legend || {};
			options.legend.titleFont = options.legend.titleFont
					|| (legendTitleStyle['font-weight'] + ' ' + legendTitleStyle['font-size'] + ' ' + legendTitleStyle['font-family']);
			options.legend.titleColor = options.legend.titleColor
					|| (legendTitleStyle['color']);
			options.legend.labelFont = options.legend.labelFont
					|| (legendLabelStyle['font-weight'] + ' ' + legendLabelStyle['font-size'] + ' ' + legendLabelStyle['font-family']);
			options.legend.labelColor = options.legend.labelColor
					|| (legendLabelStyle['color']);

			// Title Style
			var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
			var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
			options.title = options.title || {};
			options.title.main = options.title.main || {};
			options.title.main.font = options.title.main.font
					|| (mainTitleStyle["font-weight"] + ' ' + mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
			options.title.main.color = options.title.main.color || (mainTitleStyle["color"]);

			options.title.sub = options.title.sub || {};
			options.title.sub.font = options.title.sub.font
					|| (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"] + ' ' + subTitleStyle["font-family"]);
			options.title.sub.color = options.title.sub.color || (subTitleStyle["color"]);

			// Bar or Line style
			var barStyle = settings.bar;
			options.bar = options.bar || {};
			options.bar.isShowGradient = options.bar.isShowGradient || barStyle.isShowGradient;
			options.bar.isShowInnerBorder = options.bar.isShowInnerBorder || barStyle.isShowInnerBorder;
			options.bar.isShowOutBorder = options.bar.isShowOutBorder || barStyle.isShowOutBorder;
			options.bar.isShowShadow = options.bar.isShowShadow || barStyle.isShowShadow;

			var lineStyle = settings.line;
			options.line = options.line || {};
			options.line.isShowLineShadow = (options.line.isShowLineShadow || lineStyle.line.isShowShadow);
			options.line.isShowMarkerShadow = (options.line.isShowMarkerShadow || lineStyle.marker.isShowShadow);
			options.line.lineThickness = (options.line.lineThickness || lineStyle.line.size);
			options.line.lineMarkerSize = (options.line.lineMarkerSize || lineStyle.marker.size);

			// TODO Merge Tooltip properties and theme

			// Axis
			var axisStyle = settings.axis;
			var axisTitleStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.title);
			var axisLabelStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.label);
			if (TypeUtils.isUndefined(options.xAxis)) {
				options.xAxis = [{}];
			}
			for ( var i = 0, len = options.xAxis.length; i < len; i++) {
				var axis = options.xAxis[i];
				this._resolveAxisThemeAndProperties(axis, axisTitleStyle, axisLabelStyle,
						axisStyle.lineColor);
				
				axis.gridLine = axis.gridLine || {};
				axis.gridLine.majorColor = axis.gridLine.majorColor || axisStyle.xAxisMajorGridLine.color;
				axis.gridLine.majorThickness = axis.gridLine.majorThickness || axisStyle.xAxisMajorGridLine.thickness;
				axis.gridLine.minorColor = axis.gridLine.minorColor || axisStyle.xAxisMinorGridLine.color;
				axis.gridLine.minorThickness = axis.gridLine.minorThickness || axisStyle.xAxisMinorGridLine.thickness;
				axis.gridLine.subColor = axis.gridLine.subColor || axisStyle.xAxisSubGridLine.color;
			}
			
			if (TypeUtils.isUndefined(options.yAxis)) {
				options.yAxis = [{}];
			}
			for ( var i = 0, len = options.yAxis.length; i < len; i++) {
				var axis = options.yAxis[i];
				this._resolveAxisThemeAndProperties(axis, axisTitleStyle, axisLabelStyle,
						axisStyle.lineColor);
				
				axis.gridLine = axis.gridLine || {};
				axis.gridLine.majorColor = axis.gridLine.majorColor || axisStyle.yAxisMajorGridLine.color;
				axis.gridLine.majorThickness = axis.gridLine.majorThickness || axisStyle.yAxisMajorGridLine.thickness;
				axis.gridLine.minorColor = axis.gridLine.minorColor || axisStyle.yAxisMinorGridLine.color;
				axis.gridLine.minorThickness = axis.gridLine.minorThickness || axisStyle.yAxisMinorGridLine.thickness;
				axis.gridLine.subColor = axis.gridLine.subColor || axisStyle.yAxisSubGridLine.color;
			}
		},

		_resolveAxisThemeAndProperties : function(axis, axisTitleStyle, axisLabelStyle, lineStyle) {
			axis = axis || {};
			axis.titleFont = (axis.titleFont || axisTitleStyle['font-weight'] + " "
					+ axisTitleStyle['font-size'] + " " + axisTitleStyle['font-family']);
			axis.titleColor = (axis.titleColor || axisTitleStyle['color']);
			axis.labelFont = (axis.labelFont || axisLabelStyle['font-weight'] + " "
					+ axisLabelStyle['font-size'] + " " + axisLabelStyle['font-family']);
			axis.labelColor = (axis.labelColor || axisLabelStyle['color']);
			axis.lineColor = (axis.lineColor || lineStyle);
		},

		_initSubComponents : function(redraw) {
			this.autoresizeSubComponents(false);
			var size = this.size();
			if (!redraw) {
				this._xychart_layout = new BasicLayout(size, this._xychart_options);
			}

			if (!redraw) {
				this._backgroundComponent = new BackgroundComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					backgroundOptions : this._xychart_options.background,
					id : 'backgroundComponent'
				});
				// background component is always the first
				// component
				this.addSubComponent(this._backgroundComponent);

				// here we give a default size to title(or any
				// other sub)
				// component to ensure
				// sub component has initial size to rely on
				// sap.riv.vizkit.UIComponentAutosizing
				// for auto layout
				this._titleComponent = new TitleCanvasComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					titleOptions : this._xychart_options.title,
					id : 'xyChartTitleComponent'
				});

				this._legendComponent = new LegendCanvasComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					legendOptions : {
						properties : this._xychart_options
					},
					id : 'xyChartLegendComponent'
				});
				this._legendComponent.addEventObserver(this);
				if ( TypeUtils.isDefined(this._xychart_options.measure.visibilityChangeable)
						&& this._xychart_options.measure.visibilityChangeable ) {
					// Unlock legend state and appearance changeability.
					this._legendComponent.setStateChangeable(true);
				}

				this._chartComponent = new XYChartPlotComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					chart : {
						metaData : this._metaData,
						dataTree : this._dataTree,
						properties : this._xychart_options
					},
					id : 'xyChartPlotComponent'
				});

			}

		},

        /**
         * Notification hooking up method in order to
         * receive event broadcasts.
         * 
         * @param {Object} args
         * - Could be anything as broadcasting data package
         * 
         * @author eye
         */
        notify : function ( args ) {
        	this._chartComponent.receiveCommand(args);
        },
		
		/**
		 * Resize component's visual content, when the
		 * component's size changed, this method will be invoked
		 * before layout sub components
		 */
		doContentResize : function(osize, nsize) {
			this.callParent('doContentResize', osize, nsize);
			this._xychart_layout.updateSize(nsize);        	
			this._relayout();
		},

		/**
		 * when we pass properties to the sub components, we may
		 * want to attach some special properties(calculated
		 * properties) for sub components. these properties are
		 * internal and should not be returned to clients
		 */
		_attach_additional_properties : function() {
			if (this._xychart_options) {
				var options = this._xychart_options;
				// reset before we attach
				delete options._additional;
				var _additional = {};
				// attach colorlist
				var colorList = [];
				var legendNumberFormat = [];
				var markerList = [];
				var defaultColors = options.measureDefault.colors;
				var defaultFormat = options.measureDefault.numberFormats;
				var labels = this._getEffectiveLables();

				var barOptions = options.bar;
				var lineOptions = options.line;
				var measureOption = options.measures || {};
				var measure = this._metaData.measureMembers;

				for ( var i = 0, len = labels.length; i < len; i++) {
					var o = measureOption[i] || {};
					if (o.type === 'bar') {
						o = ObjUtils.extend(true, {}, barOptions, o);
					} else {
						o = ObjUtils.extend(true, {}, lineOptions, o);
					}
					colorList.push(TypeUtils.isExist(o.fillColor) ? o.fillColor : defaultColors[i
							% defaultColors.length]);

					if (TypeUtils.isExist(options.type) && options.type === "bar") {
						markerList.push("rect");
					} else {
						// Combination chart
						if (TypeUtils.isExist(o.type) && o.type === "bar") {
							markerList.push("rect");
						} else {
							if (TypeUtils.isExist(o.markerSymbol)) {
								markerList.push(o.markerSymbol);
							} else {
								markerList.push("circle");
							}
						}
					}

				}

				var formats = options.legend.formatString;
				for ( var i = 0, formatsLen = formats.length, len = labels.length; i < len; i++) {
					if (i < formatsLen) {
						legendNumberFormat.push(formats[i]);
					} else {
						legendNumberFormat.push(formats[formatsLen - 1]);
					}
				}

				_additional.colorList = colorList;
				_additional.legendNumberFormat = legendNumberFormat;

				// attach legend title
				// [jyang, 19/3/2012] we can expose a legend
				// title property
				// instead of
				// binding it to data model if we have
				// requirement in the
				// future.
				// [jyang, 4/24/2012] it doesn't make sense to use dimension name as legend title in XYChart
				// as the labels here are measure names. so we remove title for now.
				//_additional.legendTitle = this._metaData.dimension[this._metaData.dimension.length - 1].name;
				
				// attach legend labels
				_additional.legendLabels = labels;
				_additional.legendMarkers = markerList;

				this._xychart_options._additional = _additional;
			}
		},

		_getEffectiveLables : function() {
			var tree = this._dataTree;
			var measure = this._metaData.measureMembers;
			var labels = [], measureIndex;
			var length = measure.length;

			for ( var i = 0; i < length; i++) {
				labels.push({
					category : measure[i]
				});

			}
			return labels;
		},

		_processLayoutOfComponent : function(component, layarr) {
			if (!layarr) {
				component.detachFromSuperComponent();
			} else {
			    LOG.debug("chartComponent["+this.id()+"]"+"subComponent["+component.getCanvasSurface().getRootLayer().id()+"]initialized.", "perf");
				if (!component.superComponent()) {
					// has been detached, re-attach
					this.addSubComponent(component);
				}
				component.position({
					x : layarr[0],
					y : layarr[1],
				});
				component.size({
					width : layarr[2],
					height : layarr[3],
				});
			}
		},

		_relayout : function(force) {
			if (this._xychart_layout.layoutChanged() || force) {
				if (this._xychart_options.layout.legendFirst) {
					var legendSize = this._legendComponent.calMaxLegendSize(this._xychart_options);
					this._xychart_layout.setMaxLegendWidth(legendSize.width);
					this._xychart_layout.setMaxLegendHeight(legendSize.height);
				}

				var titleSize = this._titleComponent.getPreferredSize(this._xychart_layout._size,
						this._xychart_options.title);

				this._xychart_layout.setPreferredTitleWidth(titleSize.width);
				this._xychart_layout.setPreferredTitleHeight(titleSize.height);

				var layoutinfo = this._xychart_layout.getLayoutInfo();
				
				//Ian [2012-4-10] fix the bug:ADAPT01629959, when the chart's width or height is less than 0, we should do nothing.
				//Nick [2012-4-19] move the following code from doContentResize function here.
	        	if(layoutinfo.main[2] <=0 || layoutinfo.main[3] <=0){
	        		return;
	        	}
	        	//End
	        	
				if ( layoutinfo.title ) {
					this._titleComponent.setPreferredSize({
						width : layoutinfo.title[2],
						height : layoutinfo.title[3]
					});
				}
				
				this._processLayoutOfComponent(this._chartComponent, layoutinfo.main);
				this._processLayoutOfComponent(this._titleComponent, layoutinfo.title);
				this._processLayoutOfComponent(this._legendComponent, layoutinfo.legend);
				this._processLayoutOfComponent(this._backgroundComponent, layoutinfo.background);
			}
		},

		applyTheme : function(theme) {
			var options = this._xychart_options;
			this._setThemes(options, theme);
			this.updateProperties(options);
			// this._backgroundComponent.applyTheme(theme);
			// this._titleComponent.applyTheme(theme);
			// this._legendComponent.applyTheme(theme);
			// this._chartComponent.applyTheme(theme);
		},

		_setThemes : function(options, theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var globalStyle = settings.global;

			// Background
			options.background.color = settings.background;

			// Legend Style
			var legendStyle = settings.legend;
			var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
			var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
			options.legend.titleFont = (legendTitleStyle['font-weight'] + ' '
					+ legendTitleStyle['font-size'] + ' ' + legendTitleStyle['font-family']);
			options.legend.titleColor = (legendTitleStyle['color']);
			options.legend.labelFont = (legendLabelStyle['font-weight'] + ' '
					+ legendLabelStyle['font-size'] + ' ' + legendLabelStyle['font-family']);
			options.legend.labelColor = (legendLabelStyle['color']);

			// Title Style
			var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
			var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
			options.title.main.font = (mainTitleStyle["font-weight"] + ' '
					+ mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
			options.title.main.color = (mainTitleStyle["color"]);

			options.title.sub.font = (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"]
					+ ' ' + subTitleStyle["font-family"]);
			options.title.sub.color = (subTitleStyle["color"]);

			// Bar or Line style
			var barStyle = settings.bar;
			options.bar.isShowGradient = barStyle.isShowGradient;
			options.bar.isShowInnerBorder = barStyle.isShowInnerBorder;
			options.bar.isShowOutBorder = barStyle.isShowOutBorder;
			options.bar.isShowShadow = barStyle.isShowShadow;

			var lineStyle = settings.line;
			options.line.isShowLineShadow = lineStyle.line.isShowShadow;
			options.line.isShowMarkerShadow = lineStyle.marker.isShowShadow;
			options.line.lineThickness = lineStyle.line.size;
			options.line.lineMarkerSize = lineStyle.marker.size;

			// TODO Merge Tooltip properties and theme

			// Axis
			var axisStyle = settings.axis;
			var axisTitleStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.title);
			var axisLabelStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.label);
			if (TypeUtils.isExist(options.xAxis)) {
				for ( var i = 0, len = options.xAxis.length; i < len; i++) {
					var axis = options.xAxis[i];
					this._setAxisThemes(axis, axisTitleStyle, axisLabelStyle, axisStyle.lineColor);
					
					axis.gridLine = axis.gridLine || {};
					axis.gridLine.majorColor = axisStyle.xAxisMajorGridLine.color;
					axis.gridLine.majorThickness = axisStyle.xAxisMajorGridLine.thickness;
					axis.gridLine.minorColor = axisStyle.xAxisMinorGridLine.color;
					axis.gridLine.minorThickness = axisStyle.xAxisMinorGridLine.thickness;
					axis.gridLine.subColor = axisStyle.xAxisSubGridLine.color;
				}
			}
			if (TypeUtils.isExist(options.yAxis)) {
				for ( var i = 0, len = options.yAxis.length; i < len; i++) {
					var axis = options.yAxis[i];
					this._setAxisThemes(axis, axisTitleStyle, axisLabelStyle, axisStyle.lineColor);
					
					axis.gridLine = axis.gridLine || {};
					axis.gridLine.majorColor = axisStyle.yAxisMajorGridLine.color;
					axis.gridLine.majorThickness = axisStyle.yAxisMajorGridLine.thickness;
					axis.gridLine.minorColor = axisStyle.yAxisMinorGridLine.color;
					axis.gridLine.minorThickness = axisStyle.yAxisMinorGridLine.thickness;
					axis.gridLine.subColor = axisStyle.yAxisSubGridLine.color;
				}
			}
		},

		_setAxisThemes : function(axis, axisTitleStyle, axisLabelStyle, lineStyle) {
			axis.titleFont = axisTitleStyle['font-weight'] + " " + axisTitleStyle['font-size'] + " "
					+ axisTitleStyle['font-family'];
			axis.titleColor = axisTitleStyle['color'];
			axis.labelFont = axisLabelStyle['font-weight'] + " " + axisLabelStyle['font-size'] + " "
					+ axisLabelStyle['font-family'];
			axis.labelColor = axisLabelStyle['color'];
			axis.lineColor = lineStyle;
		},

		updateProperties : function(propBag) {
			var validatedOptions = this._propsMgr.properties(propBag);
			this._xychart_options = ObjUtils.extend(true, this._xychart_options, validatedOptions);
			this._attach_additional_properties();
			this._xychart_layout.updateSettings(this._xychart_options);

			this._relayout(false);
			// sub component update properties
			this._backgroundComponent.updateProperties(this._xychart_options);
			this._chartComponent.updateProperties(this._xychart_options);
			this._titleComponent.updateProperties(this._xychart_options);
			this._legendComponent.updateProperties(this._xychart_options);
		},

		getProperties : function() {
			return this._propsMgr.properties();
		},

		setDataset : function(dataset) {
			this._dataTree = dataset.dataTree;
			this._metaData = dataset.metaData;
			this._initSubComponents(true);
			// re_attach additional properties
			this._attach_additional_properties();
			this._relayout(false);
			this._chartComponent.updateOptions({
				metaData : this._metaData,
				dataTree : this._dataTree,
				properties : this._xychart_options
			});

			var colorList = [];
			var defaultColors = this._xychart_options.measureDefault.colors;
			var labels = this._metaData.measureMembers;
			var measureOption = this._xychart_options.measures || {};
			for ( var i = 0, len = labels.length; i < len; i++) {
				var o = measureOption[i] || {};
				colorList.push(TypeUtils.isExist(o.fillColor) ? o.fillColor : defaultColors[i
						% defaultColors.length]);
			}

			this._legendComponent.updateOptions({
				labels : labels,
				legendTitle : this._metaData.dimension[0],
				colorList : colorList,
				properties : this._xychart_options
			});
		},
		
		getOptions : function() {
			return this._xychart_options;
		},

		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : function() {
			return this._chartComponent.getSupportedAppEvents();
		},

		doPrint : function(drawingCtx) {

		}
	});
	return XYChartComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.VizAppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.DataTree',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PieController',
  version : '1.0.0'
}
],
function Setup(ObjUtils, VizAppDelegate, DataTree, PieController) {
	var AppDelegate = ObjUtils.derive(VizAppDelegate, {
		constructor : function() {
			this._rootController = undefined;
		},
		appDidFinishLaunching : function(application, launchOptions) {
			var dataset = launchOptions.data.rawData;
			var data = dataset.exportTree();

			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(data.dataTree),
				metaData : data.metaData
			}

			this._rootController = new PieController({
				dataset : completedDataset,
				option : launchOptions.option
			});
		},
		rootController : function() {
			return this._rootController;
		},
		getPreloadAssets : function() {
			return [];
		},

		updateProperties : function(propBag) {
			this._rootController.updateProperties(propBag);
		},

		getProperties : function() {
			return this._rootController.getProperties();
		},

		getSupportedEvents : function() {
			return [ 'selectData' ];
		},

		setDataset : function(data) {
			var dataset = data.exportTree();
			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(dataset.dataTree),
				metaData : dataset.metaData
			}

			this._rootController.setDataset(completedDataset);
		}
	});
	return AppDelegate;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.MouseEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, Event) {
	/**
	 * This class defines Mouse Event
	 * 
	 * @name sap.riv.vizkit.MouseEvent
	 * @class
	 * @augments sap.riv.vizkit.Event
	 */
	var MouseEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.riv.vizkit.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, localXY, pageXY) {
			this._relatedTarget = undefined;
			this._currentLocalXY = this._targetLocalXY = localXY;
			this._pageXY = pageXY;
		},

		_setCurrentLocalXY_ : function(currentLocalXY) {
			this._currentLocalXY = currentLocalXY;
		},

		_setRelatedTarget_ : function(relatedTarget) {
			this._relatedTarget = relatedTarget;
		},

		/**
		 * Get the XY according to target component's coordinates system
		 * 
		 * @name sap.riv.vizkit.MouseEvent#targetLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		targetLocalXY : function() {
			return {
				x : this._targetLocalXY.x,
				y : this._targetLocalXY.y
			};
		},

		/**
		 * Get the XY according to current component's coordinates system
		 * 
		 * @name sap.riv.vizkit.MouseEvent#currentLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		currentLocalXY : function() {
			return {
				x : this._currentLocalXY.x,
				y : this._currentLocalXY.y
			};
		},
		/**
		 * Get the page XY of the event
		 * 
		 * @name sap.riv.vizkit.MouseEvent#pageXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		pageXY : function() {
			return {
				x : this._pageXY.x,
				y : this._pageXY.y
			};
		}
	});
	return MouseEvent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, AbstractVisualization) {
	var AbstractPieChart = ObjectUtils.derive(AbstractVisualization,
	/**
	 * @lends sap.riv.viz.AbstractPieChart.prototype
	 */
	{
		/**
		 * this is an abstract pie chart. clients should not use it directly
		 * @augments sap.riv.viz.AbstractVisualization
		 * @constructs
		 */
		constructor : function(holderElement, properties, dataset){
		}
	});

	return AbstractPieChart;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.ArrayUtils',
  version : '1.0.0'
},
function Setup() {
	var ArrayUtils = {
		each : function(array, callback) {
			array = array || [];
			for ( var i = 0, len = array.length; i < len; i++) {
				callback.call(array, i, array[i]);
			}
		},
		unique : function(array) {
			array = array || [];
			array = array.sort();
			for ( var i = 1; i < array.length; i++) {
				if (array[i] === array[i - 1]) {
					array.splice(i--, 1);
				}
			}
			return array;
		}
	};
	return ArrayUtils;
});sap.riv.module(
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
}
],
function Setup(ObjUtils, AbstractVisualization) {
	var AbstractXYChart = ObjUtils.derive(AbstractVisualization,
	/**
	 * @lends sap.riv.viz.AbstractXYChart.prototype
	 */
	{
		/**
		 * this is an abstract XY chart, clients should not use it directly
		 * 
		 * @augments sap.riv.viz.AbstractVisualization
		 * @constructs
		 */
		constructor : function(holderElement, options, dataset) {
		}
	});

	return AbstractXYChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.XYChartController',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIController',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.BaseTooltip',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.XYChartComponent',
  version : '1.0.0'
}
],
function Setup(ObjUtils, FunctionUtils, UIController, BaseTooltip, XYChartComponent) {
	var Controller = ObjUtils.derive(UIController, {
		constructor : function(options) {
			this._dataset = options.dataset;
			this._chartComponent = undefined;
			this._option = options.option;
			this._tooltip = null;
		},
		/**
		 * Subclass should overide this method to initialize custom UIComponent
		 * hierarchy and return the root UIComponent. The default implementation
		 * creates an empty UIComponent
		 */
		initUIComponent : function(width, height) {
			this._chartComponent = new XYChartComponent({
				id : 'rootComponent',
				dataset : this._dataset,
				xyChartOptions : this._option,
				clipToBound : false,
				size : {
					w : width,
					h : height
				}
			});
			return this._chartComponent;
		},

		doThemeApplied : function(theme) {
			this._chartComponent.applyTheme(theme);
		},

		updateProperties : function(propBag) {
			this._chartComponent.updateProperties(propBag);
			this._tooltip.reset({
				parent : this._chartComponent,
				metaData : this._dataset.metaData,
				dataTree : this._dataset.dataTree,
				properties : this._chartComponent.getOptions()
			});
		},

		getProperties : function() {
			return this._chartComponent.getProperties();
		},

		getSupportedEvents : function() {
			return this._chartComponent.getSupportedEvents();
		},

		getSupportedAppEvents : function() {
			return this._chartComponent.getSupportedAppEvents();
		},

		/**
		 * This method will be called after the managed UIComponent initialized
		 */
		afterUIComponentLoaded : FunctionUtils.noop,

		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentAppear : FunctionUtils.noop,

		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentAppear : function() {
			// init tooltip
			this._tooltip = new BaseTooltip({
				parent : this._chartComponent,
				metaData : this._dataset.metaData,
				dataTree : this._dataset.dataTree,
				properties : this._chartComponent.getOptions()
			});
			
			// var customizedTooltip = this._tooltip.getCustomization();
			// if (customizedTooltip != null) {
			//    // TODO use customized tooltip
			// }

			var appEvent = this._chartComponent.getSupportedAppEvents();
			for ( var i = appEvent.length; i-- || i == 0;) {
				this._chartComponent._chartComponent._chartModule.on({
					eventName : appEvent[i],
					listener : this._fireInternalAppEvent,
					scope : this
				});
			}
		},
		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentDisappear : FunctionUtils.noop,
		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentDisappear : FunctionUtils.noop,

		setDataset : function(dataset) {
			this._dataset = dataset;
			this._chartComponent.setDataset(dataset);
			this._tooltip.reset({
				parent : this._chartComponent,
				metaData : this._dataset.metaData,
				dataTree : this._dataset.dataTree,
				properties : this._chartComponent.getOptions()
			});
		},

		_fireInternalAppEvent : function(evt) {
			// [Ian] if the event type is showTooltip, we should convert the
			// point to global point based on root component
			if (evt.name === 'showTooltip') {
				var pointOnSeriesLayer = evt.data[0].point;
				// convert point on series layer to root layer
				var pointOnRootLayer = this._chartComponent._chartComponent._rootLayer.convertPointFromLayer(
						pointOnSeriesLayer, this._chartComponent._chartComponent._seriesLayer)
				var pointOnComponent = {};
				var pos = this._chartComponent._chartComponent.position();

				// convert point to root component
				pointOnComponent.x = pointOnRootLayer.x + pos.x;
				pointOnComponent.y = pointOnRootLayer.y + pos.y;

				// reset the point
				evt.data[0].point = pointOnComponent;

				this._tooltip.show(evt);
			} else if (evt.name == 'hideTooltip') {
				this._tooltip.hide(evt);
			}
			this.fireAppEvent(evt.name, evt);
		}
	});
	return Controller;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.DomWatcher',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
}
],
function Setup(UADetector, LinkedHashMap) {
    var watcherId = 0;
    var domId = 1;
    var nextWatcherId = function() {
        return watcherId++;
    };
    var nextDomId = function() {
        return domId++;
    };
    var isEmpty = function(obj) {
        for(var prop in obj) {
            if(obj.hasOwnProperty(prop))
                return false;
        }
        return true;
    };
    var css = function(dom, prop) {
        var val = null;
        if(window.getComputedStyle) {
            val = window.getComputedStyle(dom, null)[prop];
        } else if(dom.currentStyle) {
            val = dom.currentStyle[prop];
        }
        return val;
    };
    var domDataAccessor = function(key, value) {
        if(!this._data)
            this._data = {};
        if(arguments.length === 2) {
            this._data[key] = value;
        } else
            return this._data[key];
    };
    var domTasks = new LinkedHashMap();

    var eventHandler = function(e) {
    	var task;
        var dom = e.srcElement || e.target;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;
        var domTaskIt = domTasks.get(domId).getIterator();
        while(domTaskIt.hasMore()) {
            task = domTaskIt.nextValue();
            task.checkChange();
        }
    };
    var addEventHandler = function(id) {
        var task = taskQueue.get(id);
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId) {
            domId = nextDomId();
            domDataAccessor.call(dom, 'domId', domId);
            domTasks.add(domId, new LinkedHashMap());
        }
        domTasks.get(domId).add(task.id, task);
        if(!domDataAccessor.call(dom, 'eventHandler')) {
            if( typeof (dom.onpropertychange) == "object") {
                dom.attachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.addEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', eventHandler);
        }
    };
    var removeFromEventHandler = function(task) {
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;

        if(domTasks.get(domId).has(task.id))
            domTasks.get(domId).remove(task.id);

        if(domTasks.get(domId).isEmpty()) {
            var eventHandler = domDataAccessor.call(dom, 'eventHandler');
            if( typeof (dom.onpropertychange) == "object") {
                dom.detachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.removeEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', null);
        }
    };
    var scannerInstance = undefined;
    var taskQueue = new LinkedHashMap();
    var scanner = function() {
        var taskItr = taskQueue.getIterator();
        var task;
        while(taskItr.hasMore()) {
            task = taskItr.nextValue();
            task.checkChange();
        }
    };
    var addIntervalTask = function(task) {
        if(!scannerInstance)
            scannerInstance = setInterval(scanner, 100);
        if(!taskQueue.has(task.id))
            taskQueue.add(task.id, task);
    };
    var removeIntervalTask = function(id) {
        if(taskQueue.has(id)) {
            taskQueue.remove(id);
        }
        if(taskQueue.isEmpty()) {
            clearInterval(scannerInstance);
            scannerInstance = undefined;
        }
    };
    var hookChange = function(task) {
        var dom = task.domElem;
        if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
            addEventHandler(task.id);
        } else {
            //for browsers not support dom attributes change event, add a iterval task to check properties changes.
            addIntervalTask(task);
        }
    };
    var __watcher = function(id) {
        var task = taskQueue.get(id);
        if(!task)
            return;
        var dom = task.domElem;
        if(!task.callback)
            return;

        var changed = false;
        var i = 0;
        var changedProps = [];
        for(var l = task.cssProps.length; i < l; i++) {
            var newVal = css(dom, task.cssProps[i]);
            if(task.lastestVals[i] != newVal) {
                task.lastestVals[i] = newVal;
                changed = true;
                changedProps.push(task.cssProps[i]);
            }
        }
        if(changed)
            //task.callback.call(caller, changedProps);
            task.callback(changedProps);
    };
    //var caller;
    var DomWatcher = {
        /**
         * watch a dom element on specific css properties, if change, excute callback func,
         * callback parameter is an array of changed properties
         *
         * @param dom element to watch
         * @param props css properties on element to watch, input as a string, properties should be seperated by comma ','
         * @param func function to execute on properties change, when calling DomWatcher.watch,
         *     ObjectUtils.proxy(func, this) is recommend for the callback function. i.e. DomWatcher.watch(dom,props, ObjectUtils.proxy(func, this));
         * @return generated watcher id
         */
        watch : function(dom, props, func) {
            //caller = this.watch.caller;
            var id = nextWatcherId();
            var checkChange = function() {
                __watcher(id);
            };
            var task = {
                id : id,
                domElem : dom,
                cssProps : props.split(","),
                lastestVals : [props.split(",").length],
                callback : func,
                checkChange : checkChange
            };

            for(var i = 0, len = task.cssProps.length; i < len; i++) {
                task.lastestVals[i] = css(dom, task.cssProps[i]);
            }
            if(!taskQueue.has(task.id))
                taskQueue.add(task.id, task);
            hookChange(task);
            return id;
        },
        unwatch : function(id) {
            var task = taskQueue.get(id);
            var dom = task.domElem;
            try {
                if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
                    removeFromEventHandler(task);
                } else
                    removeIntervalTask(task.id);
            }
            // ignore if element was already unbound
            catch (e) {
            }
        }
    };
    return (DomWatcher);
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.VizFrame',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.DomWatcher',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.MouseEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.TouchEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, UIComponent, GestureDetector, DomWatcher, Event, MouseEvent, TouchEvent,
		Math) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var isInDomtree = function(node) {
		var bodyNode = undefined;
		do {
			if (node.nodeName == 'BODY') {
				bodyNode = node;
				break;
			} else {
				node = node.parentNode;
			}
		} while (node)
		return bodyNode;
	};

	var setFrame = function(vframe) {
		// set offset according to parent postion property
		var holder = vframe._holder;
		if (holder.css('position') == "static" || holder.css('position') == "fix") {
			var position = holder.position();
			vframe.frame({
				x : position.left,
				y : position.top,
				width : holder.width(),
				height : holder.height()
			});
		} else {
			vframe.frame({
				x : 0,
				y : 0,
				width : holder.width(),
				height : holder.height()
			});
		}
	};
	// callback on css change
	var func = function(changedProps) {
		for ( var i = 0, len = changedProps.length; i < len; i++) {
			if (changedProps[i] === "position") {
				setFrame(this);
				break;
			}
		}
	};

	var getHittedComponent = function(event) {
		var domEntity = $(event.target);
		while (!domEntity.data('selfComp')) {
			domEntity = domEntity.parent();
		}
		return domEntity.data('selfComp');
	};

	var ts = GestureDetector.TransitionState;
	var VizFrame = ObjectUtils
			.derive(
					UIComponent,
					{
						constructor : function(options) {
							if (options.container) {
								this._holder = $(options.container);
								if (!isInDomtree(this._holder.get(0))) {
									FunctionUtils.error('The holder DIV must be a child of Body element.');
								}
								// VizFrame's logical parent is always visible
								if (this._holder.css('display') === 'none') {
									this.markHide();
								}
								this.clipToBound(false);
								this._regDOMEventHandlers();
								this._holder.append(this._container);
								this.anchorPoint({
									x : 0,
									y : 0
								});
								setFrame(this);
								// watch position changes
								DomWatcher.watch(this._holder.get(0), "position", ObjectUtils.proxy(func, this));
								this._parentVisible = true;
								this._attached = true;
								// structure for event dispatching
								this._msTracking = [];
								this._touchSeqTracking = {};

							} else {
								throw new Error('you have to provide a container for viz frame');
							}
						},

						_regDOMEventHandlers : function() {
							this._container.bind('click', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('dblclick', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusin', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusout', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focus', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('blur', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousedown', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseup', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseenter', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseleave', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousemove', ObjectUtils.proxy(this._handleDomEvent, this));
							// Below events are supposed to be fired when the
							// element is attached/detached to/from document,
							// it's used to register touch listener correctly in
							// iOS Mobile Safari.
							this._container.bind('DOMNodeInsertedIntoDocument', ObjectUtils.proxy(
									this._registerDOMTouchHandler, this));
							this._container.bind('DOMNodeRemovedFromDocument', ObjectUtils.proxy(
									this._unregisterDOMTouchHandler, this));
						},

						_registerDOMTouchHandler : function() {
							this._container.bind('touchstart', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchmove', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchend', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchcancel', ObjectUtils.proxy(this._handleDomEvent, this));
						},

						_unregisterDOMTouchHandler : function() {
							this._container.unbind('touchstart');
							this._container.unbind('touchmove');
							this._container.unbind('touchend');
							this._container.unbind('touchcancel');
						},

						_handleDomEvent : function(event) {
							event.preventDefault();
							var hittedComp = getHittedComponent(event);
							switch (event.type) {
							case 'mousemove':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									var localPoint = {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									};
									if (this._msTracking.length) {
										if (this._msTracking[this._msTracking.length - 1] !== hittedComp) {
											var enteredComps = [];
											var entered = hittedComp;
											while (entered) {
												enteredComps.push(entered);
												entered = entered.superComponent();
											}
											var inCompCount = 0, checkFinished = false, minLen = Math.min(
													this._msTracking.length, enteredComps.length);
											while (true) {
												var left = undefined;
												if (!checkFinished
														&& this._msTracking[inCompCount] === enteredComps[enteredComps.length
																- 1 - inCompCount]) {
													inCompCount++;
													checkFinished = inCompCount === minLen;
												} else {
													while (this._msTracking.length > inCompCount) {
														left = this._msTracking.pop();
														var mlEvt = new MouseEvent('mouseleave', left, false,
																localPoint, {
																	x : event.pageX,
																	y : event.pageY
																});
														mlEvt._setRelatedTarget_(hittedComp);
														left._fireMouseEvent_(mlEvt);
													}
													while (inCompCount < enteredComps.length) {
														var entered = enteredComps.shift();
														left = this._msTracking[enteredComps.length - 1];
														this._msTracking[enteredComps.length] = entered;
														var mlEvt = new MouseEvent('mouseenter', entered, false,
																localPoint, {
																	x : event.pageX,
																	y : event.pageY
																});
														mlEvt._setRelatedTarget_(left);
														entered._fireMouseEvent_(mlEvt);
													}
													break;
												}
											}
										}
									} else {
										var entered = hittedComp;
										do {
											this._msTracking.push(entered);
											entered._fireMouseEvent_(new MouseEvent('mouseenter', entered, false,
													localPoint, {
														x : event.pageX,
														y : event.pageY
													}));
											entered = entered.superComponent();
										} while (entered)
										this._msTracking.reverse();
									}
									hittedComp._fireMouseEvent_(new MouseEvent('mousemove', hittedComp, true,
											localPoint, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									while (this._msTracking.length) {
										var left = this._msTracking.pop();
										left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, localPoint, {
											x : event.pageX,
											y : event.pageY
										}));
									}
								}
								break;
							case 'mouseleave':
								while (this._msTracking.length) {
									var left = this._msTracking.pop();
									var leftCompPageXY = left.pagePosition();
									left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, {
										x : event.pageX - leftCompPageXY.x,
										y : event.pageY - leftCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mouseup':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mouseup', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mousedown':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mousedown', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'dblclick':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer,
													true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('dblclick', this._focusedComp,
											true, {
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedLayer, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'click':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusout', this._focusedComp, true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('click', this._focusedComp, true,
											{
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedComp, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'touchstart':
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// 'false' means the touch hasn't been
									// marked
									// cancelled
									this._touchSeqTracking[touch.identifier] = false;
								}

								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchstart', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							case 'touchmove':
								// Handle gesture Detection and fire touchmove
								// event when no gesture currently detected
								if (!this._handleGestureDetect(hittedComp, event.originalEvent)) {
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchmove', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								break;
							case 'touchend':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var uncancelledTouchesArray = [], cancelledTouchesArray = [], touchesArray = [], targetTouchesArray = [];
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									this._touchSeqTracking[touch.identifier] === true ? cancelledTouchesArray
											.push(touch) : uncancelledTouchesArray.push(touch);
									delete this._touchSeqTracking[touch.identifier];
								}

								if (uncancelledTouchesArray.length) {
									// Some touches are not cancelled, so we
									// have to split the event into two events,
									// one for cancelled touches, one for
									// uncancelled touches
									for ( var i = 0, touch, targetTouches = event.originalEvent.targetTouches, len = targetTouches.length; i < len; i++) {
										touch = targetTouches.item(i);
										targetTouchesArray.push(touch);
									}
									for ( var i = 0, touch, touches = event.originalEvent.touches, len = touches.length; i < len; i++) {
										touch = touches.item(i);
										touchesArray.push(touch);
									}
									var touchCancelEvent = TouchEvent.buildFrom3TouchArray('touchcancel', hittedComp,
											touchesArray, cancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchCancelEvent);
									var touchEndEvent = TouchEvent.buildFrom3TouchArray('touchend', hittedComp,
											touchesArray, uncancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchEndEvent);
								} else {
									// All ended touches are marked as cancelled
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								// Fire touch event
								break;

							case 'touchcancel':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									delete this._touchSeqTracking[touch.identifier];
								}
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							}
						},

						_handleGestureDetect : function(hittedComponent, origTouchEvent) {
							var grs = [];
							var thisLevel = hittedComponent;
							// find the gesture recognizers responsible for the
							// gesture detection of the component hierarchy
							while (!thisLevel._gestureDetectors.length && thisLevel._superComp) {
								thisLevel = thisLevel._superComp;
							}
							grs = thisLevel._gestureDetectors;
							var someGestureDetected = false, gestureDetected, needToCancelTouches = false;
							for ( var i = 0, state, gd, len = grs.length; i < len; i++) {
								gd = grs[i];
								switch (origTouchEvent.type) {
								case 'touchstart':
									gd.touchBegin(origTouchEvent);
									break;
								case 'touchmove':
									gd.touchMove(origTouchEvent);
									break;
								case 'touchend':
									gd.touchEnd(origTouchEvent);
									break;
								case 'touchcancel':
									gd.touchCancel(origTouchEvent);
									break;
								}
								state = gd.state();
								gestureDetected = (state === ts.Began) || (state === ts.Changed)
										|| (state === ts.Recognized);
								someGestureDetected = someGestureDetected || gestureDetected;
								needToCancelTouches = needToCancelTouches || (gestureDetected && gd.cancelTouches());
							}
							if (needToCancelTouches) {
								for ( var i = 0, touch, changedTouches = origTouchEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// Mark all changed touch as cancelled
									this._touchSeqTracking[touch.identifier] = true;
								}
							}
							return someGestureDetected;
						},

						hidden : function(hidden) {
							hidden ? this._holder.hide() : this._holder.show();
							if (hidden) {
								this.markHide();
							} else {
								this.markShow();
							}
						}
					});
	return VizFrame;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ImageManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.VizFrame',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(Observable, FuncUtils, ObjectUtils, ThemeManager, ImageManager, VizFrame, CanvasHelper, UIComponent, LOG) {
    
    var id = 0;
    function nextId(){
        return id++;
    }
	var Autosizing = UIComponent.Autosizing;
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * The main entry of a given visualization application. It implements most
	 * of the things that need to start a viz application, e.g. bootstrapping,
	 * preload images
	 * 
	 * @name sap.riv.vizkit.VizApplication
	 * @constructor
	 * @param {Object}
	 *            options the options that needs to start the application
	 * @param {String}
	 *            options.wrapperDivEl the wrapper DIV element
	 * @param {Constructor}
	 *            options.delegateClass the constructor of your custom viz app
	 *            delegate
	 * @param {Object}
	 *            [launchOption] the additional option that will pass to the
	 *            {@link sap.riv.vizkit.VizAppDelegate#appDidFinishLaunching}
	 */
	var VizApplication = function(options) {
	    var _nextId = nextId();
        this._id = options.id ? options.id + '_' + _nextId : _nextId;
        LOG.debug("Chart Application["+this._id+"] initializing.","perf");
		if (!options.delegateClass) {
			FuncUtils.error('You have to specify a delegate for visualization custom behavior.');
		}
		if (!options.wrapperDivEl) {
			FuncUtils.error('You have to specify a div element for holding the visualization.');
		}
		this._vizFrame = new VizFrame({
			container : options.wrapperDivEl
		});
		this._canvasForPrinting = CanvasHelper.createCanvasElement(1, 1);
		this._delegate = new options.delegateClass();
		var assets = this._delegate.getPreloadAssets();
		ImageManager.loadImages(assets, undefined, ObjectUtils.proxy(function() {
			this._delegate._afterLaunched(this, options.launchOption);
		}, this));
		var comsItr = this._vizFrame.subComponents().getIterator();
		while(comsItr.hasMore()){
		    LOG.debug("application["+this._id+"]"+"component["+comsItr.nextValue().id()+"] initialized.","perf");
		}
		this._eventBridge = new Observable();
		this._addEvents(this._delegate.getSupportedEvents());
		ThemeManager.on('defaultThemeChanged', this._handleDefaultThemeChanged);
		ThemeManager.on('themeSettingChanged', this._handleThemeSettingChanged);
	};

	var ap = VizApplication.prototype;
	
    ap.id = function(){
        return this._id;
    };
	/**
	 * Print the current state of the running viz application to the given
	 * canvas
	 * 
	 * @name sap.riv.vizkit.VizApplication#printTo
	 * @param {Object}
	 *            options the print option
	 * @param {String}
	 *            options.targetCanvas the id of the target canvas to print to
	 * 
	 */
	ap.printTo = function(options) {
		if (options.targetCanvas) {
			var targetCanvas = CanvasHelper.getCanvasElement($(options.targetCanvas));
			var workingCanvas = this._canvasForPrinting;
			var workingCtx = workingCanvas.getContext('2d');
			var destCtx = targetCanvas.getContext('2d');
			var size = this.size();
			workingCanvas.width(size.width);
			workingCanvas.height(size.height);
			destCtx.clearRect(0, 0, targetCanvas.width(), targetCanvas.height());
			destCtx.save();
			destCtx.scale(targetCanvas.width() / size.width, targetCanvas.height() / size.height);
			destCtx.translate(0, 0);
			destCtx.rect(0, 0, size.width, size.height);
			destCtx.clip();
			var pStack = [ {
				processed : false,
				uiComp : this._vizFrame,
				subCompItr : this._vizFrame.subComponents().getIterator()
			} ], cFrame, cUIComp;
			while (pStack.length) {
				cFrame = pStack[pStack.length - 1];
				cUIComp = cFrame.uiComp;
				if (cUIComp.printable() && !cUIComp.hidden()) {
					if (!cFrame.processed) {
						cUIComp.printTo(workingCtx);
						destCtx.drawImage(workingCanvas, 0, 0);
						cFrame.processed = true;
					}
					if (cFrame.subCompItr.hasMore()) {
						var subComp = cFrame.subCompItr.next().value;
						workingCanvas.width(subComp.width());
						workingCanvas.height(subComp.height());
						var frame = subComp.frame();
						destCtx.save();
						destCtx.translate(frame.x, frame.y);
						destCtx.beginPath();
						destCtx.moveTo(0, 0);
						destCtx.lineTo(frame.width, 0);
						destCtx.lineTo(frame.width, frame.height);
						destCtx.lineTo(0, frame.height);
						destCtx.closePath();
						destCtx.clip();
						pStack.push({
							processed : false,
							uiComp : subComp,
							subCompItr : subComp.subComponents().getIterator()
						});
					} else {
						destCtx.restore();
						pStack.pop();
					}
				} else {
					destCtx.restore();
					pStack.pop();
				}
			}
		}
	};

	/**
	 * Get and set the size of the application
	 * 
	 * @name sap.riv.vizkit.VizApplication#size
	 * @param {undefined|Object}
	 *            size undefined or new size of the application
	 * @returns {this|Object} when set the size the return is this object, when
	 *          get the size the return will be the size
	 * 
	 */
	ap.size = function(size) {
		if (size !== undefined) {
			this._vizFrame.size(size);
			return this;
		} else {
			return this._vizFrame.size();
		}
	};

	/**
	 * Get and set the visibility of the application
	 * 
	 * @name sap.riv.vizkit.VizApplication#hidden
	 * @param {undefined|Boolean}
	 *            hidden undefined or boolean value indicating whether the
	 *            application should be hided.
	 * @returns {this|Object} when set the hidden status the return is this
	 *          object, when get the hidden status the return will be the
	 *          current hidden status.
	 * 
	 */
	ap.hidden = function(hidden) {
		if (hidden !== undefined) {
			if (this._vizFrame.hidden() !== hidden) {
				this._vizFrame.hidden(hidden);
			}
			return this;
		} else {
			return this._vizFrame.hidden();
		}
	};
	/**
	 * Get a list of event names the current visualization instance supports
	 * 
	 * @name sap.riv.vizkit.VizApplication#getSupportedEvent
	 * @returns {Array} an array of event names supported
	 * 
	 */
	ap.getSupportedEvent = function() {
		return this._eventBridge.getSupportedEvents();
	};
	/**
	 * Add a listener to the supported event
	 * 
	 * @name sap.riv.vizkit.VizApplication#addListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the function to be called back when event occurs
	 * 
	 */
	ap.addListener = function(event, listener) {
		this._eventBridge.addListeners({
			eventName : event,
			listener : listener
		});
	};
	/**
	 * Remove an existing listener
	 * 
	 * @name sap.riv.vizkit.VizApplication#removeListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the existing function to be removed
	 * 
	 */
	ap.removeListener = function(event, listener) {
		this._eventBridge.removeListener(event, listener);
	};

	ap._addEvents = function(events) {
		for ( var i = 0, len = events.length; i < len; i++) {
			this._eventBridge.addEvents(events[i]);
		}
	};

	ap._fireEvent = function() {
		this._eventBridge.fireEvent.apply(this._eventBridge, arguments);
	};

	/**
	 * Get a list of public method names the current visualization instance
	 * supports
	 * 
	 * @name sap.riv.vizkit.VizApplication#getPublicMethods
	 * @returns {Array} an array of public method names supported
	 * 
	 */
	ap.getPublicMethods = function() {
		this._delegate.getSupportedMethods();
	};
	/**
	 * Invoke the public method of the current visualization with options
	 * 
	 * @name sap.riv.vizkit.VizApplication#invokePublicMethod
	 * @param {String}
	 *            publicMethodName, the name of the public method.
	 * @param {Object}
	 *            [options] the options object is passed as argument.
	 */
	ap.invokePublicMethod = function(publicMethodName, options) {
		this._delegate._invokePublicMethod(publicMethodName, options);
	};
	/**
	 * Apply a new theme to the visualization instance
	 * 
	 * @name sap.riv.vizkit.VizApplication#applyTheme
	 * @param {String}
	 *            theme, the name of the theme.
	 */
	ap.applyTheme = function(theme) {
		this._delegate._applyTheme(theme);
	};

	/**
	 * Get or set the properties of the current visualization instance.
	 * 
	 * @name sap.riv.vizkit.VizApplication#properties
	 * @param {Object}
	 *            [propBag]
	 * @returns {Object}
	 */
	ap.properties = function(propBag) {
		if (propBag !== undefined) {
			this._delegate.updateProperties(propBag);
		}
		return this._delegate.getProperties();
	};

	/**
	 * Update dataset after chart created
	 * 
	 * @name sap.riv.vizkit.VizApplication#setDataset
	 * @param {Object}
	 */
	ap.setDataset = function(dataset) {
		if (dataset) {
			this._delegate.setDataset(dataset);
		}
	};

	ap._setRootController = function(rootController) {
		if (rootController) {
			var rootUIComp = rootController.rootUIComponent();
			rootUIComp.frame(this._vizFrame.bounds());
			rootUIComp.autoresizingMask(Autosizing.FlexibleWidth | Autosizing.FlexibleHeight);
			this._vizFrame.addSubComponent(rootUIComp);
		}
	};

	ap._handleDefaultThemeChanged = function(oldDefault, newDefault) {
		if (this._delegate._currentTheme() === oldDefault) {
			this._delegate._applyTheme(newDefault);
		}
	};

	ap._handleThemeSettingChanged = function(theme, key, oldValue, newValue) {
		this._delegate._updateThemeSetting(theme, key, oldValue, newValue);
	};
	return VizApplication;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.VizAppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.DataTree',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.XYChartController',
  version : '1.0.0'
}
],
function Setup(ObjUtils, VizAppDelegate, DataTree, XYChartController) {
	var AppDelegate = ObjUtils.derive(VizAppDelegate, {
		constructor : function() {
			this._rootController = undefined;
		},
		appDidFinishLaunching : function(application, launchOptions) {
			var dataset = launchOptions.data.rawData;
			var data = dataset.exportTree();

			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(data.dataTree),
				metaData : data.metaData
			}

			this._rootController = new XYChartController({
				dataset : completedDataset,
				option : launchOptions.option
			});
		},
		rootController : function() {
			return this._rootController;
		},
		getPreloadAssets : function() {
			return [];
		},

		updateProperties : function(propBag) {
			this._rootController.updateProperties(propBag);
		},

		getProperties : function() {
			return this._rootController.getProperties();
		},

		getSupportedEvents : function() {
			return [ 'selectData' ];
		},

		setDataset : function(data) {
			var dataset = data.exportTree();
			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(dataset.dataTree),
				metaData : dataset.metaData
			}

			this._rootController.setDataset(completedDataset);
		}
	});
	return AppDelegate;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.log.LogAnalyzer',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
}
],
function Setup(LinkedHashMap) {

    /*var Node = function(key, value) {
        this.key = key;
        this.value = value;
        this.childs = [];
    };
    Node.prototype = {
        addChild : function(node) {
            this.childs.push(node);
        },
        search : function(key ,value) {
            // var node = this;
            if(this.key === key && this.value === value)
                return this;
            else {
                var nodes = this.childs;
                for(var i = 0, l = nodes.length; i < l; i++) {
                    var ret = nodes[i].search(key);
                    if(ret !== null)
                        return ret;
                }
                return null;
            }
        }
    };

    var Tree = function(node) {
        this.root = node;
    };
    Tree.prototype = {
        searchTree : function(key, value) {
            var p = this.root;
            return p.search(key, value);
        }
    };*/
    
    var chartStartTime = {};
    var chartAppMap={};
    var chartAppComMap={};
    var chartMap = new LinkedHashMap();
    var chartStartP = /Chart\[(.+?)\]\sinitializing\./;
    var chartMapP= /Chart\[(.+?)\]application\[(.+?)\]\sinitialized\./;
    //var chartAppStartP = /Chart\sApplication\[(.+?)\]\sinitializing\./;
    //var chartComStartP = /chart\[(.+?)\]start\sinitialize\sSubComponents\./;
    var chartAppComMapP = /application\[(.+?)\]component\[(.+?)\]\sinitialized\./;
    var chartSubP = /chartComponent\[(.+?)\]subComponent\[(.+?)\]initialized\./;
    // var chartFinishP = /chart\[(.+?)\]all\ssubComponents\sinitialized\./;
    var comP = /layer\[(.+?)\]rendering\send\./;
    //var comSkipP = /chart\[(.+?)\]subComponent\[(.+?)\]skipped\./;
    var timeP = /#(\d+)#/;

    function chartFinished(comItr) {
        while(comItr.hasMore()) {
            if(comItr.nextValue() === -1)
                return false;
        }
        return true;
    }

    function max(nums) {
        var m = nums[0];
        var length = nums.length;
        for(var i = 1; i < length; i++) {
            m = nums[i] > m ? nums[i] : m;
        }
        return m;
    }

    var LogAnalyzer = {
        analyze : function(log) {
            var m = chartStartP.exec(log);
            if(m){
                // chartMainStartTime[m[1]]=timeP.exec(log)[1];
                chartStartTime[m[1]]=timeP.exec(log)[1];
                return;
            }
            m=chartAppComMapP.exec(log);
            if(m){
                chartAppComMap[m[2]]=m[1];
                //chartStartTime[m[2]] = {chart:chartAppTime[m[1]].chart,time:chartAppTime[m[1]].time};
                return;
            }
            m=chartMapP.exec(log);
            if(m){
                chartAppMap[m[2]]=m[1];
                //chartAppTime[m[2]] = {chart:m[1],time:chartMainStartTime[m[1]]};
                return;
            }
            // m = chartComStartP.exec(log);
            // if(m) {
            // chartStartTime[m[1]] = undefined;//timeP.exec(log)[1];
            // return;
            // }
            m = chartSubP.exec(log);
            if(m) {
                if(!chartMap.has(m[1])) {
                    chartMap.add(m[1], new LinkedHashMap());
                }
                chartMap.get(m[1]).add(m[2], -1);
                return;
            }
            // m = comSkipP.exec(log);
            // if(m) {
                // chartMap.get(m[1]).remove(m[2]);
                // return;
            // }
            m = comP.exec(log);
            if(m) {
                var timeStamp = timeP.exec(log)[1];
                var chartItr = chartMap.getIterator();
                while(chartItr.hasMore()) {
                    var chart = chartItr.next();
                    var componentMap = chart.value;
                    if(componentMap.has(m[1]) && componentMap.get(m[1]) === -1) {
                        componentMap.add(m[1], timeStamp);
                        var chartTime = 0;
                        var comItr = componentMap.getIterator();
                        if(chartFinished(comItr)) {
                            comItr.reset();
                            var endTimes = [];
                            while(comItr.hasMore()) {
                                endTimes.push(comItr.nextValue());
                            }
                            var chartKey =chartAppMap[chartAppComMap[chart.key]];
                            chartTime = max(endTimes) - chartStartTime[chartKey];
                            chartMap.remove(chart.key);
                            return ("chart[" + chartKey + "]time consume[" + chartTime + "]");
                        }
                    }
                }
            }
        }
    };
    return LogAnalyzer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.MultiPieChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractPieChart, LOG) {
	var multiPieChart = ObjUtils.derive(AbstractPieChart,
	/**
	 * @lends sap.riv.viz.MultiPieChart.prototype
	 */
	{
		/**
		 * @constructs
		 * @augments sap.riv.viz.AbstractPieChart
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'multipie';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return multiPieChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.dataConverter.CrossTableDataset',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ArrayUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.dataConverter.BaseDataset',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, ArrayUtils, TypeUtils, BaseDataset) {
	var crossTableDataset = ObjectUtils
			.derive(
					BaseDataset,
					/**
					 * @lends sap.riv.viz.shared.dataConverter.CrossTableDataset.prototype
					 */
					{
						/**
						 * CrossTableDataset can contain multiple dimensions and multiple measures
						 * in two axes
						 * @constructs
						 */
						constructor : function() {
							// -------------------------------------------
							// Properties
							// -------------------------------------------
							this.metadata = {
								columnAxis : [],
								rowAxis : []
							};

							this.origData = [];
							this.data = [];
							this.aggregation = [];

							this.chartInstances = {};
							// all chart instances which use this dataset

							this._axisCounter = 0;

							this.ERROR_CHAR = "NaN";
							this.AXIS_TYPE_MEASURE = "measure";
							this.AXIS_TYPE_DIMENSION = "dimension";

							this.AXIS_KEY_TYPE = "type";
							this.AXIS_KEY_LEVEL = "level";

							this.AGGREGATION_DEFAULTTYPE = "default";
							this.AGGREGATION_INLINETYPE = "inline";
						},

						_verifyAxesName : function(axes, name) {

							if (TypeUtils.isString(name) && name.length > 0) {
								// check name existance
								for ( var i = 0; i < axes.length; i++)
									if (axes[i].name == name)
										throw new Error(
												"Axis with this name already exists!");

								return name;
							} else {
								return "";
							}
						},

						_updateAxesLevels : function(isRow) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);
							for ( var i = 0; i < axes.length; i++)
								axes[i].level = parseInt(i, 10);
						},

						_addAxis : function(isRow, name, members, type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							return this._addAxisAt(isRow, axes.length, name,
									members, type);
						},

						_addAxisAt : function(isRow, level, name, members, type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							// check param validity
							if (!members)
								throw new Error("Invalid params!");
							if (!members.length)
								throw new Error("Invalid params!");
							if (level < 0 || level > axes.length)
								throw new Error(
										"Invalid params! Level out of range!");

							if (typeof type == "undefined")
								type = this.AXIS_TYPE_DIMENSION;
							if (type != this.AXIS_TYPE_MEASURE
									&& type != this.AXIS_TYPE_DIMENSION)
								throw new Error("Invalid params!");
							name = this._verifyAxesName(axes, name);
							var targetMembers = [];
							ObjectUtils.extend(true, targetMembers, members);

							// gen uid
							var uid = (isRow ? "d" : "c") + this._axisCounter;
							this._axisCounter++;

							var newAxis = {
								uid : uid,
								level : level,
								name : name,
								members : targetMembers,
								type : type
							};

							if (level == axes.length)
								axes[axes.length] = newAxis;
							else {
								// insert
								axes.splice(level, 0, newAxis);
								// update level values
								this._updateAxesLevels(isRow);
							}

							this.markDirty();

							return uid;
						},

						_modifyAxis : function(isRow, level, name, members,
								type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							// check param validity
							if (!members)
								throw new Error("Invalid params!");
							if (!members.length)
								throw new Error("Invalid params!");
							if (level < 0 || level >= axes.length)
								throw new Error(
										"Invalid params! Level out of range!");

							if (name != axes[level].name)
								name = this._verifyAxesName(axes, name);

							if (typeof type == "undefined")
								type = this.AXIS_TYPE_DIMENSION;
							if (type != this.AXIS_TYPE_MEASURE
									&& type != this.AXIS_TYPE_DIMENSION)
								throw new Error("Invalid params!");

							axes[level].name = name;
							axes[level].type = type;
							axes[level].members = [];
							ObjectUtils.extend(true, axes[level].members,
									members);

							this.markDirty();

							return {
								uid : axes[level].uid,
								level : level,
								name : name,
								type : type
							};
						},

						_modifyAxisByUid : function(isRow, uid, name, members,
								type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							var retval = null;
							for ( var i = 0; i < axes.length; i++)
								if (axes[i].uid == uid) {
									return this._modifyAxis(isRow,
											axes[i].level, name, members, type);
								}

							return retval;
						},

						_getAxesInfo : function(isRow) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							var retval = [];
							ObjectUtils.extend(true, retval, axes);
							ObjectUtils.each(retval, function(index, value) {
								delete value.members;
							});
							return !retval.length ? null : retval;
						},

						_getAxisInfo : function(isRow, level) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (level < 0 || level >= axes.length)
								throw new Error("Level out of range!");

							return {
								uid : axes[level].uid,
								level : level,
								name : axes[level].name,
								type : axes[level].type
							};
						},

						_getAxisInfoByUid : function(isRow, uid) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							for ( var i = 0; i < axes.length; i++)
								if (axes[i].uid == uid)
									return {
										uid : uid,
										level : axes[i].level,
										name : axes[i].name,
										type : axes[i].type
									};

							return null;
						},

						_getAxisMembersByUid : function(isRow, uid) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							var targetMembers = [];
							for ( var i = 0; i < axes.length; i++) {
								if (axes[i].uid == uid) {
									ObjectUtils.extend(true, targetMembers,
											axes[i].members);
									return targetMembers;
								}
							}

							return null;
						},

						_getAxisMembers : function(isRow, level) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (level < 0 || level >= axes.length)
								throw new Error(
										"Invalid params! Level out of range!");

							var targetMembers = [];
							ObjectUtils.extend(true, targetMembers,
									axes[level].members);

							return targetMembers;
						},

						_removeAxis : function(isRow, level) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (level < 0 || level >= axes.length)
								throw new Error(
										"Invalid params! Level out of range!");
							//[tony,18/4/2012],return {uid,level,name,type}
							var retval = {
								uid : axes[level].uid,
								level : level,
								name : axes[level].name,
								type : axes[level].type
							};
							axes.splice(level, 1);

							this._updateAxesLevels(isRow);

							this.markDirty();

							return retval;
						},

						_removeAxisByUid : function(isRow, uid) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (!uid)
								throw new Error("Invalid uid!");

							var retval = {};
							for ( var i = 0; i < axes.length; i++) {
								if (axes[i].uid == uid) {
									return this._removeAxis(isRow, i);
								}
							}

							return null;
						},

						_getAxisUniqueMembersByType : function(isRow, type) {
							var axisInfos = this._getAxesInfo(isRow);
							var targetMember = [];
							for ( var item = 0; item < axisInfos.length; item++) {
								if (type == axisInfos[item].type) {
									var uid = axisInfos[item].uid;
									targetMember = this._getAxisMembersByUid(
											isRow, uid);
									return ArrayUtils.unique(targetMember);
								}
							}
							return null;
						},

						_getAxisUniqueMembersByLevel : function(isRow, level) {
							try {
								var targetMember = this._getAxisMembers(isRow,
										level);
								return ArrayUtils.unique(targetMember);
							} catch (e) {
								return null;
							}
						},

						_getAxisUniqueMembers : function(isRow, key, value) {
							switch (key) {
							case this.AXIS_KEY_TYPE:
								return this._getAxisUniqueMembersByType(isRow,
										value);
							case this.AXIS_KEY_LEVEL:
								return this._getAxisUniqueMembersByLevel(isRow,
										value);

							default:
								return null;
							}

						},

						_cleanData : function() {
							this.data = [];
							ObjectUtils.extend(true, this.data, this.origData);
							if (this.metadata.columnAxis.length == 0) {
								throw new Error(
										"There should be at least one column measure axis!");
							}
							if (this.metadata.rowAxis.length == 0) {
								throw new Error(
										"There should be at least one row dimension axis!");
							}
							// we assume the first axis is measure axis, TODO we
							// can do more check
							var col = this.metadata.columnAxis[0].members.length;

							var rowAxisCount = this.metadata.rowAxis.length;
							var row = this.metadata.rowAxis[rowAxisCount - 1].members.length;

							var _col = col;
							var _row = row;
							if (!this.metadata.dataByColumn) {
								_col = row;
								_row = col;
							}

							if (!TypeUtils.isExist(this.data))
								this.data = [];
							for ( var i = 0; i < _col; i++) {
								if (!TypeUtils.isExist(this.data[i]))
									this.data[i] = [];
								for ( var j = 0; j < _row; j++) {
									if (!TypeUtils.isExist(this.data[i][j])) {
										this.data[i][j] = this.ERROR_CHAR;
									} else {
										// verify is number data
										if (!TypeUtils
												.isNumber(this.data[i][j])) {
											var r = /(^-?\d+$)|(^(-?\d+)(\.\d+)?$)/;
											if (!r.test(this.data[i][j])) {
												this.data[i][j] = this.ERROR_CHAR;
											}
										}

									}
								}
								if (this.data[i].length > _row)
									this.data[i].splice(_row,
											this.data[i].length - _row);
							}
						},

						// -------------------------------------------
						// Public Methods
						// -------------------------------------------
						/**
						 * 
						 * @param {String}
						 *            name: The column axis name.
						 * @param {String[]}
						 *            members: The full list of column axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added column axis
						 *         uid, level is changing but uid is fixed.
						 */
						addColumnAxis : function(name, members, type) {

							return this._addAxis(false, name, members, type);
						},

						/**
						 * 
						 * @param {Number}
						 *            level: The level to be added, if dataset
						 *            has the same level column axis, we insert
						 *            the new column before that level position.
						 * @param {String}
						 *            name: The column axis name.
						 * @param {String[]}
						 *            members: The full list of column axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added column axis
						 *         uid, level is changing but uid is fixed.
						 */
						addColumnAxisAt : function(level, name, members, type) {

							return this._addAxisAt(false, level, name, members,
									type);

						},

						/**
						 * 
						 * @param {Number}
						 *            level
						 * @param {String}
						 *            name
						 * @param {String[]}
						 *            members
						 * @param (string)
						 *            type
						 * @return {uid, level, name, type}
						 */
						modifyColumnAxis : function(level, name, members, type) {

							return this._modifyAxis(false, level, name,
									members, type);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @param {String}
						 *            name
						 * @param {String[]}
						 *            members
						 * @param (string)
						 *            type
						 * @return {uid, level, name, type}
						 */
						modifyColumnAxisByUid : function(uid, name, members,
								type) {

							return this._modifyAxisByUid(false, uid, name,
									members, type);
						},

						/**
						 * 
						 * @return {Object[]} return [{uid, level, name, type},
						 *         ...]
						 */
						getColumnAxesInfo : function() {

							return this._getAxesInfo(false);
						},

						/**
						 * @param {Number}
						 *            level
						 * @return {Object} return {uid, level, name, type}
						 */
						getColumnAxisInfo : function(level) {

							return this._getAxisInfo(false, level);
						},

						/**
						 * @param {String}
						 *            uid
						 * @return {Object} return {uid, level, name, type}
						 */
						getColumnAxisInfoByUid : function(uid) {

							return this._getAxisInfoByUid(false, uid);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {String[]} return the column axis members
						 *         cloned Array by level.
						 */
						getColumnAxisMembersByUid : function(uid) {

							return this._getAxisMembersByUid(false, uid);
						},

						/**
						 * 
						 * @param {Object}
						 *            level
						 * @return {String[]} return the column axis members
						 *         cloned Array by level.
						 */
						getColumnAxisMembers : function(level) {

							return this._getAxisMembers(false, level);
						},

						/**
						 * 
						 * @param {String}
						 *            key: AXIS_KEY_TYPE/AXIS_KEY_LEVEL
						 * @param {Object}
						 *            value: the value of specific key
						 * @return {String[]} return the column axis unique
						 *         members with specific type/level value
						 */
						getColumnAxisUniqueMembers : function(key, value) {
							return this
									._getAxisUniqueMembers(false, key, value);
						},

						/**
						 * 
						 * @param {Number}
						 *            level
						 * @return {uid, level, name, type}
						 */
						removeColumnAxis : function(level) {

							return this._removeAxis(false, level);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {uid, level, name, type}
						 */
						removeColumnAxisByUid : function(uid) {

							return this._removeAxisByUid(false, uid);
						},

						/**
						 * 
						 * @param {String}
						 *            name: The row axis name.
						 * @param {String[]}
						 *            members: The full list of row axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added row axis uid,
						 *         level is changing but uid is fixed.
						 */
						addRowAxis : function(name, members, type) {

							return this._addAxis(true, name, members, type);
						},

						/**
						 * 
						 * @param {Number}
						 *            level: The level to be added, if dataset
						 *            has the same level row axis, we insert the
						 *            new row before that level position.
						 * @param {String}
						 *            name: The row axis name.
						 * @param {String[]}
						 *            members: The full list of row axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added row axis uid,
						 *         level is changing but uid is fixed.
						 */
						addRowAxisAt : function(level, name, members, type) {

							return this._addAxisAt(true, level, name, members,
									type);
						},

						/**
						 * 
						 * @param {Object}
						 *            level
						 * @param {Object}
						 *            name
						 * @param {Object}
						 *            members
						 * @return {uid, level, name, type}
						 */
						modifyRowAxis : function(level, name, members, type) {

							return this._modifyAxis(true, level, name, members,
									type);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @param {String}
						 *            name
						 * @param {String[]}
						 *            members
						 * @param {String}
						 *            type
						 * @return {uid, level, name}
						 */
						modifyRowAxisByUid : function(uid, name, members, type) {

							return this._modifyAxisByUid(true, uid, name,
									members, type);
						},

						/**
						 * @return {Object[]} return [{uid, level, name, type},
						 *         ...]
						 */
						getRowAxesInfo : function() {

							return this._getAxesInfo(true);
						},

						/**
						 * @param {Number}
						 *            level
						 * @return {Object} return {uid, level, name, type}
						 */
						getRowAxisInfo : function(level) {

							return this._getAxisInfo(true, level);
						},

						/**
						 * @param {String}
						 *            uid
						 * @return {Object} return {uid, level, name, type}
						 */
						getRowAxisInfoByUid : function(uid) {

							return this._getAxisInfoByUid(true, uid);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {String[]} return the row axis members cloned
						 *         Array by level.
						 */
						getRowAxisMembersByUid : function(uid) {

							return this._getAxisMembersByUid(true, uid);
						},

						/**
						 * 
						 * @param {Object}
						 *            level
						 * @return {String[]} return the row axis members cloned
						 *         Array by level.
						 */
						getRowAxisMembers : function(level) {

							return this._getAxisMembers(true, level);
						},

						/**
						 * 
						 * @param {String}
						 *            key: AXIS_KEY_TYPE/AXIS_KEY_LEVEL
						 * @param {Object}
						 *            value: the value of specific key
						 * @return {String[]} return the row axis unique members
						 *         with specific type/level value
						 */
						getRowAxisUniqueMembers : function(key, value) {
							return this._getAxisUniqueMembers(true, key, value);
						},

						/**
						 * 
						 * @param {Number}
						 *            level
						 * @return {uid, level, name, type}
						 */
						removeRowAxis : function(level) {

							return this._removeAxis(true, level);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {uid, level, name, type}
						 */
						removeRowAxisByUid : function(uid) {

							return this._removeAxisByUid(true, uid);
						},

						/**
						 * 
						 * @param {Boolean}
						 *            byColumn: Data in column or row.
						 * @param {[[]]}
						 *            data: The dataset values in 2D array.
						 */
						setData : function(byColumn, data) {
							if (typeof (byColumn) != 'boolean' || !data)
								throw new Error("Invalid params!");
							if (!data.length)
								throw new Error("Invalid params!");
							this.metadata.dataByColumn = byColumn;
							this.origData = [];
							ObjectUtils.extend(true, this.origData, data);
							this._cleanData();

							this.markDirty();
						},

						/**
						 * 
						 * @param {Boolean}
						 *            byColumn: Data in column or row.
						 * @return {[[]]} return the dataset values in 2D array.
						 */
						getData : function(byColumn) {
							var targetDataset = [];
							if (byColumn == this.metadata.dataByColumn) {
								ObjectUtils.extend(true, targetDataset,
										this.data);
							} else {
								for ( var i = 0; i < this.data[0].length; i++) {
									targetDataset[i] = [];
									for ( var j = 0; j < this.data.length; j++)
										targetDataset[i][j] = this.data[j][i];
								}
							}

							return targetDataset;
						},

						getValue : function(colIdx, rowIdx) {
							if (this.metadata.dataByColumn) {
								return this.data[colIdx][rowIdx];
							} else {
								return this.data[rowIdx][colIdx];
							}

						},

						getColumnCount : function() {
							if (this.metadata.dataByColumn) {
								return this.data.length;
							} else {
								if (this.data.length > 0) {
									return this.data[0].length;
								} else {
									return 0;
								}
							}
						},

						getRowCount : function() {
							if (!this.metadata.dataByColumn) {
								return this.data.length;
							} else {
								if (this.data.length > 0) {
									return this.data[0].length;
								} else {
									return 0;
								}
							}
						},

						/**
						 * @ignore
						 * @return {Object} return the JSON object including all
						 *         the metadata and data.
						 */
						exportJsonStr : function() {

							function axisParser(isRow) {
								var axes = (isRow ? this.metadata.rowAxis
										: this.metadata.columnAxis);
								var title = (isRow ? "rowAxis" : "columnAxis");
								var json = [];

								json.push('"' + title + '":[');
								for ( var i = 0; i < axes.length; i++) {
									json.push('{"uid":"' + axes[i].uid
											+ '","level":' + axes[i].level
											+ ',"name":"' + axes[i].name
											+ '","members":[');
									for ( var j = 0; j < axes[i].members.length; j++) {
										json.push('"' + axes[i].members[j]
												+ '"');
										if (j != axes[i].members.length - 1)
											json.push(',');
									}
									json.push(']');
									json
											.push(',"type":"' + axes[i].type
													+ '"}');
									if (i != axes.length - 1)
										json.push(',');
								}
								json.push(']');
								if (!isRow)
									json.push(',');

								return json;
							}
							;

							function aggregationParser() {
								var json = [];
								json.push('"aggregation":[');

								for ( var i = 0; i < this.aggregation.length; i++) {
									if (TypeUtils
											.type(this.aggregation[i].label) == 'string') {
										json.push('{"label":"'
												+ this.aggregation[i].label
												+ '","rowDimension":[');
									} else {
										json.push('{"label":[');

										for ( var j = 0; j < this.aggregation[i].label.length; j++) {
											json
													.push('"'
															+ this.aggregation[i].label[j]
															+ '"');
											if (j != this.aggregation[i].label.length - 1)
												json.push(',');
										}
										json.push('],"rowDimension":[');
									}

									for ( var j = 0; j < this.aggregation[i].rowDimension.length; j++) {
										json
												.push('"'
														+ this.aggregation[i].rowDimension[j]
														+ '"');
										if (j != this.aggregation[i].rowDimension.length - 1)
											json.push(',');
									}
									json.push(']');
									json.push(',"value":[');

									for ( var t = 0; t < this.aggregation[i].value.length; t++) {
										json.push(this.aggregation[i].value[t]);
										if (t != this.aggregation[i].value.length - 1)
											json.push(',');
									}
									json.push('],');
									json.push('"type":"'
											+ this.aggregation[i].type + '"');
									json.push('}');

									if (i != this.aggregation.length - 1)
										json.push(',');
								}

								json.push(']');

								return json;
							}
							;

							var json = new Array();
							json.push('{');

							// convert metadata
							json.push('"metadata":{');
							json = json.concat(axisParser.call(this, false));
							json = json.concat(axisParser.call(this, true));
							json.push(',');
							json
									.push('"dataByColumn":'
											+ (typeof (this.metadata.dataByColumn) == 'boolean' ? this.metadata.dataByColumn
													: null));
							json.push('},');

							// convert data
							json.push('"data":[');
							for ( var i = 0; i < this.data.length; i++) {
								json.push('[');
								for ( var j = 0, jlen = this.data[i].length; j < jlen; j++) {
									var dt = this.data[i][j];
									if (dt == this.ERROR_CHAR) {
										json.push("null");
										// we want the result json can be parsed
										// successfully through JQuery.json
									} else {
										json.push(dt);
									}
									if (j != jlen - 1)
										json.push(',');
								}
								json.push(']');
								if (i != this.data.length - 1)
									json.push(',');
							}
							json.push('],');

							// convert aggregation
							json = json.concat(aggregationParser.call(this));

							json.push('}');

							return json.join('');
						},

						/**
						 * @ignore
						 * @param {Object}
						 *            The exported JSON object including all the
						 *            metadata and data.
						 * @return {void}
						 */
						importJsonStr : function(value) {
							if (typeof (value) != 'string')
								throw new Error("Invalid JSON string!");
							var newDS = ObjectUtils.parseJSON(value);
							if (!newDS.metadata)
								throw new Error(
										"JSON object does not contain metadata!");
							if (!newDS.data)
								throw new Error(
										"JSON object does not contain data!");
							ObjectUtils.extend(true, this.metadata,
									newDS.metadata);
							this.origData = [];
							ObjectUtils.extend(true, this.origData, newDS.data);
							this.aggregation = [];
							ObjectUtils.extend(true, this.aggregation,
									newDS.aggregation);
							this._cleanData();
							this.markDirty();
						},

						/**
						 * @ignore
						 * @return {Object} Clone the dataset.
						 */
						clone : function() {
							var copy = {};

							ObjectUtils.extend(true, copy, this);

							return copy;
						},

						/**
						 * 
						 * Clear all the metadata and data.
						 * 
						 * @return {void}
						 */
						empty : function() {
							this.metadata = {
								columnAxis : [],
								rowAxis : []
							};

							this.data = [];
							this.origData = [];
							this.aggregation = [];
						},

						/**
						 * @ignore
						 * register chart instance which use this dataset.
						 * 
						 * we won't keep chart reference in dataset, as dataset
						 * can be shared between charts, user can set chart
						 * instance to null to trigger memory GC
						 */
						registerChartInstance : function(chartId) {
							if (TypeUtils.isExist(chartId)) {
								var ci = this.chartInstances;
								if (!ci.hasOwnProperty(chartId)) {
									ci[chartId] = {
										dirtyDS : false
									};
									return true;
								} else {
									return true;
								}
							}
							throw new Error(
									"Failed to register chart instance in dataset!");
						},

						/**
						 * @ignore
						 * dataset has been changed
						 */
						markDirty : function() {
							// change needRedraw flag for all registered chart
							// instances
							var ci = this.chartInstances;
							for ( var id in ci) {
								if (ci.hasOwnProperty(id)) {
									ci[id].dirtyDS = true;
								}
							}
						},

						/**
						 * @ignore
						 */
						checkDirty : function(chartId) {
							var ci = this.chartInstances;
							if (TypeUtils.isExist(ci[chartId])) {
								var d = ci[chartId];
								if (d.dirtyDS) {
									d.dirtyDS = false;
									return true;
								} else {
									return false;
								}
							}
							throw new Error(
									"Failed to check dirty for the chart:"
											+ chartId + "!");
						},

						/**
						 * @ignore
						 * @param label
						 *            string of aggregation name
						 * @param value
						 *            array of aggregation value, the order
						 *            following measure
						 * @param rowDimension
						 *            (optional) array of dimension path for the
						 *            aggregation. If not set or set as empty
						 *            array, the aggregation will be treated as
						 *            global
						 */
						addAggregation : function(label, value, rowDimension) {
							// if (TypeUtils.type(label) != 'string'
							if (TypeUtils.isString(label)
									&& !(label instanceof Array)) {
								throw new Error("Invalid params!");
							} else if ('' == label) {
								return;
							}
							if (!TypeUtils.isExist(value)
									|| typeof (value) != 'object') {
								throw new Error("Invalid params!");
							}
							if (TypeUtils.isExist(rowDimension)) {
								if (typeof (rowDimension) != 'object') {
									throw new Error("Invalid params!");
								}
								if (rowDimension.length >= this
										.getRowAxesInfo().length) {
									return;
								}

								var valid = false;
								for ( var i = 0; i < this.getRowCount(); i++) {
									var matchNum = 0;
									for ( var j = 0; j < rowDimension.length; j++) {
										if (rowDimension[j] == this
												.getRowAxisMembers(j)[i]) {
											matchNum++;
										}
									}

									if (matchNum == rowDimension.length) {
										valid = true;
										break;
									}
								}
								if (!valid) {
									throw new Error("Invalid params!");
								}

							}

							var _label = label;
							var _value = value;
							var _rowDimension = TypeUtils.isExist(rowDimension) ? rowDimension
									: [];
							var _type = TypeUtils.isString(label) ? this.AGGREGATION_DEFAULTTYPE
									: this.AGGREGATION_INLINETYPE;
							_value.length = this.getColumnCount();

							this.aggregation.push({
								label : _label,
								value : _value,
								rowDimension : _rowDimension,
								type : _type
							});
						},

						/**
						 * @ignore
						 * @param rowDimension
						 *            (optional) array of dimension path for the
						 *            aggregation
						 * @return array of matched aggregation, some special
						 *         cases: if {rowDimension} is not set, all
						 *         aggregation will be returned if
						 *         {rowDimension} is set as empty array, all
						 *         global aggregation will be returned
						 */
						getAggregation : function(rowDimension) {
							if (!TypeUtils.isExist(rowDimension)) {
								return this.aggregation;
							}
							var ret = [];
							for ( var i = 0; i < this.aggregation.length; i++) {
								var unit = this.aggregation[i];
								if (rowDimension.length == 0
										&& unit.rowDimension.length == 0) {
									ret.push(unit);

								} else if (rowDimension.length > 0) {
									var matchNum = 0;
									for ( var j = 0; j < rowDimension.length; j++) {
										if (j >= unit.rowDimension.length
												|| unit.rowDimension[j] != rowDimension[j]) {
											matchNum = 0;
											break;
										}
										matchNum++;
									}
									if (matchNum == rowDimension.length) {
										ret.push(unit);
									}
								}

							}
							return ret;
						},

						/**
						 * @ignore
						 * @param rowDimension
						 *            (optional) array of dimension path for the
						 *            aggregation
						 * @return object
						 */
						modifyAggregation : function(level, label, value,
								rowDimension) {
							if (TypeUtils.isString(label)
									&& !(label instanceof Array)) {
								throw new Error("Invalid params!");
							} else if ('' == label) {
								return;
							}
							if (!TypeUtils.isExist(value)
									|| typeof (value) != 'object') {
								throw new Error("Invalid params!");
							}
							if (TypeUtils.isExist(rowDimension)) {
								if (typeof (rowDimension) != 'object') {
									throw new Error("Invalid params!");
								}
								if (rowDimension.length >= this
										.getRowAxesInfo().length) {
									return;
								}

								var valid = false;
								for ( var i = 0; i < this.getRowCount(); i++) {
									var matchNum = 0;
									for ( var j = 0; j < rowDimension.length; j++) {
										if (rowDimension[j] == this
												.getRowAxisMembers(j)[i]) {
											matchNum++;
										}
									}

									if (matchNum == rowDimension.length) {
										valid = true;
										break;
									}
								}
								if (!valid) {
									throw new Error("Invalid params!");
								}

							}

							var type = TypeUtils.isString(label) ? this.AGGREGATION_DEFAULTTYPE
									: this.AGGREGATION_INLINETYPE;

							this.aggregation[level].label = label;
							this.aggregation[level].value = value;
							this.aggregation[level].rowDimension = [];

							ObjectUtils.extend(true,
									this.aggregation[level].rowDimension,
									rowDimension);

							this.markDirty();

							return {
								level : level,
								label : label,
								value : value,
								rowDimension : rowDimension,
								type : type
							};
						},
						
						/**
						 * @ignore
						 */
						exportTree : function() {
							var measureMembers = this
									.getColumnAxisUniqueMembers(
											this.AXIS_KEY_TYPE,
											this.AXIS_TYPE_MEASURE);
							// [jyang, 3/14/2012]we require that the first
							// member of column axis is measure
							var measureLabels = this.getColumnAxisMembers(0);
							// [jyang, 3/14/2012]now we support unlimited
							// measure member and one dimension member in column
							// axis
							var columnAxis = this.metadata.columnAxis;
							var rowDimensions = this.metadata.rowAxis;
							var columnDimensions = columnAxis.slice(1);
							var axisNum = 0;
							// [jyang, 3/14/2012] the default path of dimension
							// is rowaxis -> columnaxis
							var dimensionNames = [];
							for ( var j = 0; j < rowDimensions.length; j++) {
								dimensionNames.push({
									'name' : rowDimensions[j].name,
									'analysisAxisIndex' : 0
								});
							}
							if (rowDimensions.length > 0) {
								// we have dimension in row axis
								axisNum++;
							}
							for ( var j = 0; j < columnDimensions.length; j++) {
								dimensionNames.push({
									'name' : columnDimensions[j].name,
									'analysisAxisIndex' : 1
								});
							}
							if (columnDimensions.length > 0) {
								// we have dimension in row axis
								axisNum++;
							}
							var setValue = function(parent, path, depth,
									measureMember, measureIndex, value) {
								var pathObj = path[depth];
								var current = null;
								for ( var i = 0; i < parent.subNodes.length; i++) {
									if (pathObj.name === parent.subNodes[i].label) {
										current = parent.subNodes[i];
										break;
									}
								}

								if (current == null) {
									current = {};
									current.member = i;
									current.label = pathObj.name;
									current.measureValues = {};
									current.subNodes = [];
									for ( var i = 0; i < measureMembers.length; i++) {
										// [jyang 3/15/2012] if we have
										// aggregation info, we can
										// add measure values for each level
										current.measureValues[measureMembers[i]] = {};
									}
									parent.subNodes.push(current);
								}

								if (depth == path.length - 1) {
									// [jyang 3/15/2012] if we have aggregation
									// info, we can
									// add measure values for each level
									var dimensionPath = [];
									for ( var i = 0, len = path.length; i < len; i++) {
										var p = path[i];
										dimensionPath
												.push({
													'analysisAxisIndex' : p.analysisAxisIndex,
													'dimensionIndex' : p.dimensionIndex,
													'dimensionItemIndex' : p.dimensionItemIndex
												});
									}
									// FIXME JYANG 3/15/2012 we may duplicate
									// too much data if we have too many
									// measures.
									// it's better if tree can have metadata
									// also for node.
									// and we can use less characters to save
									// memory?
									current.measureValues[measureMember] = {
										'sum' : {
											result : value,
											tags : {
												'dimensionPath' : dimensionPath,
												// [jyang 3/15/2012]be noted
												// that measureIndex doesn't
												// mean the unique
												// index of measure members,
												// clients can use this index to
												// fetch measure
												// member in the crosstable
												// dataset columnaxis measure.
												'measureIndex' : measureIndex
											}
										}
									};
								} else {
									setValue(current, path, depth + 1,
											measureMember, measureIndex, value);
								}
							};

							var columnPath = [];
							for ( var i = 0, len = this.getColumnCount(); i < len; i++) {
								columnPath[i] = [];
								for ( var j = 0; j < columnDimensions.length; j++) {
									var pathObj = {
										'name' : columnDimensions[j].members[i],
										'analysisAxisIndex' : 1,
										'dimensionIndex' : j,
										// [jyang, 3/15/2012] note the
										// dimensionItemIndex doesn't
										// mean the index in the unique members
										// array. it's the index
										// in the crosstable. clients can use it
										// to fetch dimensionItem
										// in crosstabledataset
										'dimensionItemIndex' : i
									};
									columnPath[i].push(pathObj);
								}
							}

							var rowPath = [];
							for ( var i = 0, len = this.getRowCount(); i < len; i++) {
								rowPath[i] = [];
								for ( var j = 0; j < rowDimensions.length; j++) {
									var pathObj = {
										'name' : rowDimensions[j].members[i],
										'analysisAxisIndex' : 0,
										'dimensionIndex' : j,
										'dimensionItemIndex' : i
									};
									rowPath[i].push(pathObj);
								}
							}

							var root = {};
							root.member = "root";
							root.measureValues = {};
							root.subNodes = [];
							// TODO jyang 3.15.2012 we can add aggreation for
							// each node level
							// currently we only have data for the last level
							for ( var i = 0; i < measureMembers.length; i++) {
								root.measureValues[measureMembers[i]] = {};
							}
							// jyang 3/15/2012 we need dimensionAxisIndex,
							// dimensionIndex, dimensionItemIndex and
							// measureIndex
							// to composite a path in datacontext
							for ( var i = 0, len = this.getColumnCount(); i < len; i++) {
								for ( var j = 0, jlen = this.getRowCount(); j < jlen; j++) {
									var data = this.getValue(i, j);
									var path = rowPath[j].concat(columnPath[i]);
									var measureMember = measureLabels[i];
									// function(parent, path, depth,
									// measureMember, value)
									setValue(root, path, 0, measureMember, i,
											data);
								}
							}

							var result = {
								dataTree : JSON.stringify(root),
								metaData : {
									// FIXME JYANG 3/15/2012 what if we have
									// different measure members for different
									// dimension?
									measureMembers : measureMembers,
									// TODO JYANG 3/15/2012 change the name to
									// dimensions
									dimension : dimensionNames,
									axisNum : axisNum
								}
							};
							return result;

						}

					});

	return crossTableDataset;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.dataConverter.SimpleDMDataset',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.dataConverter.BaseDataset',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, BaseDataset, fnUtils) {
	var undefined = void (0);
	var SimpleDMDataset = ObjUtils.derive(BaseDataset,
	/**
	 * @lends sap.riv.viz.shared.dataConverter.SimpleDMDataset.prototype
	 */
	{
		/**
		 * SimpleDMDataset contains only one dimension and several measures
		 * 
		 * @constructs
		 */
		constructor : function() {
			this._measureNames = [ '' ];
			this._dimensionLabels = [];
			this._dimensionName = [ '' ];
			this._data = null;
			this._inValidData = null;
			this.ERROR_CHAR = "NaN";
		},

		/**
		 * get or set measure names of SimpleDMDataset
		 * 
		 * @param {StringArray}names
		 *            measure names to be set. empty parameter means get current
		 *            measure names
		 * @returns {this|Array}
		 */
		measureNames : function(names) {
			if (arguments.length == 1) {
				if (TypeUtils.isExist(arguments[0])) {
					this._measureNames = names;
					return this;
				} else {
					fnUtils.error("Measure Name doesn't exist");
				}
			}
			return this._measureNames;
		},

		/**
		 * get or set dimension labels of SimpleDMDataset
		 * 
		 * @param {StringArray}dmLabels
		 *            dimension labels to be set. empty parameter means get
		 *            current dimension labels
		 * @returns {this|Array}
		 */
		dimensionLabels : function(dmLabels) {
			if (arguments.length == 1) {
				if (TypeUtils.isExist(arguments[0])) {
					this._dimensionLabels = dmLabels;
					return this;
				} else {
					throw "Dimension Label isn't exist";
				}
			}
			return this._dimensionLabels;
		},
		
		/**
		 * get or set dimension name of SimpleDMDataset
		 * 
		 * @param {String}dmName
		 *            dimension name to be set. empty parameter means get
		 *            current dimension name
		 * @returns {this|String}
		 */
		dimensionName : function(dmName) {
			if (arguments.length == 1) {
				if (TypeUtils.isExist(arguments[0])) {
					this._dimensionName = dmName;
					return this;
				} else {
					throw "Dimension Name isn't exist";
				}
			}
			return this._dimensionName;
		},
		
		/**
		 * get or set data of SimpleDMDataset
		 * 
		 * @param {[[]]} data
		 *            data to be set. empty parameter means get
		 *            current data. 
		 * @returns {this|Array}
		 */
		data : function(data) {
			if (arguments.length > 0) {
				if ((TypeUtils.isExist(data)) && (TypeUtils.isExist(data.length))) {
					this._data = data;
				} else {
					throw "Data is invalid.";
				}
			}
			return this._data;
		},
		
		/**
		 * @ignore
		 * 
		 */
		exportTree : function() {
			var root = {};

			root.member = "root";
			root.measureValues = {};
			root.subNodes = [];

			this._cleanData();

			for ( var i = 0, len = this._measureNames.length; i < len; i++) {
				root.measureValues[this._measureNames[i]] = {};
			}

			for ( var i = 0, ilen = this._dimensionLabels.length; i < ilen; i++) {
				root.subNodes[i] = {
					member : i,
					label : TypeUtils.isExist(this._dimensionLabels[i]) ? this._dimensionLabels[i] : '',
					subNodes : [],
					measureValues : {}
				};

				for ( var j = 0, jlen = this._measureNames.length; j < jlen; j++) {
					var value;
					if ((this._inValidData[j] !== undefined) && (this._inValidData[j][i] !== undefined)
							&& (this._inValidData[j][i] === this.ERROR_CHAR)) {
						value = this.ERROR_CHAR;
					} else {
						value = this._data[j][i];
					}

					root.subNodes[i].measureValues[this._measureNames[j]] = {
						sum : {
							result : value, // this._data[j][i]
							tags : {
								// [jyang, 20/3/2012] we make it consistent with
								// hierarchy dataset
								'dimensionPath' : [ {
									'analysisAxisIndex' : 0,
									'dimensionIndex' : 0,
									'dimensionItemIndex' : i
								} ],
								measureIndex : j
							}
						}
					};

				}
			}

			var result = {
				dataTree : JSON.stringify(root),
				metaData : {
					measureMembers : this._measureNames,
					dimension : [ {
						'name' : this._dimensionName,
						'analysisAxisIndex' : 0
					} ],
					axisNum : 1
				}
			};

			return result;
		},

		/**
		 * @ignore
		 */
		_cleanData : function() {
			var data = this._data;
			this._inValidData = [];
			var noDimensionFlag = false;

			var _col = this._measureNames.length;
			var _row = this._dimensionLabels.length;
			if (_row === 0) {
				// [Christy.Fei|2012/3/9]No dimension labels
				noDimensionFlag = true;
			} else {
				var maxDataLength = 0;
				var labelTmp = '';
				for ( var i = 0; i < data.length; i++) {
					if ((TypeUtils.isExist(data[i])) && (TypeUtils.isExist(data[i].length))
							&& (data[i].length > maxDataLength)) {
						maxDataLength = data[i].length;
					}
				}
				if (maxDataLength < _row) {
					// [Christy.Fei|2012/3/9]More Dimension Name, less data
					for ( var i = maxDataLength; i < _row; i++) {
						// [Christy.Fei|2012/3/9]If have more dimension labels,
						// remove the redundance dimension labels.
						labelTmp = this._dimensionLabels.pop();
					}
					_row = this._dimensionLabels.length;
					if (_row === 0) {
						// [Christy.Fei|2012/3/9]If no data, but have dimension
						// label. Save the first dimension labels and draw it in
						// legend.
						this._dimensionLabels.push(labelTmp);
					}
				}
			}
			if (!TypeUtils.isExist(data))
				data = this._data = [];
			for ( var i = 0; i < _col; i++) {
				if (!TypeUtils.isExist(data[i]))
					data[i] = [];
				for ( var j = 0; j < _row || j < data[i].length; j++) {
					if (noDimensionFlag) {
						this._dimensionLabels.push(j + 1);
					} else {
						if (!(j < _row)) {
							this._dimensionLabels.push('');
						}
					}
					_row = this._dimensionLabels.length;
					if (!TypeUtils.isExist(data[i][j])) {
						this._inValidData[i] = this._inValidData[i] || [];
						this._inValidData[i][j] = this.ERROR_CHAR;
					} else {
						// verify is number data
						if (!TypeUtils.isNumber(data[i][j])) {
							var r = /(^-?\d+$)|(^(-?\d+)(\.\d+)?$)/;
							if (!r.test(data[i][j])) {
								this._inValidData[i] = this._inValidData[i] || [];
								this._inValidData[i][j] = this.ERROR_CHAR;
							}
						}
					}
				}
				noDimensionFlag = false;
			}
		}
	});
	return SimpleDMDataset;
});sap.riv.module(
{
  qname : 'sap.riv.viz.Environment',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(TypeUtils, LOG) {
    var _locale = 'en_US';

    var _setLocale = function(_loc) {
        if(TypeUtils.isExist(_loc)) {
            _locale = _loc;
            sap.common.globalization.NumericFormatManager.setPVL(_loc);
        }
    };
    var _setLogLevel = function(_level) {
        if(TypeUtils.isExist(_level)) {
            LOG.setLevel(_level);
        }
    };
    var _initLogger = function(options) {
        if(!options)
            return;
        if(options.enable)
            LOG.enable();
        if(!options.appenders)
            return;
        for(var i = 0, l = options.appenders.length; i < l; i++) {
            var appender = options.appenders[i];
            if(appender.appenderKey)
                LOG.addAppender(appender.appenderKey, appender.appender);
            else
                LOG.addAppender(appender.appender);
        }
        // LOG.addAppender('analyzerAppender', new AnalyzerAppender());
        // LOG.addAppender("ajaxApp", new LOG.AjaxAppender("http://localhost:8800"));
        // LOG.getAppender("ajaxApp").setLevel(LOG.LEVEL.DEBUG);
        //LOG.getAppender("[default]").setLevel(_level);
    };
    var env =
    /**
     * @lends sap.riv.viz.Environment
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * initialize visualization environment
         * @param {Object}
         *            option {locale:'en_US'}
         *
         */
        initialize : function(option) {
            _setLocale(option.locale);
            _initLogger(option.log);
            // _setLogLevel(option.log);
        },
        
        /**
         * set locale of visualization environment
         * @param locale locale string
         */
        setLocale : function(locale) {
            _setLocale(locale);
        },
        
        /**
         * get current locale string
         * @returns {String}
         */
        getLocale : function() {
            return _locale;
        },
        
        /**
         * @ignore
         * @param enable
         */
        setLoggerEnable : function(enable) {
            if(enable === true)
                LOG.enable();
            else if(enable === false)
                LOG.disable();
        },
        
        /**
         * @ignore
         * @returns
         */
        addLogAppender : function() {
            if(arguments.length === 1)
                return LOG.addAppender(arguments[0]);
            else if(arguments.length === 2)
                return LOG.addAppender(arguments[0], arguments[1]);
        },
        
        /**
         * @ignore
         * @param key
         * @returns
         */
        removeLogAppender : function(key) {
            return LOG.removeAppender(key);
        },
    };

    return env;
});sap.riv.module(
{
  qname : 'sap.riv.viz.BarChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var BarChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.BarChart.prototype
	 */
	{
		/**
		 * class for clients to create Bar Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'bar';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'bar';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return BarChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.CombinationChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var ComChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.CombinationChart.prototype
	 */
	{
		/**
		 * class for clients to create Combination Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'combination';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return ComChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.PieChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractPieChart, LOG) {

    var pieChart = ObjUtils.derive(AbstractPieChart,
    /**
     * @lends sap.riv.viz.PieChart.prototype
     */
    {
        /**
         * @constructs
         * @augments sap.riv.viz.AbstractPieChart
         * @param holderElement
         *            a div container returned from jQuery selection.
         * @param properties
         *            a json object for chart properties. refer to properties
         *            doc for details
         * @param dataset
         *            one of supported sap.riv.viz.shared.dataConverter
         */
        constructor : function(holderElement, properties, dataset) {
        	var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'pie';
            LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
            this._viz = new VizApplication({
                id : "PieApplication",
                wrapperDivEl : holderElement,
                delegateClass : AppDelegate,
                launchOption : {
                    option : props,
                    data : {
                        rawData : dataset
                    }
                }
            });
            LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
        },
    });

    return pieChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.LineChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var LineChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.LineChart.prototype
	 */
	{
		/**
		 * class for clients to create Line Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'line';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return LineChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.ColumnChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var ColChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.ColumnChart.prototype
	 */
	{
		/**
		 * class for clients to create Column Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'bar';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return ColChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.Visualization',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.PieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.MultiPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.BarChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.LineChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.ColumnChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.CombinationChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, AbstractVisualization, PieChart, MultiPieChart, BarChart, LineChart, ColumnChart,
		CombinationChart, fnUtils) {
	var Visualization = ObjectUtils.derive(AbstractVisualization,
	/**
	 * @lends sap.riv.viz.Visualization.prototype
	 */
	{
		/**
		 * a generic API which can be used to create a certain viz
		 * 
		 * @constructs
		 * @augments sap.riv.viz.AbstractVisualization
		 * 
		 * @param typeString
		 *            currently we support 'riv/pie', 'riv/multipie', 'riv/bar',
		 *            'riv/column', 'riv/line', 'riv/combination'
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(typeString, holderElement, properties, dataset) {
			switch (typeString) {
			case 'riv/pie':
				this._viz = new PieChart(holderElement, properties, dataset);
				break;
			case 'riv/multipie':
				this._viz = new MultiPieChart(holderElement, properties, dataset);
				break;
			case 'riv/bar':
				this._viz = new BarChart(holderElement, properties, dataset);
				break;
			case 'riv/column':
				this._viz = new ColumnChart(holderElement, properties, dataset);
				break;
			case 'riv/line':
				this._viz = new LineChart(holderElement, properties, dataset);
				break;
			case 'riv/combination':
				this._viz = new CombinationChart(holderElement, properties, dataset);
				break;
			default:
				fnUtils.error('Unsupported chart type');
				break;
			}
		}
	});

	return Visualization;
});sap.riv.module(
{
  qname : 'sap.riv.viz.PieChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractPieChart, LOG) {

    var pieChart = ObjUtils.derive(AbstractPieChart,
    /**
     * @lends sap.riv.viz.PieChart.prototype
     */
    {
        /**
         * @constructs
         * @augments sap.riv.viz.AbstractPieChart
         * @param holderElement
         *            a div container returned from jQuery selection.
         * @param properties
         *            a json object for chart properties. refer to properties
         *            doc for details
         * @param dataset
         *            one of supported sap.riv.viz.shared.dataConverter
         */
        constructor : function(holderElement, properties, dataset) {
        	var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'pie';
            LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
            this._viz = new VizApplication({
                id : "PieApplication",
                wrapperDivEl : holderElement,
                delegateClass : AppDelegate,
                launchOption : {
                    option : props,
                    data : {
                        rawData : dataset
                    }
                }
            });
            LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
        },
    });

    return pieChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.LineChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var LineChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.LineChart.prototype
	 */
	{
		/**
		 * class for clients to create Line Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'line';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return LineChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.ColumnChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var ColChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.ColumnChart.prototype
	 */
	{
		/**
		 * class for clients to create Column Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'bar';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return ColChart;
});
}; // end of sap.service.visualization.chart.ChartSourceCode.libs.saprivmodules
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.ChartSourceCode.libs.saprivthemes') ) {
  jQuery.sap.declare('sap.service.visualization.chart.ChartSourceCode.libs.saprivthemes');
sap.riv.require(
[
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function InstallTheme(ThemeManager) {
	var props = {
		background : '#FFF',
		textFontFamily : 'Arial, Helvetica, sans-serif',
		global : {
			'font-family' : 'Arial, Helvetica', // Must
			'font-weight' : 'bold', // Must
			'color' : '#616161', // Must
		},
		legend : {
			title : {
				'font-size' : '14px',
				'font-weight' : 'bold',
			},
			label : {
				'font-size' : '12px',
			}
		},
		title : {
			mainTitle : {
				'font-size' : '16px',
				'color' : '#2B2B2B'
			},
			subTitle : {
				'font-size' : '14px',
				'color' : '#616161'
			}
		},
		pie : {
			isShowOuterShadow : true,
			isShowInnerShadow : true,
			donut : {
				measureLabel : {
					'font-size' : '12px'
				},
			// background : 'red'
			},
			tooltip : {
				valueLabel : {
					'font-size' : '12px',
					'font-weight' : 'bold',
				// 'color': '#000'
				},
				dimensionLabel : {
					'font-size' : '12px',
					'font-weight' : 'normal',
				},
				percentLabel : {
					'font-size' : '12px',
					'font-weight' : 'normal',
				}
			}
		},
		bar : {
			isShowInnerBorder : true,
			isShowOutBorder : true,
			isShowGradient : true,
			isShowShadow : true
		},
		line : {
			marker : {
				'size' : '8',
				isShowShadow : true
			},
			line : {
				'size' : '3',
				isShowShadow : true
			}
		},
		axis : {
			label : {
				'font-size' : '11px',
				'color' : '#616161'
			},
			title : {
				'font-size' : '13px',
				'color' : '#616161'
			},
			xAxisMajorGridLine : {
				color : '#B8B8B8',
				thickness : '1'
			},
			xAxisMinorGridLine : {
				color : '#B8B8B8',
				thickness : '1'
			},
			xAxisSubGridLine : {
				color : '#B8B8B8'
			},
			yAxisMajorGridLine : {
				color : '#B8B8B8',
				thickness : '1'
			},
			yAxisMinorGridLine : {
				color : '#B8B8B8',
				thickness : '1'
			},
			yAxisSubGridLine : {
				color : '#B8B8B8'
			},
			lineColor : '#676767'
		}
	};
	ThemeManager.installTheme('classic-day', props);
});sap.riv.require(
[
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function InstallTheme(ThemeManager) {
	var props = {
		background : '#202020',
		textFontFamily : 'Arial, Helvetica, sans-serif',
		global : {
			'font-family' : 'Arial, Helvetica',
			'font-weight' : 'bold',
			'color' : 'c0c0c0'
		},
		legend : {
			title : {
				'font-size' : '14px',
				'color' : '#e5e5e5'
			},
			label : {
				'font-size' : '12px',
				'color' : '#e5e5e5'
			}
		},
		title : {
			mainTitle : {
				'font-size' : '16px',
				'color' : '#dbdbdb'
			},
			subTitle : {
				'font-size' : '14px',
				'color' : '#c0c0c0'
			}
		},
		pie : {
			isShowOuterShadow : true,
			isShowInnerShadow : true,
			donut : {
				measureLabel : {
					'font-size' : '16px',
					'color' : '#616161'
				},
				background : '#FFF'
			},
			tooltip : {
				valueLabel : {
					'font-size' : '12px',
					'color' : '#616161',
					'font-weight' : 'bold',
				},
				dimensionLabel : {
					'font-size' : '12px',
					'color' : '#616161',
					'font-weight' : 'normal',
				},
				percentLabel : {
					'font-size' : '12px',
					'color' : '#616161',
					'font-weight' : 'normal',
				}
			}
		},
		bar : {
			isShowInnerBorder : true,
			isShowOutBorder : false,
			isShowGradient : true,
			isShowShadow : false
		},
		line : {
			marker : {
				'size' : '8',
				isShowShadow : true
			},
			line : {
				'size' : '3',
				isShowShadow : true
			}
		},
		axis : {
			label : {
				'font-size' : '11px',
				'color' : '#c0c0c0'
			},
			title : {
				'font-size' : '13px',
				'color' : '#c0c0c0'
			},
			xAxisMajorGridLine : {
				color : '#333333',
				thickness : '1'
			},
			xAxisMinorGridLine : {
				color : '#333333',
				thickness : '1'
			},
			xAxisSubGridLine : {
				color : '#333333'
			},
			yAxisMajorGridLine : {
				color : '#333333',
				thickness : '1'
			},
			yAxisMinorGridLine : {
				color : '#333333',
				thickness : '1'
			},
			yAxisSubGridLine : {
				color : '#333333'
			},
			lineColor : '#676767'
		}
	};
	ThemeManager.installTheme('classic-night', props);
});
}; // end of sap.service.visualization.chart.ChartSourceCode.libs.saprivthemes
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.ColumnRenderer') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */
jQuery.sap.declare("sap.service.visualization.chart.ColumnRenderer");

/**
 * @class Column renderer. 
 * @static
 */
sap.service.visualization.chart.ColumnRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRenderManager the RenderManager that can be used for writing to the Render-Output-Buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
		
 */
sap.service.visualization.chart.ColumnRenderer.render = function(oRenderManager, oControl){ 
    // convenience variable
	var rm = oRenderManager;
	
	// write the HTML into the render manager  
    rm.write("<DIV");
    rm.writeControlData(oControl);
    
    rm.writeAttribute("class","sapservicevisualizationchart-Column"); 
    
    rm.addStyle("width", oControl.getWidth());
	rm.addStyle("height", oControl.getHeight());
	rm.addStyle("position","relative");
	//rm.addStyle("left","0px");
	//rm.addStyle("top","0px");
	rm.writeStyles();
	
    rm.write(">"); 
    rm.write("</DIV>");
};

}; // end of sap.service.visualization.chart.ColumnRenderer
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.CombinationRenderer') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */
jQuery.sap.declare("sap.service.visualization.chart.CombinationRenderer");

/**
 * @class Combination renderer. 
 * @static
 */
sap.service.visualization.chart.CombinationRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRenderManager the RenderManager that can be used for writing to the Render-Output-Buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
 */
sap.service.visualization.chart.CombinationRenderer.render = function(oRenderManager, oControl){ 
    // convenience variable
		var rm = oRenderManager;
	
	// write the HTML into the render manager  
    rm.write("<DIV");
    rm.writeControlData(oControl);
    
    rm.writeAttribute("class","sapservicevisualizationchart-Combination"); 
    
    rm.addStyle("width", oControl.getWidth());
	rm.addStyle("height", oControl.getHeight());
	rm.addStyle("position","relative");
	//rm.addStyle("left","0px");
	//rm.addStyle("top","0px");
	rm.writeStyles();
	
    rm.write(">"); 
    rm.write("</DIV>");
};

}; // end of sap.service.visualization.chart.CombinationRenderer
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.LineRenderer') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */
jQuery.sap.declare("sap.service.visualization.chart.LineRenderer");

/**
 * @class Line renderer. 
 * @static
 */
sap.service.visualization.chart.LineRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRenderManager the RenderManager that can be used for writing to the Render-Output-Buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
 */
sap.service.visualization.chart.LineRenderer.render = function(oRenderManager, oControl){ 
    // convenience variable
	var rm = oRenderManager;
	
	// write the HTML into the render manager  
    rm.write("<DIV");
    rm.writeControlData(oControl);
    
    rm.writeAttribute("class","sapservicevisualizationchart-Line"); 
    
    rm.addStyle("width", oControl.getWidth());
	rm.addStyle("height", oControl.getHeight());
	rm.addStyle("position","relative");
	//rm.addStyle("left","0px");
	//rm.addStyle("top","0px");
	rm.writeStyles();
	
    rm.write(">"); 
    rm.write("</DIV>");
};

}; // end of sap.service.visualization.chart.LineRenderer
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.PieRenderer') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */
jQuery.sap.declare("sap.service.visualization.chart.PieRenderer");

/**
 * @class Pie renderer. 
 * @static
 */
sap.service.visualization.chart.PieRenderer = {
};


/**
 * Renders the HTML for the given control, using the provided {@link sap.ui.core.RenderManager}.
 * 
 * @param {sap.ui.core.RenderManager} oRenderManager the RenderManager that can be used for writing to the Render-Output-Buffer
 * @param {sap.ui.core.Control} oControl an object representation of the control that should be rendered
 */
sap.service.visualization.chart.PieRenderer.render = function(oRenderManager, oControl){ 
    // convenience variable
	var rm = oRenderManager;
	
	// write the HTML into the render manager  
    rm.write("<DIV");
    rm.writeControlData(oControl);
    
    rm.writeAttribute("class","sapservicevisualizationchart-Pie"); 
    
    rm.addStyle("width", oControl.getWidth());
	rm.addStyle("height", oControl.getHeight());
	rm.addStyle("position","relative");
	//rm.addStyle("left","0px");
	//rm.addStyle("top","0px");
	rm.writeStyles();
	
    rm.write(">"); 
    rm.write("</DIV>");
};

}; // end of sap.service.visualization.chart.PieRenderer
if ( !jQuery.sap.isDeclared('sap.service.visualization.library') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* -----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying
 * source files only (*.type, *.js) or they will be lost after the next generation.
 * ----------------------------------------------------------------------------------- */

/**
 * Initialization Code and shared classes of library sap.service.visualization (1.11.0)
 */
jQuery.sap.declare("sap.service.visualization.library");
jQuery.sap.require('sap.ui.core.Core'); // unlisted dependency retained

/**
 * this lib contains pie bar line and combination charts
 *
 * @namespace
 * @name sap.service.visualization
 * @public
 */


// library dependencies
jQuery.sap.require('sap.ui.core.library'); // unlisted dependency retained


// delegate further initialization of this library to the Core
sap.ui.getCore().initLibrary({
  name : "sap.service.visualization",
  dependencies : ["sap.ui.core"],
  types: [],
  interfaces: [],
  controls: [
    "sap.service.visualization.chart.Bar",
    "sap.service.visualization.chart.Column",
    "sap.service.visualization.chart.Combination",
    "sap.service.visualization.chart.Line",
    "sap.service.visualization.chart.Pie"
  ],
  elements: [
    "sap.service.visualization.ChartOption",
    "sap.service.visualization.Themings",
    "sap.service.visualization.dataset.SimpleDMDataset"
  ],
  version: "1.11.0"});


}; // end of sap.service.visualization.library
if ( !jQuery.sap.isDeclared('sap.service.visualization.ChartOption') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.ChartOption.
jQuery.sap.declare("sap.service.visualization.ChartOption");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained


/**
 * Constructor for a new ChartOption.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * parse all the ChartOptions for charts.
 * @extends sap.ui.core.Element
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.ChartOption
 */
sap.ui.core.Element.extend("sap.service.visualization.ChartOption", { metadata : {

	// ---- object ----
	deprecated : true,

	// ---- control specific ----
	library : "sap.service.visualization"
}});


/**
 * Creates a new subclass of class sap.service.visualization.ChartOption with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.ChartOption.extend
 * @function
 */


// Start of sap/service/visualization/ChartOption.js
/*!
 * @copyright@
 */
sap.service.visualization.ChartOption.prototype.getXYChartOption = function(control, chartType){
	
	var legendDirection = control.getLegendDirection();
	var legendVerticalOffset = control.getLegendVerticalOffset();
	var legendHorizontalOffset = control.getLegendHorizontalOffset();
	var legendFirst = control.getLegendFirst();
	var showLegend = control.getShowLegend();
	var measures = control.getMeasures();
	var title = control.getTitle();
	var titleHorizontalAlign = control.getTitleHorizontalAlign();
	var subTitle = control.getSubTitle();
	var subTitleHorizontalAlign = control.getSubTitleHorizontalAlign();
	var showTitle = control.getShowTitle();
	var legendFormatString = control.getLegendFormatString();
	var titleFormatString = control.getTitleFormatString();
	var subTitleFormatString = control.getSubTitleFormatString();
	var yAxis = control.getYAxis();
	var xAxis = control.getXAxis();
	//enable selection for xy 
	var deselectEnabled = control.getDeselectEnabled();
 	var defaultSelectedItems = control.getDefaultSelectedItems();
 	var selectionMode = control.getSelectionMode();
	 	
	var lineMarkerAndThickness;
	var barMarker;
	
//	if(measure==null){
//		measure=undefined;
//	}
//	if(measures==null){
//		measures=undefined;
//	}
	switch(chartType){
	 case 'Bar': control.bar=null;
	 	 barMarker = control.getBarMarker();
	 	 if(barMarker==null){
	 		 barMarker=undefined;
	 	 };
	 break;
	 case 'Line': control.line=null;
	 	 lineMarkerAndThickness = control.getLineMarkerAndThickness();
	 	 if(lineMarkerAndThickness==null){
	 		 lineMarkerAndThickness=undefined;
	 	 };
	 break;
	 case 'Column': control.column=null;
	 	 barMarker = control.getBarMarker();
	 	 if(barMarker==null){
	 		 barMarker=undefined;
	 	 };
	 break;  
	 case 'Combination': control.combination=null;
	 	 lineMarkerAndThickness = control.getLineMarkerAndThickness();
	 	 
	 	 barMarker = control.getBarMarker();
	 	  if(barMarker==null){
	 		 barMarker=undefined;
	 	 };
	 	 if(lineMarkerAndThickness==null){
	 	 	lineMarkerAndThickness=undefined;
	 	 }
	 break;
	}
	


	
	
	//integrate themes and props
    var themes = new sap.service.visualization.Themings().getCorrespondingThemings(chartType);

	var isNumber = function(value) {
		var patt = /^(0|-?[1-9]\d*)$|^(0|-?[1-9]\d*)\.(\d+)$/;
		return patt.exec(value);
	};
	var chartPadding = themes.chartPadding;
	//lay out
	var layoutObj = {};
	layoutObj.legendFirst= legendFirst;
	layoutObj.chartPadding = chartPadding;
	//bg color
	var backgroundObj = {};
	backgroundObj.color = themes.bgColor;
	// legend properties
	var legendObj = {};
	legendObj.visible = showLegend;
	legendObj.position = legendDirection;
	legendObj.verticalOffset = legendVerticalOffset;
	legendObj.horizontalOffset = legendHorizontalOffset;
	legendObj.formatString = legendFormatString;
	var legendTitleFont = themes.legendTitleFont;
	legendObj.titleFont = legendTitleFont;
	legendObj.titleColor = themes.legendTitleFontColor;
	var legendFont = themes.legendFont;
	legendObj.labelFont = legendFont;
	legendObj.labelColor = themes.legendColor;

	// main title
	var mainTitle = {};
	mainTitle.text = title;
	mainTitle.visible = showTitle;
	mainTitle.font =  themes.mainTitleFont;
	mainTitle.color = themes.mainTitleColor;
	mainTitle.horizontalAlign = titleHorizontalAlign;
	mainTitle.formatString = titleFormatString;
	
	// sub title properties
	var subTitleObj = {};
	subTitleObj.text = subTitle;
	subTitleObj.visible = showTitle;
	subTitleObj.font = themes.subTitleFont;
	subTitleObj.color = themes.subTitleColor;
	subTitleObj.horizontalAlign = subTitleHorizontalAlign;
	subTitleObj.formatString = subTitleFormatString;
	
	//title properties
	var titleObj = {};
	titleObj.main=mainTitle;
	titleObj.sub=subTitleObj;

	// tool tip themes
	var toolTipObj = {};
	toolTipObj.mainValue={};
	toolTipObj.mainValue.font = themes.toolTipMainValueFont;
	toolTipObj.mainValue.color = themes.toolTipMainValueColor;
	//toolTipObj.mainValue.formatString = tooltipFormatString;
	toolTipObj.subValue={};
	toolTipObj.subValue.font = themes.toolTipSubValueFont;
	toolTipObj.subValue.color = themes.toolTipSubValueColor;
	//toolTipObj.subValue.formatString = tooltipFormatString;
	toolTipObj.text={};
	toolTipObj.text.font = themes.toolTipTextFont;
	toolTipObj.text.color = themes.toolTipTextColor;
	//toolTipObj.text.formatString = tooltipFormatString;
	
	// axis
	var axisLineColor = themes.axisLineColor;
	var axisLabelColor = themes.axisLabelColor;
	var axisTitleColor = themes.axisTitleColor;
	var axisGridLineColor = themes.axisGridLineColor;

	if(typeof xAxis=='undefined'){
		xAxis=[{}];
	}
	for(var i=0;i<xAxis.length;i++){
		xAxis[i].lineColor = axisLineColor;
		xAxis[i].labelColor = axisLabelColor;
		xAxis[i].titleColor = axisTitleColor;
		if(typeof xAxis[i].gridLine!=='undefined'){
			xAxis[i].gridLine.majorColor = axisGridLineColor;
			xAxis[i].gridLine.minorColor = axisGridLineColor;
			xAxis[i].gridLine.subColor = axisGridLineColor;
		}
	};
	if(typeof yAxis=='undefined'){
		yAxis=[{}];
	}
	for(var i=0;i<yAxis.length;i++){
		yAxis[i].lineColor = axisLineColor;
		yAxis[i].labelColor = axisLabelColor;
		yAxis[i].titleColor = axisTitleColor;
		if(typeof yAxis[i].gridLine!=='undefined'){
			yAxis[i].gridLine.majorColor = axisGridLineColor;
			yAxis[i].gridLine.minorColor = axisGridLineColor;
			yAxis[i].gridLine.subColor = axisGridLineColor;
		}
	};
	
	var chartOption = {
			layout : layoutObj,
			background : backgroundObj ,
			legend :legendObj,
			title : titleObj,
		//	measure :measure,
			measures : measures,
			xAxis : xAxis,
			yAxis : yAxis,
			line : lineMarkerAndThickness,
			bar : barMarker,
			selectability : {
				mode : selectionMode,
				deSelectable : deselectEnabled,
				defaultSelectedItems : defaultSelectedItems
			}
		};
	return chartOption;
};
}; // end of sap.service.visualization.ChartOption
if ( !jQuery.sap.isDeclared('sap.service.visualization.Themings') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.Themings.
jQuery.sap.declare("sap.service.visualization.Themings");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained


/**
 * Constructor for a new Themings.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * parse all the themings settings for all charts.
 * @extends sap.ui.core.Element
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.Themings
 */
sap.ui.core.Element.extend("sap.service.visualization.Themings", { metadata : {

	// ---- object ----
	deprecated : true,

	// ---- control specific ----
	library : "sap.service.visualization"
}});


/**
 * Creates a new subclass of class sap.service.visualization.Themings with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.Themings.extend
 * @function
 */


// Start of sap/service/visualization/Themings.js
/*!
 * @copyright@
 */
sap.service.visualization.Themings.prototype.getCorrespondingThemings = function(chartType){

	var correspondingThemings = function(){};
	var chartTypeParam = "sap.service.visualization."+chartType+":";
	
	correspondingThemings.bgColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"bgColor");
	var fontFamily = sap.ui.core.theming.Parameters.get(chartTypeParam+"fontFamily");
	
	//chart padding 
	
	var paddingArr = sap.ui.core.theming.Parameters.get(chartTypeParam+"chartPadding").split(',');
	var chartPadding= [];
	for(var i=0;i<paddingArr.length;i++){
			chartPadding[i] = parseInt(paddingArr[i]);
			
	};
	correspondingThemings.chartPadding =chartPadding;
	//legend properties			
	var legendTitleFontSize = sap.ui.core.theming.Parameters.get(chartTypeParam+"legendTitleFontSize");
	legendTitleFontSize = this.mapFontSize(legendTitleFontSize);
	correspondingThemings.legendTitleFont = "bold " + legendTitleFontSize + " " + fontFamily;
	correspondingThemings.legendTitleFontColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"legendTitleFontColor");
	
	var legendFontSize = sap.ui.core.theming.Parameters.get(chartTypeParam+"legendFontSize");
	legendFontSize = this.mapFontSize(legendFontSize);
	correspondingThemings.legendFont = "normal " + legendFontSize + " " + fontFamily;
	correspondingThemings.legendColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"legendColor");

    //main title properties
	var mainTitleFontSize = sap.ui.core.theming.Parameters.get(chartTypeParam+"mainTitleFontSize");
	mainTitleFontSize = this.mapFontSize(mainTitleFontSize);
	correspondingThemings.mainTitleFont = "normal " + mainTitleFontSize + " " + fontFamily;
	correspondingThemings.mainTitleColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"mainTitleColor");
	//sub title properties
	var subTitleObjFontSize = sap.ui.core.theming.Parameters.get(chartTypeParam+"subTitleFontSize");
	subTitleObjFontSize = this.mapFontSize(subTitleObjFontSize);
	correspondingThemings.subTitleFont = "normal " + subTitleObjFontSize + " " + fontFamily;
	correspondingThemings.subTitleColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"subTitleColor");
	//tool tip themes
	var toolTipMainValueFontSize = sap.ui.core.theming.Parameters.get(chartTypeParam+"toolTipMainValueFontSize");
	toolTipMainValueFontSize = this.mapFontSize(toolTipMainValueFontSize);
	correspondingThemings.toolTipMainValueFont = "normal " + toolTipMainValueFontSize + " " + fontFamily;
	correspondingThemings.toolTipMainValueColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"toolTipMainValueColor");
	
	var toolTipSubValueFontSize = sap.ui.core.theming.Parameters.get(chartTypeParam+"toolTipSubValueFontSize");
	toolTipSubValueFontSize = this.mapFontSize(toolTipSubValueFontSize);
	correspondingThemings.toolTipSubValueFont = "normal " + toolTipSubValueFontSize + " " + fontFamily;
	correspondingThemings.toolTipSubValueColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"toolTipSubValueColor");
	
	var toolTipTextFontSize = sap.ui.core.theming.Parameters.get(chartTypeParam+"toolTipTextFontSize");
	toolTipTextFontSize = this.mapFontSize(toolTipTextFontSize);
	correspondingThemings.toolTipTextFont = "normal " + toolTipTextFontSize + " " + fontFamily;
	correspondingThemings.toolTipTextColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"toolTipTextColor");

    //axis 
	correspondingThemings.axisLineColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"axisLineColor");
	correspondingThemings.axisLabelColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"axisLabelColor");
	correspondingThemings.axisTitleColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"axisTitleColor");
	correspondingThemings.axisGridLineColor = sap.ui.core.theming.Parameters.get(chartTypeParam+"axisGridLineColor");
	
	for( prop in correspondingThemings){
		if( prop.indexOf("Color") !=-1 || prop.indexOf('color') != -1){
			correspondingThemings[prop] = this.mapColor(correspondingThemings[prop]);
		}
	}
   
	return correspondingThemings;
};

sap.service.visualization.Themings.prototype.mapFontSize = function(fontSize){

	var fsp = /(x{1,2}-)?(small|medium|large)/i;
	var sizeMap ={
		"xx-small" : '9px',
        "x-small" : '10px',
        "small" : '13px',
        "medium" : '16px',
        "large" : '18px',
        "x-large" : '24px',
        "xx-large" : '32px'
    };
    var m = fsp.exec(fontSize);
    if (m==null) {
    	return fontSize;
    }else{
    	return fontSize = sizeMap[m[0].toLowerCase()];
    }
};

sap.service.visualization.Themings.prototype.mapColor = function(hexColor){

	var fsp = /(aqua|black|blue|fuchsia|gray|grey|green|lime|maroon|navy|olive|purple|red|silver|teal|white|yellow)/i;
	var colorMap ={
		"aqua" : '#00FFFF',
        "black" : '#000000',
        "blue" : '#0000FF',
        "fuchsia" : '#FF00FF',
        "gray" : '#808080',
        "grey" : '#808080',
        "green" : '#008000',
        "lime" : '#00FF00',
        "maroon" : '#800000',
        "navy" : '#000080',
        "olive" : '#808000',
        "purple" : '#800080',
        "red" : '#FF0000',
        "silver" : '#C0C0C0',
        "teal" : '#008080',
        "white" : '#FFFFFF',
        "yellow" : '#FFFF00',
        "transparent" : 'rgba(0,0,0,0)'
    };
    var m = fsp.exec(hexColor);
    if (m==null) {
    	return hexColor;
    }else{
    	return hexColor = colorMap[m[0].toLowerCase()];
    }
};


sap.service.visualization.Themings.prototype.applyCurrentThemeToXYChart = function(control, chartType){
		var themes = new sap.service.visualization.Themings().getCorrespondingThemings(chartType);
		var chartPadding = themes.chartPadding;
		var bgColor = themes.bgColor;
		//tool tip
		var toolTipMainValueFont = themes.toolTipMainValueFont;
		var toolTipMainValueColor = themes.toolTipMainValueColor;
		var toolTipSubValueFont = themes.toolTipSubValueFont;
		var toolTipSubValueColor = themes.toolTipSubValueColor;
		var toolTipTextFont = themes.toolTipTextFont;
		var toolTipTextColor = themes.toolTipTextColor;
		
		//legend
		var legendFont = themes.legendFont;
		var legendColor = themes.legendColor;
		var legendTitleFont = themes.legendTitleFont;
		var legendTitleFontColor = themes.legendTitleFontColor;
		
		//title
		var mainTitleColor = themes.mainTitleColor;
		var mainTitleFont = themes.mainTitleFont;
		var subTitleObjColor = themes.subTitleColor;
		var subTitleObjFont = themes.subTitleFont;
		
		// axis
		var axisLineColor = themes.axisLineColor;
		var axisLabelColor = themes.axisLabelColor;
		var axisTitleColor = themes.axisTitleColor;
		var axisGridLineColor = themes.axisGridLineColor;
		
		var xAxis = control.getXAxis();
		var yAxis = control.getYAxis();
		
		for(var i=0;i<xAxis.length;i++){
			xAxis[i].lineColor = axisLineColor;
			xAxis[i].labelColor = axisLabelColor;
			xAxis[i].titleColor = axisTitleColor;
			if(typeof xAxis[i].gridLine!=='undefined'){
				xAxis[i].gridLine.majorColor = axisGridLineColor;
				xAxis[i].gridLine.minorColor = axisGridLineColor;
				xAxis[i].gridLine.subColor = axisGridLineColor;
			}
		};
	
		for(var i=0;i<yAxis.length;i++){
			yAxis[i].lineColor = axisLineColor;
			yAxis[i].labelColor = axisLabelColor;
			yAxis[i].titleColor = axisTitleColor;
			if(typeof yAxis[i].gridLine!=='undefined'){
				yAxis[i].gridLine.majorColor = axisGridLineColor;
				yAxis[i].gridLine.minorColor = axisGridLineColor;
				yAxis[i].gridLine.subColor = axisGridLineColor;
			}
		};
		var chartOption = {
			layout : {
				chartPadding : chartPadding
			},
			background : {
				color : bgColor
			},
			tooltip : {
				text : {
					font : toolTipTextFont,
					color : toolTipTextColor
				},
				mainValue : {
					font : toolTipMainValueFont,
					color : toolTipMainValueColor
				},
				subValue : {
					font : toolTipSubValueFont,
					color : toolTipSubValueColor
				}
			},
			legend : {
				labelFont : legendFont,
				labelColor : legendColor,
				titleFont : legendTitleFont,
				titleFontColor : legendTitleFontColor
			},
			xAxis : xAxis,
			yAxis : yAxis,
			title : {
				main : {
					color : mainTitleColor,
					font : mainTitleFont
				},
				sub : {
					color : subTitleObjColor,
					font : subTitleObjFont
				}
			}
		};
		var xy;
		switch(chartType){
		 case 'Bar': xy = control.bar;
		 break;
		 case 'Line': xy = control.line;
		 break;
		 case 'Column': xy = control.column;
		 break;  
		 case 'Combination': xy = control.combination;
		 break;
		}
		xy.updateProperties(chartOption);
};
}; // end of sap.service.visualization.Themings
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.Bar') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.chart.Bar.
jQuery.sap.declare("sap.service.visualization.chart.Bar");

jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained


/**
 * Constructor for a new chart/Bar.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getWidth width} : sap.ui.core.CSSSize</li>
 * <li>{@link #getHeight height} : sap.ui.core.CSSSize</li>
 * <li>{@link #getDeselectEnabled deselectEnabled} : boolean (default: true)</li>
 * <li>{@link #getSelectionMode selectionMode} : string (default: 'single')</li>
 * <li>{@link #getLegendFirst legendFirst} : boolean (default: false)</li>
 * <li>{@link #getLegendDirection legendDirection} : string (default: 'right')</li>
 * <li>{@link #getLegendVerticalOffset legendVerticalOffset} : int (default: 0)</li>
 * <li>{@link #getLegendHorizontalOffset legendHorizontalOffset} : int (default: 0)</li>
 * <li>{@link #getDefaultSelectedItems defaultSelectedItems} : object[]</li>
 * <li>{@link #getMeasures measures} : object[]</li>
 * <li>{@link #getBarMarker barMarker} : object</li>
 * <li>{@link #getShowLegend showLegend} : boolean (default: true)</li>
 * <li>{@link #getLegendFormatString legendFormatString} : string[] (default: [''])</li>
 * <li>{@link #getTitle title} : string</li>
 * <li>{@link #getTitleHorizontalAlign titleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getSubTitle subTitle} : string</li>
 * <li>{@link #getSubTitleHorizontalAlign subTitleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getShowTitle showTitle} : boolean (default: true)</li>
 * <li>{@link #getTitleFormatString titleFormatString} : string (default: '')</li>
 * <li>{@link #getSubTitleFormatString subTitleFormatString} : string (default: '')</li>
 * <li>{@link #getXAxis xAxis} : object[]</li>
 * <li>{@link #getYAxis yAxis} : object[]</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getDataset dataset} : sap.service.visualization.dataset.SimpleDMDataset</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.service.visualization.chart.Bar#event:selectData selectData} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 

 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * 
 * Is used for show a Bar chart with feeding data. The API
 * provides data feeding, and a set of behavior of the bar chart.
 * 
 * @extends sap.ui.core.Control
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.chart.Bar
 */
sap.ui.core.Control.extend("sap.service.visualization.chart.Bar", { metadata : {

	// ---- object ----
	deprecated : true,

	// ---- control specific ----
	library : "sap.service.visualization",
	properties : {
		"width" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"height" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"deselectEnabled" : {type : "boolean", group : "Misc", defaultValue : true},
		"selectionMode" : {type : "string", group : "Misc", defaultValue : 'single'},
		"legendFirst" : {type : "boolean", group : "Misc", defaultValue : false},
		"legendDirection" : {type : "string", group : "Misc", defaultValue : 'right'},
		"legendVerticalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"legendHorizontalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"defaultSelectedItems" : {type : "object[]", group : "Misc", defaultValue : null},
		"measures" : {type : "object[]", group : "Misc", defaultValue : null},
		"barMarker" : {type : "object", group : "Misc", defaultValue : null},
		"showLegend" : {type : "boolean", group : "Misc", defaultValue : true},
		"legendFormatString" : {type : "string[]", group : "Misc", defaultValue : ['']},
		"title" : {type : "string", group : "Misc", defaultValue : null},
		"titleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"subTitle" : {type : "string", group : "Misc", defaultValue : null},
		"subTitleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"showTitle" : {type : "boolean", group : "Misc", defaultValue : true},
		"titleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"subTitleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"xAxis" : {type : "object[]", group : "Misc", defaultValue : null},
		"yAxis" : {type : "object[]", group : "Misc", defaultValue : null}
	},
	aggregations : {
    	"dataset" : {type : "sap.service.visualization.dataset.SimpleDMDataset", multiple : false}
	},
	events : {
		"selectData" : {}
	}
}});


/**
 * Creates a new subclass of class sap.service.visualization.chart.Bar with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.chart.Bar.extend
 * @function
 */

sap.service.visualization.chart.Bar.M_EVENTS = {'selectData':'selectData'};


/**
 * Getter for property <code>width</code>.
 * the chart width.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>width</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getWidth
 * @function
 */


/**
 * Setter for property <code>width</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sWidth  new value for property <code>width</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setWidth
 * @function
 */

/**
 * Getter for property <code>height</code>.
 * the chart height.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>height</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getHeight
 * @function
 */


/**
 * Setter for property <code>height</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sHeight  new value for property <code>height</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setHeight
 * @function
 */

/**
 * Getter for property <code>deselectEnabled</code>.
 * de-selectable for measure items. Be noted that it cannot be updated after chart initialization.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>deselectEnabled</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getDeselectEnabled
 * @function
 */


/**
 * Setter for property <code>deselectEnabled</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bDeselectEnabled  new value for property <code>deselectEnabled</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setDeselectEnabled
 * @function
 */

/**
 * Getter for property <code>selectionMode</code>.
 * default value is false, single: you can just select one slice; none : no slice can be selected.
 *
 * Default value is <code>single</code>
 *
 * @return {string} the value of property <code>selectionMode</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getSelectionMode
 * @function
 */


/**
 * Setter for property <code>selectionMode</code>.
 *
 * Default value is <code>single</code> 
 *
 * @param {string} sSelectionMode  new value for property <code>selectionMode</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setSelectionMode
 * @function
 */

/**
 * Getter for property <code>legendFirst</code>.
 * first ensure to plot legend, then the chart area plot.
 *
 * Default value is <code>false</code>
 *
 * @return {boolean} the value of property <code>legendFirst</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getLegendFirst
 * @function
 */


/**
 * Setter for property <code>legendFirst</code>.
 *
 * Default value is <code>false</code> 
 *
 * @param {boolean} bLegendFirst  new value for property <code>legendFirst</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setLegendFirst
 * @function
 */

/**
 * Getter for property <code>legendDirection</code>.
 * the position of legend located at, left|right|top|bottom.
 *
 * Default value is <code>right</code>
 *
 * @return {string} the value of property <code>legendDirection</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getLegendDirection
 * @function
 */


/**
 * Setter for property <code>legendDirection</code>.
 *
 * Default value is <code>right</code> 
 *
 * @param {string} sLegendDirection  new value for property <code>legendDirection</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setLegendDirection
 * @function
 */

/**
 * Getter for property <code>legendVerticalOffset</code>.
 * the offset of the legend, used to adjust the position of legend.if left or right, positive, legend will move up,minus down.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendVerticalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getLegendVerticalOffset
 * @function
 */


/**
 * Setter for property <code>legendVerticalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendVerticalOffset  new value for property <code>legendVerticalOffset</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setLegendVerticalOffset
 * @function
 */

/**
 * Getter for property <code>legendHorizontalOffset</code>.
 * the offset of the legend, used to adjust the position of legend. if position top or bottom, positive, legend will move right, minus left.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendHorizontalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getLegendHorizontalOffset
 * @function
 */


/**
 * Setter for property <code>legendHorizontalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendHorizontalOffset  new value for property <code>legendHorizontalOffset</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setLegendHorizontalOffset
 * @function
 */

/**
 * Getter for property <code>defaultSelectedItems</code>.
 * the default selected bar index.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>defaultSelectedItems</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getDefaultSelectedItems
 * @function
 */


/**
 * Setter for property <code>defaultSelectedItems</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aDefaultSelectedItems  new value for property <code>defaultSelectedItems</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setDefaultSelectedItems
 * @function
 */

/**
 * Getter for property <code>measures</code>.
 * for each object:{ valueAxis: 0, should be valid index in your value axis (can be xAxis or yAxis)}.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>measures</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getMeasures
 * @function
 */


/**
 * Setter for property <code>measures</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aMeasures  new value for property <code>measures</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setMeasures
 * @function
 */

/**
 * Getter for property <code>barMarker</code>.
 * for each object:{barMarkerSize//It is for all measures. When the bar size is too large, it only can draw the limited value. It can not be less than 0.}.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object} the value of property <code>barMarker</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getBarMarker
 * @function
 */


/**
 * Setter for property <code>barMarker</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object} oBarMarker  new value for property <code>barMarker</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setBarMarker
 * @function
 */

/**
 * Getter for property <code>showLegend</code>.
 * show/hide legend.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showLegend</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getShowLegend
 * @function
 */


/**
 * Setter for property <code>showLegend</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowLegend  new value for property <code>showLegend</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setShowLegend
 * @function
 */

/**
 * Getter for property <code>legendFormatString</code>.
 * the format style for legend. the format for legend default is [''], numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'. If feed not enough then reuse the last one.
 *
 * Default value is <code>['']</code>
 *
 * @return {string[]} the value of property <code>legendFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getLegendFormatString
 * @function
 */


/**
 * Setter for property <code>legendFormatString</code>.
 *
 * Default value is <code>['']</code> 
 *
 * @param {string[]} aLegendFormatString  new value for property <code>legendFormatString</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setLegendFormatString
 * @function
 */

/**
 * Getter for property <code>title</code>.
 * title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>title</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getTitle
 * @function
 */


/**
 * Setter for property <code>title</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sTitle  new value for property <code>title</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setTitle
 * @function
 */

/**
 * Getter for property <code>titleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>titleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>titleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sTitleHorizontalAlign  new value for property <code>titleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>subTitle</code>.
 * sub title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>subTitle</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getSubTitle
 * @function
 */


/**
 * Setter for property <code>subTitle</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sSubTitle  new value for property <code>subTitle</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setSubTitle
 * @function
 */

/**
 * Getter for property <code>subTitleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>subTitleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getSubTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>subTitleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sSubTitleHorizontalAlign  new value for property <code>subTitleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setSubTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>showTitle</code>.
 * show/hide title.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showTitle</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getShowTitle
 * @function
 */


/**
 * Setter for property <code>showTitle</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowTitle  new value for property <code>showTitle</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setShowTitle
 * @function
 */

/**
 * Getter for property <code>titleFormatString</code>.
 * the format style for main title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>titleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getTitleFormatString
 * @function
 */


/**
 * Setter for property <code>titleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sTitleFormatString  new value for property <code>titleFormatString</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setTitleFormatString
 * @function
 */

/**
 * Getter for property <code>subTitleFormatString</code>.
 * the format style for sub title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>subTitleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getSubTitleFormatString
 * @function
 */


/**
 * Setter for property <code>subTitleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sSubTitleFormatString  new value for property <code>subTitleFormatString</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setSubTitleFormatString
 * @function
 */

/**
 * Getter for property <code>xAxis</code>.
 * for each object:{
 * showMajorTicks : true,// default value = undefined,show/hide major grid line and only works on value axis
 * showMinorTicks : true,// default value = false,show/hide minor grid line and only works on value axis. If showMajor is false, this option will not work
 * title : 'X Axis Title',
 * titleFormatString : '', //refer to legend format.
 * labelsFormatString : [''],//refer to legend format.
 * showTitle : true,//show or hide title showLabels : true, show or hide labels
 * gridLine : {
 * showMajor : false, //the major grid line
 * majorThickness : 1, the thickness for major tick.
 * showMinor : false, //the minor grid line.
 * minorThickness : 1, the thickness of minor tick.
 * showSub : true, //default value=false, show/hide sub grid line and only works on dimension axis }
 * }.
 * For major and minor ticks, they only works on value axis, it takes effect but the behavior is unexpected.
 * Set the grid line releated properties.For value axis, only showMajor and showMinor options work.
 * If showSub is set to true on value axis, it takes effect but the behavior is unexpected.
 * For dimension axis, only showSub option works.
 * If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.
 * 
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>xAxis</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getXAxis
 * @function
 */


/**
 * Setter for property <code>xAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aXAxis  new value for property <code>xAxis</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setXAxis
 * @function
 */

/**
 * Getter for property <code>yAxis</code>.
 * the same as xAxis.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>yAxis</code>
 * @public
 * @name sap.service.visualization.chart.Bar#getYAxis
 * @function
 */


/**
 * Setter for property <code>yAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aYAxis  new value for property <code>yAxis</code>
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setYAxis
 * @function
 */

/**
 * Getter for aggregation <code>dataset</code>.<br/>
 * chart use this aggregation to get data feed.
 * 
 * @return {sap.service.visualization.dataset.SimpleDMDataset}
 * @public
 * @name sap.service.visualization.chart.Bar#getDataset
 * @function
 */

/**
 * Setter for the aggregated <code>dataset</code>.
 * @param oDataset {sap.service.visualization.dataset.SimpleDMDataset}
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#setDataset
 * @function
 */


/**
 * Destroys  in the aggregation 
 * named <code>dataset</code>.
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#destroyDataset
 * @function
 */

/**
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on bar. 
 *
 * @name sap.service.visualization.chart.Bar#selectData
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'selectData' event of this <code>sap.service.visualization.chart.Bar</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.service.visualization.chart.Bar</code>.<br/> itself. 
 *  
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on bar. 
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener=this] Context object to call the event handler with. Defaults to this <code>sap.service.visualization.chart.Bar</code>.<br/> itself.
 *
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#attachSelectData
 * @function
 */


/**
 * Detach event handler <code>fnFunction</code> from the 'selectData' event of this <code>sap.service.visualization.chart.Bar</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Bar#detachSelectData
 * @function
 */


/**
 * Fire event selectData to attached listeners.

 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.service.visualization.chart.Bar} <code>this</code> to allow method chaining
 * @protected
 * @name sap.service.visualization.chart.Bar#fireSelectData
 * @function
 */

// Start of sap/service/visualization/chart/Bar.js
/*!
 * @copyright@
 */





jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained


sap.service.visualization.chart.Bar.prototype.isNumber = function(value) {
	var patt = /^(0|-?[1-9]\d*)$|^(0|-?[1-9]\d*)\.(\d+)$/;
	return patt.exec(value);
};

sap.service.visualization.chart.Bar.prototype.setWidth = function(width) {

	this.setProperty("width", width);
	return this;
};

sap.service.visualization.chart.Bar.prototype.setHeight = function(height) {

	this.setProperty("height", height);
	return this;
};

sap.service.visualization.chart.Bar.prototype.setDeselectEnabled = function(deselectEnabled) {

	this.setProperty("deselectEnabled", deselectEnabled);

	if (this.bar != undefined) {

		var chartOption = {
			selectbility : {
				deSelectable : (deselectEnabled != undefined) ? deselectEnabled : true
			}
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setSelectionMode = function(selectionMode) {

	this.setProperty("selectionMode", selectionMode);

	if (this.bar != undefined) {
		if ((selectionMode != 'multiple') && (selectionMode != 'single')) {
			selectionMode = 'single';
		}
		var chartOption = {
			selectbility : {
				selectionMode : selectionMode,
			}

		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setTitleHorizontalAlign = function(titleHorizontalAlign) {

	this.setProperty("titleHorizontalAlign", titleHorizontalAlign);

	if (this.bar != undefined) {

		var chartOption = {
			title : {
				main : {
					HorizontalAlign: titleHorizontalAlign
				}
			}
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setSubTitleHorizontalAlign = function(subTitleHorizontalAlign) {

	this.setProperty("subTitleHorizontalAlign", subTitleHorizontalAlign);

	if (this.bar != undefined) {

		var chartOption = {
			title : {
				sub:{
					HorizontalAlign: subTitleHorizontalAlign
				}
			}
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setLegendDirection = function(legendDirection) {

	this.setProperty("legendDirection", legendDirection);

	if (this.bar != undefined) {
		var legendVerticalOffset = this.getLegendVerticalOffset();
		var legendHorizontalOffset = this.getLegendHorizontalOffset();
		if (legendDirection == 'left'||legendDirection == 'right') {
			legendVerticalOffset = (this.isNumber(legendVerticalOffset)) ? parseInt(legendVerticalOffset) : 0;;
		} else{
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset)) ? parseInt(legendHorizontalOffset) : 0;
		}

		var chartOption = {
			legend : {
				position : legendDirection,
				verticalOffset : legendVerticalOffset,
				horizontalOffset : legendHorizontalOffset
			}
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setLegendVerticalOffset = function(legendVerticalOffset) {

	this.setProperty("legendVerticalOffset", legendVerticalOffset);
	
	if (this.bar != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendVerticalOffset = 0;
		var chartOption;
		if (legendDirection == 'left'|| legendDirection=='right'){
			legendVerticalOffset = (this.isNumber(legendVerticalOffset))? parseInt(legendVerticalOffset) : 0;
			chartOption = {
				legend: {
					verticalOffset: legendVerticalOffset,
				}
			};
		}
		this.bar.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Bar.prototype.setLegendHorizontalOffset = function(legendHorizontalOffset) {

	this.setProperty("legendHorizontalOffset", legendHorizontalOffset);
	
	if (this.bar != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendHorizontalOffset = 0;
		var chartOption;
		if (legendDirection == 'top'|| legendDirection=='left'){
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset))? parseInt(legendHorizontalOffset) : 0;
			chartOption = {
				legend: {
					horizontalOffset: legendHorizontalOffset,
				}
			};
		}
		this.bar.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Bar.prototype.setLegendFirst = function(legendFirst) {

	this.setProperty("legendFirst", legendFirst);

	if (this.bar != undefined) {

		var legendFirst = this.getLegendFirst();

		var chartOption = {
			layout : {
				legendFirst : (legendFirst != undefined) ? legendFirst : true
			}
		};
		this.bar.updateProperties(chartOption);
	}

	return this;

};
sap.service.visualization.chart.Bar.prototype.setDefaultSelectedItems = function(defaultSelectedItems) {

	this.setProperty("defaultSelectedItems", defaultSelectedItems);

	if (this.bar != undefined) {

		var chartOption = {
			selectability : {
				defaultSelectedItems : defaultSelectedItems
			},
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setShowLegend = function(showLegend) {

	this.setProperty("showLegend", showLegend);

	if (this.bar != undefined) {

		var chartOption = {
			legend : {
				visible : (showLegend != undefined) ? showLegend : true
			},
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setTitle = function(title) {

	this.setProperty("title", title);

	if (this.bar != undefined) {

		var chartOption = {};
		if (title === "") {
			chartOption = {
				title : {
					main : {
						text : title
					},
					sub : {
						visible : false
					}
				}
			};
		} else {
			chartOption = {
				title : {
					main : {
						text : title
					}
				}
			};
		}
		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setSubTitle = function(subTitle) {

	this.setProperty("subTitle", subTitle);

	if (this.bar != undefined) {

		var chartOption = {
			title : {
				sub : {
					text : subTitle
				}
			}
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setShowTitle = function(showTitle) {

	this.setProperty("showTitle", showTitle);

	if (this.bar != undefined) {

		var chartOption = {
			title : {
				main : {
					visible : (showTitle != undefined) ? showTitle : true
				},
				sub : {
					visible : (showTitle != undefined) ? showTitle : true
				}
			}
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setLegendFormatString = function(legendFormatString) {
	
	this.setProperty("legendFormatString", legendFormatString);
	
	if (this.bar != undefined) {
		
		var chartOption = {
			legend:{
				legendFormatString : legendFormatString
			}
		};
		
		this.bar.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Bar.prototype.setTitleFormatString = function(titleFormatString) {
	
	this.setProperty("titleFormatString", titleFormatString);
	
	if (this.bar != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : titleFormatString
				}
			}
		};
		
		this.bar.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Bar.prototype.setSubTitleFormatString = function(subTitleFormatString) {
	
	this.setProperty("subTitleFormatString", subTitleFormatString);
	
	if (this.bar != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : subTitleFormatString
				}
			}
		};
		
		this.bar.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Bar.prototype.setMeasures = function(measures) {

	this.setProperty("measures", measures);

	if (this.bar != undefined) {

		var chartOption = {
			measures : measures
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setBarMarker = function(barMarker) {

	this.setProperty("barMarker", barMarker);

	if (this.bar != undefined) {

		var chartOption = {
			bar : barMarker
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setXAxis = function(xAxis) {

	this.setProperty("xAxis", xAxis);

	if (this.bar != undefined) {

		var chartOption = {
			xAxis : xAxis
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.setYAxis = function(yAxis) {

	this.setProperty("yAxis", yAxis);

	if (this.bar != undefined) {

		var chartOption = {
			yAxis :  yAxis
		};

		this.bar.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Bar.prototype.onAfterRendering = function(oEvent) {

	// Create chart after lazy load finishes
	var control = this;
	var renderTo = this.getId();	
	//aggregations
	var dataset = this.getDataset().dataset;
	//the prop only for bar
	var option = new sap.service.visualization.ChartOption();
    var chartOption= option.getXYChartOption(control, 'Bar');

    sap.riv.viz.Environment.initialize({
			'locale' : 'en_US',
			'log' : 'debug'
	});
   
    control.bar = new sap.riv.viz.BarChart(jQuery.sap.byId(renderTo), chartOption, dataset);
	control.bar.addListener('selectData', function(evt) {
		control.fireSelectData({
			Id : renderTo,
			Data : evt.data,
			EventName : evt.name
		});
	});

	sap.ui.getCore().attachThemeChanged(function(evt) {
		var themes = new sap.service.visualization.Themings();
		themes.applyCurrentThemeToXYChart(control,'Bar');
	});
};
}; // end of sap.service.visualization.chart.Bar
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.Column') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.chart.Column.
jQuery.sap.declare("sap.service.visualization.chart.Column");

jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained


/**
 * Constructor for a new chart/Column.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getWidth width} : sap.ui.core.CSSSize</li>
 * <li>{@link #getHeight height} : sap.ui.core.CSSSize</li>
 * <li>{@link #getDeselectEnabled deselectEnabled} : boolean (default: true)</li>
 * <li>{@link #getSelectionMode selectionMode} : string (default: 'single')</li>
 * <li>{@link #getLegendFirst legendFirst} : boolean (default: false)</li>
 * <li>{@link #getLegendDirection legendDirection} : string (default: 'right')</li>
 * <li>{@link #getLegendVerticalOffset legendVerticalOffset} : int (default: 0)</li>
 * <li>{@link #getLegendHorizontalOffset legendHorizontalOffset} : int (default: 0)</li>
 * <li>{@link #getDefaultSelectedItems defaultSelectedItems} : object[]</li>
 * <li>{@link #getMeasures measures} : object[]</li>
 * <li>{@link #getBarMarker barMarker} : object</li>
 * <li>{@link #getShowLegend showLegend} : boolean (default: true)</li>
 * <li>{@link #getLegendFormatString legendFormatString} : string[] (default: [''])</li>
 * <li>{@link #getTitle title} : string</li>
 * <li>{@link #getTitleHorizontalAlign titleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getSubTitle subTitle} : string</li>
 * <li>{@link #getSubTitleHorizontalAlign subTitleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getShowTitle showTitle} : boolean (default: true)</li>
 * <li>{@link #getTitleFormatString titleFormatString} : string (default: '')</li>
 * <li>{@link #getSubTitleFormatString subTitleFormatString} : string (default: '')</li>
 * <li>{@link #getXAxis xAxis} : object[]</li>
 * <li>{@link #getYAxis yAxis} : object[]</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getDataset dataset} : sap.service.visualization.dataset.SimpleDMDataset</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.service.visualization.chart.Column#event:selectData selectData} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 

 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * 
 * Is used for show a Column chart with feeding data. The API
 * provides data feeding, and a set of behavior of the column chart.
 * 
 * @extends sap.ui.core.Control
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.chart.Column
 */
sap.ui.core.Control.extend("sap.service.visualization.chart.Column", { metadata : {

	// ---- object ----
	deprecated : true,

	// ---- control specific ----
	library : "sap.service.visualization",
	properties : {
		"width" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"height" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"deselectEnabled" : {type : "boolean", group : "Misc", defaultValue : true},
		"selectionMode" : {type : "string", group : "Misc", defaultValue : 'single'},
		"legendFirst" : {type : "boolean", group : "Misc", defaultValue : false},
		"legendDirection" : {type : "string", group : "Misc", defaultValue : 'right'},
		"legendVerticalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"legendHorizontalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"defaultSelectedItems" : {type : "object[]", group : "Misc", defaultValue : null},
		"measures" : {type : "object[]", group : "Misc", defaultValue : null},
		"barMarker" : {type : "object", group : "Misc", defaultValue : null},
		"showLegend" : {type : "boolean", group : "Misc", defaultValue : true},
		"legendFormatString" : {type : "string[]", group : "Misc", defaultValue : ['']},
		"title" : {type : "string", group : "Misc", defaultValue : null},
		"titleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"subTitle" : {type : "string", group : "Misc", defaultValue : null},
		"subTitleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"showTitle" : {type : "boolean", group : "Misc", defaultValue : true},
		"titleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"subTitleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"xAxis" : {type : "object[]", group : "Misc", defaultValue : null},
		"yAxis" : {type : "object[]", group : "Misc", defaultValue : null}
	},
	aggregations : {
    	"dataset" : {type : "sap.service.visualization.dataset.SimpleDMDataset", multiple : false}
	},
	events : {
		"selectData" : {}
	}
}});


/**
 * Creates a new subclass of class sap.service.visualization.chart.Column with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.chart.Column.extend
 * @function
 */

sap.service.visualization.chart.Column.M_EVENTS = {'selectData':'selectData'};


/**
 * Getter for property <code>width</code>.
 * the chart width.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>width</code>
 * @public
 * @name sap.service.visualization.chart.Column#getWidth
 * @function
 */


/**
 * Setter for property <code>width</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sWidth  new value for property <code>width</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setWidth
 * @function
 */

/**
 * Getter for property <code>height</code>.
 * the chart height.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>height</code>
 * @public
 * @name sap.service.visualization.chart.Column#getHeight
 * @function
 */


/**
 * Setter for property <code>height</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sHeight  new value for property <code>height</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setHeight
 * @function
 */

/**
 * Getter for property <code>deselectEnabled</code>.
 * de-selectable for measure items. Be noted that it cannot be updated after chart initialization.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>deselectEnabled</code>
 * @public
 * @name sap.service.visualization.chart.Column#getDeselectEnabled
 * @function
 */


/**
 * Setter for property <code>deselectEnabled</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bDeselectEnabled  new value for property <code>deselectEnabled</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setDeselectEnabled
 * @function
 */

/**
 * Getter for property <code>selectionMode</code>.
 * default value is false, single: you can just select one slice; none : no slice can be selected.
 *
 * Default value is <code>single</code>
 *
 * @return {string} the value of property <code>selectionMode</code>
 * @public
 * @name sap.service.visualization.chart.Column#getSelectionMode
 * @function
 */


/**
 * Setter for property <code>selectionMode</code>.
 *
 * Default value is <code>single</code> 
 *
 * @param {string} sSelectionMode  new value for property <code>selectionMode</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setSelectionMode
 * @function
 */

/**
 * Getter for property <code>legendFirst</code>.
 * first ensure to plot legend, then the chart area plot.
 *
 * Default value is <code>false</code>
 *
 * @return {boolean} the value of property <code>legendFirst</code>
 * @public
 * @name sap.service.visualization.chart.Column#getLegendFirst
 * @function
 */


/**
 * Setter for property <code>legendFirst</code>.
 *
 * Default value is <code>false</code> 
 *
 * @param {boolean} bLegendFirst  new value for property <code>legendFirst</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setLegendFirst
 * @function
 */

/**
 * Getter for property <code>legendDirection</code>.
 * the position of legend located at, left|right|top|bottom.
 *
 * Default value is <code>right</code>
 *
 * @return {string} the value of property <code>legendDirection</code>
 * @public
 * @name sap.service.visualization.chart.Column#getLegendDirection
 * @function
 */


/**
 * Setter for property <code>legendDirection</code>.
 *
 * Default value is <code>right</code> 
 *
 * @param {string} sLegendDirection  new value for property <code>legendDirection</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setLegendDirection
 * @function
 */

/**
 * Getter for property <code>legendVerticalOffset</code>.
 * the offset of the legend, used to adjust the position of legend.if left or right, positive, legend will move up,minus down.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendVerticalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Column#getLegendVerticalOffset
 * @function
 */


/**
 * Setter for property <code>legendVerticalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendVerticalOffset  new value for property <code>legendVerticalOffset</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setLegendVerticalOffset
 * @function
 */

/**
 * Getter for property <code>legendHorizontalOffset</code>.
 * the offset of the legend, used to adjust the position of legend. if position top or bottom, positive, legend will move right, minus left.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendHorizontalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Column#getLegendHorizontalOffset
 * @function
 */


/**
 * Setter for property <code>legendHorizontalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendHorizontalOffset  new value for property <code>legendHorizontalOffset</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setLegendHorizontalOffset
 * @function
 */

/**
 * Getter for property <code>defaultSelectedItems</code>.
 * the default selected column index.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>defaultSelectedItems</code>
 * @public
 * @name sap.service.visualization.chart.Column#getDefaultSelectedItems
 * @function
 */


/**
 * Setter for property <code>defaultSelectedItems</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aDefaultSelectedItems  new value for property <code>defaultSelectedItems</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setDefaultSelectedItems
 * @function
 */

/**
 * Getter for property <code>measures</code>.
 * for each object:{ valueAxis: 0, should be valid index in your value axis (can be xAxis or yAxis) columnMarkerSize: 20}.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>measures</code>
 * @public
 * @name sap.service.visualization.chart.Column#getMeasures
 * @function
 */


/**
 * Setter for property <code>measures</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aMeasures  new value for property <code>measures</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setMeasures
 * @function
 */

/**
 * Getter for property <code>barMarker</code>.
 * for each object:{barMarkerSize//It is for all measures. When the bar size is too large, it only can draw the limited value. It can not be less than 0.}.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object} the value of property <code>barMarker</code>
 * @public
 * @name sap.service.visualization.chart.Column#getBarMarker
 * @function
 */


/**
 * Setter for property <code>barMarker</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object} oBarMarker  new value for property <code>barMarker</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setBarMarker
 * @function
 */

/**
 * Getter for property <code>showLegend</code>.
 * show/hide legend.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showLegend</code>
 * @public
 * @name sap.service.visualization.chart.Column#getShowLegend
 * @function
 */


/**
 * Setter for property <code>showLegend</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowLegend  new value for property <code>showLegend</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setShowLegend
 * @function
 */

/**
 * Getter for property <code>legendFormatString</code>.
 * the format style for legend. the format for title number default is [''], numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'. If feed not enough then reuse the last one.
 *
 * Default value is <code>['']</code>
 *
 * @return {string[]} the value of property <code>legendFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Column#getLegendFormatString
 * @function
 */


/**
 * Setter for property <code>legendFormatString</code>.
 *
 * Default value is <code>['']</code> 
 *
 * @param {string[]} aLegendFormatString  new value for property <code>legendFormatString</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setLegendFormatString
 * @function
 */

/**
 * Getter for property <code>title</code>.
 * title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>title</code>
 * @public
 * @name sap.service.visualization.chart.Column#getTitle
 * @function
 */


/**
 * Setter for property <code>title</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sTitle  new value for property <code>title</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setTitle
 * @function
 */

/**
 * Getter for property <code>titleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>titleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Column#getTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>titleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sTitleHorizontalAlign  new value for property <code>titleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>subTitle</code>.
 * sub title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>subTitle</code>
 * @public
 * @name sap.service.visualization.chart.Column#getSubTitle
 * @function
 */


/**
 * Setter for property <code>subTitle</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sSubTitle  new value for property <code>subTitle</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setSubTitle
 * @function
 */

/**
 * Getter for property <code>subTitleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>subTitleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Column#getSubTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>subTitleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sSubTitleHorizontalAlign  new value for property <code>subTitleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setSubTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>showTitle</code>.
 * show/hide title.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showTitle</code>
 * @public
 * @name sap.service.visualization.chart.Column#getShowTitle
 * @function
 */


/**
 * Setter for property <code>showTitle</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowTitle  new value for property <code>showTitle</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setShowTitle
 * @function
 */

/**
 * Getter for property <code>titleFormatString</code>.
 * the format style for main title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>titleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Column#getTitleFormatString
 * @function
 */


/**
 * Setter for property <code>titleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sTitleFormatString  new value for property <code>titleFormatString</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setTitleFormatString
 * @function
 */

/**
 * Getter for property <code>subTitleFormatString</code>.
 * the format style for sub title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>subTitleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Column#getSubTitleFormatString
 * @function
 */


/**
 * Setter for property <code>subTitleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sSubTitleFormatString  new value for property <code>subTitleFormatString</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setSubTitleFormatString
 * @function
 */

/**
 * Getter for property <code>xAxis</code>.
 * for each object:{
 * showMajorTicks : true,// default value = undefined,show/hide major grid line and only works on value axis
 * showMinorTicks : true,// default value = false,show/hide minor grid line and only works on value axis. If showMajor is false, this option will not work
 * title : 'X Axis Title',
 * titleFormatString : '', //refer to legend format.
 * labelsFormatString : [''],//refer to legend format.
 * showTitle : true,//show or hide title showLabels : true, show or hide labels
 * gridLine : {
 * showMajor : false, //the major grid line
 * majorThickness : 1, the thickness for major tick.
 * showMinor : false, //the minor grid line.
 * minorThickness : 1, the thickness of minor tick.
 * showSub : true, //default value=false, show/hide sub grid line and only works on dimension axis }
 * }.
 * For major and minor ticks, they only works on value axis, it takes effect but the behavior is unexpected.
 * Set the grid line releated properties.For value axis, only showMajor and showMinor options work.
 * If showSub is set to true on value axis, it takes effect but the behavior is unexpected.
 * For dimension axis, only showSub option works.
 * If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.
 * 
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>xAxis</code>
 * @public
 * @name sap.service.visualization.chart.Column#getXAxis
 * @function
 */


/**
 * Setter for property <code>xAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aXAxis  new value for property <code>xAxis</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setXAxis
 * @function
 */

/**
 * Getter for property <code>yAxis</code>.
 * the same as xAxis.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>yAxis</code>
 * @public
 * @name sap.service.visualization.chart.Column#getYAxis
 * @function
 */


/**
 * Setter for property <code>yAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aYAxis  new value for property <code>yAxis</code>
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setYAxis
 * @function
 */

/**
 * Getter for aggregation <code>dataset</code>.<br/>
 * chart use this aggregation to get data feed.
 * 
 * @return {sap.service.visualization.dataset.SimpleDMDataset}
 * @public
 * @name sap.service.visualization.chart.Column#getDataset
 * @function
 */

/**
 * Setter for the aggregated <code>dataset</code>.
 * @param oDataset {sap.service.visualization.dataset.SimpleDMDataset}
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#setDataset
 * @function
 */


/**
 * Destroys  in the aggregation 
 * named <code>dataset</code>.
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#destroyDataset
 * @function
 */

/**
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on column. 
 *
 * @name sap.service.visualization.chart.Column#selectData
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'selectData' event of this <code>sap.service.visualization.chart.Column</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.service.visualization.chart.Column</code>.<br/> itself. 
 *  
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on column. 
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener=this] Context object to call the event handler with. Defaults to this <code>sap.service.visualization.chart.Column</code>.<br/> itself.
 *
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#attachSelectData
 * @function
 */


/**
 * Detach event handler <code>fnFunction</code> from the 'selectData' event of this <code>sap.service.visualization.chart.Column</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Column#detachSelectData
 * @function
 */


/**
 * Fire event selectData to attached listeners.

 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.service.visualization.chart.Column} <code>this</code> to allow method chaining
 * @protected
 * @name sap.service.visualization.chart.Column#fireSelectData
 * @function
 */

// Start of sap/service/visualization/chart/Column.js
/*!
 * @copyright@
 */





jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained


sap.service.visualization.chart.Column.prototype.isNumber = function(value) {
	var patt = /^(0|-?[1-9]\d*)$|^(0|-?[1-9]\d*)\.(\d+)$/;
	return patt.exec(value);
};

sap.service.visualization.chart.Column.prototype.setWidth = function(width) {

	this.setProperty("width", width);
	return this;
};

sap.service.visualization.chart.Column.prototype.setHeight = function(height) {

	this.setProperty("height", height);
	return this;
};


sap.service.visualization.chart.Column.prototype.setDeselectEnabled = function(deselectEnabled) {

	this.setProperty("deselectEnabled", deselectEnabled);

	if (this.column != undefined) {

		var chartOption = {
			selectbility : {
				deSelectable : (deselectEnabled != undefined) ? deselectEnabled : true
			}
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setSelectionMode = function(selectionMode) {

	this.setProperty("selectionMode", selectionMode);

	if (this.column != undefined) {
		if ((selectionMode != 'multiple') && (selectionMode != 'single')) {
			selectionMode = 'single';
		}
		var chartOption = {
			selectbility : {
				selectionMode : selectionMode,
			}

		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setTitleHorizontalAlign = function(titleHorizontalAlign) {

	this.setProperty("titleHorizontalAlign", titleHorizontalAlign);

	if (this.column != undefined) {

		var chartOption = {
			title : {
				main : {
					HorizontalAlign: titleHorizontalAlign
				}
			}
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setSubTitleHorizontalAlign = function(subTitleHorizontalAlign) {

	this.setProperty("subTitleHorizontalAlign", subTitleHorizontalAlign);

	if (this.column != undefined) {

		var chartOption = {
			title : {
				sub:{
					HorizontalAlign: subTitleHorizontalAlign
				}
			}
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};


sap.service.visualization.chart.Pie.prototype.setLegendDirection = function(legendDirection) {

	this.setProperty("legendDirection", legendDirection);

	if (this.pie != undefined) {
		var legendVerticalOffset = this.getLegendVerticalOffset();
		var legendHorizontalOffset = this.getLegendHorizontalOffset();
		if (legendDirection == 'left'||legendDirection == 'right') {
			legendVerticalOffset = (this.isNumber(legendVerticalOffset)) ? parseInt(legendVerticalOffset) : 0;;
		} else{
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset)) ? parseInt(legendHorizontalOffset) : 0;
		}

		var chartOption = {
			legend : {
				position : legendDirection,
				verticalOffset : legendVerticalOffset,
				horizontalOffset : legendHorizontalOffset
			}
		};

		this.pie.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendVerticalOffset = function(legendVerticalOffset) {

	this.setProperty("legendVerticalOffset", legendVerticalOffset);
	
	if (this.pie != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendVerticalOffset = 0;
		var chartOption;
		if (legendDirection == 'left'|| legendDirection=='right'){
			legendVerticalOffset = (this.isNumber(legendVerticalOffset))? parseInt(legendVerticalOffset) : 0;
			chartOption = {
				legend: {
					verticalOffset: legendVerticalOffset,
				}
			};
		}
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendHorizontalOffset = function(legendHorizontalOffset) {

	this.setProperty("legendHorizontalOffset", legendHorizontalOffset);
	
	if (this.pie != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendHorizontalOffset = 0;
		var chartOption;
		if (legendDirection == 'top'|| legendDirection=='left'){
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset))? parseInt(legendHorizontalOffset) : 0;
			chartOption = {
				legend: {
					horizontalOffset: legendHorizontalOffset,
				}
			};
		}
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Column.prototype.setLegendFirst = function(legendFirst) {

	this.setProperty("legendFirst", legendFirst);

	if (this.column != undefined) {

		var legendFirst = this.getLegendFirst();

		var chartOption = {
			layout : {
				legendFirst : (legendFirst != undefined) ? legendFirst : true
			}
		};
		this.column.updateProperties(chartOption);
	}

	return this;

};
sap.service.visualization.chart.Column.prototype.setDefaultSelectedItems = function(defaultSelectedItems) {

	this.setProperty("defaultSelectedItems", defaultSelectedItems);

	if (this.column != undefined) {

		var chartOption = {
			selectability : {
				defaultSelectedItems : defaultSelectedItems
			},
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setShowLegend = function(showLegend) {

	this.setProperty("showLegend", showLegend);

	if (this.column != undefined) {

		var chartOption = {
			legend : {
				visible : (showLegend != undefined) ? showLegend : true
			},
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setTitle = function(title) {

	this.setProperty("title", title);

	if (this.column != undefined) {

		var chartOption = {};
		if (title === "") {
			chartOption = {
				title : {
					main : {
						text : title
					},
					sub : {
						visible : false
					}
				}
			};
		} else {
			chartOption = {
				title : {
					main : {
						text : title
					}
				}
			};
		}
		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setSubTitle = function(subTitle) {

	this.setProperty("subTitle", subTitle);

	if (this.column != undefined) {

		var chartOption = {
			title : {
				sub : {
					text : subTitle
				}
			}
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setShowTitle = function(showTitle) {

	this.setProperty("showTitle", showTitle);

	if (this.column != undefined) {

		var chartOption = {
			title : {
				main : {
					visible : (showTitle != undefined) ? showTitle : true
				},
				sub : {
					visible : (showTitle != undefined) ? showTitle : true
				}
			}
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setLegendFormatString = function(legendFormatString) {
	
	this.setProperty("legendFormatString", legendFormatString);
	
	if (this.column != undefined) {
		
		var chartOption = {
			legend:{
				legendFormatString : legendFormatString
			}
		};
		
		this.column.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Column.prototype.setTitleFormatString = function(titleFormatString) {
	
	this.setProperty("titleFormatString", titleFormatString);
	
	if (this.column != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : titleFormatString
				}
			}
		};
		
		this.column.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Column.prototype.setSubTitleFormatString = function(subTitleFormatString) {
	
	this.setProperty("subTitleFormatString", subTitleFormatString);
	
	if (this.column != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : subTitleFormatString
				}
			}
		};
		
		this.column.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Column.prototype.setMeasures = function(measures) {

	this.setProperty("measures", measures);

	if (this.column != undefined) {

		var chartOption = {
			measures : measures
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setMeasures = function(measures) {

	this.setProperty("measures", measures);

	if (this.column != undefined) {

		var chartOption = {
			measures : measures
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setColumnMarker = function(barMarker) {

	this.setProperty("barMarker", barMarker);

	if (this.column != undefined) {

		var chartOption = {
			column : barMarker
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setXAxis = function(xAxis) {

	this.setProperty("xAxis", xAxis);

	if (this.column != undefined) {

		var chartOption = {
			xAxis : xAxis
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.setYAxis = function(yAxis) {

	this.setProperty("yAxis", yAxis);

	if (this.column != undefined) {

		var chartOption = {

			yAxis : [ {
				title : yAxis
			} ]
		};

		this.column.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Column.prototype.onAfterRendering = function(oEvent) {

	// Create chart after lazy load finishes
	var control = this;
	var renderTo = this.getId();	
	//aggregations
	var dataset = this.getDataset().dataset;
	//the prop only for column
	var option = new sap.service.visualization.ChartOption();
    var chartOption= option.getXYChartOption(control, 'Column');

    sap.riv.viz.Environment.initialize({
			'locale' : 'en_US',
			'log' : 'debug'
	});
   
    control.column = new sap.riv.viz.ColumnChart(jQuery.sap.byId(renderTo), chartOption, dataset);
	control.column.addListener('selectData', function(evt) {
		control.fireSelectData({
			Id : renderTo,
			Data : evt.data,
			EventName : evt.name
		});
	});

	sap.ui.getCore().attachThemeChanged(function(evt) {
		var themes = new sap.service.visualization.Themings();
		themes.applyCurrentThemeToXYChart(control,'Column');
	});
};
}; // end of sap.service.visualization.chart.Column
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.Combination') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.chart.Combination.
jQuery.sap.declare("sap.service.visualization.chart.Combination");

jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained


/**
 * Constructor for a new chart/Combination.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getWidth width} : sap.ui.core.CSSSize</li>
 * <li>{@link #getHeight height} : sap.ui.core.CSSSize</li>
 * <li>{@link #getDeselectEnabled deselectEnabled} : boolean (default: true)</li>
 * <li>{@link #getSelectionMode selectionMode} : string (default: 'single')</li>
 * <li>{@link #getDefaultSelectedItems defaultSelectedItems} : object[]</li>
 * <li>{@link #getLegendFirst legendFirst} : boolean (default: false)</li>
 * <li>{@link #getLegendDirection legendDirection} : string (default: 'right')</li>
 * <li>{@link #getLegendVerticalOffset legendVerticalOffset} : int (default: 0)</li>
 * <li>{@link #getLegendHorizontalOffset legendHorizontalOffset} : int (default: 0)</li>
 * <li>{@link #getMeasures measures} : object[]</li>
 * <li>{@link #getLineMarkerAndThickness lineMarkerAndThickness} : object (default: { lineMarkerSize: 10,lineThickness: 1})</li>
 * <li>{@link #getBarMarker barMarker} : object</li>
 * <li>{@link #getShowLegend showLegend} : boolean (default: true)</li>
 * <li>{@link #getLegendFormatString legendFormatString} : string[] (default: [''])</li>
 * <li>{@link #getTitle title} : string</li>
 * <li>{@link #getTitleHorizontalAlign titleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getSubTitle subTitle} : string</li>
 * <li>{@link #getSubTitleHorizontalAlign subTitleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getShowTitle showTitle} : boolean (default: true)</li>
 * <li>{@link #getTitleFormatString titleFormatString} : string (default: '')</li>
 * <li>{@link #getSubTitleFormatString subTitleFormatString} : string (default: '')</li>
 * <li>{@link #getXAxis xAxis} : object[]</li>
 * <li>{@link #getYAxis yAxis} : object[]</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getDataset dataset} : sap.service.visualization.dataset.SimpleDMDataset</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.service.visualization.chart.Combination#event:selectData selectData} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 

 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * 
 * Is used for show a Combination chart with feeding data. The API
 * provides data feeding, and a set of behavior of the combination chart.
 * 
 * @extends sap.ui.core.Control
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.chart.Combination
 */
sap.ui.core.Control.extend("sap.service.visualization.chart.Combination", { metadata : {

	// ---- object ----
	deprecated : true,

	// ---- control specific ----
	library : "sap.service.visualization",
	properties : {
		"width" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"height" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"deselectEnabled" : {type : "boolean", group : "Misc", defaultValue : true},
		"selectionMode" : {type : "string", group : "Misc", defaultValue : 'single'},
		"defaultSelectedItems" : {type : "object[]", group : "Misc", defaultValue : null},
		"legendFirst" : {type : "boolean", group : "Misc", defaultValue : false},
		"legendDirection" : {type : "string", group : "Misc", defaultValue : 'right'},
		"legendVerticalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"legendHorizontalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"measures" : {type : "object[]", group : "Misc", defaultValue : null},
		"lineMarkerAndThickness" : {type : "object", group : "Misc", defaultValue : { lineMarkerSize: 10,lineThickness: 1}},
		"barMarker" : {type : "object", group : "Misc", defaultValue : null},
		"showLegend" : {type : "boolean", group : "Misc", defaultValue : true},
		"legendFormatString" : {type : "string[]", group : "Misc", defaultValue : ['']},
		"title" : {type : "string", group : "Misc", defaultValue : null},
		"titleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"subTitle" : {type : "string", group : "Misc", defaultValue : null},
		"subTitleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"showTitle" : {type : "boolean", group : "Misc", defaultValue : true},
		"titleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"subTitleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"xAxis" : {type : "object[]", group : "Misc", defaultValue : null},
		"yAxis" : {type : "object[]", group : "Misc", defaultValue : null}
	},
	aggregations : {
    	"dataset" : {type : "sap.service.visualization.dataset.SimpleDMDataset", multiple : false}
	},
	events : {
		"selectData" : {}
	}
}});


/**
 * Creates a new subclass of class sap.service.visualization.chart.Combination with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.chart.Combination.extend
 * @function
 */

sap.service.visualization.chart.Combination.M_EVENTS = {'selectData':'selectData'};


/**
 * Getter for property <code>width</code>.
 * the chart width.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>width</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getWidth
 * @function
 */


/**
 * Setter for property <code>width</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sWidth  new value for property <code>width</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setWidth
 * @function
 */

/**
 * Getter for property <code>height</code>.
 * the chart height.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>height</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getHeight
 * @function
 */


/**
 * Setter for property <code>height</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sHeight  new value for property <code>height</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setHeight
 * @function
 */

/**
 * Getter for property <code>deselectEnabled</code>.
 * deselect enabled, first click the slice it will break away from the pie, then click other place the slice will be back.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>deselectEnabled</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getDeselectEnabled
 * @function
 */


/**
 * Setter for property <code>deselectEnabled</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bDeselectEnabled  new value for property <code>deselectEnabled</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setDeselectEnabled
 * @function
 */

/**
 * Getter for property <code>selectionMode</code>.
 * default value is false, single: you can just select one slice; none : no slice can be selected.
 *
 * Default value is <code>single</code>
 *
 * @return {string} the value of property <code>selectionMode</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getSelectionMode
 * @function
 */


/**
 * Setter for property <code>selectionMode</code>.
 *
 * Default value is <code>single</code> 
 *
 * @param {string} sSelectionMode  new value for property <code>selectionMode</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setSelectionMode
 * @function
 */

/**
 * Getter for property <code>defaultSelectedItems</code>.
 * the default selected item index. for each object should be like: {measureIndex: 0, dimensionItemIndex : 3}
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>defaultSelectedItems</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getDefaultSelectedItems
 * @function
 */


/**
 * Setter for property <code>defaultSelectedItems</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aDefaultSelectedItems  new value for property <code>defaultSelectedItems</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setDefaultSelectedItems
 * @function
 */

/**
 * Getter for property <code>legendFirst</code>.
 * first ensure to plot legend, then the chart area plot.
 *
 * Default value is <code>false</code>
 *
 * @return {boolean} the value of property <code>legendFirst</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getLegendFirst
 * @function
 */


/**
 * Setter for property <code>legendFirst</code>.
 *
 * Default value is <code>false</code> 
 *
 * @param {boolean} bLegendFirst  new value for property <code>legendFirst</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setLegendFirst
 * @function
 */

/**
 * Getter for property <code>legendDirection</code>.
 * the position of legend located at, left|right|top|bottom.
 *
 * Default value is <code>right</code>
 *
 * @return {string} the value of property <code>legendDirection</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getLegendDirection
 * @function
 */


/**
 * Setter for property <code>legendDirection</code>.
 *
 * Default value is <code>right</code> 
 *
 * @param {string} sLegendDirection  new value for property <code>legendDirection</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setLegendDirection
 * @function
 */

/**
 * Getter for property <code>legendVerticalOffset</code>.
 * the offset of the legend, used to adjust the position of legend.if left or right, positive, legend will move up,minus down.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendVerticalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getLegendVerticalOffset
 * @function
 */


/**
 * Setter for property <code>legendVerticalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendVerticalOffset  new value for property <code>legendVerticalOffset</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setLegendVerticalOffset
 * @function
 */

/**
 * Getter for property <code>legendHorizontalOffset</code>.
 * the offset of the legend, used to adjust the position of legend. if position top or bottom, positive, legend will move right, minus left.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendHorizontalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getLegendHorizontalOffset
 * @function
 */


/**
 * Setter for property <code>legendHorizontalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendHorizontalOffset  new value for property <code>legendHorizontalOffset</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setLegendHorizontalOffset
 * @function
 */

/**
 * Getter for property <code>measures</code>.
 * for each object:{type:bar|line, valueAxis: 0, Set valid index in your value axis (can be xAxis or yAxis),lineThickness: 3,//Set the line size of measure member.markerSymbol:circle,triangle,diamond,Set marker symbol of measure.}.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>measures</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getMeasures
 * @function
 */


/**
 * Setter for property <code>measures</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aMeasures  new value for property <code>measures</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setMeasures
 * @function
 */

/**
 * Getter for property <code>lineMarkerAndThickness</code>.
 * for each object:{ lineMarkerSize: 0, //It is for all measures in line chart. When it is too large, it can only draw limited size. The default value is undefined means that the size is auto-calculated by viz chart. lineThickness: It is for all measures in line chart}.
 *
 * Default value is <code>{ lineMarkerSize: 10,lineThickness: 1}</code>
 *
 * @return {object} the value of property <code>lineMarkerAndThickness</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getLineMarkerAndThickness
 * @function
 */


/**
 * Setter for property <code>lineMarkerAndThickness</code>.
 *
 * Default value is <code>{ lineMarkerSize: 10,lineThickness: 1}</code> 
 *
 * @param {object} oLineMarkerAndThickness  new value for property <code>lineMarkerAndThickness</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setLineMarkerAndThickness
 * @function
 */

/**
 * Getter for property <code>barMarker</code>.
 * for each object:{barMarkerSize//It is for all measures. When the bar size is too large, it only can draw the limited value. It can not be less than 0.}.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object} the value of property <code>barMarker</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getBarMarker
 * @function
 */


/**
 * Setter for property <code>barMarker</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object} oBarMarker  new value for property <code>barMarker</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setBarMarker
 * @function
 */

/**
 * Getter for property <code>showLegend</code>.
 * show/hide legend.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showLegend</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getShowLegend
 * @function
 */


/**
 * Setter for property <code>showLegend</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowLegend  new value for property <code>showLegend</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setShowLegend
 * @function
 */

/**
 * Getter for property <code>legendFormatString</code>.
 * the format style for legend. the format for legend number default is [''], numeric :'0.00', Currency: $"#,##0.00",percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'. If feed not enough then reuse the last one.
 *
 * Default value is <code>['']</code>
 *
 * @return {string[]} the value of property <code>legendFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getLegendFormatString
 * @function
 */


/**
 * Setter for property <code>legendFormatString</code>.
 *
 * Default value is <code>['']</code> 
 *
 * @param {string[]} aLegendFormatString  new value for property <code>legendFormatString</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setLegendFormatString
 * @function
 */

/**
 * Getter for property <code>title</code>.
 * title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>title</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getTitle
 * @function
 */


/**
 * Setter for property <code>title</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sTitle  new value for property <code>title</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setTitle
 * @function
 */

/**
 * Getter for property <code>titleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>titleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>titleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sTitleHorizontalAlign  new value for property <code>titleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>subTitle</code>.
 * sub title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>subTitle</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getSubTitle
 * @function
 */


/**
 * Setter for property <code>subTitle</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sSubTitle  new value for property <code>subTitle</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setSubTitle
 * @function
 */

/**
 * Getter for property <code>subTitleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>subTitleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getSubTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>subTitleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sSubTitleHorizontalAlign  new value for property <code>subTitleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setSubTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>showTitle</code>.
 * show/hide title.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showTitle</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getShowTitle
 * @function
 */


/**
 * Setter for property <code>showTitle</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowTitle  new value for property <code>showTitle</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setShowTitle
 * @function
 */

/**
 * Getter for property <code>titleFormatString</code>.
 * the format style for main title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>titleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getTitleFormatString
 * @function
 */


/**
 * Setter for property <code>titleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sTitleFormatString  new value for property <code>titleFormatString</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setTitleFormatString
 * @function
 */

/**
 * Getter for property <code>subTitleFormatString</code>.
 * the format style for sub title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>subTitleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getSubTitleFormatString
 * @function
 */


/**
 * Setter for property <code>subTitleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sSubTitleFormatString  new value for property <code>subTitleFormatString</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setSubTitleFormatString
 * @function
 */

/**
 * Getter for property <code>xAxis</code>.
 * for each object:{
 * showMajorTicks : true,// default value = undefined,show/hide major grid line and only works on value axis
 * showMinorTicks : true,// default value = false,show/hide minor grid line and only works on value axis. If showMajor is false, this option will not work
 * title : 'X Axis Title',
 * titleFormatString : '', //refer to legend number format.
 * labelsFormatString : [''],//refer to legend number format.
 * showTitle : true,//show or hide title showLabels : true, show or hide labels
 * gridLine : {
 * showMajor : false, //the major grid line
 * majorThickness : 1, the thickness for major tick.
 * showMinor : false, //the minor grid line.
 * minorThickness : 1, the thickness of minor tick.
 * showSub : true, //default value=false, show/hide sub grid line and only works on dimension axis }
 * }.
 * For major and minor ticks, they only works on value axis, it takes effect but the behavior is unexpected.
 * Set the grid line releated properties.For value axis, only showMajor and showMinor options work.
 * If showSub is set to true on value axis, it takes effect but the behavior is unexpected.
 * For dimension axis, only showSub option works.
 * If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.
 * 
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>xAxis</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getXAxis
 * @function
 */


/**
 * Setter for property <code>xAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aXAxis  new value for property <code>xAxis</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setXAxis
 * @function
 */

/**
 * Getter for property <code>yAxis</code>.
 * the same as xAxis.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>yAxis</code>
 * @public
 * @name sap.service.visualization.chart.Combination#getYAxis
 * @function
 */


/**
 * Setter for property <code>yAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aYAxis  new value for property <code>yAxis</code>
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setYAxis
 * @function
 */

/**
 * Getter for aggregation <code>dataset</code>.<br/>
 * chart use this aggregation to get data feed.
 * 
 * @return {sap.service.visualization.dataset.SimpleDMDataset}
 * @public
 * @name sap.service.visualization.chart.Combination#getDataset
 * @function
 */

/**
 * Setter for the aggregated <code>dataset</code>.
 * @param oDataset {sap.service.visualization.dataset.SimpleDMDataset}
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#setDataset
 * @function
 */


/**
 * Destroys  in the aggregation 
 * named <code>dataset</code>.
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#destroyDataset
 * @function
 */

/**
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on column. 
 *
 * @name sap.service.visualization.chart.Combination#selectData
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'selectData' event of this <code>sap.service.visualization.chart.Combination</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.service.visualization.chart.Combination</code>.<br/> itself. 
 *  
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on column. 
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener=this] Context object to call the event handler with. Defaults to this <code>sap.service.visualization.chart.Combination</code>.<br/> itself.
 *
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#attachSelectData
 * @function
 */


/**
 * Detach event handler <code>fnFunction</code> from the 'selectData' event of this <code>sap.service.visualization.chart.Combination</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Combination#detachSelectData
 * @function
 */


/**
 * Fire event selectData to attached listeners.

 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.service.visualization.chart.Combination} <code>this</code> to allow method chaining
 * @protected
 * @name sap.service.visualization.chart.Combination#fireSelectData
 * @function
 */

// Start of sap/service/visualization/chart/Combination.js
/*!
 * @copyright@
 */





jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained


sap.service.visualization.chart.Combination.prototype.isNumber = function(value) {
	var patt = /^(0|-?[1-9]\d*)$|^(0|-?[1-9]\d*)\.(\d+)$/;
	return patt.exec(value);
};

sap.service.visualization.chart.Combination.prototype.setWidth = function(width) {

	this.setProperty("width", width);
	return this;
};

sap.service.visualization.chart.Combination.prototype.setHeight = function(height) {

	this.setProperty("height", height);
	return this;
};

sap.service.visualization.chart.Combination.prototype.setDeselectEnabled = function(deselectEnabled) {

	this.setProperty("deselectEnabled", deselectEnabled);

	if (this.combination != undefined) {

		var chartOption = {
			selectbility : {
				deSelectable : (deselectEnabled != undefined) ? deselectEnabled : true
			}
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setSelectionMode = function(selectionMode) {

	this.setProperty("selectionMode", selectionMode);

	if (this.combination != undefined) {
		if ((selectionMode != 'multiple') && (selectionMode != 'single')) {
			selectionMode = 'single';
		}
		var chartOption = {
			selectbility : {
				selectionMode : selectionMode,
			}

		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setDefaultSelectedItems = function(defaultSelectedItems) {

	this.setProperty("defaultSelectedItems", defaultSelectedItems);

	if (this.combination != undefined) {

		var chartOption = {
			selectability : {
				defaultSelectedItems : defaultSelectedItems
			},
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setLegendDirection = function(legendDirection) {

	this.setProperty("legendDirection", legendDirection);

	if (this.combination != undefined) {
		var legendVerticalOffset = this.getLegendVerticalOffset();
		var legendHorizontalOffset = this.getLegendHorizontalOffset();
		if (legendDirection == 'left'||legendDirection == 'right') {
			legendVerticalOffset = (this.isNumber(legendVerticalOffset)) ? parseInt(legendVerticalOffset) : 0;;
		} else{
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset)) ? parseInt(legendHorizontalOffset) : 0;
		}

		var chartOption = {
			legend : {
				position : legendDirection,
				verticalOffset : legendVerticalOffset,
				horizontalOffset : legendHorizontalOffset
			}
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setLegendVerticalOffset = function(legendVerticalOffset) {

	this.setProperty("legendVerticalOffset", legendVerticalOffset);
	
	if (this.combination != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendVerticalOffset = 0;
		var chartOption;
		if (legendDirection == 'left'|| legendDirection=='right'){
			legendVerticalOffset = (this.isNumber(legendVerticalOffset))? parseInt(legendVerticalOffset) : 0;
			chartOption = {
				legend: {
					verticalOffset: legendVerticalOffset,
				}
			};
		}
		this.combination.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Combination.prototype.setLegendHorizontalOffset = function(legendHorizontalOffset) {

	this.setProperty("legendHorizontalOffset", legendHorizontalOffset);
	
	if (this.combination != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendHorizontalOffset = 0;
		var chartOption;
		if (legendDirection == 'top'|| legendDirection=='left'){
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset))? parseInt(legendHorizontalOffset) : 0;
			chartOption = {
				legend: {
					horizontalOffset: legendHorizontalOffset,
				}
			};
		}
		this.combination.updateProperties(chartOption);
	}
	
	return this;
};
sap.service.visualization.chart.Combination.prototype.setLegendFirst = function(legendFirst) {

	this.setProperty("legendFirst", legendFirst);

	if (this.combination != undefined) {
	
		var chartOption = {
			layout : {
				legendFirst : (legendFirst != undefined) ? legendFirst : true
			}
		};
		this.combination.updateProperties(chartOption);
	}

	return this;

};

sap.service.visualization.chart.Combination.prototype.setLegendFormatString = function(legendFormatString) {
	
	this.setProperty("legendFormatString", legendFormatString);
	
	if (this.combination != undefined) {
		
		var chartOption = {
			legend:{
				legendFormatString : legendFormatString
			}
		};
		
		this.combination.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Combination.prototype.setTitleFormatString = function(titleFormatString) {
	
	this.setProperty("titleFormatString", titleFormatString);
	
	if (this.combination != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : titleFormatString
				}
			}
		};
		
		this.combination.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Combination.prototype.setSubTitleFormatString = function(subTitleFormatString) {
	
	this.setProperty("subTitleFormatString", subTitleFormatString);
	
	if (this.combination != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : subTitleFormatString
				}
			}
		};
		
		this.combination.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Combination.prototype.setShowLegend = function(showLegend) {

	this.setProperty("showLegend", showLegend);

	if (this.combination != undefined) {

		var chartOption = {
			legend : {
				visible : (showLegend != undefined) ? showLegend : true
			},
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setTitle = function(title) {

	this.setProperty("title", title);

	if (this.combination != undefined) {

		var chartOption = {
			title : {
				main : {
					text : title
				}
			}
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setSubTitle = function(subTitle) {

	this.setProperty("subTitle", subTitle);

	if (this.combination != undefined) {

		var chartOption = {
			title : {
				sub : {
					text : subTitle
				}
			}
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setShowTitle = function(showTitle) {

	this.setProperty("showTitle", showTitle);

	if (this.combination != undefined) {

		var chartOption = {
			title:{
				main:{
					visible: showTitle
				},
				sub:{
					visible: showTitle
				}
			}
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setXAxis = function(xAxis) {

	this.setProperty("xAxis", xAxis);

	if (this.combination != undefined) {

		var chartOption = {
			xAxis :  xAxis
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setYAxis = function(yAxis) {

	this.setProperty("yAxis", yAxis);

	if (this.combination != undefined) {

		var chartOption = {
			yAxis : yAxis
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setMeasures = function(measures) {

	this.setProperty("measures", measures);

	if (this.combination != undefined) {

		var chartOption = {
				measures : measures
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setLineMarkerAndThickness = function(lineMarkerAndThickness) {

	this.setProperty("lineMarkerAndThickness", lineMarkerAndThickness);

	if (this.combination != undefined) {

		var chartOption = {
			line : lineMarkerAndThickness
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setBarMarker = function(barMarker) {

	this.setProperty("barMarker", barMarker);

	if (this.combination != undefined) {

		var chartOption = {
			bar : barMarker
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setTitleHorizontalAlign = function(titleHorizontalAlign) {

	this.setProperty("titleHorizontalAlign", titleHorizontalAlign);

	if (this.combination != undefined) {

		var chartOption = {
			title : {
				main : {
					HorizontalAlign: titleHorizontalAlign
				}
			}
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.setSubTitleHorizontalAlign = function(subTitleHorizontalAlign) {

	this.setProperty("subTitleHorizontalAlign", subTitleHorizontalAlign);

	if (this.combination != undefined) {

		var chartOption = {
			title : {
				sub:{
					HorizontalAlign: subTitleHorizontalAlign
				}
			}
		};

		this.combination.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Combination.prototype.onAfterRendering = function(oEvent) {

	var control = this;
	var renderTo = this.getId();	
	//aggregations
	var dataset = this.getDataset().dataset;
	//composite
	var option = new sap.service.visualization.ChartOption();
    var chartOption= option.getXYChartOption(control, 'Combination');
    
    sap.riv.viz.Environment.initialize({
			'locale' : 'en_US',
			'log' : 'debug'
	});
   
    control.combination = new sap.riv.viz.CombinationChart(jQuery.sap.byId(renderTo), chartOption, dataset);
	control.combination.addListener('selectData', function(evt) {
		control.fireSelectData({
			Id : renderTo,
			Data : evt.data,
			EventName : evt.name
		});
	});
	
	sap.ui.getCore().attachThemeChanged(function(evt) {
		var themes = new sap.service.visualization.Themings();
		themes.applyCurrentThemeToXYChart(control,'Combination');
	});
};
}; // end of sap.service.visualization.chart.Combination
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.Line') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.chart.Line.
jQuery.sap.declare("sap.service.visualization.chart.Line");

jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained


/**
 * Constructor for a new chart/Line.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getWidth width} : sap.ui.core.CSSSize</li>
 * <li>{@link #getHeight height} : sap.ui.core.CSSSize</li>
 * <li>{@link #getDeselectEnabled deselectEnabled} : boolean (default: true)</li>
 * <li>{@link #getSelectionMode selectionMode} : string (default: 'single')</li>
 * <li>{@link #getDefaultSelectedItems defaultSelectedItems} : object[]</li>
 * <li>{@link #getLegendFirst legendFirst} : boolean (default: false)</li>
 * <li>{@link #getLegendDirection legendDirection} : string (default: 'right')</li>
 * <li>{@link #getLegendVerticalOffset legendVerticalOffset} : int (default: 0)</li>
 * <li>{@link #getLegendHorizontalOffset legendHorizontalOffset} : int (default: 0)</li>
 * <li>{@link #getMeasures measures} : object[]</li>
 * <li>{@link #getLineMarkerAndThickness lineMarkerAndThickness} : object (default: { lineMarkerSize: 10,lineThickness: 1})</li>
 * <li>{@link #getShowLegend showLegend} : boolean (default: true)</li>
 * <li>{@link #getLegendFormatString legendFormatString} : string[] (default: [''])</li>
 * <li>{@link #getTitle title} : string</li>
 * <li>{@link #getTitleHorizontalAlign titleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getSubTitle subTitle} : string</li>
 * <li>{@link #getSubTitleHorizontalAlign subTitleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getShowTitle showTitle} : boolean (default: true)</li>
 * <li>{@link #getTitleFormatString titleFormatString} : string (default: '')</li>
 * <li>{@link #getSubTitleFormatString subTitleFormatString} : string (default: '')</li>
 * <li>{@link #getXAxis xAxis} : object[]</li>
 * <li>{@link #getYAxis yAxis} : object[]</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getDataset dataset} : sap.service.visualization.dataset.SimpleDMDataset</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.service.visualization.chart.Line#event:selectData selectData} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 

 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * 
 * Is used for show a Line chart with feeding data. The API
 * provides data feeding, and a set of behavior of the line chart.
 * 
 * @extends sap.ui.core.Control
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.chart.Line
 */
sap.ui.core.Control.extend("sap.service.visualization.chart.Line", { metadata : {

	// ---- object ----
	deprecated : true,

	// ---- control specific ----
	library : "sap.service.visualization",
	properties : {
		"width" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"height" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"deselectEnabled" : {type : "boolean", group : "Misc", defaultValue : true},
		"selectionMode" : {type : "string", group : "Misc", defaultValue : 'single'},
		"defaultSelectedItems" : {type : "object[]", group : "Misc", defaultValue : null},
		"legendFirst" : {type : "boolean", group : "Misc", defaultValue : false},
		"legendDirection" : {type : "string", group : "Misc", defaultValue : 'right'},
		"legendVerticalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"legendHorizontalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"measures" : {type : "object[]", group : "Misc", defaultValue : null},
		"lineMarkerAndThickness" : {type : "object", group : "Misc", defaultValue : { lineMarkerSize: 10,lineThickness: 1}},
		"showLegend" : {type : "boolean", group : "Misc", defaultValue : true},
		"legendFormatString" : {type : "string[]", group : "Misc", defaultValue : ['']},
		"title" : {type : "string", group : "Misc", defaultValue : null},
		"titleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"subTitle" : {type : "string", group : "Misc", defaultValue : null},
		"subTitleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"showTitle" : {type : "boolean", group : "Misc", defaultValue : true},
		"titleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"subTitleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"xAxis" : {type : "object[]", group : "Misc", defaultValue : null},
		"yAxis" : {type : "object[]", group : "Misc", defaultValue : null}
	},
	aggregations : {
    	"dataset" : {type : "sap.service.visualization.dataset.SimpleDMDataset", multiple : false}
	},
	events : {
		"selectData" : {}
	}
}});


/**
 * Creates a new subclass of class sap.service.visualization.chart.Line with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.chart.Line.extend
 * @function
 */

sap.service.visualization.chart.Line.M_EVENTS = {'selectData':'selectData'};


/**
 * Getter for property <code>width</code>.
 * the chart width.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>width</code>
 * @public
 * @name sap.service.visualization.chart.Line#getWidth
 * @function
 */


/**
 * Setter for property <code>width</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sWidth  new value for property <code>width</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setWidth
 * @function
 */

/**
 * Getter for property <code>height</code>.
 * the chart height.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>height</code>
 * @public
 * @name sap.service.visualization.chart.Line#getHeight
 * @function
 */


/**
 * Setter for property <code>height</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sHeight  new value for property <code>height</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setHeight
 * @function
 */

/**
 * Getter for property <code>deselectEnabled</code>.
 * deselect enabled, first click the slice it will break away from the pie, then click other place the slice will be back.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>deselectEnabled</code>
 * @public
 * @name sap.service.visualization.chart.Line#getDeselectEnabled
 * @function
 */


/**
 * Setter for property <code>deselectEnabled</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bDeselectEnabled  new value for property <code>deselectEnabled</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setDeselectEnabled
 * @function
 */

/**
 * Getter for property <code>selectionMode</code>.
 * default value is false, single: you can just select one slice; none : no slice can be selected.
 *
 * Default value is <code>single</code>
 *
 * @return {string} the value of property <code>selectionMode</code>
 * @public
 * @name sap.service.visualization.chart.Line#getSelectionMode
 * @function
 */


/**
 * Setter for property <code>selectionMode</code>.
 *
 * Default value is <code>single</code> 
 *
 * @param {string} sSelectionMode  new value for property <code>selectionMode</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setSelectionMode
 * @function
 */

/**
 * Getter for property <code>defaultSelectedItems</code>.
 * the default selected item index. for each object should be like: {measureIndex: 0, dimensionItemIndex : 3}
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>defaultSelectedItems</code>
 * @public
 * @name sap.service.visualization.chart.Line#getDefaultSelectedItems
 * @function
 */


/**
 * Setter for property <code>defaultSelectedItems</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aDefaultSelectedItems  new value for property <code>defaultSelectedItems</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setDefaultSelectedItems
 * @function
 */

/**
 * Getter for property <code>legendFirst</code>.
 * first ensure to plot legend, then the chart area plot.
 *
 * Default value is <code>false</code>
 *
 * @return {boolean} the value of property <code>legendFirst</code>
 * @public
 * @name sap.service.visualization.chart.Line#getLegendFirst
 * @function
 */


/**
 * Setter for property <code>legendFirst</code>.
 *
 * Default value is <code>false</code> 
 *
 * @param {boolean} bLegendFirst  new value for property <code>legendFirst</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setLegendFirst
 * @function
 */

/**
 * Getter for property <code>legendDirection</code>.
 * the position of legend located at, left|right|top|bottom.
 *
 * Default value is <code>right</code>
 *
 * @return {string} the value of property <code>legendDirection</code>
 * @public
 * @name sap.service.visualization.chart.Line#getLegendDirection
 * @function
 */


/**
 * Setter for property <code>legendDirection</code>.
 *
 * Default value is <code>right</code> 
 *
 * @param {string} sLegendDirection  new value for property <code>legendDirection</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setLegendDirection
 * @function
 */

/**
 * Getter for property <code>legendVerticalOffset</code>.
 * the offset of the legend, used to adjust the position of legend.if left or right, positive, legend will move up,minus down.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendVerticalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Line#getLegendVerticalOffset
 * @function
 */


/**
 * Setter for property <code>legendVerticalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendVerticalOffset  new value for property <code>legendVerticalOffset</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setLegendVerticalOffset
 * @function
 */

/**
 * Getter for property <code>legendHorizontalOffset</code>.
 * the offset of the legend, used to adjust the position of legend. if position top or bottom, positive, legend will move right, minus left.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendHorizontalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Line#getLegendHorizontalOffset
 * @function
 */


/**
 * Setter for property <code>legendHorizontalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendHorizontalOffset  new value for property <code>legendHorizontalOffset</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setLegendHorizontalOffset
 * @function
 */

/**
 * Getter for property <code>measures</code>.
 * for each object:{ valueAxis: 0, should be valid index in your value axis (can be xAxis or yAxis),markerSymbol:circle,// circle|| triangle||diamond, lineThickness: 3, // Set the line size of measure member.}.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>measures</code>
 * @public
 * @name sap.service.visualization.chart.Line#getMeasures
 * @function
 */


/**
 * Setter for property <code>measures</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aMeasures  new value for property <code>measures</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setMeasures
 * @function
 */

/**
 * Getter for property <code>lineMarkerAndThickness</code>.
 * for each object:{ lineMarkerSize: 0,It is for all measures in line chart. When it is too large, it can only draw limited size. The default value is undefined means that the size is auto-calculated by viz chart. lineThickness: It is for all measures in line chart.}.
 *
 * Default value is <code>{ lineMarkerSize: 10,lineThickness: 1}</code>
 *
 * @return {object} the value of property <code>lineMarkerAndThickness</code>
 * @public
 * @name sap.service.visualization.chart.Line#getLineMarkerAndThickness
 * @function
 */


/**
 * Setter for property <code>lineMarkerAndThickness</code>.
 *
 * Default value is <code>{ lineMarkerSize: 10,lineThickness: 1}</code> 
 *
 * @param {object} oLineMarkerAndThickness  new value for property <code>lineMarkerAndThickness</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setLineMarkerAndThickness
 * @function
 */

/**
 * Getter for property <code>showLegend</code>.
 * show/hide legend.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showLegend</code>
 * @public
 * @name sap.service.visualization.chart.Line#getShowLegend
 * @function
 */


/**
 * Setter for property <code>showLegend</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowLegend  new value for property <code>showLegend</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setShowLegend
 * @function
 */

/**
 * Getter for property <code>legendFormatString</code>.
 * the format style for legend. the format for title number default is [''], numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'. If feed not enough then reuse the last one.
 *
 * Default value is <code>['']</code>
 *
 * @return {string[]} the value of property <code>legendFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Line#getLegendFormatString
 * @function
 */


/**
 * Setter for property <code>legendFormatString</code>.
 *
 * Default value is <code>['']</code> 
 *
 * @param {string[]} aLegendFormatString  new value for property <code>legendFormatString</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setLegendFormatString
 * @function
 */

/**
 * Getter for property <code>title</code>.
 * title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>title</code>
 * @public
 * @name sap.service.visualization.chart.Line#getTitle
 * @function
 */


/**
 * Setter for property <code>title</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sTitle  new value for property <code>title</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setTitle
 * @function
 */

/**
 * Getter for property <code>titleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>titleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Line#getTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>titleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sTitleHorizontalAlign  new value for property <code>titleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>subTitle</code>.
 * sub title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>subTitle</code>
 * @public
 * @name sap.service.visualization.chart.Line#getSubTitle
 * @function
 */


/**
 * Setter for property <code>subTitle</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sSubTitle  new value for property <code>subTitle</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setSubTitle
 * @function
 */

/**
 * Getter for property <code>subTitleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>subTitleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Line#getSubTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>subTitleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sSubTitleHorizontalAlign  new value for property <code>subTitleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setSubTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>showTitle</code>.
 * show/hide title.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showTitle</code>
 * @public
 * @name sap.service.visualization.chart.Line#getShowTitle
 * @function
 */


/**
 * Setter for property <code>showTitle</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowTitle  new value for property <code>showTitle</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setShowTitle
 * @function
 */

/**
 * Getter for property <code>titleFormatString</code>.
 * the format style for main title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>titleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Line#getTitleFormatString
 * @function
 */


/**
 * Setter for property <code>titleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sTitleFormatString  new value for property <code>titleFormatString</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setTitleFormatString
 * @function
 */

/**
 * Getter for property <code>subTitleFormatString</code>.
 * the format style for sub title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>subTitleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Line#getSubTitleFormatString
 * @function
 */


/**
 * Setter for property <code>subTitleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sSubTitleFormatString  new value for property <code>subTitleFormatString</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setSubTitleFormatString
 * @function
 */

/**
 * Getter for property <code>xAxis</code>.
 * for each object:{
 * showMajorTicks : true,// default value = undefined,show/hide major grid line and only works on value axis
 * showMinorTicks : true,// default value = false,show/hide minor grid line and only works on value axis. If showMajor is false, this option will not work
 * title : 'X Axis Title',
 * titleFormatString : '', //refer to legend number format.
 * labelsFormatString : [''],//refer to legend number format.
 * showTitle : true,//show or hide title showLabels : true, show or hide labels
 * gridLine : {
 * showMajor : false, //the major grid line
 * majorThickness : 1, the thickness for major tick.
 * showMinor : false, //the minor grid line.
 * minorThickness : 1, the thickness of minor tick.
 * showSub : true, //default value=false, show/hide sub grid line and only works on dimension axis }
 * }.
 * For major and minor ticks, they only works on value axis, it takes effect but the behavior is unexpected.
 * Set the grid line releated properties.For value axis, only showMajor and showMinor options work.
 * If showSub is set to true on value axis, it takes effect but the behavior is unexpected.
 * For dimension axis, only showSub option works.
 * If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.
 * 
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>xAxis</code>
 * @public
 * @name sap.service.visualization.chart.Line#getXAxis
 * @function
 */


/**
 * Setter for property <code>xAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aXAxis  new value for property <code>xAxis</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setXAxis
 * @function
 */

/**
 * Getter for property <code>yAxis</code>.
 * the same as xAxis.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>yAxis</code>
 * @public
 * @name sap.service.visualization.chart.Line#getYAxis
 * @function
 */


/**
 * Setter for property <code>yAxis</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aYAxis  new value for property <code>yAxis</code>
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setYAxis
 * @function
 */

/**
 * Getter for aggregation <code>dataset</code>.<br/>
 * chart use this aggregation to get data feed.
 * 
 * @return {sap.service.visualization.dataset.SimpleDMDataset}
 * @public
 * @name sap.service.visualization.chart.Line#getDataset
 * @function
 */

/**
 * Setter for the aggregated <code>dataset</code>.
 * @param oDataset {sap.service.visualization.dataset.SimpleDMDataset}
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#setDataset
 * @function
 */


/**
 * Destroys  in the aggregation 
 * named <code>dataset</code>.
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#destroyDataset
 * @function
 */

/**
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on column. 
 *
 * @name sap.service.visualization.chart.Line#selectData
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'selectData' event of this <code>sap.service.visualization.chart.Line</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.service.visualization.chart.Line</code>.<br/> itself. 
 *  
 * this event is bind to chart, the chart will response all the information of the rectangle of you selected on column. 
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener=this] Context object to call the event handler with. Defaults to this <code>sap.service.visualization.chart.Line</code>.<br/> itself.
 *
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#attachSelectData
 * @function
 */


/**
 * Detach event handler <code>fnFunction</code> from the 'selectData' event of this <code>sap.service.visualization.chart.Line</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Line#detachSelectData
 * @function
 */


/**
 * Fire event selectData to attached listeners.

 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.service.visualization.chart.Line} <code>this</code> to allow method chaining
 * @protected
 * @name sap.service.visualization.chart.Line#fireSelectData
 * @function
 */

// Start of sap/service/visualization/chart/Line.js
/*!
 * @copyright@
 */





jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained


sap.service.visualization.chart.Line.prototype.isNumber = function(value) {
	var patt = /^(0|-?[1-9]\d*)$|^(0|-?[1-9]\d*)\.(\d+)$/;
	return patt.exec(value);
};

sap.service.visualization.chart.Line.prototype.setWidth = function(width) {

	this.setProperty("width", width);
	return this;
};

sap.service.visualization.chart.Line.prototype.setHeight = function(height) {

	this.setProperty("height", height);
	return this;
};

sap.service.visualization.chart.Line.prototype.setDeselectEnabled = function(deselectEnabled) {

	this.setProperty("deselectEnabled", deselectEnabled);

	if (this.line != undefined) {

		var chartOption = {
			selectbility : {
				deSelectable : (deselectEnabled != undefined) ? deselectEnabled : true
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setSelectionMode = function(selectionMode) {

	this.setProperty("selectionMode", selectionMode);

	if (this.line != undefined) {
		if ((selectionMode != 'multiple') && (selectionMode != 'single')) {
			selectionMode = 'single';
		}
		var chartOption = {
			selectbility : {
				selectionMode : selectionMode,
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setDefaultSelectedItems = function(defaultSelectedItems) {

	this.setProperty("defaultSelectedItems", defaultSelectedItems);

	if (this.line != undefined) {

		var chartOption = {
			selectability : {
				defaultSelectedItems : defaultSelectedItems
			},
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setLegendDirection = function(legendDirection) {

	this.setProperty("legendDirection", legendDirection);

	if (this.line != undefined) {
		var legendVerticalOffset = this.getLegendVerticalOffset();
		var legendHorizontalOffset = this.getLegendHorizontalOffset();
		if (legendDirection == 'left'||legendDirection == 'right') {
			legendVerticalOffset = (this.isNumber(legendVerticalOffset)) ? parseInt(legendVerticalOffset) : 0;;
		} else{
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset)) ? parseInt(legendHorizontalOffset) : 0;
		}

		var chartOption = {
			legend : {
				position : legendDirection,
				verticalOffset : legendVerticalOffset,
				horizontalOffset : legendHorizontalOffset
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setLegendVerticalOffset = function(legendVerticalOffset) {

	this.setProperty("legendVerticalOffset", legendVerticalOffset);
	
	if (this.line != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendVerticalOffset = 0;
		var chartOption;
		if (legendDirection == 'left'|| legendDirection=='right'){
			legendVerticalOffset = (this.isNumber(legendVerticalOffset))? parseInt(legendVerticalOffset) : 0;
			chartOption = {
				legend: {
					verticalOffset: legendVerticalOffset,
				}
			};
		}
		this.line.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Line.prototype.setLegendHorizontalOffset = function(legendHorizontalOffset) {

	this.setProperty("legendHorizontalOffset", legendHorizontalOffset);
	
	if (this.line != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendHorizontalOffset = 0;
		var chartOption;
		if (legendDirection == 'top'|| legendDirection=='left'){
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset))? parseInt(legendHorizontalOffset) : 0;
			chartOption = {
				legend: {
					horizontalOffset: legendHorizontalOffset,
				}
			};
		}
		this.line.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Line.prototype.setLegendFirst = function(legendFirst) {

	this.setProperty("legendFirst", legendFirst);

	if (this.line != undefined) {

		var legendFirst = this.getLegendFirst();

		var chartOption = {
			layout : {
				legendFirst : (legendFirst != undefined) ? legendFirst : true
			}
		};
		this.line.updateProperties(chartOption);
	}

	return this;

};

sap.service.visualization.chart.Line.prototype.setLegendFormatString = function(legendFormatString) {
	
	this.setProperty("legendFormatString", legendFormatString);
	
	if (this.line != undefined) {
		
		var chartOption = {
			legend:{
				legendFormatString : legendFormatString
			}
		};
		
		this.line.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Line.prototype.setTitleFormatString = function(titleFormatString) {
	
	this.setProperty("titleFormatString", titleFormatString);
	
	if (this.line != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : titleFormatString
				}
			}
		};
		
		this.line.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Line.prototype.setSubTitleFormatString = function(subTitleFormatString) {
	
	this.setProperty("subTitleFormatString", subTitleFormatString);
	
	if (this.line != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : subTitleFormatString
				}
			}
		};
		
		this.line.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Line.prototype.setMeasures = function(measures) {

	this.setProperty("measures", measures);

	if (this.line != undefined) {

		var chartOption = {
			measures : measures
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setLineMarkerAndThickness = function(lineMarkerAndThickness) {

	this.setProperty("lineMarkerAndThickness", lineMarkerAndThickness);

	if (this.line != undefined) {

		var chartOption = {
			line : lineMarkerAndThickness
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setShowLegend = function(showLegend) {

	this.setProperty("showLegend", showLegend);

	if (this.line != undefined) {

		var chartOption = {
			legend : {
				visible : (showLegend != undefined) ? showLegend : true
			},
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setTitle = function(title) {

	this.setProperty("title", title);

	if (this.line != undefined) {

		var chartOption = {
			title : {
				main : {
					text : title
				}
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setSubTitle = function(subTitle) {

	this.setProperty("subTitle", subTitle);

	if (this.line != undefined) {

		var chartOption = {
			title : {
				sub : {
					text : subTitle
				}
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};


sap.service.visualization.chart.Line.prototype.setShowTitle = function(showTitle) {

	this.setProperty("showTitle", showTitle);

	if (this.line != undefined) {

		var chartOption = {
			title:{
				main:{
					visible: showTitle
				},
				sub:{
					visible: showTitle
				}
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};


sap.service.visualization.chart.Line.prototype.setXAxis = function(xAxis) {

	this.setProperty("xAxis", xAxis);

	if (this.line != undefined) {

		var chartOption = {

			xAxis : xAxis
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setYAxis = function(yAxis) {

	this.setProperty("yAxis", yAxis);

	if (this.line != undefined) {

		var chartOption = {

			yAxis : yAxis
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setTitleHorizontalAlign = function(titleHorizontalAlign) {

	this.setProperty("titleHorizontalAlign", titleHorizontalAlign);

	if (this.line != undefined) {

		var chartOption = {
			title : {
				main : {
					HorizontalAlign: titleHorizontalAlign
				}
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.setSubTitleHorizontalAlign = function(subTitleHorizontalAlign) {

	this.setProperty("subTitleHorizontalAlign", subTitleHorizontalAlign);

	if (this.line != undefined) {

		var chartOption = {
			title : {
				sub:{
					HorizontalAlign: subTitleHorizontalAlign
				}
			}
		};

		this.line.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Line.prototype.onAfterRendering = function(oEvent) {

	var control = this;
	var renderTo = this.getId();	
	//aggregations
	var dataset = this.getDataset().dataset;
    //get line options for line chart
    var option = new sap.service.visualization.ChartOption();
    var chartOption= option.getXYChartOption(control, 'Line');
    
    sap.riv.viz.Environment.initialize({
			'locale' : 'en_US',
			'log' : 'debug'
	});
   
    control.line = new sap.riv.viz.LineChart(jQuery.sap.byId(renderTo), chartOption, dataset);
	control.line.addListener('selectData', function(evt) {
		control.fireSelectData({
			Id : renderTo,
			Data : evt.data,
			EventName : evt.name
		});
	});

	sap.ui.getCore().attachThemeChanged(function(evt) {
		var themes = new sap.service.visualization.Themings();
		themes.applyCurrentThemeToXYChart(control,'Line');
	});
};
}; // end of sap.service.visualization.chart.Line
if ( !jQuery.sap.isDeclared('sap.service.visualization.chart.Pie') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.chart.Pie.
jQuery.sap.declare("sap.service.visualization.chart.Pie");

jQuery.sap.require('sap.ui.core.Control'); // unlisted dependency retained


/**
 * Constructor for a new chart/Pie.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getWidth width} : sap.ui.core.CSSSize</li>
 * <li>{@link #getHeight height} : sap.ui.core.CSSSize</li>
 * <li>{@link #getAllDeSelectable allDeSelectable} : boolean (default: true)</li>
 * <li>{@link #getAllSelectable allSelectable} : boolean (default: true)</li>
 * <li>{@link #getSelectionMode selectionMode} : string (default: 'single')</li>
 * <li>{@link #getLegendFirst legendFirst} : boolean (default: false)</li>
 * <li>{@link #getLegendDirection legendDirection} : string (default: 'right')</li>
 * <li>{@link #getLegendVerticalOffset legendVerticalOffset} : int (default: 0)</li>
 * <li>{@link #getLegendHorizontalOffset legendHorizontalOffset} : int (default: 0)</li>
 * <li>{@link #getDefaultSelectedSliceIndexes defaultSelectedSliceIndexes} : int[]</li>
 * <li>{@link #getSectorColors sectorColors} : string[] (default: ['#748CB2','#9CC677','#EACF5E','#F9AD79','#D16A7C','#8873A2','#3A95B3','#B6D949','#FDD36C','#F47958','#A65084','#0063B1','#0DA841','#FCB71D','#F05620','#B22D6E','#3C368E','\'#8FB2CF'])</li>
 * <li>{@link #getShowLegend showLegend} : boolean (default: true)</li>
 * <li>{@link #getLegendFormatString legendFormatString} : string[] (default: [''])</li>
 * <li>{@link #getTitle title} : string</li>
 * <li>{@link #getTitleHorizontalAlign titleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getSubTitle subTitle} : string</li>
 * <li>{@link #getSubTitleHorizontalAlign subTitleHorizontalAlign} : string (default: 'center')</li>
 * <li>{@link #getShowTitle showTitle} : boolean (default: true)</li>
 * <li>{@link #getTitleFormatString titleFormatString} : string (default: '')</li>
 * <li>{@link #getSubTitleFormatString subTitleFormatString} : string (default: '')</li>
 * <li>{@link #getTooltipTextFormatString tooltipTextFormatString} : string[]</li>
 * <li>{@link #getTooltipMainValueFormatString tooltipMainValueFormatString} : string[]</li>
 * <li>{@link #getTooltipSubValueFormatString tooltipSubValueFormatString} : string[]</li>
 * <li>{@link #getPieType pieType} : string (default: 'pie')</li></ul>
 * </li>
 * <li>Aggregations
 * <ul>
 * <li>{@link #getDataset dataset} : sap.service.visualization.dataset.SimpleDMDataset</li></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul>
 * <li>{@link sap.service.visualization.chart.Pie#event:selectData selectData} : fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]</li></ul>
 * </li>
 * </ul> 

 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * 
 * Is used for show a Pie chart with feeding data. The API
 * provides data feeding, and a set of behavior of the pie chart.
 * 
 * @extends sap.ui.core.Control
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.chart.Pie
 */
sap.ui.core.Control.extend("sap.service.visualization.chart.Pie", { metadata : {

	// ---- object ----
	deprecated : true,

	// ---- control specific ----
	library : "sap.service.visualization",
	properties : {
		"width" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"height" : {type : "sap.ui.core.CSSSize", group : "Misc", defaultValue : null},
		"allDeSelectable" : {type : "boolean", group : "Misc", defaultValue : true},
		"allSelectable" : {type : "boolean", group : "Misc", defaultValue : true},
		"selectionMode" : {type : "string", group : "Misc", defaultValue : 'single'},
		"legendFirst" : {type : "boolean", group : "Misc", defaultValue : false},
		"legendDirection" : {type : "string", group : "Misc", defaultValue : 'right'},
		"legendVerticalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"legendHorizontalOffset" : {type : "int", group : "Misc", defaultValue : 0},
		"defaultSelectedSliceIndexes" : {type : "int[]", group : "Misc", defaultValue : null},
		"sectorColors" : {type : "string[]", group : "Misc", defaultValue : ['#748CB2','#9CC677','#EACF5E','#F9AD79','#D16A7C','#8873A2','#3A95B3','#B6D949','#FDD36C','#F47958','#A65084','#0063B1','#0DA841','#FCB71D','#F05620','#B22D6E','#3C368E','\'#8FB2CF']},
		"showLegend" : {type : "boolean", group : "Misc", defaultValue : true},
		"legendFormatString" : {type : "string[]", group : "Misc", defaultValue : ['']},
		"title" : {type : "string", group : "Misc", defaultValue : null},
		"titleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"subTitle" : {type : "string", group : "Misc", defaultValue : null},
		"subTitleHorizontalAlign" : {type : "string", group : "Misc", defaultValue : 'center'},
		"showTitle" : {type : "boolean", group : "Misc", defaultValue : true},
		"titleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"subTitleFormatString" : {type : "string", group : "Misc", defaultValue : ''},
		"tooltipTextFormatString" : {type : "string[]", group : "Misc", defaultValue : null},
		"tooltipMainValueFormatString" : {type : "string[]", group : "Misc", defaultValue : null},
		"tooltipSubValueFormatString" : {type : "string[]", group : "Misc", defaultValue : null},
		"pieType" : {type : "string", group : "Misc", defaultValue : 'pie'}
	},
	aggregations : {
    	"dataset" : {type : "sap.service.visualization.dataset.SimpleDMDataset", multiple : false}
	},
	events : {
		"selectData" : {}
	}
}});


/**
 * Creates a new subclass of class sap.service.visualization.chart.Pie with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.chart.Pie.extend
 * @function
 */

sap.service.visualization.chart.Pie.M_EVENTS = {'selectData':'selectData'};


/**
 * Getter for property <code>width</code>.
 * the chart width.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>width</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getWidth
 * @function
 */


/**
 * Setter for property <code>width</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sWidth  new value for property <code>width</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setWidth
 * @function
 */

/**
 * Getter for property <code>height</code>.
 * the chart height.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {sap.ui.core.CSSSize} the value of property <code>height</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getHeight
 * @function
 */


/**
 * Setter for property <code>height</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {sap.ui.core.CSSSize} sHeight  new value for property <code>height</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setHeight
 * @function
 */

/**
 * Getter for property <code>allDeSelectable</code>.
 * deselect enabled, first click the slice it will break away from the pie, then click other place the slice will be back. To be deprecated.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>allDeSelectable</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getAllDeSelectable
 * @function
 */


/**
 * Setter for property <code>allDeSelectable</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bAllDeSelectable  new value for property <code>allDeSelectable</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setAllDeSelectable
 * @function
 */

/**
 * Getter for property <code>allSelectable</code>.
 * the sectors selectable or not. To be deprecated.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>allSelectable</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getAllSelectable
 * @function
 */


/**
 * Setter for property <code>allSelectable</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bAllSelectable  new value for property <code>allSelectable</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setAllSelectable
 * @function
 */

/**
 * Getter for property <code>selectionMode</code>.
 * supported value: (single|multiple), single: you can just select one slice; multiple : multiple slices can be selected. To be deprecated.
 *
 * Default value is <code>single</code>
 *
 * @return {string} the value of property <code>selectionMode</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getSelectionMode
 * @function
 */


/**
 * Setter for property <code>selectionMode</code>.
 *
 * Default value is <code>single</code> 
 *
 * @param {string} sSelectionMode  new value for property <code>selectionMode</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setSelectionMode
 * @function
 */

/**
 * Getter for property <code>legendFirst</code>.
 * first ensure to plot legend, then the chart area plot.
 *
 * Default value is <code>false</code>
 *
 * @return {boolean} the value of property <code>legendFirst</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getLegendFirst
 * @function
 */


/**
 * Setter for property <code>legendFirst</code>.
 *
 * Default value is <code>false</code> 
 *
 * @param {boolean} bLegendFirst  new value for property <code>legendFirst</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setLegendFirst
 * @function
 */

/**
 * Getter for property <code>legendDirection</code>.
 * the position of legend located at, left|right|top|bottom.
 *
 * Default value is <code>right</code>
 *
 * @return {string} the value of property <code>legendDirection</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getLegendDirection
 * @function
 */


/**
 * Setter for property <code>legendDirection</code>.
 *
 * Default value is <code>right</code> 
 *
 * @param {string} sLegendDirection  new value for property <code>legendDirection</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setLegendDirection
 * @function
 */

/**
 * Getter for property <code>legendVerticalOffset</code>.
 * the offset of the legend, used to adjust the position of legend.if left or right, positive, legend will move up,minus down.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendVerticalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getLegendVerticalOffset
 * @function
 */


/**
 * Setter for property <code>legendVerticalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendVerticalOffset  new value for property <code>legendVerticalOffset</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setLegendVerticalOffset
 * @function
 */

/**
 * Getter for property <code>legendHorizontalOffset</code>.
 * the offset of the legend, used to adjust the position of legend. if position top or bottom, positive, legend will move right, minus left.
 *
 * Default value is <code>0</code>
 *
 * @return {int} the value of property <code>legendHorizontalOffset</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getLegendHorizontalOffset
 * @function
 */


/**
 * Setter for property <code>legendHorizontalOffset</code>.
 *
 * Default value is <code>0</code> 
 *
 * @param {int} iLegendHorizontalOffset  new value for property <code>legendHorizontalOffset</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setLegendHorizontalOffset
 * @function
 */

/**
 * Getter for property <code>defaultSelectedSliceIndexes</code>.
 * the default selected slice index.To be deprecated.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {int[]} the value of property <code>defaultSelectedSliceIndexes</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getDefaultSelectedSliceIndexes
 * @function
 */


/**
 * Setter for property <code>defaultSelectedSliceIndexes</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {int[]} aDefaultSelectedSliceIndexes  new value for property <code>defaultSelectedSliceIndexes</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setDefaultSelectedSliceIndexes
 * @function
 */

/**
 * Getter for property <code>sectorColors</code>.
 * for example['#000000','#000000','#000000'],//array of color string, if supply not enough, reuse the laset one.
 *
 * Default value is <code>['#748CB2','#9CC677','#EACF5E','#F9AD79','#D16A7C','#8873A2','#3A95B3','#B6D949','#FDD36C','#F47958','#A65084','#0063B1','#0DA841','#FCB71D','#F05620','#B22D6E','#3C368E','#8FB2CF]</code>
 *
 * @return {string[]} the value of property <code>sectorColors</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getSectorColors
 * @function
 */


/**
 * Setter for property <code>sectorColors</code>.
 *
 * Default value is <code>['#748CB2','#9CC677','#EACF5E','#F9AD79','#D16A7C','#8873A2','#3A95B3','#B6D949','#FDD36C','#F47958','#A65084','#0063B1','#0DA841','#FCB71D','#F05620','#B22D6E','#3C368E','#8FB2CF]</code> 
 *
 * @param {string[]} aSectorColors  new value for property <code>sectorColors</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setSectorColors
 * @function
 */

/**
 * Getter for property <code>showLegend</code>.
 * show/hide legend.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showLegend</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getShowLegend
 * @function
 */


/**
 * Setter for property <code>showLegend</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowLegend  new value for property <code>showLegend</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setShowLegend
 * @function
 */

/**
 * Getter for property <code>legendFormatString</code>.
 * the format style for legend. the format for legend default is [''], numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'. If feed not enough then reuse the last one.
 *
 * Default value is <code>['']</code>
 *
 * @return {string[]} the value of property <code>legendFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getLegendFormatString
 * @function
 */


/**
 * Setter for property <code>legendFormatString</code>.
 *
 * Default value is <code>['']</code> 
 *
 * @param {string[]} aLegendFormatString  new value for property <code>legendFormatString</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setLegendFormatString
 * @function
 */

/**
 * Getter for property <code>title</code>.
 * title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>title</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getTitle
 * @function
 */


/**
 * Setter for property <code>title</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sTitle  new value for property <code>title</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setTitle
 * @function
 */

/**
 * Getter for property <code>titleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>titleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>titleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sTitleHorizontalAlign  new value for property <code>titleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>subTitle</code>.
 * sub title text.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>subTitle</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getSubTitle
 * @function
 */


/**
 * Setter for property <code>subTitle</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sSubTitle  new value for property <code>subTitle</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setSubTitle
 * @function
 */

/**
 * Getter for property <code>subTitleHorizontalAlign</code>.
 * the title align left|center|right.
 *
 * Default value is <code>center</code>
 *
 * @return {string} the value of property <code>subTitleHorizontalAlign</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getSubTitleHorizontalAlign
 * @function
 */


/**
 * Setter for property <code>subTitleHorizontalAlign</code>.
 *
 * Default value is <code>center</code> 
 *
 * @param {string} sSubTitleHorizontalAlign  new value for property <code>subTitleHorizontalAlign</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setSubTitleHorizontalAlign
 * @function
 */

/**
 * Getter for property <code>showTitle</code>.
 * show/hide title.
 *
 * Default value is <code>true</code>
 *
 * @return {boolean} the value of property <code>showTitle</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getShowTitle
 * @function
 */


/**
 * Setter for property <code>showTitle</code>.
 *
 * Default value is <code>true</code> 
 *
 * @param {boolean} bShowTitle  new value for property <code>showTitle</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setShowTitle
 * @function
 */

/**
 * Getter for property <code>titleFormatString</code>.
 * the format style for main title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>titleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getTitleFormatString
 * @function
 */


/**
 * Setter for property <code>titleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sTitleFormatString  new value for property <code>titleFormatString</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setTitleFormatString
 * @function
 */

/**
 * Getter for property <code>subTitleFormatString</code>.
 * the format style for sub title. numeric :'0.00', Currency: '$"#,##0.00"' ,percent:'0.00%',Date:'M/dd/yyyy', time:'h:mm:ss A/P'.
 *
 * Default value is <code>''</code>
 *
 * @return {string} the value of property <code>subTitleFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getSubTitleFormatString
 * @function
 */


/**
 * Setter for property <code>subTitleFormatString</code>.
 *
 * Default value is <code>''</code> 
 *
 * @param {string} sSubTitleFormatString  new value for property <code>subTitleFormatString</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setSubTitleFormatString
 * @function
 */

/**
 * Getter for property <code>tooltipTextFormatString</code>.
 * the format style for text tool tip. same with legend.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string[]} the value of property <code>tooltipTextFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getTooltipTextFormatString
 * @function
 */


/**
 * Setter for property <code>tooltipTextFormatString</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string[]} aTooltipTextFormatString  new value for property <code>tooltipTextFormatString</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setTooltipTextFormatString
 * @function
 */

/**
 * Getter for property <code>tooltipMainValueFormatString</code>.
 * the format style for main tool tip. same with legend.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string[]} the value of property <code>tooltipMainValueFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getTooltipMainValueFormatString
 * @function
 */


/**
 * Setter for property <code>tooltipMainValueFormatString</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string[]} aTooltipMainValueFormatString  new value for property <code>tooltipMainValueFormatString</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setTooltipMainValueFormatString
 * @function
 */

/**
 * Getter for property <code>tooltipSubValueFormatString</code>.
 * the format style for sub tool tip. same with legend.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string[]} the value of property <code>tooltipSubValueFormatString</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getTooltipSubValueFormatString
 * @function
 */


/**
 * Setter for property <code>tooltipSubValueFormatString</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string[]} aTooltipSubValueFormatString  new value for property <code>tooltipSubValueFormatString</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setTooltipSubValueFormatString
 * @function
 */

/**
 * Getter for property <code>pieType</code>.
 * pie|donut
 *
 * Default value is <code>pie</code>
 *
 * @return {string} the value of property <code>pieType</code>
 * @public
 * @name sap.service.visualization.chart.Pie#getPieType
 * @function
 */


/**
 * Setter for property <code>pieType</code>.
 *
 * Default value is <code>pie</code> 
 *
 * @param {string} sPieType  new value for property <code>pieType</code>
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setPieType
 * @function
 */

/**
 * Getter for aggregation <code>dataset</code>.<br/>
 * chart use this aggregation to get data feed.
 * 
 * @return {sap.service.visualization.dataset.SimpleDMDataset}
 * @public
 * @name sap.service.visualization.chart.Pie#getDataset
 * @function
 */

/**
 * Setter for the aggregated <code>dataset</code>.
 * @param oDataset {sap.service.visualization.dataset.SimpleDMDataset}
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#setDataset
 * @function
 */


/**
 * Destroys  in the aggregation 
 * named <code>dataset</code>.
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#destroyDataset
 * @function
 */

/**
 * this event is bind to chart, the chart will response all the information of the slice of you selected on pie. 
 *
 * @name sap.service.visualization.chart.Pie#selectData
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @public
 */
 
/**
 * Attach event handler <code>fnFunction</code> to the 'selectData' event of this <code>sap.service.visualization.chart.Pie</code>.<br/>.
 * When called, the context of the event handler (its <code>this</code>) will be bound to <code>oListener<code> if specified
 * otherwise to this <code>sap.service.visualization.chart.Pie</code>.<br/> itself. 
 *  
 * this event is bind to chart, the chart will response all the information of the slice of you selected on pie. 
 *
 * @param {object}
 *            [oData] An application specific payload object, that will be passed to the event handler along with the event object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs.  
 * @param {object}
 *            [oListener=this] Context object to call the event handler with. Defaults to this <code>sap.service.visualization.chart.Pie</code>.<br/> itself.
 *
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#attachSelectData
 * @function
 */


/**
 * Detach event handler <code>fnFunction</code> from the 'selectData' event of this <code>sap.service.visualization.chart.Pie</code>.<br/>
 *
 * The passed function and listener object must match the ones used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Context object on which the given function had to be called.
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.chart.Pie#detachSelectData
 * @function
 */


/**
 * Fire event selectData to attached listeners.

 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.service.visualization.chart.Pie} <code>this</code> to allow method chaining
 * @protected
 * @name sap.service.visualization.chart.Pie#fireSelectData
 * @function
 */

// Start of sap/service/visualization/chart/Pie.js
/*!
 * @copyright@
 */




jQuery.sap.require('sap.ui.core.theming.Parameters'); // unlisted dependency retained


sap.service.visualization.chart.Pie.prototype.isNumber = function(value){
	var patt = /^(0|-?[1-9]\d*)$|^(0|-?[1-9]\d*)\.(\d+)$/;
	return patt.exec(value);
};

sap.service.visualization.chart.Pie.prototype.setWidth = function(width) {

	this.setProperty("width", width);
	return this;
};

sap.service.visualization.chart.Pie.prototype.setHeight = function(height) {

	this.setProperty("height", height);
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setAllSelectable = function(allSelectable) {

	this.setProperty("allSelectable", allSelectable);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			allSelectable : allSelectable
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setAllDeSelectable = function(allDeSelectable) {

	this.setProperty("allDeSelectable", allDeSelectable);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			allDeSelectable : allDeSelectable
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setSelectionMode = function(selectionMode) {
	
	this.setProperty("selectionMode", selectionMode);
	
	if (this.pie != undefined) {
	
		if ((selectionMode != 'multiple') && (selectionMode != 'single')) {
			selectionMode = 'single';
		}
		var chartOption = {
			selectionMode : selectionMode,
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendFirst = function(legendFirst) {

	this.setProperty("legendFirst", legendFirst);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			layout:{
				legendFirst: legendFirst
			} 
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendDirection = function(legendDirection) {

	this.setProperty("legendDirection", legendDirection);

	if (this.pie != undefined) {
		var legendVerticalOffset = this.getLegendVerticalOffset();
		var legendHorizontalOffset = this.getLegendHorizontalOffset();
		if (legendDirection == 'left'||legendDirection == 'right') {
			legendVerticalOffset = (this.isNumber(legendVerticalOffset)) ? parseInt(legendVerticalOffset) : 0;;
		} else{
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset)) ? parseInt(legendHorizontalOffset) : 0;
		}

		var chartOption = {
			legend : {
				position : legendDirection,
				verticalOffset : legendVerticalOffset,
				horizontalOffset : legendHorizontalOffset
			}
		};

		this.pie.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendVerticalOffset = function(legendVerticalOffset) {

	this.setProperty("legendVerticalOffset", legendVerticalOffset);
	
	if (this.pie != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendVerticalOffset = 0;
		var chartOption;
		if (legendDirection == 'left'|| legendDirection=='right'){
			legendVerticalOffset = (this.isNumber(legendVerticalOffset))? parseInt(legendVerticalOffset) : 0;
			chartOption = {
				legend: {
					verticalOffset: legendVerticalOffset,
				}
			};
		}
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendHorizontalOffset = function(legendHorizontalOffset) {

	this.setProperty("legendHorizontalOffset", legendHorizontalOffset);
	
	if (this.pie != undefined) {
		var legendDirection = this.getLegendDirection();
		var legendHorizontalOffset = 0;
		var chartOption;
		if (legendDirection == 'top'|| legendDirection=='left'){
			legendHorizontalOffset = (this.isNumber(legendHorizontalOffset))? parseInt(legendHorizontalOffset) : 0;
			chartOption = {
				legend: {
					horizontalOffset: legendHorizontalOffset,
				}
			};
		}
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setDefaultSelectedSliceIndexes = function(defaultSelectedSliceIndexes) {
	
	this.setProperty("defaultSelectedSliceIndexes", defaultSelectedSliceIndexes);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			defaultSelectedSectorIndexes : defaultSelectedSliceIndexes
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setSectorColors = function(sectorColors) {
	
	this.setProperty("sectorColors", sectorColors);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			measures:[{
				sectorColors:sectorColors
			}]
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendFormatString = function(legendFormatString) {
	
	this.setProperty("legendFormatString", legendFormatString);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			legend:{
				legendFormatString : legendFormatString
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setTitleFormatString = function(titleFormatString) {
	
	this.setProperty("titleFormatString", titleFormatString);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : titleFormatString
				}
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setSubTitleFormatString = function(subTitleFormatString) {
	
	this.setProperty("subTitleFormatString", subTitleFormatString);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			title:{
				main:{
				 	formatString : subTitleFormatString
				}
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setTooltipTextFormatString = function(tooltipTextFormatString) {
	
	this.setProperty("tooltipTextFormatString", tooltipTextFormatString);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			tooltip:{
				text:{
					formatSting :tooltipTextFormatString
			    }
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};


sap.service.visualization.chart.Pie.prototype.setTooltipMainValueFormatString = function(tooltipMainValueFormatString) {
	
	this.setProperty("tooltipMainValueFormatString", tooltipMainValueFormatString);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			tooltip:{
				mainValue:{
				 	formatSting :tooltipMainValueFormatString
				}
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};


sap.service.visualization.chart.Pie.prototype.setTooltipSubValueFormatString = function(tooltipSubValueFormatString) {
	
	this.setProperty("tooltipSubValueFormatString", tooltipSubValueFormatString);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			tooltip:{
				subValue:{
					formatSting :tooltipSubValueFormatString
				}
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};


sap.service.visualization.chart.Pie.prototype.setShowLegend = function(showLegend) {
	
	this.setProperty("showLegend", showLegend);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			legend: {
				visible: (showLegend != undefined) ? showLegend : true
			},
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setLegendFirst = function(legendFirst) {
	
	this.setProperty("legendFirst", legendFirst);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			layout: {
				legendFirst : (legendFirst != undefined) ? legendFirst : true
			},
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setTitle = function(title) {
	
	this.setProperty("title", title);
	
	if (this.pie != undefined) {
	
		var chartOption = {
			title: {
				main: {
					text: title
				}
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setSubTitle = function(subTitle) {

	this.setProperty("subTitle", subTitle);
	
	if (this.pie != undefined) {
		
		var chartOption = {
			title: {
				sub: {
					text: subTitle
				}
			}
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};

sap.service.visualization.chart.Pie.prototype.setShowTitle = function(showTitle) {

	this.setProperty("showTitle", showTitle);

	if (this.pie != undefined) {

		var chartOption = {
			title : {
				main : {
					visible:(showTitle != undefined) ? showTitle : true
				},
				sub:{
					visible:(showTitle != undefined) ? showTitle : true
				}
			}
		};

		this.pie.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Pie.prototype.setTitleHorizontalAlign = function(titleHorizontalAlign) {

	this.setProperty("titleHorizontalAlign", titleHorizontalAlign);

	if (this.pie != undefined) {

		var chartOption = {
			title : {
				mian : {
					HorizontalAlign: titleHorizontalAlign
				}
			}
		};

		this.pie.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Pie.prototype.setSubTitleHorizontalAlign = function(subTitleHorizontalAlign) {

	this.setProperty("subTitleHorizontalAlign", subTitleHorizontalAlign);

	if (this.pie != undefined) {

		var chartOption = {
			title : {
				sub:{
					HorizontalAlign: subTitleHorizontalAlign
				}
			}
		};

		this.pie.updateProperties(chartOption);
	}

	return this;
};

sap.service.visualization.chart.Pie.prototype.setPieType= function(pieType) {

	this.setProperty("pieType", pieType);
	
	if (this.pie != undefined) {
		
		var chartOption = {
				pieType : pieType
		};
		
		this.pie.updateProperties(chartOption);
	}
	
	return this;
};
			
sap.service.visualization.chart.Pie.prototype.onAfterRendering = function(oEvent) {

	var Environment = sap.riv.viz.Environment;
		
	// Create chart after lazy load finishes
	var dataset = this.getDataset().dataset;
	var control = this; 
	var renderTo = this.getId(); 

	var selectionMode = this.getSelectionMode();
	var allDeSelectable = this.getAllDeSelectable();
	var allSelectable = this.getAllSelectable();
	var legendDirection = this.getLegendDirection();
	var legendVerticalOffset = this.getLegendVerticalOffset();
	var legendHorizontalOffset = this.getLegendHorizontalOffset();
	var showLegend = this.getShowLegend();
	var legendFirst = this.getLegendFirst();
	var legendFormatString = this.getLegendFormatString();
	var defaultSelectedSliceIndexes = this.getDefaultSelectedSliceIndexes();
	var sectorColors = this.getSectorColors();
	var title = this.getTitle();
	var titleHorizontalAlign = this.getTitleHorizontalAlign();
	var subTitle = this.getSubTitle();
	var subTitleHorizontalAlign = this.getSubTitleHorizontalAlign();
	var showTitle= this.getShowTitle();
	var titleFormatString = this.getTitleFormatString();
	var subTitleFormatString = this.getSubTitleFormatString();
	var tooltipTextFormatString = this.getTooltipTextFormatString();
	var tooltipMainValueFormatString = this.getTooltipMainValueFormatString();
	var tooltipSubValueFormatString = this.getTooltipSubValueFormatString();
	
	var pieType = this.getPieType();
	this.pie = null;

	var themes = new sap.service.visualization.Themings().getCorrespondingThemings("Pie");
	var bgColor = themes.bgColor;
	var chartPadding = themes.chartPadding;

	// legend properties
	var legendObj = {};
	legendObj.visible = showLegend;
	legendObj.position = legendDirection;
	legendObj.verticalOffset = legendVerticalOffset;
	legendObj.horizontalOffset = legendHorizontalOffset;
	legendObj.formatString = legendFormatString;
	legendObj.titleFont = themes.legendTitleFont;
	legendObj.titleColor = themes.legendTitleFontColor;
	legendObj.labelFont = themes.legendFont;
	legendObj.labelColor = themes.legendColor;

	// main title properties
	var mainTitle = {};
	mainTitle.text = title;
	mainTitle.visible = showTitle;
	mainTitle.font  = themes.mainTitleFont;
	mainTitle.color = themes.mainTitleColor;
	mainTitle.horizontalAlign = titleHorizontalAlign;
	mainTitle.formatString = titleFormatString;

	// sub title properties
	var subTitleObj = {};
	subTitleObj.text = subTitle;
	subTitleObj.visible = showTitle;
	subTitleObj.font  = themes.subTitleFont;
	subTitleObj.color = themes.subTitleColor;
	subTitleObj.horizontalAlign = subTitleHorizontalAlign;
	subTitleObj.formatString = subTitleFormatString;

	// tool tip themes
	var toolTipMainValueFont = themes.toolTipMainValueFont;
	var toolTipMainValueColor = themes.toolTipMainValueColor;
	var toolTipSubValueFont = themes.toolTipSubValueFont;
	var toolTipSubValueColor = themes.toolTipSubValueColor;
	var toolTipTextFont = themes.toolTipTextFont;
	var toolTipTextColor = themes.toolTipTextColor;
	
	Environment.initialize({
		'locale' : 'en_US',
		'log' : 'debug'
	});
	var chartOption = {
		layout:{
				legendFirst: legendFirst,
				padding : chartPadding
			}, 
		background: {
			color: bgColor
		},
		tooltip: {
			mainValue: {
				font: toolTipMainValueFont,
				color: toolTipMainValueColor,
				formatString: tooltipMainValueFormatString
			},
			subValue: {
				font: toolTipSubValueFont,
				color: toolTipSubValueColor,
				formatString: tooltipSubValueFormatString
			},
			text: {
				font: toolTipTextFont,
				color: toolTipTextColor,
				formatString: tooltipTextFormatString
			}
		},
		legend:legendObj,
		title: {
			main: mainTitle,
			sub: subTitleObj
		},
		sort : 'asc',
		selectionMode : selectionMode,
		allSelectable : allSelectable,
		allDeSelectable : allDeSelectable,
		selectedDataIndexes : defaultSelectedSliceIndexes,
		pieType : (pieType == undefined) ? 'pie' : pieType,
		measures:[{
		 sectorColors:sectorColors
		}]
	};
    control.pie = new sap.riv.viz.PieChart(jQuery.sap.byId(renderTo), chartOption, dataset);
	control.pie.addListener('selectData', function(evt){
		control.fireSelectData({
			Id: renderTo,
			Data: evt.data,
			EventName: evt.name
		});
	});
	// Apply new theme when theme changes	
	var applyCurrentThemeToChart = function(pie){
	
		var themes = new sap.service.visualization.Themings().getCorrespondingThemings("Pie");
		var bgColor = themes.bgColor;
		
		//title theme
		var mainTitleFont = themes.mainTitleFont;
		var mainTitleColor = themes.mainTitleColor;
		var subTitleObjFont = themes.subTitleFont;
		var subTitleObjColor = themes.subTitleColor;
		
		//legend theme
		var legendTitleFont = themes.legendTitleFont;
		var legendTitleFontColor = themes.legendTitleFontColor;
		var legendFont = themes.legendFont;
		var legendColor = themes.legendColor;
		
		//tooltip theme
			// tool tip themes
		var toolTipMainValueFont = themes.toolTipMainValueFont;
		var toolTipMainValueColor = themes.toolTipMainValueColor;
		var toolTipSubValueFont = themes.toolTipSubValueFont;
		var toolTipSubValueColor = themes.toolTipSubValueColor;
		var toolTipTextFont = themes.toolTipTextFont;
		var toolTipTextColor = themes.toolTipTextColor;
	
		var chartOption = {
			background: {
				color: bgColor
			},
			tooltip: {
				text: {
					font: toolTipTextFont,
					color: toolTipTextColor
				},
				mainValue: {
					font: toolTipMainValueFont,
					color: toolTipMainValueColor
				},
				subValue: {
					font: toolTipSubValueFont,
					color: toolTipSubValueColor
				}
			},
			legend : {
			    labelFont: legendFont,
			    labelColor: legendColor,
			    titleFont: legendTitleFont,
			    titleColor: legendTitleFontColor
			},
			title:{
				main:{
				        color: mainTitleColor,
				        font: mainTitleFont
				},
			    sub:{
				        color: subTitleObjColor,
				        font: subTitleObjFont
			    }
			}	
		};
		pie.updateProperties(chartOption);
    };
    sap.ui.getCore().attachThemeChanged(function(evt){
        applyCurrentThemeToChart(control.pie);
    });
};
}; // end of sap.service.visualization.chart.Pie
if ( !jQuery.sap.isDeclared('sap.service.visualization.dataset.SimpleDMDataset') ) {
/*!
 * CVOM HTML5 charts
 * 
 * 	(c) Copyright 2009-2012 SAP AG. All rights reserved
 */

/* ----------------------------------------------------------------------------------
 * Hint: This is a derived (generated) file. Changes should be done in the underlying 
 * source files only (*.control, *.js) or they will be lost after the next generation.
 * ---------------------------------------------------------------------------------- */

// Provides control sap.service.visualization.dataset.SimpleDMDataset.
jQuery.sap.declare("sap.service.visualization.dataset.SimpleDMDataset");

jQuery.sap.require('sap.ui.core.Element'); // unlisted dependency retained


/**
 * Constructor for a new dataset/SimpleDMDataset.
 * 
 * Accepts an object literal <code>mSettings</code> that defines initial 
 * property values, aggregated and associated objects as well as event handlers. 
 * 
 * If the name of a setting is ambiguous (e.g. a property has the same name as an event), 
 * then the framework assumes property, aggregation, association, event in that order. 
 * To override this automatic resolution, one of the prefixes "aggregation:", "association:" 
 * or "event:" can be added to the name of the setting (such a prefixed name must be
 * enclosed in single or double quotes).
 *
 * The supported settings are:
 * <ul>
 * <li>Properties
 * <ul>
 * <li>{@link #getDimensionName dimensionName} : string</li>
 * <li>{@link #getDimensionItems dimensionItems} : string[]</li>
 * <li>{@link #getMeasureNames measureNames} : string[]</li>
 * <li>{@link #getData data} : object[]</li>
 * <li>{@link #getTabularData tabularData} : object[]</li></ul>
 * </li>
 * <li>Aggregations
 * <ul></ul>
 * </li>
 * <li>Associations
 * <ul></ul>
 * </li>
 * <li>Events
 * <ul></ul>
 * </li>
 * </ul> 
 *
 * 
 * In addition, all settings applicable to the base type {@link sap.ui.core.Element#constructor sap.ui.core.Element}
 * can be used as well.
 *
 * @param {string} [sId] id for the new control, generated automatically if no id is given 
 * @param {object} [mSettings] initial settings for the new control
 *
 * @class
 * the element used for feeding dataset for all kinds of charts.
 * @extends sap.ui.core.Element
 *
 * @author sap visualization 
 * @version 1.11.0
 *
 * @constructor   
 * @public
 * @deprecated Since version 1.7.2. 
 * This library has been deprecated in favor of the new charting library sap.viz. Please migrate as soon as possible as this older library will be removed from the SAPUI5 delivery in one of the next releases.
 * @name sap.service.visualization.dataset.SimpleDMDataset
 */
sap.ui.core.Element.extend("sap.service.visualization.dataset.SimpleDMDataset", { metadata : {

	// ---- object ----
	deprecated : true,
	publicMethods : [
		// methods
		"setDataTable"
	],

	// ---- control specific ----
	library : "sap.service.visualization",
	properties : {
		"dimensionName" : {type : "string", group : "Data", defaultValue : null, bindable : "bindable"},
		"dimensionItems" : {type : "string[]", group : "Data", defaultValue : null, bindable : "bindable"},
		"measureNames" : {type : "string[]", group : "Data", defaultValue : null, bindable : "bindable"},
		"data" : {type : "object[]", group : "Data", defaultValue : null, bindable : "bindable"},
		"tabularData" : {type : "object[]", group : "Data", defaultValue : null, bindable : "bindable"}
	}
}});


/**
 * Creates a new subclass of class sap.service.visualization.dataset.SimpleDMDataset with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.service.visualization.dataset.SimpleDMDataset.extend
 * @function
 */


/**
 * Getter for property <code>dimensionName</code>.
 * A name for the dimension (index into measures array)
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string} the value of property <code>dimensionName</code>
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#getDimensionName
 * @function
 */


/**
 * Setter for property <code>dimensionName</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string} sDimensionName  new value for property <code>dimensionName</code>
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#setDimensionName
 * @function
 */

/**
 * Binder for property <code>dimensionName</code>.
 *
 * @param {string} sPath path to a property in the model 
 * @param {function} [fnFormatter=null] the formatter function
 * @param {sap.ui.model.BindingMode} [sMode=Default] the binding mode to be used for this property binding (e.g. one way) 
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#bindDimensionName
 * @function
 */


/**
 * Unbinder for property <code>dimensionName</code>.
 *
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#unbindDimensionName
 * @function

 */

/**
 * Getter for property <code>dimensionItems</code>.
 * An array of dimension items.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string[]} the value of property <code>dimensionItems</code>
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#getDimensionItems
 * @function
 */


/**
 * Setter for property <code>dimensionItems</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string[]} aDimensionItems  new value for property <code>dimensionItems</code>
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#setDimensionItems
 * @function
 */

/**
 * Binder for property <code>dimensionItems</code>.
 *
 * @param {string} sPath path to a property in the model 
 * @param {function} [fnFormatter=null] the formatter function
 * @param {sap.ui.model.BindingMode} [sMode=Default] the binding mode to be used for this property binding (e.g. one way) 
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#bindDimensionItems
 * @function
 */


/**
 * Unbinder for property <code>dimensionItems</code>.
 *
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#unbindDimensionItems
 * @function

 */

/**
 * Getter for property <code>measureNames</code>.
 * An array of measures names.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {string[]} the value of property <code>measureNames</code>
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#getMeasureNames
 * @function
 */


/**
 * Setter for property <code>measureNames</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {string[]} aMeasureNames  new value for property <code>measureNames</code>
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#setMeasureNames
 * @function
 */

/**
 * Binder for property <code>measureNames</code>.
 *
 * @param {string} sPath path to a property in the model 
 * @param {function} [fnFormatter=null] the formatter function
 * @param {sap.ui.model.BindingMode} [sMode=Default] the binding mode to be used for this property binding (e.g. one way) 
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#bindMeasureNames
 * @function
 */


/**
 * Unbinder for property <code>measureNames</code>.
 *
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#unbindMeasureNames
 * @function

 */

/**
 * Getter for property <code>data</code>.
 * An array of measures, with each measure as an array.
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>data</code>
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#getData
 * @function
 */


/**
 * Setter for property <code>data</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aData  new value for property <code>data</code>
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#setData
 * @function
 */

/**
 * Binder for property <code>data</code>.
 *
 * @param {string} sPath path to a property in the model 
 * @param {function} [fnFormatter=null] the formatter function
 * @param {sap.ui.model.BindingMode} [sMode=Default] the binding mode to be used for this property binding (e.g. one way) 
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#bindData
 * @function
 */


/**
 * Unbinder for property <code>data</code>.
 *
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#unbindData
 * @function

 */

/**
 * Getter for property <code>tabularData</code>.
 * An array of objects of equal structure, each containing a dimension label and a set of measures.
 * When this property is used, the values of the other properties are determined automatically:
 * the dimensionName is derived from the first property name in the first measure object,
 * the measureNames are derived from the remaining property names of the same object,
 * the dimensionItems (labels) are determined from the values of the property named after the dimensionName
 * and the data (measures) are determined from the remaining properties of all measure objects
 * 
 *
 * Default value is empty/<code>undefined</code>
 *
 * @return {object[]} the value of property <code>tabularData</code>
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#getTabularData
 * @function
 */


/**
 * Setter for property <code>tabularData</code>.
 *
 * Default value is empty/<code>undefined</code> 
 *
 * @param {object[]} aTabularData  new value for property <code>tabularData</code>
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#setTabularData
 * @function
 */

/**
 * Binder for property <code>tabularData</code>.
 *
 * @param {string} sPath path to a property in the model 
 * @param {function} [fnFormatter=null] the formatter function
 * @param {sap.ui.model.BindingMode} [sMode=Default] the binding mode to be used for this property binding (e.g. one way) 
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#bindTabularData
 * @function
 */


/**
 * Unbinder for property <code>tabularData</code>.
 *
 * @return {sap.service.visualization.dataset.SimpleDMDataset} <code>this</code> to allow method chaining
 * @public
 * @name sap.service.visualization.dataset.SimpleDMDataset#unbindTabularData
 * @function

 */

/**
 * setDataTable(dataTable) dataTable the control contains all the data set.
 *
 * @name sap.service.visualization.dataset.SimpleDMDataset.prototype.setDataTable
 * @function

 * @type void
 * @public
 */


// Start of sap/service/visualization/dataset/SimpleDMDataset.js
/*!
 * @copyright@
 */ 






sap.service.visualization.dataset.SimpleDMDataset.prototype.init = function() {
	// do something for initialization...
	this.dataset = new sap.riv.viz.shared.dataConverter.SimpleDMDataset();
};

sap.service.visualization.dataset.SimpleDMDataset.prototype.setDimensionItems = function(dimensionItems) {
	this.setProperty("dimensionItems", dimensionItems);
	this.dataset.dimensionLabels(dimensionItems);
};

sap.service.visualization.dataset.SimpleDMDataset.prototype.setDimensionName = function(dimensionName) {
    this.setProperty("dimensionName", dimensionName);
	this.dataset.dimensionName(dimensionName);
};

sap.service.visualization.dataset.SimpleDMDataset.prototype.setData = function(data) {
	this.setProperty("data", data);
	this.dataset.data(data);
};

sap.service.visualization.dataset.SimpleDMDataset.prototype.setMeasureNames = function(measureNames) {
	this.setProperty("measureNames", measureNames);
	this.dataset.measureNames(measureNames);
};

sap.service.visualization.dataset.SimpleDMDataset.prototype.setTabularData = function(tabularData) {
    this.setProperty("tabularData", tabularData);
	var dimensionLabelarr = new Array();
	var modelData = tabularData;
	var JSONObjkeys = new Array();

    var firstObjOfModelData= modelData[0];
    for(var key in firstObjOfModelData){
    	if(firstObjOfModelData.hasOwnProperty(key)){
    		JSONObjkeys.push(key);
    	}
     };
	var dimensionName = JSONObjkeys[0];
	for (var i = 0; i < modelData.length; i++) {
		if(typeof modelData[i]!=='undefined')
         dimensionLabelarr.push(modelData[i][dimensionName]);
	};

	var measureNamesArr = JSONObjkeys.slice(1);
	var dataArr = this.getMeasureValueNameArr(JSONObjkeys, modelData);
	this.setDimensionName(dimensionName);
	this.setData(dataArr);
	this.setMeasureNames(measureNamesArr);
	this.setDimensionItems(dimensionLabelarr);
};

sap.service.visualization.dataset.SimpleDMDataset.prototype.setDataTable = function(dataTable) {
       
       var tableData = dataTable.getModel().getData();
       if( !tableData ||  typeof tableData === "undefined") return;
       var modelData;
       for(prop in tableData){
    	   modelData = tableData[prop];
       }
       this.setTabularData(modelData);
   };

sap.service.visualization.dataset.SimpleDMDataset.prototype.getMeasureValueNameArr = function(JSONObjkeys, modelData) {
	var dataArr = new Array();
	for (var j = 1; j < JSONObjkeys.length; j++) {
		var tempMeasureValue = new Array();
		var measureName = JSONObjkeys[j];
		for (var i = 0; i < modelData.length; i++) {
		    for (var i = 0; i < modelData.length; i++) {
		    	if(typeof modelData[i]!=='undefined')
		        tempMeasureValue.push(modelData[i][measureName]);
			}
		}
		dataArr.push(tempMeasureValue);
	}

	return dataArr;
};


}; // end of sap.service.visualization.dataset.SimpleDMDataset
